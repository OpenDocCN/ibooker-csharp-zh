- en: Chapter 3\. Types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'C# does not limit us to the built-in data types shown in [Chapter 2](ch02.xhtml#ch_basic_coding).
    You can define your own types. In fact, you have no choice: if you want to write
    code at all, C# requires that code to be inside a type. Everything we write, and
    any functionality we consume from the .NET runtime libraries (or any other .NET
    library), will belong to a type.'
  prefs: []
  type: TYPE_NORMAL
- en: C# recognizes multiple kinds of types. I’ll begin with the most important.
  prefs: []
  type: TYPE_NORMAL
- en: Classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most of the types you work with in C# will be *classes*. A class can contain
    both code and data, and it can choose to make some of its features publicly available
    while keeping others accessible only to code within the class. So classes offer
    a mechanism for *encapsulation*—they can define a clear public programming interface
    for other people to use while keeping internal implementation details inaccessible.
  prefs: []
  type: TYPE_NORMAL
- en: If you’re familiar with object-oriented languages, this will all seem very ordinary.
    If you’re not, then you might want to read a more introductory-level book first,
    because this book is not meant to teach programming. I’ll just describe the details
    specific to C# classes.
  prefs: []
  type: TYPE_NORMAL
- en: I’ve already shown examples of classes in earlier chapters, but let’s look at
    the structure in more detail. [Example 3-1](#simple_class) shows a simple class.
    (See the sidebar [“Naming Conventions”](#naming_conventions) for information about
    names for types and their members.)
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-1\. A simple class
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Class definitions always contain the `class` keyword followed by the name of
    the class. C# does not require the name to match the containing file, nor does
    it limit you to having one class in a file. That said, most C# projects make the
    class and filenames match by convention. In any case, class names must follow
    the basic rules described in [Chapter 2](ch02.xhtml#ch_basic_coding) for identifiers
    such as variables; e.g., they cannot start with a number.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first line of [Example 3-1](#simple_class) contains an additional keyword:
    `public`. Class definitions can optionally specify *accessibility*, which determines
    what other code is allowed to use the class. Ordinary classes have just two choices
    here: `public` and `internal`, with the latter being the default. (As I’ll show
    later, you can nest classes inside other types, and nested classes have a slightly
    wider range of accessibility options.) An internal class is available for use
    only within the component that defines it. So if you are writing a class library,
    you are free to define classes that exist purely as part of your library’s implementation:
    by marking them as `internal`, you prevent the rest of the world from using them.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'You can choose to make your internal types visible to selected external components.
    Microsoft sometimes does this with its libraries. The runtime libraries are spread
    across numerous DLLs, each of which defines many internal types, but some internal
    features are used by other DLLs in the library. This is made possible by annotating
    a component with the `[assembly: Int⁠ern⁠als​Vis⁠ibl⁠eTo("*name*")]` attribute,
    specifying the name of the component with which you wish to share. ([Chapter 14](ch14.xhtml#ch_attributes)
    describes this in more detail.) For example, you might want to make every class
    in your application visible to a test project so that you can write unit tests
    for code that you don’t intend to make publicly available.'
  prefs: []
  type: TYPE_NORMAL
- en: The `Counter` class in [Example 3-1](#simple_class) has chosen to be `public`,
    but that doesn’t mean it has to make everything accessible. It defines two members—a
    field called `_count` that holds an `int` and a method called `GetNextValue` that
    operates on the information in that field. (The CLR will automatically initialize
    this field to 0 when a `Counter` is created.) As you can see, both of these members
    have accessibility qualifiers too. As is very common with object-oriented programming,
    this class has chosen to make the data member private, exposing public functionality
    through a method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Accessibility modifiers are optional for members, just as they are for classes,
    and again, they default to the most restrictive option available: `private`, in
    this case. So I could have left off the `private` keyword in [Example 3-1](#simple_class)
    without changing the meaning, but I prefer to be explicit. (If you leave it unspecified,
    people reading your code may wonder whether the omission was deliberate or accidental.)'
  prefs: []
  type: TYPE_NORMAL
- en: Fields hold data. They are a kind of variable, but unlike a local variable,
    whose scope and lifetime is determined by its containing method, a field is tied
    to its containing type. [Example 3-1](#simple_class) is able to refer to the `_count`
    field by its unqualified name because fields are in scope within their defining
    class. But what about the lifetime? We know that each invocation of a method gets
    its own set of local variables. How many sets of a class’s fields are there? There
    are a couple of possibilities, depending on how you define the field, and in this
    case, it’s one per instance. [Example 3-2](#using_a_custom_class) uses the `Counter`
    class from [Example 3-1](#simple_class) to illustrate this.
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-2\. Using a custom class
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This uses the `new` operator to create new instances of my class. Since I use
    `new` twice, I get two `Counter` objects, and each has its own `_count` field.
    So we get two independent counts, as the program’s output shows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: As you’d expect, it begins counting up, and then a new sequence starts at 1
    when we switch to the second counter. But when we go back to the first counter,
    it carries on from where it left off. This demonstrates that each instance has
    its own `_count`. But what if we don’t want that? Sometimes you will want to keep
    track of information that doesn’t relate to any single object.
  prefs: []
  type: TYPE_NORMAL
- en: Static Members
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `static` keyword lets us declare that a member is not associated with any
    particular instance of the class. [Example 3-3](#class_with_static_members) shows
    a modified version of the `Counter` class from [Example 3-1](#simple_class). I’ve
    added two new members, both static, for tracking and reporting counts across all
    instances.
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-3\. Class with static members
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '`TotalCount` reports the count, but it doesn’t do any work—it just returns
    a value that the class keeps up to date, and as I’ll explain in [“Properties”](#properties),
    this makes it an ideal candidate for being a property rather than a method. The
    static field `_totalCount` keeps track of the total number of calls to `GetNextValue`,
    unlike the nonstatic `_count`, which just tracks calls to the current instance.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The `=>` syntax in the `TotalCount` property lets us define the property with
    a single expression—in this case, whenever code reads the `Counter.TotalCount`
    property, the result will be the value of the `_totalCount` field. As we’ll see
    later, there are ways to write more complex properties, but this is a common approach
    for simple, read-only properties.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that I’m free to use that static field inside `GetNextValue` in exactly
    the same way as I use the nonstatic `_count`. The difference in behavior is clear
    if I add the line of code shown in [Example 3-4](#using_a_static_property) to
    the end of the code in [Example 3-2](#using_a_custom_class).
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-4\. Using a static property
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This line displays 5, the sum of the two counts. To access a static member,
    I just write `*ClassName*.*MemberName*`. In fact, [Example 3-4](#using_a_static_property)
    uses two static members—as well as my class’s `TotalCount` property, it uses the
    `Console` class’s static `WriteLine` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because I’ve declared `TotalCount` as a static property, the code it contains
    has access only to other static members. If it tried to use the nonstatic `_count`
    field or call the nonstatic `GetNextValue` method, the compiler would complain.
    Replacing `_totalCount` with `_count` in the `TotalCount` property results in
    this error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Since nonstatic fields are associated with a particular instance of a class,
    C# needs to know which instance to use. With a nonstatic method or property, that’ll
    be whichever instance the method or property itself was invoked on. So in [Example 3-2](#using_a_custom_class),
    I wrote either `c1.GetNextValue()` or `c2.GetNextValue()` to choose which of my
    two objects to use. C# passed the reference stored in either `c1` or `c2`, respectively,
    as an implicit hidden first argument. You can get hold of that reference from
    code inside a class by using the `this` keyword. [Example 3-5](#this_keyword)
    shows an alternative way we could have written the first line of `GetNextValue`
    from [Example 3-3](#class_with_static_members), indicating explicitly that we
    believe `_count` is a member of the instance on which the `GetNextValue` method
    was invoked.
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-5\. The `this` keyword
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Explicit member access through `this` is sometimes necessary due to name collisions.
    Although all the members of a class are in scope for any code in the same class,
    the code in a method does not share a *declaration space* with the class. Remember
    from [Chapter 2](ch02.xhtml#ch_basic_coding) that a declaration space is a region
    of code in which a single name must not refer to two different entities, and since
    methods do not share theirs with the containing class, you are allowed to declare
    local variables and method parameters that have the same name as class members.
    This can easily happen if you don’t use a convention such as an underscore prefix
    for field names. You don’t get an error in this case—locals and parameters just
    hide the class members. But you can still get at the class members by qualifying
    access with `this`.
  prefs: []
  type: TYPE_NORMAL
- en: Static methods don’t get to use the `this` keyword, because they are not associated
    with any particular instance.
  prefs: []
  type: TYPE_NORMAL
- en: Static Classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Some classes only provide static members. There are several examples in the
    `Sys⁠tem.​Thr⁠ead⁠ing` namespace, which contains various classes that offer multithreading
    utilities. For example, the `Interlocked` class provides atomic, lock-free, read-modify-write
    operations; the `LazyInitializer` class provides helper methods for performing
    deferred initialization in a way that guarantees to avoid double initialization
    in multithreaded environments. These classes provide services only through static
    methods. It makes no sense to create instances of these types, because there’s
    no useful per-instance information they could hold.
  prefs: []
  type: TYPE_NORMAL
- en: You can declare that your class is intended to be used this way by putting the
    `static` keyword in front of the `class` keyword. This compiles the class in a
    way that prevents instances of it from being constructed. Anyone attempting to
    construct instances of a class designed to be used this way clearly doesn’t understand
    what it does, so the compiler error will be a useful prod in the direction of
    the documentation.
  prefs: []
  type: TYPE_NORMAL
- en: You can declare that you want to be able to invoke static methods on certain
    classes without naming the class every time. This can be useful if you are writing
    code that makes heavy use of the static methods supplied by a particular type.
    (This isn’t limited to static classes, by the way. You can use this technique
    with any class that has static members, but it is likely to be most useful with
    classes whose members are all static.) [Example 3-6](#using_static_members_normally)
    uses a static method (`Sin`) and a static property (`PI`) of the `Math` class
    (in the `System` namespace). It also uses the `Console` class’s static `WriteLine`
    method. (I’m showing the entire source file in this and the next example because
    the `using` directives are particularly important. The first example doesn’t need
    a `using System;` because default implicit global usings make this available everywhere.)
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-6\. Using static members normally
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 3-7](#using_static_members_without_explicit_qu) is exactly equivalent,
    but the line that invokes the three static members does not qualify any of them
    with their defining class’s name.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-7\. Using static members without explicit qualification
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: To utilize this less verbose alternative, you must declare which classes you
    want to use in this way with `using static` directives. Whereas `using` directives
    normally specify a namespace, enabling types in that namespace to be used without
    qualification, `using static` directives specify a class, enabling its static
    members to be used without qualification. By the way, as you saw in [Chapter 1](ch01.xhtml#ch_introducing_csharp),
    C# 10.0 lets you add the `global` keyword to `using` directives. That works for
    `using static` directives too, so if you want, say, the `Math` type’s static members
    to be available without qualification in any file in your project, you can write
    `global using static System.Math;` in just one file, and it will apply to all
    of them.
  prefs: []
  type: TYPE_NORMAL
- en: Records
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although encapsulation is a powerful tool for managing complexity in software
    development, it can sometimes be useful to have types that just hold information.
    We might want to represent a message sent over a network, or a row from a table
    in a database, for example. Types designed for this are sometimes referred to
    as *POD types*, where POD stands for plain old data. We might try to do this by
    writing a class containing nothing but public fields, as [Example 3-8](#pod_all_public_fields)
    shows.
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-8\. Plain old data, using public fields
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Some developers will recoil in horror at the lack of encapsulation here. There’s
    nothing to stop anyone from reaching into a `Person` instance and just changing
    the fields—oh, the humanity! In a type that was doing anything more than just
    holding some data, that could indeed cause problems. The type’s methods might
    contain code that relies on those fields being used in particular ways, and the
    problem with making fields public is that anything could change them, making it
    hard to know what state they will be in. But this type has no code—its only job
    is to hold some data, so this won’t be the end of the world. That said, this example
    has created a problem: these fields contain strings, but I’ve had to put a `?`
    after the type name. This signifies the fact that these fields might contain the
    special value `null`. If I don’t add those `?` qualifiers, the compiler will issue
    a warning telling me that I’ve done nothing to ensure that these fields are suitably
    initialized, and so I shouldn’t go around claiming that they are definitely going
    to contain strings. If I wanted to require that these fields always have non-null
    values, I’d need to take control of how the type is initialized, which I can do
    by writing a *constructor*. I’ll be describing these in more detail later in the
    chapter, but [Example 3-9](#ctor_enforcing_field_initialization) shows a simple
    example that ensures that the fields are initialized, enabling us to remove the
    `?` qualifiers.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-9\. Enforcing initialization of fields with a constructor
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This is now looking rather verbose. Record types offer a much simpler way to
    write a plain old data type, as [Example 3-10](#record_type_enforcing_initialization)
    shows.
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-10\. A record type with positional syntax
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 3-11](#using_a_record_type) shows how we can use this record type.
    If we have a variable referring to a `Person`, like the `p` argument in the `ShowPerson`
    method, we can write `p.Name` and `p.FavoriteColor` to access the data it contains,
    just as we would if `Person` were defined as in Examples [3-8](#pod_all_public_fields)
    or [3-9](#ctor_enforcing_field_initialization). (My record type isn’t exactly
    equivalent. Those earlier examples both define public fields, but [Example 3-11](#using_a_record_type)
    is better aligned with normal .NET practice, because it defines `Name` and `FavoriteColor`
    as properties. I’ll be describing properties in more detail later in this chapter.)
    As you can see, we create instances of record types with the `new` keyword, just
    as we do with a class. When a record type is defined in the way [Example 3-10](#record_type_enforcing_initialization)
    shows, we have to pass in all of the properties to the constructor, and in the
    right order. This way of defining a record is called the *positional syntax*.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-11\. Using a record type
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'When you use the syntax in [Example 3-10](#record_type_enforcing_initialization),
    the resulting record type is immutable: if you wrote code that tried to modify
    either of the properties of an existing `Person`, the compiler would report an
    error. Immutable data types can make it much easier to analyze code, especially
    multithreaded code, because you can count on them not to change under your feet.
    This is one of the reasons strings are immutable in .NET. However, before record
    types were introduced, immutable custom types have typically been inconvenient
    to work with in C#. For example, if you need to produce some new value that is
    a modified version of an existing value, you can be in for a lot of tedious work.
    Whereas the built-in `string` type provides numerous methods for producing new
    strings built out of existing strings (e.g., substrings, or conversions to lower-
    or uppercase), you’re on your own when you write a class.'
  prefs: []
  type: TYPE_NORMAL
- en: For example, suppose you are writing an application in which you’ve defined
    a data type representing the state of someone’s payment account at a particular
    moment in time. If you define this as an immutable type, then when processing
    a new transaction, you will need to make a copy that’s identical except for the
    current balance. Historically, doing this in C# meant you ended up needing to
    write code to copy over any unchanged data when creating the new instance. The
    main purpose of record types is to make it much easier to define and use immutable
    data types, so they offer an easy way to create a copy of an existing instance
    but with certain properties modified. As [Example 3-12](#modified_copy_of_record_type)
    shows, you can write `with` after a record expression, followed by a brace-delimited
    list of the properties you’d like to change.
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-12\. Making a modified copy of an immutable record
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In this particular case, our type has only two properties, so this isn’t dramatically
    better than just writing `new Person(startingRecord.Name, "Green")`. However,
    for records with larger numbers of properties, this syntax is much more convenient
    than rebuilding the whole thing every time.
  prefs: []
  type: TYPE_NORMAL
- en: While records make it much easier to create and use immutable data types, they
    don’t have to be immutable. [Example 3-13](#mutable_record_type) shows a `Person`
    record in which the properties can be modified after construction. (The `{ get;
    set; }` syntax indicates that these are auto-implemented properties. I’ll be describing
    them in more detail later, but they are essentially just simple read/write properties.)
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-13\. A record type with modifiable properties
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: At this point, we’re very nearly back to what we had in [Example 3-9](#ctor_enforcing_field_initialization),
    with the only difference being that `Name` and `FavoriteColor` are now properties
    instead of fields. We could just replace the `record` keyword in this example
    with `class` and it would still compile. So what exactly changes when we make
    this a `record`?
  prefs: []
  type: TYPE_NORMAL
- en: Although the primary purpose of records is to make it easy to build immutable
    data types, the `record` keyword also adds a couple of useful features. In addition
    to the `with` syntax for building modified copies, records get built-in support
    for equality testing and a `ToString` implementation that reports all of the property
    values. The equality testing enables you to use the `==` operator to compare two
    records, and as long as all their properties have the same values, they are considered
    to be equal. The same functionality is available through the `Equals` method.
    All types provide an `Equals` method (which I’ll describe in more detail later),
    and records arrange for this method to provide value-based comparison. You might
    wonder why record types are special in this regard—wouldn’t `Equals` work the
    same way for all types? Not so. Look at [Example 3-14](#comparing_instances).
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-14\. Comparing two instances of a type
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run this against any of the `Person` types defined in earlier examples
    as a `record` type, it will display the text `Equal`. However, if you were to
    use the definition of `Person` in [Example 3-9](#ctor_enforcing_field_initialization)
    (which defines it as a `class`), this will not display that message. Even though
    all the properties have the same value, `Equals` will report that they are not
    equal in that case. That’s because the default comparison behavior for classes
    is identity based: two variables are equal only if they refer to the very same
    object. When variables refer to two different objects, then even if those objects
    are of exactly the same type and have all the same property and field values,
    they are still distinct, and `Equals` reflects that. You can change this behavior
    when you write a class, but you have to write your own `Equals` method. With `record`,
    the compiler generates that for you.'
  prefs: []
  type: TYPE_NORMAL
- en: The other behavior `record` gives you is a specialized `ToString` implementation.
    All types in .NET offer a `ToString` method, and you can call this either directly
    or through some mechanism that invokes it implicitly, such as string interpolation.
    In types that don’t provide their own `ToString`, the default implementation just
    returns the type name, so if you call `ToString` on the class defined in [Example 3-9](#ctor_enforcing_field_initialization),
    it will always return `"Person"`, no matter what value the members have. Types
    are free to supply their own `ToString`, and the compiler does this for you for
    any record type. So if you call `ToString` on either of the `Person` instances
    created in [Example 3-14](#comparing_instances), it will return `"Person { Name
    = Ian, FavoriteColor = Blue }"`.
  prefs: []
  type: TYPE_NORMAL
- en: You can define records with properties whose types are also record types. [Example 3-15](#nested_records)
    defines a `Person` record type, and also a `Relation` record type to indicate
    some way in which two people are related.
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-15\. Nested record types
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: When you have this sort of composite structure—records within records—both `Equals`
    and `ToString` traverse into nested records. [Example 3-16](#using_nested_records)
    demonstrates this.
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-16\. Using nested record types
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Running this produces the following output (with lines split up to fit on the
    page):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the `Relation` type’s `ToString` has shown all of the properties
    of each of its nested `Person` records (and also the `RelationshipType` property,
    which is just a plain `string`). Likewise, the comparison logic works for nested
    records. Nothing special is happening here—a record type compares each property
    in turn by calling `Equals` on its value for that property, passing in the corresponding
    property from the record with which it is being compared. So when it happens to
    reach a record-type property, it calls its `Equals` method just as it would any
    other property, at which point that record type’s own `Equals` implementation
    will execute, comparing each nested property in turn.
  prefs: []
  type: TYPE_NORMAL
- en: None of the `record` keyword features I’ve described do anything you couldn’t
    have done by hand. It would be tedious but uncomplicated to write equivalent implementations
    of `ToString` and `Equals` by hand. (The compiler also provides implementations
    of the `==` and `!=` operators and methods called `GetHashCode` and `Deconstruct`
    that I’ll be describing later. But you could write all of those by hand too.)
    And as far as the .NET runtime is concerned, there’s nothing special about record
    types—it just sees them as ordinary classes.
  prefs: []
  type: TYPE_NORMAL
- en: Record types are a language-level feature. The C# compiler generates these types
    in such a way that it can recognize when types in external libraries were declared
    as records,^([1](ch03.xhtml#idm45884853473568)) but they are essentially just
    classes for which the compiler generates a few extra members. In fact, you can
    be explicit about this by declaring the type as `record class` instead of just
    `record`—these two syntaxes are equivalent.
  prefs: []
  type: TYPE_NORMAL
- en: References and Nulls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Any type defined with the `class` keyword will be a *reference type* (as will
    any type declared as `record`, or the equivalent `record class`). A variable of
    any reference type will not contain the data that makes up an instance of the
    type; instead, it can contain a *reference* to an instance of the type. Consequently,
    assignments don’t copy the object; they just copy the reference. [Example 3-17](#copying_references)
    contains almost the same code as [Example 3-2](#using_a_custom_class), except
    instead of using the `new` keyword to initialize the `c2` variable, it initializes
    it with a copy of `c1`.
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-17\. Copying references
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Because this example uses `new` just once, there is only one `Counter` instance,
    and the two variables both refer to this same instance. So we get different output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: It’s not just locals that do this—if you use a reference type for any other
    kind of variable, such as a field or property, assignment works the same way,
    copying the reference and not the whole object. This is the defining characteristic
    of a reference type, and it is different from the behavior we saw with the built-in
    numeric types in [Chapter 2](ch02.xhtml#ch_basic_coding). With those, each variable
    contains a value, not a reference to a value, so assignment necessarily involves
    copying the value. (This value-copying behavior is not available for most reference
    types—see the next sidebar, [“Copying Instances”](#copying_instances).)
  prefs: []
  type: TYPE_NORMAL
- en: We can write code that detects whether two references refer to the same thing.
    [Example 3-18](#comparing_references) arranges for three variables to refer to
    two counters with the same count, and then compares their identities. By default,
    the `==` operator does exactly this sort of object identity comparison when its
    operands are reference types. However, types are allowed to redefine the `==`
    operator. The `string` type changes `==` to perform value comparisons, so if you
    pass two distinct string objects as the operands of `==`, the result will be true
    if they contain identical text. If you want to force comparison of object identity,
    you can use the static `object.ReferenceEquals` method.
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-18\. Comparing references
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The first three lines of output confirm that all three variables refer to counters
    with the same count:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: It also illustrates that while they all have the same count, only `c1` and `c2`
    are considered to be the same thing. That’s because we assigned `c1` into `c2`,
    meaning that `c1` and `c2` will both refer to the same object, which is why the
    first comparison succeeds. But `c3` refers to a different object entirely (even
    though it happens to have the same value), which is why the second comparison
    fails. (I’ve used both the `==` and `object.ReferenceEquals` comparisons here
    to illustrate that they do the same thing in this case, because `Counter` has
    not defined a custom meaning for `==`.)
  prefs: []
  type: TYPE_NORMAL
- en: We could try the same thing with `int` instead of a `Counter`, as [Example 3-19](#comparing_values)
    shows. (This initializes the variables in a slightly idiosyncratic way in order
    to resemble [Example 3-18](#comparing_references) as closely as possible.)
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-19\. Comparing values
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'As before, we can see that all three variables have the same value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'This also illustrates that the `int` type defines a special meaning for `==`.
    With `int`, this operator compares the values, so those three comparisons succeed.
    But `obj⁠ect.​Ref⁠ere⁠nce⁠Equ⁠als` never succeeds for value types—in fact, I’ve
    added an extra, fourth comparison here, where I compare `c1` with itself, and
    even that fails! That surprising result occurs because it’s not meaningful to
    perform a reference comparison with `int`—it’s not a reference type. The compiler
    has to perform implicit conversions from `int` to `object` for the last four lines
    of [Example 3-19](#comparing_values): it has wrapped each argument to `object.ReferenceEquals`
    in something called a *box*, which we’ll be looking at in [Chapter 7](ch07.xhtml#ch_object_lifetime).
    Each argument gets a distinct box, which is why even the final comparison fails.'
  prefs: []
  type: TYPE_NORMAL
- en: There’s another difference between reference types and types like `int`. By
    default, any reference type variable can contain a special value, `null`, meaning
    that the variable does not refer to any object at all. You cannot assign this
    value into any of the built-in numeric types (although see the next sidebar, [“Nullable<T>”](#nullableless_thantgreater_than)).
  prefs: []
  type: TYPE_NORMAL
- en: Banishing Null with Non-Nullable References
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The widespread availability of null references in programming languages dates
    back to 1965, when computer scientist Tony Hoare added them to the highly influential
    ALGOL language. He has since apologized for this invention, which he described
    as his “billion-dollar mistake.” The possibility that a reference type variable
    might contain `null` makes it hard to know whether it’s safe to attempt to perform
    an action with that variable. (C# programs will throw a `NullReferenceException`
    if you attempt this, which will typically crash your program. [Chapter 8](ch08.xhtml#ch_exceptions)
    discusses exceptions.) Some modern programming languages avoid the practice of
    allowing references to be nullable by default, offering instead some system for
    optional values through an explicit opt-in mechanism in the type system. In fact,
    as you’ve seen with `Nullable<T>`, this is already the case for built-in numeric
    types (and also, as we’ll see, any custom value types that you define), but until
    recently, nullability has not been optional for all reference type variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'C# 8.0 introduced a significant new feature to the language that extends the
    type system to make a distinction between references that may be null and ones
    that must not be. Before C# 10.0, this feature was disabled by default, but now
    when you create a new project, it will be enabled. The feature’s name is *nullable
    references*, which seems odd, because references have been able to contain `null`
    since C# 1.0\. However, this name refers to the fact that with this feature enabled,
    nullability becomes an opt-in feature: a reference will never contain `null` unless
    it is explicitly defined as a nullable reference. At least, that’s the theory.'
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Enabling the type system to distinguish between nullable and non-nullable references
    was always going to be a tricky thing to retrofit to a language almost two decades
    into its life. So the reality is that C# cannot always guarantee that a non-nullable
    reference will never contain a `null`. However, it can make the guarantee if certain
    constraints hold, and more generally it will significantly reduce the chances
    of encountering a `NullReferenceException` even in cases where it cannot absolutely
    rule this out.
  prefs: []
  type: TYPE_NORMAL
- en: Enabling non-nullability is a radical change, which is why the feature was,
    until recently, switched off until you enabled it explicitly. (Even now, the change
    with C# 10.0 is that newly created *.csproj* files include the setting that turns
    this feature on. Without that setting, the feature continues to be off by default.)
    Switching it on can have a dramatic impact on existing code, so it is possible
    to control the feature at a fine-grained level to enable a gradual transition
    between the old world and the new nullable-references-aware world.
  prefs: []
  type: TYPE_NORMAL
- en: C# provides two dimensions of control, which it calls the *nullable annotation
    context* and the *nullable warning context*. Each line of code in a C# program
    is associated with one of each kind of context. The default is that all your code
    is in a *disabled* nullable annotation context and a *disabled* nullable warning
    context. You can change these defaults at a project level (and a newly created
    C# 10.0 project will do that). You can also use the `#nullable` directive to change
    either of the nullable annotation contexts at a more fine-grained level—a different
    one every line if you want. So how do these two contexts work?
  prefs: []
  type: TYPE_NORMAL
- en: The nullable annotation context determines whether we get to declare the nullability
    of a particular variable that uses a reference type. (I’m using C#’s broader definition
    of *variable* here, which includes not just local variables but also fields, parameters,
    and properties.) In a disabled annotation context (the default), we cannot express
    this, and all references are implicitly nullable. The official categorization
    describes these as *oblivious* to nullability, distinguishing them from references
    you have deliberately annotated as being nullable. However, in an enabled annotation
    context, we get to choose. [Example 3-20](#specifying_nullability) shows how.
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-20\. Specifying nullability
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This mirrors the syntax for nullability of built-in numeric types and custom
    value types. If you just write the type name, that denotes something non-nullable.
    If you want it to be nullable, you append a `?`.
  prefs: []
  type: TYPE_NORMAL
- en: The most important point to notice here is that in an enabled nullable annotation
    context, the old syntax gets the new behavior, and if you want the old behavior,
    you need to use the new syntax. This means that if you take existing code originally
    written without any awareness of nullability, and you put it into an enabled annotation
    context, *all* reference type variables are now effectively annotated as being
    non-nullable, the opposite of how the compiler treated the exact same code before.
  prefs: []
  type: TYPE_NORMAL
- en: The most direct way to put code into an enabled nullable annotation context
    is with a `#nullable enable annotations` directive. You can put this at the top
    of a source file to enable it for the whole file, or you can use it more locally,
    followed by a `#nullable restore annotations` to put back the project-wide default.
    On its own this will produce no visible change. The compiler won’t act on these
    annotations if the nullable warning context is disabled, and it is disabled by
    default. You can enable it locally with `#nullable enable warnings` (and `#nullable
    restore warnings` reverts to the project-wide default). You can control the project-wide
    defaults in the *.csproj* file by adding a `<Nullable>` property. [Example 3-21](#enabling_nullable_warnings_in_csproj)
    sets the defaults to an enabled nullable warning context and an enabled nullable
    annotation context. You will find a setting like this in any newly created C#
    10.0 project (whether created from Visual Studio or using the `dotnet new` at
    the command line).
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-21\. Specifying enabled nullable warning and annotation contexts as
    the project-wide default
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This means that all code will be in an enabled nullable warning context and
    also in an enabled nullable annotation context unless it explicitly opts out.
    Other project-wide settings are `disable` (which has the same effect as not setting
    `<Nullable>` at all), `warnings` (enables warnings but not annotations), and `annotations`
    (enables annotations but not warnings).
  prefs: []
  type: TYPE_NORMAL
- en: If you’ve specified an enabled annotation context at the project level, you
    can use `#nullable disable annotations` to opt out in individual files. Likewise,
    if you’ve specified an enabled warning context at the project level, you can opt
    out with `#nullable disable warnings`.
  prefs: []
  type: TYPE_NORMAL
- en: We have all this fine-grained control to make it easier to enable non-nullability
    for existing code. If you just fully enable the feature for an entire project
    in one step, you’re likely to encounter a lot of warnings. In practice, it may
    make more sense to put all code in the project in an enabled warning context but
    not to enable annotations anywhere to begin with. Since all of your references
    will be deemed *oblivious* to nullability checking, the only warnings you’ll see
    will relate to use of libraries. And any warnings at this stage are quite likely
    to be indicative of potential problems, e.g., missing tests for null. Once you’ve
    addressed these, you can start to move your own code into an enabled annotation
    context one file at a time (or in even smaller chunks if you prefer), making any
    necessary changes.
  prefs: []
  type: TYPE_NORMAL
- en: Over time, the goal would be to get all the code to the point where you can
    fully enable non-nullable support at the project level. And for newly created
    projects, it is usually best to have nullable references enabled from the start
    so that you can prevent problematic null handling ever getting into your code—that’s
    why new projects have this feature enabled.
  prefs: []
  type: TYPE_NORMAL
- en: What does the compiler do for us in code where we’ve fully enabled non-nullability
    support? We get two main things. First, the compiler uses rules similar to the
    definite assignment rules to ensure that we don’t attempt to dereference a variable
    without first checking to see whether it’s null. [Example 3-22](#dereferencing_nullable_reference)
    shows some cases the compiler will accept and some that would cause warnings in
    an enabled nullable warning context, assuming that `mayBeNull` was declared in
    an enabled nullable annotation context as being nullable.
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-22\. Dereferencing a nullable reference
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Second, in addition to checking whether dereferencing (use of `.` to access
    a member) is safe, the compiler will also warn you when you’ve attempted to assign
    a reference that might be null into something that requires a non-nullable reference,
    or if you pass one as an argument to a method when the corresponding parameter
    is declared as non-nullable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes, you’ll run into a roadblock on the path to moving all your code
    into fully enabled nullability contexts. Perhaps you depend on some component
    that is unlikely to be upgraded with nullability annotations in the foreseeable
    future, or perhaps there’s a scenario in which C#’s conservative safety rules
    incorrectly decide that some code is not safe. What can you do in these cases?
    You wouldn’t want to disable warnings for the entire project, and it would be
    irritating to have to leave the code peppered with `#nullable` directives. And
    while you can prevent warnings by adding explicit checks for `null`, this is undesirable
    in cases where you are confident that they are unnecessary. There is an alternative:
    you can tell the C# compiler that you know something it doesn’t. If you have a
    reference that the compiler presumes could be null but that you have good reason
    to believe will never be null, you can tell the compiler this by using the *null
    forgiving operator*, which you can see near the end of the second line of [Example 3-23](#null_forgiving_operator).
    It is sometimes known informally as the *dammit operator*, because being an exclamation
    mark makes it look like a slightly exasperated kind of assertion.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-23\. The null forgiving operator
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: You can use the null forgiving operator in any enabled nullable annotation context.
    It has the effect of converting a nullable reference to a non-nullable reference.
    You can then go on to dereference that non-nullable reference or otherwise use
    it in places where a nullable reference would not be allowed without causing any
    compiler warnings.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The null forgiving operator does not check its input. If you apply this in a
    scenario where the value turns out to be null at runtime, it will not detect this.
    Instead, you will get a runtime error at the point where you try to use the reference.
  prefs: []
  type: TYPE_NORMAL
- en: 'While the null forgiving operator can be useful at the boundary between nullable-aware
    code and old code that you don’t control, there’s another way to let the compiler
    know when an apparently nullable expression will not in fact be null: nullable
    attributes. .NET defines several attributes that you can use to annotate code
    to describe when it will or won’t return null values. Consider the code in [Example 3-24](#nullability_try_pattern).
    If you do not enable the nullable reference type features, this works fine, but
    if you turn them on, you will get a warning. (This uses a dictionary, a collection
    type that is described in detail in [Chapter 5](ch05.xhtml#ch_collections).)'
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-24\. Nullability and the Try pattern—before nullable reference types
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: With nullability fully enabled, the compiler will complain at the `out string
    s`. It will tell you, correctly, that `TryGetValue` might pass a `null` through
    that `out` argument. (This kind of argument is discussed later; it provides a
    way to return additional values besides the function’s main return value.) This
    function checks whether the dictionary contains an entry with the specified key.
    If it does, it will return `true` and put the relevant value into the `out` argument,
    but if not, it returns `false` and sets that `out` argument to `null`. We can
    modify our code to reflect this fact by putting a `?` after the `out string`.
    [Example 3-25](#try_pattern_nullable_aware) shows this modification.
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-25\. Nullable-aware use of the Try pattern
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: You might expect this to cause a new problem. Our `Get` method returns a `string`,
    not a `string?`, so how can that `return s` be correct? We just modified our code
    to indicate that `s` might be null, so won’t the compiler complain when we try
    to return this possibly null value from a method that declares that it won’t return
    `null`? But in fact this compiles. The compiler accepts this because it knows
    that `TryGetValue` will only set that `out` argument to `null` if it returns `false`.
    That means that the compiler knows that although the `s` variable’s type is `string?`,
    it will not be `null` inside the body of the `if` statement. It knows this thanks
    to a nullable attribute applied to the `TryGetValue` method’s definition. (Attributes
    are described in [Chapter 14](ch14.xhtml#ch_attributes).) [Example 3-26](#nullable_attribute)
    shows the attribute in the method’s declaration. (This method is part of a generic
    type, which is why we see `TKey` and `TValue` here and not the `int` and `string`
    types I used in my examples. [Chapter 4](ch04.xhtml#ch_generics) discusses this
    kind of method in detail. In the examples at hand, `TKey` and `TValue` are, in
    effect, `int` and `string`.)
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-26\. A nullable attribute
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: This annotation is how C# knows that the value might be `null` if `TryGetValue`
    returns `false` but won’t be if it returns `true`. Without this attribute, [Example 3-24](#nullability_try_pattern)
    would have compiled successfully even with nullable warnings enabled, because
    by writing `IDictionary<int, string>` (and not `IDictionary<int, string?>`) I
    am indicating that my dictionary does not permit null values. So normally, C#
    will assume that when a method returns a value from the dictionary, it will also
    produce a `string`. But `TryGetValue` sometimes has no value to return, which
    is why it needs this annotation. [Table 3-1](#nullable_attributes) describes the
    various attributes you can apply to give the C# compiler more information about
    what may or may not be `null`.
  prefs: []
  type: TYPE_NORMAL
- en: Table 3-1\. Nullable attributes
  prefs: []
  type: TYPE_NORMAL
- en: '| **Type** | **Usage** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `AllowNull` | Code is allowed to supply `null` even when the type is non-nullable.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `DisallowNull` | Code must not supply `null` even when the type is nullable.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `MaybeNull` | Code should be prepared for this to return the `null` value
    even when the type is non-nullable. |'
  prefs: []
  type: TYPE_TB
- en: '| `MaybeNullWhen` | Used only with `out` or `ref` parameters; the output may
    be `null` if the method returns the specified `bool` value. |'
  prefs: []
  type: TYPE_TB
- en: '| `NotNull` | Used with parameters. If the method returns without error, the
    argument was not `null`. (With `out` or `ref` parameters, this typically means
    the method makes sure to set them; with an inbound-only parameter, this implies
    the method checks the value and only returns without error if it was not `null`.)
    |'
  prefs: []
  type: TYPE_TB
- en: '| `NotNullWhen` | Used only with `out` or `ref` parameters; the output may
    not be `null` if the method returns the specified `bool` value. |'
  prefs: []
  type: TYPE_TB
- en: '| `NotNullIfNotNull` | If you pass a non-null value as the argument for the
    parameter that this attribute names, the value returned by this attribute’s target
    will not be `null`. |'
  prefs: []
  type: TYPE_TB
- en: These attributes have been applied where appropriate to most of the .NET runtime
    libraries to reduce the friction involved in adopting nullable references.
  prefs: []
  type: TYPE_NORMAL
- en: 'Moving code into enabled nullable warning and annotation contexts can provide
    a significant boost to code quality. Many developers who migrate existing codebases
    often uncover some latent bugs in the process, thanks to the additional checks
    the compiler performs. However, it is not perfect. There are two holes worth being
    aware of, caused by the fact that nullability was not baked into the type system
    from the start. The first is that legacy code introduces blind spots—even if all
    your code is in an enabled nullable annotation context, if it uses APIs that are
    not, references it obtains from those will be oblivious to nullability. If you
    need to use the null forgiving operator to keep the compiler happy, there’s always
    the possibility that you are mistaken, at which point you’ll end up with a `null`
    in what is supposed to be a non-nullable variable. The second is more vexing in
    that you can hit it in brand-new code, even if you fully enabled this feature
    from the start: certain storage locations in .NET have their memory filled with
    zero values when they are initialized. If these locations are of a reference type,
    they will end up starting out with a `null` value, and there’s currently no way
    that the C# compiler can enforce their non-nullability. Arrays have this issue.
    Look at [Example 3-27](#nullable_arrays).'
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-27\. Arrays and nullability
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: This code declares two arrays of strings. The first uses `string?`, so it allows
    nullable references. The second does not. However, in .NET you have to create
    arrays before you can put anything in them, and a newly created array’s memory
    is always zero-initialized. This means that our `nonNullableStrings` array will
    start life full of nulls. There is no way to avoid this because of how arrays
    work in .NET. One way to mitigate this problem is to avoid using arrays directly.
    If you use `List<string>` instead (see [Chapter 5](ch05.xhtml#ch_collections)),
    it will contain only items that you have added—unlike an array, a `List<T>` does
    not provide a way to initialize it with empty slots. But you can’t always substitute
    a `List<T>` for an array. Sometimes you will simply need to take care that you
    initialize all the elements in an array.
  prefs: []
  type: TYPE_NORMAL
- en: A similar problem exists with fields in value types, which are described in
    the following section. If they have reference type fields, there are situations
    in which you cannot prevent them from being initialized to `null`. So the nullable
    references feature is not perfect. It is nonetheless very useful. Teams that have
    made the necessary changes to existing projects to use it have reported that this
    process tends to uncover many previously undiscovered bugs. It is an important
    tool for improving the quality of your code.
  prefs: []
  type: TYPE_NORMAL
- en: Although non-nullable references diminish one of the distinctions between reference
    types and built-in numeric types, important differences remain. A variable of
    type `int` is not a reference to an `int`. It contains the value of the `int`—there
    is no indirection. In some languages, this choice between reference-like and value-like
    behavior is determined by the way in which you use a type, but in C#, it is a
    fixed feature of the type. Any particular type is either a reference type or a
    *value type*. The built-in numeric types are all value types, as is `bool`, whereas
    a `class` is always a reference type. But this is not a distinction between built-in
    and custom types. You can write custom value types.
  prefs: []
  type: TYPE_NORMAL
- en: Structs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes it will be appropriate for a custom type to get the same value-like
    behavior as the built-in value types. The most obvious example would be a custom
    numeric type. Although the CLR offers various intrinsic numeric types, some kinds
    of calculations require a bit more structure than these provide. For example,
    many scientific and engineering calculations work with complex numbers. The runtime
    does not define an intrinsic representation for these, but the runtime libraries
    support them with the `Complex` type. It would be unhelpful if a numeric type
    such as this behaved significantly differently from the built-in types. Fortunately,
    it doesn’t, because it is a value type. The way to write a custom value type is
    to use the `struct` keyword instead of `class`.
  prefs: []
  type: TYPE_NORMAL
- en: 'A struct can have most of the same features as a class; it can contain methods,
    fields, properties, constructors, and any of the other member types supported
    by classes (described in [“Members”](#members)), and we can use the same accessibility
    keywords, such as `public` and `internal`. There are a few restrictions, but with
    the simple `Counter` type I wrote earlier, I *could* just replace the `class`
    keyword with `struct`. However, this would not be a useful transformation. Remember,
    one of the main distinctions between reference types (classes) and value types
    is that the former have identity: it might be useful for me to create multiple
    `Counter` objects so that I can count different kinds of things. But with value
    types (either the built-in ones or custom structs), the assumption is that they
    can be copied freely. If I have an instance of the `int` type (e.g., 4) and I
    store that in several fields, there’s no expectation that this value has a life
    of its own: one instance of the number 4 is indistinguishable from another. The
    variables that hold values have their own identities and lifetimes, but the values
    that they hold do not. This is different from how reference types work: not only
    do the variables that refer to them have identities and lifetimes, the objects
    they refer to have their own identities and lifetimes independent of any particular
    variable.'
  prefs: []
  type: TYPE_NORMAL
- en: If I add one to the `int` value 4, the result is a completely different `int`
    value. If I call `GetNextValue()` on a `Counter`, its count goes up by one, but
    it remains the same `Counter` instance. So although replacing `class` with `struct`
    in [Example 3-3](#class_with_static_members) would compile, we really don’t want
    our `Counter` type to become a struct. [Example 3-28](#simple_struct) shows a
    better candidate.
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-28\. A simple struct
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: This represents a point in two-dimensional space. And while it’s certainly possible
    to imagine wanting the ability to represent particular points with their own identity
    (in which case we’d want a `class`), it’s perfectly reasonable to want to have
    a value-like type representing a point’s location.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although [Example 3-28](#simple_struct) is OK as far as it goes, it’s common
    for values to support comparison. As mentioned earlier, C# defines a default meaning
    for the `==` operator for reference types: it is equivalent to `object.ReferenceEquals`,
    which compares identities. That’s not meaningful for value types, so C# does not
    automatically support `==` for a `struct`. You are not strictly required to provide
    a definition, but the built-in value types all do, so if we’re trying to make
    a type with similar characteristics to those, we should do this. If you add an
    `==` operator on its own, the compiler will inform you that you are required to
    define a matching `!=` operator. You might think C# would define `!=` as the inverse
    of `==`, since they appear to mean the opposite. However, some types will return
    `false` for both operators for certain pairs of operands, so C# requires us to
    define both independently. As [Example 3-29](#support_custom_comparison) shows,
    to define a custom meaning for an operator, we use the `operator` keyword followed
    by the operator we’d like to customize. This example defines the behavior for
    `==` and `!=`, which are very straightforward for our simple type. (Since all
    of the new methods in this example do nothing more than returning the value of
    a single expression, I’ve implemented them using the `=>` syntax, just as I’ve
    done with various properties in preceding examples.)'
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-29\. Support custom comparison
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'If you just add the `==` and `!=` operators, you’ll find that the compiler
    generates warnings recommending that you define two methods called `Equals` and
    `GetHashCode`. `Equals` is a standard method available on all .NET types, and
    if you have defined a custom meaning for `==`, you should ensure that `Equals`
    does the same thing. [Example 3-29](#support_custom_comparison) does this, and
    as you can see, it contains the same logic as the `==` operator, but it has to
    do some extra work. The `Equals` method permits comparison with any type, so we
    first check to see if our `Point` is being compared with another `Point`. I’ve
    used a declaration pattern to perform this check and also to get the incoming
    `obj` argument into a variable of type `Point` in the case where the pattern matches.
    In fact it implements two versions of `Equals`: the standard method that accepts
    any `object` and a more specialized one that allows comparison only with other
    `Point` values. This allows for more efficient comparisons by avoiding boxing
    (which is described in [Chapter 7](ch07.xhtml#ch_object_lifetime)), and as is
    common practice when offering this second form of `Equals`, I’ve declared support
    for the `IEquatable<Point>` interface; I’ll be describing interfaces in [“Interfaces”](#interfaces).
    [Example 3-29](#support_custom_comparison) also implements `GetHashCode`, which
    we’re required to do if we implement `Equals`. See the next sidebar, [“GetHashCode”](#gethashcode),
    for details.'
  prefs: []
  type: TYPE_NORMAL
- en: With the version of `Point` in [Example 3-29](#support_custom_comparison), we
    can run a few tests. [Example 3-30](#comparing_structs) works similarly to Examples
    [3-18](#comparing_references) and [3-19](#comparing_values).
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-30\. Comparing struct instances
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Running that code produces this output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: All three instances have the same value. With `p2` that’s because I initialized
    it by assigning `p1` into it, and with `p3` I constructed it from scratch but
    with the same arguments. Then we have the first three comparisons, which, remember,
    use `==`. Since [Example 3-29](#support_custom_comparison) defines a custom implementation
    that compares values, all the comparisons succeed. And all the `object.ReferenceEquals`
    values fail, because this is a value type, just like `int`. In fact, this is the
    same behavior we saw with [Example 3-19](#comparing_values), which used `int`
    instead of `Counter`. (Again, the compiler has generated implicit conversions
    here that produce boxes, which we will look at in [Chapter 7](ch07.xhtml#ch_object_lifetime).)
    So we have achieved our goal of defining a type with similar behavior to built-in
    value types such as `int`.
  prefs: []
  type: TYPE_NORMAL
- en: When to Write a Value Type
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I’ve shown some of the differences in observable behavior between a reference
    type (`class` or `record`) and a `struct`, but although I argued why `Counter`
    was a poor candidate for being a `struct`, I’ve not fully explained what makes
    a good one. The short answer is that there are only two circumstances in which
    you should write a value type. First, if you need to represent something value-like,
    such as a number, a struct is likely to be ideal. Second, if you have determined
    that a struct has usefully better performance characteristics for the scenario
    in which you will use the type, a struct may not be ideal but might still be a
    good choice. But it’s worth understanding the pros and cons in more detail. And
    I will also address a surprisingly persistent myth about value types.
  prefs: []
  type: TYPE_NORMAL
- en: With reference types, an object is distinct from a variable that refers to it.
    This can be very useful, because we often use objects as models for real things
    with identities of their own. But this has some performance implications. An object’s
    lifetime is not necessarily directly related to the lifetime of a variable that
    refers to it. You can create a new object, store a reference to it in a local
    variable, and then later copy that reference to a static field. The method that
    originally created the object might then return, so the local variable that first
    referred to the object no longer exists, but the object needs to stay alive because
    it’s still possible to reach it by other means.
  prefs: []
  type: TYPE_NORMAL
- en: The CLR goes to considerable lengths to ensure that the memory an object occupies
    is not reclaimed prematurely but is eventually freed once the object is no longer
    in use. This is a fairly complex process (described in detail in [Chapter 7](ch07.xhtml#ch_object_lifetime)),
    and .NET applications can end up causing the CLR to consume a considerable amount
    of CPU time just tracking objects in order to work out when they fall out of use.
    Creating lots of objects increases this overhead. Adding complexity in certain
    ways can also increase the costs of object tracking—if a particular object remains
    alive only because it is reachable through some very convoluted path, the CLR
    may need to follow that path each time it tries to work out what memory is still
    in use. Each level of indirection you add generates extra work. A reference is
    by definition indirect, so every reference type variable creates work for the
    CLR.
  prefs: []
  type: TYPE_NORMAL
- en: 'Value types can often be handled in a much simpler way. For example, consider
    arrays. If you declare an array of some reference type, you end up with an array
    of references. This is very flexible—elements can be null if you want, and you’re
    also free to have multiple different elements all referring to the same item.
    But if what you actually need is a simple sequential collection of items, that
    flexibility is just overhead. A collection of 1,000 reference type instances requires
    1,001 blocks of memory: one block to hold an array of references, and then 1,000
    objects for those references to refer to. But with value types, a single block
    can hold all the values. This simplifies things for memory management purposes—either
    the array is still in use or it’s not, and there’s no need for the CLR to check
    the 1,000 individual elements separately.'
  prefs: []
  type: TYPE_NORMAL
- en: It’s not just arrays that can benefit from this sort of efficiency. There’s
    also an advantage for fields. Consider a class that contains 10 fields, all of
    type `int`. The 40 bytes required to hold those fields’ values can live directly
    inside the memory allocated for an instance of the containing class. Compare that
    with 10 fields of some reference type. Although those references can be stored
    inside the object instance’s memory, the objects they refer to will be separate
    entities, so if the fields are all non-null and all refer to different objects,
    you’ll now have 11 blocks of memory—one for the instance that contains all the
    fields, and then one for each object those fields refer to. [Figure 3-1](#references_versus_values)
    illustrates these differences between references and values for both arrays and
    objects (with smaller examples, because the same principle applies even with a
    handful of instances).
  prefs: []
  type: TYPE_NORMAL
- en: Value types can also sometimes simplify lifetime handling. Often, the memory
    allocated for local variables can be freed as soon as a method returns (although,
    as we’ll see in [Chapter 9](ch09.xhtml#ch_delegates_lambdas_events), anonymous
    functions mean that it’s not always that simple). This means the memory for local
    variables can often live on the stack, which typically has much lower overheads
    than the heap. For reference types, the memory for a variable is only part of
    the story—the object it refers to cannot be handled so easily, because that object
    may continue to be reachable by other paths after the method exits.
  prefs: []
  type: TYPE_NORMAL
- en: '![References versus values](assets/pc10_0301.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-1\. References versus values
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In fact, the memory for a value may be reclaimed even before a method returns.
    New value instances often overwrite older instances. For example, C# can normally
    just use a single piece of memory to represent a variable, no matter how many
    different values you put in there. Creating a new instance of a value type doesn’t
    necessarily mean allocating more memory, whereas with reference types, a new instance
    means a new heap block. This is why it’s OK for each operation we perform with
    a value type—every integer addition or subtraction, for example—to produce a new
    instance.
  prefs: []
  type: TYPE_NORMAL
- en: One of the most persistent myths about value types says that values are allocated
    on the stack, unlike objects. It’s true that objects always live on the heap,
    but value types don’t always live on the stack,^([2](ch03.xhtml#idm45884832593360))
    and even in the situations where they do, that’s an implementation detail, not
    a fundamental feature of C#. [Figure 3-1](#references_versus_values) shows two
    counterexamples. An `int` value inside an array of type `int[]` does not live
    on the stack; it lives inside the array’s heap block. Likewise, if a class declares
    a nonstatic `int` field, the value of that `int` lives inside the heap block for
    its containing object instance. And even local variables of value types don’t
    necessarily end up on the stack. For example, optimizations may make it possible
    for the value of a local variable to live entirely inside the CPU’s registers,
    rather than needing to go on the stack. And as you’ll see in Chapters [9](ch09.xhtml#ch_delegates_lambdas_events)
    and [17](ch17.xhtml#ch_asynchronous_language_features), locals can sometimes live
    on the heap.
  prefs: []
  type: TYPE_NORMAL
- en: You might be tempted to summarize the preceding few paragraphs as “there are
    some complex details, but in essence, value types are more efficient.” But that
    would be a mistake. There are some situations in which value types are significantly
    more expensive. Remember that a defining feature of a value type is that values
    get copied on assignment. If the value type is big, that will be relatively expensive.
    For example, the runtime libraries define the `Guid` type to represent the 16-byte
    *globally unique identifiers* that crop up in lots of bits of Windows. This is
    a `struct`, so any assignment statement involving a `Guid` is asking to make a
    copy of a 16-byte data structure. This is likely to be more expensive than making
    a copy of a reference, because the CLR uses a pointer-based implementation for
    references; a pointer typically takes 4 or 8 bytes, but more importantly, it’ll
    be something that fits naturally into a single CPU register.
  prefs: []
  type: TYPE_NORMAL
- en: It’s not just assignment that causes values to be copied. Passing a value type
    argument to a method may require a copy. As it happens, with method invocation,
    it is actually possible to pass a reference to a value, although as we’ll see
    later, it’s a slightly limited kind of reference, and the restrictions it imposes
    are sometimes undesirable, so you may end up deciding that the cost of the copy
    is preferable. This is why Microsoft’s design guidelines suggest that you should
    not make a type a `struct` unless it “has an instance size under 16 bytes” (a
    guideline that the `Guid` type technically violates, being exactly 16 bytes in
    size). But this is not a hard-and-fast rule—it really depends on how you will
    be using it, and since more recent versions of C# provide more flexibility for
    using values types indirectly, it is increasingly common for performance-sensitive
    code to ignore this restriction and instead to take care to minimize copying.
  prefs: []
  type: TYPE_NORMAL
- en: 'Value types are not automatically going to be more efficient than reference
    types, so in most cases, your choice should be driven by the behavior you require.
    The most important question is this: Does the identity of an instance matter to
    you? In other words, is the distinction between one object and another object
    important? For our `Counter` example, the answer is yes: if we want something
    to keep count for us, it’s simplest if that counter is a distinct thing with its
    own identity. (Otherwise, our `Counter` type adds nothing beyond what `int` gives
    us.) But for our `Point` type, the answer is no, so it’s a reasonable candidate
    for being a value type.'
  prefs: []
  type: TYPE_NORMAL
- en: 'An important and related question is: Does an instance of your type contain
    state that changes over time? Modifiable value types tend to be problematic, because
    it’s all too easy to end up working with some copy of a value and not the instance
    you meant to. (I’ll show an important example of this problem later, in [“Properties
    and mutable value types”](#properties_and_mutable_value_types), and another when
    I describe `List<T>` in [Chapter 5](ch05.xhtml#ch_collections).) So it’s usually
    a good idea for value types to be immutable. This doesn’t mean that variables
    of these types cannot be modified; it just means that to modify the variable,
    you must replace its contents entirely with a different value. For something simple
    like an `int`, this will seem like splitting hairs, but the distinction is important
    with structs that contain multiple fields, such as .NET’s `Complex` type, which
    represents numbers that combine a real and an imaginary component. You cannot
    change the `Real` or `Imaginary` property of an existing `Complex` instance, because
    the type is immutable. And the `Point` type shown earlier works the same way.
    If the value you’ve got isn’t the value you want, immutability just means you
    need to create a new value, because you can’t tweak the existing instance.'
  prefs: []
  type: TYPE_NORMAL
- en: Immutability does not necessarily mean you should write a struct—the built-in
    `string` type is immutable, and that’s a class.^([3](ch03.xhtml#fn19)) However,
    because C# often does not need to allocate new memory to hold new instances of
    a value type, value types are able to support immutability more efficiently than
    classes in scenarios where you’re creating lots of new values (e.g., in a loop).
    Immutability is not an absolute requirement for structs—there are some unfortunate
    exceptions in .NET’s runtime libraries. But value types should normally be immutable,
    so a requirement for mutability is usually a good sign that you want a class rather
    than a struct.
  prefs: []
  type: TYPE_NORMAL
- en: A type should only be a struct if it represents something that is very clearly
    similar in nature to other things that are value types. (In most cases it should
    also be fairly small, because passing large types by value is expensive.) For
    example, in the runtime libraries, `Complex` is a struct, which is unsurprising
    because it’s a numeric type, and all of the built-in numeric types are value types.
    `TimeSpan` is also a value type, which makes sense because it’s effectively just
    a number that happens to represent a length of time. In the UI framework WPF,
    types used for simple geometric data such as `Point` and `Rect` are structs. But
    if in doubt, write a class.
  prefs: []
  type: TYPE_NORMAL
- en: Guaranteeing Immutability
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can declare your intention to make a struct read-only by adding the `readonly`
    keyword in front of `struct`, as [Example 3-31](#a_readonly_struct) shows. This
    is similar to the `Point` type shown in [Example 3-28](#simple_struct), but I’ve
    made a couple of other alterations. In addition to adding the `readonly` qualifier,
    I’ve also used read-only auto-properties to reduce the clutter—the compiler will
    generate code equivalent to the earlier example for these. I’ve also added a member
    function for reasons that will soon become clear. Like the earlier version, this
    has a constructor, and in this case that was mandatory: the constructor provides
    the only opportunity to supply values for a `Point`’s properties, so this type
    would be useless without one.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-31\. A read-only struct
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Applying the `readonly` keyword to a `struct` has two effects. First, the C#
    compiler will keep you honest, preventing modification either from outside or
    from within. If you declare any fields, the compiler will generate an error unless
    these are also marked `readonly`. Similarly, if you try to define a settable auto-property
    (one with a `set;` as well as a `get;`), the compiler will produce an error.
  prefs: []
  type: TYPE_NORMAL
- en: Second, read-only structs enjoy certain optimizations. If in some other type
    you declare a `readonly` field (either directly or indirectly with a read-only
    auto-property) whose type is a `readonly struct`, the compiler may be able to
    avoid making a copy of the data when something uses that field. Consider the class
    in [Example 3-32](#readonly_struct_in_readonly_property).
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-32\. A read-only struct in a read-only property
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Suppose you had a variable `r` containing a reference to a `LocationData`. What
    would happen if you wrote the expression `r.Location.DistanceFromOrigin()`? Logically,
    we’re asking `r.Location` to retrieve the `Point`, and since `Point` is a value
    type, that would entail making a copy of the value. Normally, C# will generate
    code that really does make a copy because it cannot in general know whether invoking
    some member of a `struct` will modify it. These are known as *defensive copies*,
    and they ensure that expressions like this can’t cause a nasty surprise such as
    changing the value of a property or field that appears to be read-only. However,
    since `Point` is a `readonly struct`, the compiler can know that it does not need
    to create a defensive copy here. In this case, it would be safe for either the
    C# compiler or the JIT compiler (or AoT code generator) to optimize this code
    by invoking `DistanceFromOrigin` directly on the value stored inside the `LocationData`
    without first making a copy.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You are allowed to use a `readonly struct` in writable fields and properties
    if you want to. The `readonly` keyword guarantees only that any particular value
    of this type will not change. If you want to overwrite an existing value with
    a completely different value, that’s up to you.
  prefs: []
  type: TYPE_NORMAL
- en: Record Structs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you saw [Example 3-29](#support_custom_comparison), you might have thought
    to yourself that this seems a lot like the kind of work that the compiler can
    do for us in a `record` type. Can we get it do the same work with a `struct`?
    Starting with C# 10.0, we can declare a `record struct` type, which adds the same
    comparison behavior that we get with a `class`-based record—the compiler would
    write `GetHashCode` and both forms of the `Equals` methods for you, along with
    the `==` and `!=` operators.
  prefs: []
  type: TYPE_NORMAL
- en: Besides the usual differences between classes and value types already described,
    there are some other more subtle differences between `record` and `record struct`
    types. For example, because `struct` types have a way to declare explicitly that
    they are immutable (the `readonly` qualifier), when you use the positional syntax
    with a `record struct`, the compiler assumes that if you want a read-only type,
    you’ll say so by declaring it as `readonly record struct`. So although properties
    defined with the positional syntax are immutable on a `readonly record struct`
    (just as they are on a `record`), they are modifiable on a `record struct`. So
    whereas you cannot modify the `X` and `Y` properties of a `PointRecord` type in
    [Example 3-33](#readonly_vs_mutable_records) after construction, you could change
    the properties of a `PointStructRecord`. But `Poi⁠ntR⁠ead⁠on⁠ly​Str⁠uct⁠Rec⁠ord`
    gets immutable properties, just like `PointRecord`.
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-33\. A read-only `record`, a mutable `record struct`, and a `readonly
    record struct`
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '`record structs` also have some subtle differences around constructors, which
    I’ll describe in [“Constructors”](#constructors).'
  prefs: []
  type: TYPE_NORMAL
- en: Class, Structs, Records, or Tuples?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you’ve now seen, C# offers many ways to define types. How should we choose
    between them? Suppose your code needs to work with a pair of coordinates representing
    a position in two-dimensional space? How should you represent this in C#?
  prefs: []
  type: TYPE_NORMAL
- en: 'The simplest possible answer would be to declare two variables of type `double`,
    one for each dimension. This certainly works, but your code will fail to capture
    something important: the two values are not two separate things. If your chosen
    type doesn’t represent the fact that these two numbers are a single entity, that
    will cause problems. It is inconvenient when you want to write methods that take
    a position as an argument—you end up needing two arguments. If you accidentally
    pass the X value from one coordinate pair and the Y value from a different one,
    the compiler will have no way of knowing this is wrong. Using two separate values
    is especially troublesome if you want a function to return a position, because
    C# methods can return only a single value.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Tuples, which were described in [Chapter 2](ch02.xhtml#ch_basic_coding), can
    solve the problems I just described because a single value can contain a pair
    of numbers: `(1.0, 2.0)`. While this is certainly an improvement, the problem
    with tuples is that they are unable to distinguish between different kinds of
    data that happen to have the same structure. This isn’t unique to tuples: built-in
    types have the same issue. A `double` representing a distance in feet has the
    same C# type as one representing a distance in meters, even though there is a
    significant difference in meaning. (NASA lost a space probe in 1999 due to confusion
    over values with identical types but different units.) But these problems go beyond
    mismatched units. Suppose you have a tuple `(X: 10.0, Y: 10.0)` representing the
    position of a rectangle in meters, and another, `(Width: 2.0, Height: 1.0)` representing
    its size, also in meters. The units are the same here, but position and size are
    quite different concepts, and yet these two tuples have exactly the same type.
    This can seem particularly surprising when the members of the tuples have different
    names—the first has `X` and `Y`, but the second has `Width` and `Height`. However,
    as you saw in the preceding chapter, these tuple member names are a fiction the
    C# compiler provides for our convenience. The real names are `Item1` and `Item2`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Given the limitations of tuples, it may be more appropriate to ask: When would
    you ever want to use a tuple instead of a specialized type such as a record? I
    have found tuples very useful in private implementation details in places where
    there is little chance of the structural equivalence of conceptually unrelated
    tuple types causing a problem. For example, when using the `Dictionary<TKey, TValue>`
    container type described in [Chapter 5](ch05.xhtml#ch_collections), it is sometimes
    useful for the dictionary key to be made up of more than one value. Tuples are
    ideal for this sort of compound key. They can also be useful when a method needs
    to return multiple related pieces of data in cases where defining a whole new
    type seems like overkill. For example, if the method is a private one called in
    only one or two places, is it really worth defining a whole type just to act as
    the return type of that one method?'
  prefs: []
  type: TYPE_NORMAL
- en: 'Record types would work better than tuples for our structurally similar but
    conceptually different position and dimension examples: if we define `public record
    Position(double X, double Y)` and `public record Dimensions(double Width, double
    Height)`, we now have two distinct types to represent these two separate kinds
    of data. If we accidentally try to use positions when dimensions are required,
    the compiler will point out the mistake. Moreover, unlike the locally defined
    names we can give tuple members, the names of a record’s properties are real,
    so code using `Dimensions` will always to refer to its members as `Width` and
    `Height`. Record types automatically implement equality comparisons and hash codes,
    so they work just as well as tuples as compound keys in dictionaries. There are
    really only two reasons you might choose a tuple over a record. One is when you
    actually want the structural equivalence—there are some occasions where deliberately
    being a bit vague about types can provide extra flexibility that might justify
    the possible reduction in safety. And the second is in cases where defining a
    type seems like overkill (e.g., when using a compound key for a dictionary that
    is used only inside one method).'
  prefs: []
  type: TYPE_NORMAL
- en: Since record types are full .NET types, they can contain more than just properties—they
    can contain any of the other member types described in the following section.
    Our `Dimensions` record type could include a method that calculates the area,
    for example. And we are free to choose between defining a reference type or a
    value type by using either `record` or `record struct`.
  prefs: []
  type: TYPE_NORMAL
- en: 'When would we use a class (or struct) instead of a record? One reason might
    be that you don’t want the equality logic. If your application has entities with
    their own identities—perhaps certain objects correspond to people or to particular
    devices—the value-based comparison logic generated for record types will be inappropriate,
    because two items can be distinct even if they happen to share the same characteristics.
    (Imagine objects representing shapes in a drawing program. If you clone a shape,
    you will have two identical objects, but it’s important that they are still considered
    different because the cloned item may then go on to be moved or otherwise modified.)
    So you might want to ask: does your type represent a thing, or does it just hold
    some information? If it represents some information, a record type is likely to
    be a good choice, but a class may well be a better bet for entities that represent
    some real entity, especially if instances of the type have behavior of their own.
    For example, when building a user interface, an interactive element such as a
    button would be better modeled as a `class` than a `record`. It’s not that a record
    type couldn’t be made to work—they can be made to do more or less anything ordinary
    classes and structs can do; it’s just that they are likely to be a less good fit.'
  prefs: []
  type: TYPE_NORMAL
- en: Members
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Whether you’re writing a class, a struct, or a record, there are several different
    kinds of members you can put in a custom type. We’ve seen examples of some already,
    but let’s take a closer and more comprehensive look.
  prefs: []
  type: TYPE_NORMAL
- en: Accessibility
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can specify the accessibility for most class and struct members. Just as
    a type can be `public` or `internal`, so can each member. Members may also be
    declared as `private`, making them accessible only to code inside the type, and
    this is the default accessibility. As we’ll see in [Chapter 6](ch06.xhtml#ch_inheritance),
    inheritance adds three more accessibility levels for members: `protected`, `protected
    internal`, and `protected private`.'
  prefs: []
  type: TYPE_NORMAL
- en: Fields
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You’ve already seen that fields are named storage locations that hold either
    values or references depending on their type. By default, each instance of a type
    gets its own set of fields, but if you want a field to be singular, rather than
    having one per instance, you can use the `static` keyword. You can also apply
    the `readonly` keyword to a field, which states that it can be set only during
    initialization and cannot change thereafter.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The `readonly` keyword does not make any absolute guarantees. There are mechanisms
    by which it is possible to contrive a change in the value of a `readonly` field.
    The reflection mechanisms discussed in [Chapter 13](ch13.xhtml#ch_reflection)
    provide one way, and unsafe code, which lets you work directly with raw pointers,
    provides another. The compiler will prevent you from modifying a field accidentally,
    but with sufficient determination, you can bypass this protection. And even without
    such subterfuge, a `readonly` field is free to change during construction.
  prefs: []
  type: TYPE_NORMAL
- en: 'C# offers a keyword that seems, superficially, to be similar: you can define
    a `const` field. However, this is designed for a somewhat different purpose. A
    `readonly` field is initialized and then never changed, whereas a `const` field
    defines a value that is invariably the same. A `readonly` field is much more flexible:
    it can be of any type, and its value can be calculated at runtime, which means
    you can define either per-instance or `static` fields as `readonly`. A `const`
    field’s value is determined at compile time, which means it is defined at the
    class level (because there’s no way for individual instances to have different
    values). This also limits the available types. For most reference types, the only
    supported `const` value is `null`, so in practice, it’s normally only useful to
    use `const` with types intrinsically supported by the compiler. (Specifically,
    if you want to use values other than `null`, a `const`’s type must be one of the
    built-in numeric types, `bool`, `string`, or an enumeration type, as described
    later in this chapter.)'
  prefs: []
  type: TYPE_NORMAL
- en: 'This makes a `const` field rather more limited than a `readonly` one, so you
    could reasonably ask: What’s the point? Well, although a `const` field is inflexible,
    it makes a strong statement about the unchanging nature of the value. For example,
    .NET’s `Math` class defines a `const` field of type `double` called `PI` that
    contains as close an approximation to the mathematical constant π as a `double`
    can represent. That’s a value that’s fixed forever—thus it is a constant in a
    very strong sense.'
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to less inherently constant values, you need to be a bit careful
    about `const` fields; the C# specification allows the compiler to assume that
    the value really will never change. Code that reads the value of a `readonly`
    field will fetch the value from the memory containing the field at runtime. But
    when you use a `const` field, the compiler can read the value at compile time
    and copy it into the IL as though it were a literal. So if you write a library
    component that declares a `const` field and you later change its value, this change
    will not necessarily be picked up by code using your library unless that code
    gets recompiled.
  prefs: []
  type: TYPE_NORMAL
- en: One of the benefits of a `const` field is that it is eligible for use in certain
    contexts in which a `readonly` field is not. For example, if you want to use a
    constant pattern ([Chapter 2](ch02.xhtml#ch_basic_coding) introduced patterns),
    perhaps in the label for a `case` in a `switch` statement, the value you specify
    has to be fixed at compile time. So a constant pattern cannot refer to a `readonly`
    field, but you can use a suitably typed `const` field. You can also use `const`
    fields in the expression defining the value of another `const` field (as long
    as you don’t introduce any circular references).
  prefs: []
  type: TYPE_NORMAL
- en: A `const` field is required to contain an expression defining its value, such
    as the one shown in [Example 3-34](#const_field).
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-34\. A `const` field
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: While mandatory for a `const`, this initializer expression is optional for a
    class’s ordinary and `readonly`^([4](ch03.xhtml#idm45884832211984)) fields. If
    you omit the initializing expression, the field will automatically be initialized
    to a default value. (That’s 0 for numeric values and the equivalents for other
    types—`false`, `null`, etc.)
  prefs: []
  type: TYPE_NORMAL
- en: Instance field initializers run as part of construction, i.e., when you use
    the `new` keyword (or some equivalent mechanism such as constructing an instance
    through reflection, as described in [Chapter 13](ch13.xhtml#ch_reflection)). This
    means you should be wary of using field initializers in value types. A `struct`
    can be initialized implicitly, in which case its instance fields are set to 0
    (or `false`, etc.). Starting with C# 10.0, you can write instance field initializers
    in a `struct`, but these will only run if that `struct` is *explicitly* initialized.
    If you create an array whose elements are some value type with field initializers,
    all the fields of all the elements in the array will start out with values of
    0; if you want the field initializers to run, you’ll need to write a loop that
    uses `new` to initialize each element in the array. Likewise when you use a `struct`
    type as a field, it will be zero-initialized, and its field initializers will
    run only if you explicitly initialize the field with the `new` keyword. (Instance
    field initializers in a `class` also run only when that `class` is constructed,
    but the big difference is that it’s not possible to get hold of an instance of
    a `class` without running one of its constructors.^([5](ch03.xhtml#fn20)) There
    are common situations in which you will be able to use a `struct` instance that
    was implicitly zero-initialized.) Initializers for noninstance fields (i.e., `const`
    and `static` fields) will always be executed for structs, though.
  prefs: []
  type: TYPE_NORMAL
- en: If you do supply an initializer expression for a non-`const` field, it does
    not need to be evaluable at compile time, so it can do runtime work such as calling
    methods or reading properties. Of course, this sort of code can have side effects,
    so it’s important to be aware of the order in which initializers run.
  prefs: []
  type: TYPE_NORMAL
- en: 'Nonstatic field initializers run for each instance you create, and they execute
    in the order in which they appear in the file, immediately before the constructor
    runs. Static field initializers execute no more than once, no matter how many
    instances of the type you create. They also execute in the order in which they
    are declared, but it’s harder to pin down exactly when they will run. If your
    class has no static constructor, C# guarantees to run field initializers before
    the first time a field in the class is accessed, but it doesn’t necessarily wait
    until the last minute—it retains the right to run field initializers as early
    as it likes. (The exact moment at which this happens has varied across releases
    of .NET.) But if a static constructor does exist, then things are slightly clearer:
    static field initializers run immediately before the static constructor runs,
    but that merely raises the questions: What’s a static constructor, and when does
    it run? So we had better take a look at constructors.'
  prefs: []
  type: TYPE_NORMAL
- en: Constructors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A newly created object may require some information to do its job. For example,
    the `Uri` class in the `System` namespace represents a *Uniform Resource Identifier*
    (URI) such as a URL. Since its entire purpose is to contain and provide information
    about a URI, there wouldn’t be much point in having a `Uri` object that didn’t
    know what its URI was. So it’s not actually possible to create one without providing
    a URI. If you try the code in [Example 3-35](#error_failing_to_provide_a_uri_with_its),
    you’ll get a compiler error.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example 3-35\. Error: failing to provide a `Uri` with its URI'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: The `Uri` class defines several *constructors*, members that contain code that
    initializes a new instance of a type. If a particular class requires certain information
    to work, you can enforce this requirement through constructors. Creating an instance
    of a class almost always involves using a constructor at some point, so if the
    constructors you define all demand certain information, developers will have to
    provide that information if they want to use your class. So all of the `Uri` class’s
    constructors need to be given the URI in one form or another.
  prefs: []
  type: TYPE_NORMAL
- en: 'To define a constructor, you first specify the accessibility (`public`, `private`,
    `internal`, etc.) and then the name of the containing type. This is followed by
    a list of parameters in parentheses (which can be empty). [Example 3-36](#class_with_one_constructor)
    shows a class that defines a single constructor that requires two arguments: one
    of type `decimal` and one of type `string`. The argument list is followed by a
    block containing code. So constructors look a lot like methods but with the containing
    type name in place of the usual return type and method name.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-36\. A class with one constructor
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'This constructor is pretty simple: it just copies its arguments to fields.
    A lot of constructors do no more than that. You’re free to put as much code in
    there as you like, but by convention, developers usually expect the constructor
    to do very little—its main job is to ensure that the object is in a valid initial
    state. That might involve checking the arguments and throwing an exception if
    there’s a problem, but not much else. You are likely to surprise developers who
    use your class if you write a constructor that does something nontrivial, such
    as adding data to a database or sending a message over the network.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Example 3-37](#using_a_constructor) shows how to use the constructor defined
    by [Example 3-36](#class_with_one_constructor). We just use the `new` operator,
    passing in suitably typed values as arguments.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-37\. Using a constructor
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'You can define multiple constructors, but it must be possible to distinguish
    between them: you cannot define two constructors that both take the same number
    of arguments of the same types, because there would be no way for the `new` keyword
    to know which one you meant.'
  prefs: []
  type: TYPE_NORMAL
- en: Earlier, I showed how a record type can require certain properties to be present.
    [Example 3-38](#record_type_generated_constructor) shows a `record` similar to
    the `Item` class from [Example 3-36](#class_with_one_constructor) (although this
    makes the relevant data public). When you do this, you are in effect defining
    a constructor.
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-38\. Record type with compiler-generated constructors
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: With this example, the compiler will emit a constructor taking a `decimal` and
    a `string` argument. The generated constructor will use those arguments to initialize
    the `Price` and `Name` properties. As you saw earlier in [Example 3-13](#mutable_record_type),
    you’re free to supply your own constructor if you want to, but in cases where
    the compiler-generated one does what you need, it’s very convenient. This is not
    the only kind of constructor that the compiler can generate for you.
  prefs: []
  type: TYPE_NORMAL
- en: Default constructors and zero-argument constructors
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you do not define any constructors at all, C# will provide a *default constructor*
    that is equivalent to an empty constructor that takes no arguments. And if you’re
    writing a struct, you’ll get that even if you do define other constructors.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Although the C# specification unambiguously defines a default constructor as
    one generated for you by the compiler, be aware that there’s another widely used
    meaning. You will often see the term *default constructor* used to mean any public,
    parameterless constructor, regardless of whether it was generated by the compiler.
    There’s some logic to this—when using a class, it’s not possible to tell the difference
    between a compiler-generated constructor and an explicit zero-argument constructor,
    so if the term *default constructor* is to mean anything useful from that perspective,
    it can mean only a public constructor that takes no arguments. However, that’s
    not how the C# specification defines the term.
  prefs: []
  type: TYPE_NORMAL
- en: The compiler-generated default constructor does nothing beyond the zero initialization
    of fields, which is the starting point for all new objects. However, there are
    some situations in which it is necessary to write your own parameterless constructor.
    You might need the constructor to execute some code. [Example 3-39](#nonempty_zero-argument_constructor)
    sets an `_id` field based on a static field that it increments for each new object
    to give each instance a distinct ID. This doesn’t require any arguments to be
    passed in, but it does involve running some code.
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-39\. A nonempty zero-argument constructor
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'There is another way to achieve the same effect as [Example 3-39](#nonempty_zero-argument_constructor).
    I could have written a static method called `GetNextId`, and then used that in
    the `_id` field initializer. Then I wouldn’t have needed to write this constructor.
    However, there is one advantage to putting code in the constructor: field initializers
    are not allowed to invoke the object’s own nonstatic methods but constructors
    are. That’s because the object is in an incomplete state during field initialization,
    so it may be dangerous to call its nonstatic methods—they may rely on fields having
    valid values. But an object is allowed to call its own nonstatic methods inside
    a constructor, because although the object’s still not fully built yet, it’s closer
    to completion, and so the dangers are reduced.'
  prefs: []
  type: TYPE_NORMAL
- en: There are other reasons for writing your own zero-argument constructor. If you
    define at least one constructor for a class, this will disable the default constructor
    generation. If you need your class to provide parameterized construction, but
    you still want to offer a no-arguments constructor, you’ll need to write one,
    even if it’s empty. Alternatively, if you want to write a class whose only constructor
    is an empty, zero-argument one, but with a protection level other than the default
    of `public`—you might want to make it `private` so that only your code can create
    instances, for example—you would need to write the constructor explicitly even
    if it is empty so that you have somewhere to specify the protection level.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Some frameworks can use only classes that provide a public, zero-argument constructor.
    For example, if you build a UI with Windows Presentation Foundation (WPF), classes
    that can act as custom UI elements usually need such a constructor.
  prefs: []
  type: TYPE_NORMAL
- en: 'With structs, zero-argument constructors work slightly differently, because
    value types need to support implicit initialization. When a value type is used
    as a field of some other type, or the element type of an array, the memory that
    holds the value is part of the containing object, and when you create a new object
    or array, the CLR always fills its memory with zeros. This means that it is always
    possible to initialize a value without passing any constructor arguments. So whereas
    C# removes the default constructor for a class when you add a constructor that
    takes arguments, it does not do this for a struct (including `record struct` types)—even
    if it did hide it, you’d still be able to invoke this implicit initialization
    indirectly, e.g., by creating a one-element array of that type: `MyStruct s =
    (new MyStruct[1])[0];`. Since implicit initialization is always available for
    a struct, there would be no sense in the compiler hiding the corresponding constructor.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Up until C# 10.0, you weren’t allowed to write a zero-argument constructor
    for a struct because there are so many scenarios in which that constructor would
    not run. (This is the same reason that structs didn’t use to support instance
    field initializers: it’s essentially the same issue because field initializers
    run as part of construction.) You can now write a zero-argument constructor for
    a struct, but as with field initializers, be aware that it will only run in cases
    where your code explicitly invokes the constructor. The CLR’s zero initialization
    is used in most cases.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one more important compiler-generated constructor type to be aware
    of: when you write a `record` or `record class`, the compiler generates a constructor
    that gets used to create a duplicate whenever you use the `with` syntax shown
    back in [Example 3-12](#modified_copy_of_record_type). (This is known as a *copy
    constructor*, although if you’re familiar with C++, don’t be misled: this is used
    only within `record` types and is not a general-purpose copy mechanism. C# has
    no support for using a copy constructor in an ordinary class.) It performs a shallow
    copy by default, much as you get when copying a `struct`, but if you want to,
    you can write your own implementation, as [Example 3-40](#record_custom_copy_constructor)
    shows.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-40\. Record type with customized copy constructor
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: This prevents the compiler from generating the usual copy constructor. Yours
    will be used whenever the `with` syntax causes a copy of your type to be created.
  prefs: []
  type: TYPE_NORMAL
- en: The compiler does not generate a copy constructor for a `record struct`. There’s
    no need, because all `struct` types are inherently copyable. And although nothing
    stops you from writing a constructor similar to the one in [Example 3-40](#record_custom_copy_constructor)
    for a `record struct`, the compiler will not use it.
  prefs: []
  type: TYPE_NORMAL
- en: Chaining constructors
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you write a type that offers several constructors, you may find that they
    have a certain amount in common—there are often initialization tasks that all
    constructors have to perform. The class in [Example 3-39](#nonempty_zero-argument_constructor)
    calculates a numeric identifier for each object in its constructor, and if it
    were to provide multiple constructors, they might all need to do that same work.
    Moving the work into a field initializer would be one way to solve that, but what
    if only some constructors wanted to do it? You might have work that was common
    to most constructors, but you might want to make an exception by having one constructor
    that allows the ID to be specified rather than calculated. The field initializer
    approach would no longer be appropriate, because you’d want individual constructors
    to be able to opt in or out. [Example 3-41](#optional_chaining_of_constructors)
    shows a modified version of the code from [Example 3-39](#nonempty_zero-argument_constructor),
    defining two extra constructors.
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-41\. Optional chaining of constructors
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: If you look at the second constructor in [Example 3-41](#optional_chaining_of_constructors),
    its parameter list is followed by a colon and then `this()`, which invokes the
    first constructor. A constructor can invoke any other constructor that way. [Example 3-42](#chained_constructor_arguments)
    shows a different way to structure all three constructors, illustrating how to
    pass arguments.
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-42\. Chained constructor arguments
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: The two-argument constructor here is now the only one that actually does any
    work. The other constructors just pick suitable arguments for that main constructor.
    This is arguably a cleaner solution than the previous examples, because the work
    of initializing the fields is done in just one place, rather than having different
    constructors each performing their own smattering of field initialization.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that I’ve made the two-argument constructor in [Example 3-42](#chained_constructor_arguments)
    `private`. At first glance, it can look a bit odd to define a way of building
    an instance of a class and then make it inaccessible, but it makes perfect sense
    when chaining constructors. And there are other scenarios in which a private constructor
    might be useful—we might want to write a method that makes a clone of an existing
    `ItemWithId`, in which case that constructor would be useful, but by keeping it
    private, we retain control of exactly how new objects get created. It can sometimes
    even be useful to make all of a type’s constructors `private`, forcing users of
    the type to go through what’s sometimes called a *factory method* (a `static`
    method that creates an object) to get hold of an instance. There are two common
    reasons for doing this. One is if full initialization of the object requires additional
    work of a kind that is inadvisable in a constructor (e.g., if you need to do slow
    work that uses the asynchronous language features described in [Chapter 17](ch17.xhtml#ch_asynchronous_language_features),
    you cannot put that code inside a constructor). Another is if you want to use
    inheritance (see [Chapter 6](ch06.xhtml#ch_inheritance)) to provide multiple variations
    on a type, but you want to be able to decide at runtime which particular type
    is returned.
  prefs: []
  type: TYPE_NORMAL
- en: Static constructors
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The constructors we’ve looked at so far run when a new instance of an object
    is created. Classes and structs can also define a static constructor. This runs
    at most once in the lifetime of the application. You do not invoke it explicitly—C#
    ensures that it runs automatically at some point before you first use the class.
    So, unlike an instance constructor, there’s no opportunity to pass arguments.
    Since static constructors cannot take arguments, there can be only one per class.
    Also, because these are never accessed explicitly, you do not declare any kind
    of accessibility for a static constructor. [Example 3-43](#class_with_static_constructor)
    shows a class with a static constructor.
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-43\. Class with static constructor
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Just as an instance constructor puts the instance into a useful initial state,
    the static constructor provides an opportunity to initialize any static fields.
  prefs: []
  type: TYPE_NORMAL
- en: By the way, you’re not obliged to ensure that a constructor (static or instance)
    initializes every field. When a new instance of a class is created, the instance
    fields are initially all set to 0 (or the equivalent, such as `false` or `null`).
    Likewise, a type’s static fields are all zeroed out before the class is first
    used. Unlike with local variables, you only need to initialize fields if you want
    to set them to something other than the default zero-like value.
  prefs: []
  type: TYPE_NORMAL
- en: Even then, you may not need a constructor. A field initializer may be sufficient.
    However, it’s useful to know exactly when constructors and field initializers
    run. I mentioned earlier that the behavior varies according to whether constructors
    are present, so now that we’ve looked at constructors in a bit more detail, I
    can finally show a more complete picture of initialization. (There will still
    be more to come—as [Chapter 6](ch06.xhtml#ch_inheritance) describes, inheritance
    adds another dimension.)
  prefs: []
  type: TYPE_NORMAL
- en: At runtime, a type’s static fields will first be set to 0 (or equivalent values).
    Next, the field initializers run in the order in which they are written in the
    source file. This ordering matters if one field’s initializer refers to another.
    In [Example 3-44](#significant_ordering_of_static_fields), fields `a` and `c`
    both have the same initializer expression, but they end up with different values
    (1 and 42, respectively) due to the order in which initializers run.
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-44\. Significant ordering of static fields
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'The exact moment at which static field initializers run depends on whether
    there’s a static constructor. As mentioned earlier, if there isn’t, then the timing
    is not defined—C# guarantees to run them no later than the first access to one
    of the type’s fields, but it reserves the right to run them arbitrarily early.
    The presence of a static constructor changes matters: in that case, the static
    field initializers run immediately before the constructor. So when does the constructor
    run? It will be triggered by one of two events, whichever occurs first: creating
    an instance or accessing any static member of the class.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For nonstatic fields, the story is similar: the fields are first all initialized
    to 0 (or equivalent values), and then field initializers run in the order in which
    they appear in the source file, and this happens before the constructor runs.
    The difference is that instance constructors are invoked explicitly, so it’s clear
    when this initialization occurs.'
  prefs: []
  type: TYPE_NORMAL
- en: I’ve written a class called `InitializationTestClass` designed to illustrate
    this construction behavior, shown in [Example 3-45](#initialization_order). The
    class has both static and nonstatic fields, all of which call a method, `GetValue`,
    in their initializers. That method always returns the same value, 1, but it prints
    out a message so we can see when it is called. The class also defines a no-arguments
    instance constructor and a static constructor, both of which print out messages.
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-45\. Initialization order
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Main` method prints out a message, calls a static method defined by `Ini⁠tia⁠liz⁠ati⁠on​Tes⁠tCla⁠ss`,
    and then constructs a couple of instances. Running the program, I see the following
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Notice that both static field initializers and the static constructor run before
    the call to the static method (`Foo`) begins. The field initializers run before
    the static constructor, and as expected, they run in the order in which they appear
    in the source file. Because this class includes a static constructor, we know
    when static initialization will begin—it is triggered by the first use of that
    type, which in this example is when our `Main` method calls `InitializationTestClass.Foo`.
    You can see that it happens immediately before that point and no earlier, because
    our `Main` method manages to print out its first message before the static initialization
    occurs. If this example did not have a static constructor, and had only static
    field initializers, there would be no guarantee that static initialization would
    happen at the exact same point; the C# specification allows the initialization
    to happen earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 'You need to be careful about what you do in code that runs during static initialization:
    it may run earlier than you expect. For example, suppose your program uses some
    sort of diagnostic logging mechanism, and you need to configure this when the
    program starts in order to enable logging of messages to the proper location.
    There’s always a possibility that code that runs during static initialization
    could execute before you’ve managed to do this, meaning that diagnostic logging
    will not yet be working correctly. That might make problems in this code hard
    to debug. Even when you narrow down C#’s options by supplying a static constructor,
    it’s relatively easy to run that earlier than you intended. Use of any static
    member of a class will trigger its initialization, and you can find yourself in
    a situation where your static constructor is kicked off by static field initializers
    in some other class that doesn’t have a static constructor—this could happen before
    your `Main` method even starts.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You could try to fix this by initializing the logging code in its own static
    initialization. Because C# guarantees to run initialization before the first use
    of a type, you might think that this would ensure that the logging initialization
    would complete before the static initialization of any code that uses the logging
    system. However, there’s a potential problem: C# guarantees only when it will
    *start* static initialization for any particular class. It doesn’t guarantee to
    wait for it to finish. It cannot make such a guarantee, because if it did, code
    such as the peculiarly British [Example 3-46](#circular_static_dependencies) would
    put it in an impossible situation.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-46\. Circular static dependencies
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'There is a circular relationship between the two types in this example: both
    have static constructors that attempt to use a static field defined by the other
    class. The behavior will depend on which of these two classes the program tries
    to use first. In a program that uses `AfterYou` first, I see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: As you’d expect, the static constructor for `AfterYou` runs first, because that’s
    the class my program is trying to use. It prints out its first message, but then
    it tries to use the `NoAfterYou.Value` field. That means the static initialization
    for `NoAfterYou` now has to start, so we see the first message from its static
    constructor. It then goes on to retrieve the `AfterYou.Value` field, even though
    the `AfterYou` static constructor hasn’t finished yet. (It retrieved the value
    set by the field initializer, 42, and not the value set by the static constructor,
    123.) That’s allowed, because the ordering rules say only when static initialization
    is triggered, and they do not guarantee when it will finish. If they tried to
    guarantee complete initialization, this code would be unable to proceed—the `NoAfterYou`
    static constructor could not move forward, because the `AfterYou` static construction
    is not yet complete, but that couldn’t move forward, because it would be waiting
    for the `NoAfterYou` static initialization to finish.
  prefs: []
  type: TYPE_NORMAL
- en: The moral of this story is that you should not get too ambitious about what
    you try to achieve during static initialization. It can be hard to predict the
    exact order in which things will happen.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The `Microsoft.Extensions.Hosting` NuGet package provides a much better way
    to handle initialization problems with its `HostBuilder` class. It is beyond the
    scope of this chapter, but it is well worth finding and exploring.
  prefs: []
  type: TYPE_NORMAL
- en: Deconstructors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In [Chapter 2](ch02.xhtml#ch_basic_coding), we saw how to deconstruct a tuple
    into its component parts, but deconstruction is not just for tuples. You can enable
    deconstruction for any type you write by adding a suitable `Deconstruct` member,
    as shown in [Example 3-47](#enabling_deconstruction).
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-47\. Enabling deconstruction
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: C# recognizes this convention of a method named `Deconstruct` with a list of
    `out` arguments (the next section will describe `out` in more detail) and enables
    you to use the same deconstruction syntax as you can with tuples. [Example 3-48](#using_custom_deconstruction)
    uses this to extract the component values of a `Size` to enable it to express
    succinctly the calculation it performs.
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-48\. Using a custom deconstructor
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Types with a deconstructor can also use positional pattern matching. [Chapter 2](ch02.xhtml#ch_basic_coding)
    showed how you can use a syntax very similar to deconstruction in a pattern to
    match tuples. Any type with a custom deconstructor can use this same syntax. [Example 3-49](#pattern_match_custom_deconstruction)
    uses the `Size` type’s custom deconstructor to define various patterns for a `Size`
    in a switch expression.
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-49\. Positional pattern using a custom deconstructor
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Recall from [Chapter 2](ch02.xhtml#ch_basic_coding) that positional patterns
    are recursive: each position within the pattern contains a nested pattern. Since
    `Size` deconstructs into two elements, each positional pattern has two positions
    in which to put child patterns. [Example 3-49](#pattern_match_custom_deconstruction)
    variously uses constant patterns, a discard, and a declaration pattern.'
  prefs: []
  type: TYPE_NORMAL
- en: To use a deconstructor in a pattern, C# needs to know the type to be deconstructed
    at compile time. This works in [Example 3-49](#pattern_match_custom_deconstruction)
    because the input to the switch expression is of type `Size`. If a positional
    pattern’s input is of type `object`, the compiler will presume that you’re trying
    to match a tuple instead, unless you explicitly name the type, as [Example 3-50](#pattern_match_explicit_deconstructor)
    does.
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-50\. Positional pattern with explicit type
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: If you write a `record` type (either class-based or a `record struct`) that
    uses the positional syntax, i.e., it requires certain properties to be supplied
    on initialization as [Example 3-51](#record_struct_positional_syntax) does, the
    compiler generates a `Deconstruct` method for you. So just as with a tuple, any
    `record` defined in this way is automatically deconstructable.
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-51\. `record struct` using positional syntax
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Although the compiler provides special handling for the `Deconstruct` member
    that these examples rely on, from the runtime’s perspective, this is just an ordinary
    method. So this would be a good time to look in more detail at methods.
  prefs: []
  type: TYPE_NORMAL
- en: Methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Methods* are named bits of code that can optionally return a result and that
    may take arguments. C# makes the fairly common distinction between *parameters*
    and *arguments*: a method defines a list of the inputs it expects—the parameters—and
    the code inside the method refers to these parameters by name. The values seen
    by the code could be different each time the method is invoked, and the term *argument*
    refers to the specific value supplied for a parameter in a particular invocation.'
  prefs: []
  type: TYPE_NORMAL
- en: As you’ve already seen, when an accessibility specifier, such as `public` or
    `private`, is present, it appears at the start of the method declaration. The
    optional `static` keyword comes next, where present. After that, the method declaration
    states the return type. As with many C-family languages, you can write methods
    that return nothing, and you indicate this by putting the `void` keyword in place
    of the return type. Inside the method, you use the `return` keyword followed by
    an expression to specify the value for the method to return. In the case of a
    `void` method, you can use the `return` keyword without an expression to terminate
    the method, although this is optional, because when execution reaches the end
    of a `void` method, it terminates automatically. You normally only use `return`
    in a `void` method if your code decides to exit early.
  prefs: []
  type: TYPE_NORMAL
- en: Passing arguments by reference
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Methods can return only one item directly in C#. If you want to return multiple
    values, you can of course make that item a tuple. Alternatively, you can designate
    parameters as being for output rather than input. [Example 3-52](#returning_multiple_values_with_out)
    returns two values, both produced by integer division. The main return value is
    the quotient, but it also returns the remainder through its final parameter, which
    has been annotated with the `out` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-52\. Returning multiple values with `out`
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Because tuples were only introduced in C# 7, whereas `out` parameters have been
    around since the start, `out` crops up a lot in class libraries in scenarios where
    tuples might have been simpler. For example, you’ll see lots of methods following
    a similar pattern to `int.TryParse`, in which the return type is a `bool` indicating
    success or failure, with the actual result being passed through an `out` parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '[Example 3-53](#out_parameter_into_new_variable) shows one way to call a method
    with an `out` parameter. Instead of supplying an expression as we do with arguments
    for normal parameters, we’ve written the `out` keyword followed by a variable
    declaration. This introduces a new variable, which becomes the argument for this
    `out` parameter. So in this case, we end up with a new variable `r` initialized
    to 1 (the remainder of the division operation).'
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-53\. Putting an `out` parameter’s result into a new variable
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: A variable declared in an `out` argument follows the usual scoping rules, so
    in [Example 3-53](#out_parameter_into_new_variable), `r` will remain in scope
    for as long as `q`. Less obviously, `r` is available in the rest of the expression.
    [Example 3-54](#use_out_result_in_expression) uses this to attempt to parse some
    text as an integer, returning the parsed result if that succeeds and a fallback
    value of –1 if parsing fails.
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-54\. Using an `out` parameter’s result in the same expression
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: When you pass an `out` argument, this works by passing a reference to the local
    variable. When [Example 3-53](#out_parameter_into_new_variable) calls `Divide`,
    and when that method assigns a value into `remainder`, it’s really assigning it
    into the caller’s `r` variable. This is an `int`, which is a value type, so it
    would not normally be passed by reference, and this kind of reference is limited
    compared to what you can do with a reference type.^([6](ch03.xhtml#idm45884830549600))
    For example, you can’t declare a field in a class that can hold this kind of reference,
    because the local `r` variable will cease to exist when it goes out of scope,
    whereas an instance of a class can live indefinitely in a heap block. C# has to
    ensure that you cannot put a reference to a local variable in something that might
    outlive the variable it refers to.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Methods annotated with the `async` keyword (described in [Chapter 17](ch17.xhtml#ch_asynchronous_language_features))
    cannot have any `out` arguments. This is because asynchronous methods may implicitly
    return to their caller before they complete, continuing their execution some time
    later. This in turn means that the caller may also have returned before the `async`
    method runs again, in which case the variables passed by reference might no longer
    exist by the time the asynchronous code is ready to set them. The same restriction
    applies to anonymous functions (described in [Chapter 9](ch09.xhtml#ch_delegates_lambdas_events)).
    Both kinds of methods are allowed to pass `out` arguments into methods that they
    call, though.
  prefs: []
  type: TYPE_NORMAL
- en: You won’t always want to declare a new variable for each `out` argument. As
    [Example 3-55](#existing_variable_as_out_argument) shows, you can just write `out`
    followed by the name of an existing variable. (This was once the only way to use
    `out` arguments, so you’ll sometimes see code that declares a new variable in
    a separate statement immediately before using it as an `out` argument, even though
    the form shown in [Example 3-53](#out_parameter_into_new_variable) would be simpler.)
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-55\. Putting an `out` parameter’s result into an existing variable
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: When invoking a method with an `out` parameter, we are required to indicate
    explicitly that we are aware of how the method uses the argument. Regardless of
    whether we use an existing variable or declare a new one, we must use the `out`
    keyword at the call site as well as in the declaration.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes you will want to invoke a method that has an `out` argument that you
    have no use for—maybe you only need the main return value. As [Example 3-56](#out_argument_discard)
    shows, you can put just an underscore after the `out` keyword. This tells C# to
    discard the result.
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-56\. Discarding an `out` parameter’s result
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You should avoid using `_` (a single underscore) as the name of something in
    C#, because it can prevent the compiler from interpreting it as a discard. If
    a local variable of this name is in scope, writing `out _` has, since C# 1.0,
    indicated that you want to assign an `out` result into that variable, so for backward
    compatibility, current versions of C# have to retain that behavior. You can only
    use this form of discard if there is no symbol named `_` in scope.
  prefs: []
  type: TYPE_NORMAL
- en: An `out` reference requires information to flow from the method back to the
    caller, so if you try to write a method that returns without assigning something
    into all of its `out` arguments, you’ll get a compiler error. C# uses the *definite
    assignment* rules mentioned in [Chapter 2](ch02.xhtml#ch_basic_coding) to check
    this. (This requirement does not apply if the method throws an exception instead
    of returning.) There’s a related keyword, `ref`, that has similar reference semantics
    but allows information to flow bidirectionally. With a `ref` argument, it’s as
    though the method has direct access to the variable the caller passed in—we can
    read its current value, as well as modify it. (The caller is obliged to ensure
    that variables passed with `ref` contain a value before making the call, so in
    this case, the method is not required to set it before returning.) If you call
    a method with a parameter annotated with `ref` instead of `out`, you have to make
    clear at the call site that you meant to pass a reference to a variable as the
    argument, as [Example 3-57](#calling_a_method_with_a_ref_argument) shows.
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-57\. Calling a method with a `ref` argument
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'There’s a third way to add a level of indirection to an argument: you can apply
    the `in` keyword. Whereas `out` only enables information to flow out of the method,
    `in` only allows it to flow in. It’s like a `ref` argument but where the called
    method is not allowed to modify the variable the argument refers to. This may
    seem redundant: if there’s no way to pass information back through the argument,
    why pass it by reference? An `in int` argument doesn’t sound usefully different
    than an ordinary `int` argument. In fact, you wouldn’t use `in` with `int`. You
    only use it with relatively large types. As you know, value types are normally
    passed by value, meaning a copy has to be made when passing a value as an argument.
    The `in` keyword enables us to avoid this copy by passing a reference instead.
    In the past, people have sometimes used the `ref` keyword to avoid making copies
    of data, but this creates a risk that the method might modify the value when the
    caller might not want that. C# 7.2 introduced `in`, giving us the same in-only
    semantics we get when passing values the normal way but with the potential efficiency
    gains of not having to pass the whole value.'
  prefs: []
  type: TYPE_NORMAL
- en: You should only use `in` for types that are larger than a pointer. This is why
    `in int` is not useful. An `int` is 32 bits long, so passing a reference to an
    `int` doesn’t save us anything. In a 32-bit process, that reference will be a
    32-bit pointer, so we have saved nothing, and we end up with the slight extra
    inefficiency involved in using a value indirectly through a reference. In a 64-bit
    process, the reference will be a 64-bit pointer, so we’ve ended up having to pass
    more data into the method than we would have done if we had just passed the `int`
    directly! (Sometimes the CLR can inline the method and avoid the costs of creating
    the pointer, but this means that at best `in int` would cost the same as an `int`.
    And since `in` is purely about performance, that’s why `in` is not useful for
    small types such as `int`.)
  prefs: []
  type: TYPE_NORMAL
- en: '[Example 3-58](#large_struct) defines a fairly large value type. It contains
    four `double` values, each of which is 8 bytes in size, so each instance of this
    type occupies 32 bytes. The .NET design guidelines have always recommended avoiding
    making value types this large, and the main reason for this is that passing them
    as arguments is inefficient. Older versions of C# did not support this use of
    the `in` keyword, making this guideline more important, but now that `in` can
    reduce those costs, in some cases it might make sense to define a `struct` this
    large.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-58\. A large value type
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 3-59](#method_with_in_parameter) shows a method that calculates the
    area of a rectangle represented by the `Rect` type defined in [Example 3-58](#large_struct).
    We really wouldn’t want to have to copy all 32 bytes to call this very simple
    method, especially since it only uses half of the data in the `Rect`. Since this
    method annotates its parameter with `in`, no such copying will occur: the argument
    will be passed by reference, which in practice means that only a pointer needs
    to be passed—either 4 or 8 bytes, depending on whether the code is running in
    a 32-bit or a 64-bit process.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-59\. A method with an `in` parameter
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: You might expect that calling a method with `in` parameters would require the
    call site to indicate that it knows that the argument will be passed by reference
    by putting `in` in front of the argument, just like we need to write `out` or
    `ref` at the call site for the other two by-reference styles. And as [Example 3-60](#passing_an_in_argument)
    shows, you can do this, but it is optional. If you want to be explicit about the
    by-reference invocation, you can be, but unlike with `ref` and `out`, the compiler
    just passes the argument by reference anyway if you don’t add `in`.
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-60\. Calling a method with an `in` parameter
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: The `in` keyword is optional at the call site because defining such a parameter
    as `in` is only a performance optimization that does not change the behavior,
    unlike `out` and `ref`. Microsoft wanted to make it possible for developers to
    introduce a source-level-compatible change in which an existing method is modified
    by adding `in` to a parameter. This is a breaking change at the binary level,
    but in scenarios where you can be sure people will in any case need to recompile
    (e.g., when all the code is under your control), it might be useful to introduce
    such a change for performance reasons. Of course, as with all such enhancements
    you should measure performance before and after the change to see if it has the
    intended effect.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although the examples just shown work as intended, `in` sets a trap for the
    unwary. It works only because I marked the `struct` in [Example 3-58](#large_struct)
    as `readonly`. If instead of defining my own `Rect` I had used the very similar-looking
    `struct` with the same name from the `System.Windows` namespace (part of the WPF
    UI framework), [Example 3-60](#passing_an_in_argument) would not avoid the copy.
    It would have compiled and produced the correct results at runtime, but it would
    not offer any performance benefit. That’s because `System.Windows.Rect` is not
    read-only. Earlier, I discussed the defensive copies that C# makes when you use
    a `readonly` field containing a mutable value type. The same principle applies
    here, because an `in` argument is in effect read-only: code that passes arguments
    expects them not to be modified unless they are explicitly marked as `out` or
    `ref`. So the compiler must ensure that `in` arguments are not modified even though
    the method being called has a reference to the caller’s variable. When the type
    in question is already read-only, the compiler doesn’t have to do any extra work.
    But if it is a mutable value type, then if the method to which this argument was
    passed in turn invokes a method on that value, the compiler generates code that
    makes a copy and invokes the method on that, because it can’t know whether the
    method might modify the value. You might think that the compiler could enforce
    this by preventing the method with the `in` parameter from doing anything that
    might modify the value, but in practice that would mean stopping it from invoking
    any methods on the value—the compiler cannot in general determine whether any
    particular method call might modify the value. (And even if it doesn’t today,
    maybe it will in a future version of the library that defines the type.) Since
    properties are methods in disguise, this makes `in` arguments more or less useless
    when used with mutable types.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You should use `in` only with `readonly` value types, because mutable value
    types can undo the performance benefits. (Mutable value types are typically a
    bad idea in any case.)
  prefs: []
  type: TYPE_NORMAL
- en: C# offers a feature that can loosen this constraint a little. It allows the
    `readonly` keyword to be applied to members so that they can declare that they
    will not modify the value of which they are a member. This makes it possible to
    avoid these defensive copies on mutable values.
  prefs: []
  type: TYPE_NORMAL
- en: You can use the `out` and `ref` keywords with reference types too. That may
    sound redundant, but it can be useful. It provides double indirection—the method
    receives a reference to a variable that holds a reference. When you pass a reference
    type argument to a method, that method gets access to whatever object you choose
    to pass it. While the method can use members of that object, it can’t normally
    replace it with a different object. But if you mark a reference type argument
    with `ref`, the method has access to your variable, so it could replace it with
    a reference to a completely different object.
  prefs: []
  type: TYPE_NORMAL
- en: It’s technically possible for constructors to have `out` and `ref` parameters
    too, although it’s unusual. Also, just to be clear, the `out` or `ref` qualifiers
    are part of the method or constructor signature. A caller can pass an `out` (or
    `ref`) argument if and only if the parameter was declared as `out` (or `ref`).
    Callers can’t decide unilaterally to pass an argument by reference to a method
    that does not expect it.
  prefs: []
  type: TYPE_NORMAL
- en: Reference variables and return values
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that you’ve seen various ways in which you can pass a method a reference
    to a value (or a reference to a reference), you might be wondering whether you
    can get hold of these references in other ways. You can, as [Example 3-61](#ref_local)
    shows, but there are some constraints.
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-61\. A local `ref` variable
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'This example declares a variable called `rose`. It then declares a new variable
    of type `ref string`. The `ref` here has exactly the same effect as it does on
    a method parameter: it indicates that this variable is a reference to some other
    variable. Since the code initializes it with `ref rose`, the variable `rosaIndica`
    is a reference to that `rose` variable. So when the code assigns a value into
    `rosaIndica`, that value goes into the `rose` variable that `rosaIndica` refers
    to. When the final line reads the value of the `rose` variable, it will see the
    value that was written by the preceding line.'
  prefs: []
  type: TYPE_NORMAL
- en: So what are the constraints? C# has to ensure that you cannot put a reference
    to a local variable in something that might outlive the variable it refers to.
    So you cannot use this keyword on a field. Static fields live for as long as their
    defining type is loaded (typically until the process exits), and member fields
    of classes live on the heap enabling them to outlive any particular method call.
    (This is also true of most structs. It is not true of a `ref struct`, but even
    those do not currently support the `ref` keyword on a field.) And even in cases
    where you might think lifetime isn’t a problem (because the target of the reference
    is itself a field in an object, for example), it turns out that the runtime simply
    doesn’t support storing this kind of reference in a field, or as an element type
    in an array. More subtly, this also means you can’t use a `ref` local variable
    in a context where C# would store the variable in a class. That rules out their
    use in `async` methods and iterators and also prevents them being captured by
    anonymous functions (which are described in Chapters [17](ch17.xhtml#ch_asynchronous_language_features),
    [5](ch05.xhtml#ch_collections), and [9](ch09.xhtml#ch_delegates_lambdas_events),
    respectively).
  prefs: []
  type: TYPE_NORMAL
- en: Although types cannot define fields with `ref`, they can define methods that
    return a `ref`-style reference (and since properties are methods in disguise,
    a property getter may also return a reference). As always, the C# compiler has
    to ensure that a reference cannot outlive the thing it refers to, so it will prevent
    use of this feature in cases where it cannot be certain that it can enforce this
    rule. [Example 3-62](#ref_returns) shows various uses of `ref` return types, some
    of which the compiler accepts, and some it does not.
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-62\. Valid and invalid uses of `ref` returns
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: The methods that return a reference to an `int` that is a field, or an element
    in an array, are allowed, because `ref`-style references can always refer *to*
    items inside objects on the heap. (They just can’t live *in* them.) Heap objects
    can exist for as long as they are needed (and the garbage collector, discussed
    in [Chapter 7](ch07.xhtml#ch_object_lifetime), is aware of these kinds of references
    and will ensure that heap objects with references pointing to their interiors
    are kept alive). A method can return any of its `ref` arguments, because the caller
    was already required to ensure that they remain valid for the duration of the
    call. However, a method cannot return a reference to one of its local variables,
    because in cases where those variables end up living on the stack, the stack frame
    will cease to exist when the method returns. It would be a problem if a method
    could return a reference to a variable in a now-defunct stack frame.
  prefs: []
  type: TYPE_NORMAL
- en: 'The rules get a little more subtle when it comes to returning a reference that
    was obtained from some other method. The final two methods in [Example 3-62](#ref_returns)
    both attempt to return the reference returned by `GetBackSameRef`. One works,
    and the other does not. The outcome makes sense: `WillAlsoNotCompile` needs to
    be rejected for the same reason `WillNotCompile` was: both attempt to return a
    reference to a local variable, and `WillAlsoNotCompile` is just trying to disguise
    this by going through another method, `GetBackSameRef`. In cases like these, the
    C# compiler makes the conservative assumption that any method that returns a `ref`
    and that also takes one or more `ref` arguments might choose to return a reference
    to one of those arguments. So the compiler disallows the call to `GetBackSameRef`
    in `WillAlsoNotCompile` on the grounds that it might return a reference to the
    same local variable that was passed in by reference. (And it happens to be right
    in this case. But it would reject any call of this form even if the method in
    question returned a reference to something else entirely.) But it allows `WillCompile`
    to return the `ref` returned by `GetBackSameRef` because in that case, the reference
    we pass in is one we would be allowed to return directly.'
  prefs: []
  type: TYPE_NORMAL
- en: As with `in` arguments, the main reason for using `ref` returns is that they
    can enable greater runtime efficiency by avoiding copies. Instead of returning
    the entire value, methods of this kind can just return a pointer to the existing
    value. It also has the effect of enabling callers to modify whatever is referred
    to. For example, in [Example 3-62](#ref_returns), I can assign a value into the
    `FieldRef` property, even though the property appears to be read-only. The absence
    of a setter doesn’t matter in this case because its type is `ref int`, which is
    valid as the target of an assignment. So by writing `r.FieldRef = 42;` (where
    `r` is of type `Referable`), I get to modify the `i` field. Likewise, the reference
    returned by `GetArrayElementRef` can be used to modify the relevant element in
    the array. If this is not your intention, you can make the return type `ref readonly`
    instead of just `ref`. In this case, the compiler will not allow the resulting
    reference to be used as the target of an assignment.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You should only use `ref readonly` returns with a `readonly struct`, because
    otherwise you will run into the same defensive copy issues we saw earlier.
  prefs: []
  type: TYPE_NORMAL
- en: Optional arguments
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can make non-`out`, non-`ref` arguments optional by defining default values.
    The method in [Example 3-63](#method_with_optional_arguments) specifies the values
    that the arguments should have if the caller doesn’t supply them.
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-63\. A method with optional arguments
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: This method can then be invoked with no arguments, one argument, or both arguments.
    [Example 3-64](#omitting_one_argument) just supplies the first, taking the default
    for the `problem` argument.
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-64\. Omitting one argument
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: Normally, when invoking a method, you specify the arguments in order. However,
    what if you want to call the method in [Example 3-63](#method_with_optional_arguments),
    but you want to provide a value only for the second argument, using the default
    value for the first? You can’t just leave the first argument empty—if you tried
    to write `Blame( , "everything")`, you’d get a compiler error. Instead, you can
    specify the name of the argument you’d like to supply, using the syntax shown
    in [Example 3-65](#specifying_an_argument_name). C# will fill in the arguments
    you omit with the specified default values.
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-65\. Specifying an argument name
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: Obviously, you can omit arguments like this only when you’re invoking methods
    that define default argument values. However, you are free to specify argument
    names when invoking any method—sometimes it can be useful to do this even when
    you’re not omitting any arguments, because it can make it easier to see what the
    arguments are for when reading the code. This is particularly helpful if you’re
    faced with an API that takes arguments of type `bool` and it’s not immediately
    clear what they mean. [Example 3-66](#not_naming_arguments) constructs a `StreamReader`
    and a `StreamWriter` (described in [Chapter 15](ch15.xhtml#ch_files_and_streams)),
    each using constructors taking many arguments. It’s arguably clear enough what
    the `stream`, `filepath`, and the `Encoding.UTF8` arguments represent, but the
    others are likely to be something of a mystery to anyone reading the code, unless
    they happen to have committed all 13 `StreamReader` and 10 `StreamWriter` constructor
    overloads to memory. (The *using declaration* syntax shown here is described in
    [Chapter 7](ch07.xhtml#ch_object_lifetime).)
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-66\. Unclear arguments
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: Although argument names are not required here, we can make it much easier to
    understand what the code does by including some anyway. As [Example 3-67](#clarity_by_naming_arguments)
    shows, we’re free just to name the more cryptic ones, as long as we’re supplying
    arguments for all of the parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-67\. Improving clarity by naming arguments
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: It’s important to understand how C# implements default argument values because
    it has an impact on evolving library design. When you invoke a method without
    providing all the arguments, as [Example 3-65](#specifying_an_argument_name) does,
    the compiler generates code that passes a full set of arguments as normal. It
    effectively rewrites your code, adding back in the arguments you left out. The
    significance of this is that if you write a library that defines default argument
    values like this, you will run into problems if you ever change the defaults.
    Code that was compiled against the old version of the library will have copied
    the old defaults into the call sites and won’t pick up the new values unless it
    is recompiled.
  prefs: []
  type: TYPE_NORMAL
- en: Overloading
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You will sometimes see an alternative mechanism used for allowing arguments
    to be omitted, which avoids baking default values into call sites: *overloading*.
    This is a slightly histrionic term for the rather mundane idea that a single name
    or symbol can be given multiple meanings. In fact, we already saw this technique
    with constructors—in [Example 3-42](#chained_constructor_arguments), I defined
    one main constructor that did the real work, and then two other constructors that
    called into that one. We can use the same trick with methods, as [Example 3-68](#overloaded_method)
    shows.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-68\. Overloaded method
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'In one sense, this is slightly less flexible than default argument values,
    because code calling the `Blame` method no longer has any way to specify a value
    for the `problem` argument while picking up the default `perpetrator` (although
    it would be easy enough to solve that by just adding a method with a different
    name). On the other hand, method overloading offers two potential advantages:
    it allows you to decide on the default values at runtime if necessary, and it
    also provides a way to make `out` and `ref` arguments optional. Those require
    references to local variables, so there’s no way to define a default value, but
    you can always provide overloads with and without those arguments if you need
    to. And you can use a mixture of the two techniques—you might rely mainly on optional
    arguments, using overloads only to enable `out` or `ref` arguments to be omitted.'
  prefs: []
  type: TYPE_NORMAL
- en: Variable argument count with the params keyword
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Some methods need to be able to accept different amounts of data in different
    situations. Take the mechanism that I’ve used a few times in this book to display
    information. In most cases, I’ve passed a simple string to `Console.WriteLine`,
    and when I’ve wanted to format and display other pieces of information, I’ve used
    string interpolation to embed expressions in strings. However, as you may recall
    from [Chapter 2](ch02.xhtml#ch_basic_coding), in cases where we want to embed
    a large number of expressions into a string, string interpolation can become unwieldy,
    and it might be preferable instead to use the older `string.Format` method, shown
    in [Example 3-69](#string_formatting).
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-69\. String formatting
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: If you look at the documentation for `string.Format`, you’ll see that it offers
    several overloads taking various numbers of arguments. The number of overloads
    has to be finite, but if you try it, you’ll find that this is nonetheless an open-ended
    arrangement. You can pass as many arguments as you like after the string, and
    the numbers in the placeholders can go as high as necessary to refer to these
    arguments. The final line of [Example 3-69](#string_formatting) passes four arguments
    after the string, and even though the `string` class does not define an overload
    accepting that many arguments, it works.
  prefs: []
  type: TYPE_NORMAL
- en: 'One particular overload of the `string.Format` method takes over once you pass
    more than a certain number of arguments after the string (more than three, as
    it happens). This overload just takes two arguments: a `string` and an `object[]`
    array. The code that the compiler creates to invoke the method builds an array
    to hold all the arguments after the string and passes that. So the final statement
    of [Example 3-69](#string_formatting) is effectively equivalent to the code in
    [Example 3-70](#explicitly_passing_multiple_arguments_as). ([Chapter 5](ch05.xhtml#ch_collections)
    describes arrays.)'
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-70\. Explicitly passing multiple arguments as an array
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: The compiler will do this only with parameters that are annotated with the `params`
    keyword. [Example 3-71](#params_keyword) shows how the relevant `string.Format`
    method’s declaration looks.
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-71\. The `params` keyword
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: The `params` keyword can appear only on a method’s final parameter, and that
    parameter type must be an array. In this case, it’s an `object[]`, meaning that
    we can pass objects of any type, but you can be more specific to limit what can
    be passed in.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: When a method is overloaded, the C# compiler looks for the method whose parameters
    best match the arguments supplied. It will consider using a method with a `params`
    argument only if a more specific match is not available.
  prefs: []
  type: TYPE_NORMAL
- en: You may be wondering why the `string` class bothers to offer overloads that
    accept one, two, or three `object` arguments. The presence of this `params` version
    seems to make those redundant—it lets you pass any number of arguments after the
    string, so what’s the point of the ones that take a specific number of arguments?
    Those overloads exist to make it possible to avoid allocating an array. That’s
    not to say that arrays are particularly expensive; they cost no more than any
    other object of the same size. However, allocating memory is not free. Every object
    you allocate will eventually have to be freed by the garbage collector (except
    for objects that hang around for the whole life of the program), so reducing the
    number of allocations is usually good for performance. Because of this, most APIs
    in the runtime libraries that accept a variable number of arguments through `params`
    also offer overloads that allow a small number of arguments to be passed without
    needing to allocate an array to hold them.
  prefs: []
  type: TYPE_NORMAL
- en: Local functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can define methods inside other methods. These are called *local functions*,
    and [Example 3-72](#local_function) defines two of them. (You can also put them
    inside other method-like features, such as constructors or property accessors.)
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-72\. Local functions
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: One reason for using local functions is that they can make the code easier to
    read by moving steps into named methods—it’s easier to see what’s happening when
    there’s a method call to `GetDistance` than it is if we just have the calculations
    inline. Be aware that there can be overheads, although in this particular example,
    when I run the Release build of this code on .NET 6.0, the JIT compiler is smart
    enough to inline both of the local calls here, so the two local functions vanish,
    and `Get⁠Ave⁠ra⁠ge​Dis⁠tan⁠ceF⁠rom` ends up being just one method. So we’ve paid
    no penalty here, but with more complex nested functions, the JIT compiler may
    decide not to inline. And when that happens, it’s useful to know how the C# compiler
    enables this code to work.
  prefs: []
  type: TYPE_NORMAL
- en: The `GetDistanceFromReference` method here takes a single tuple argument, but
    it uses the `referencePoint` variable defined by its containing method. For this
    to work, the C# compiler moves that variable into a generated `struct`, which
    it passes by reference to the `GetDistanceFromReference` method as a hidden argument.
    This is how a single local variable can be accessible to both methods. Since this
    generated `struct` is passed by reference, the `referencePoint` variable can still
    remain on the stack in this example. However, if you obtain a delegate referring
    to a local method, any variables shared in this way have to move into a `class`
    that lives on the garbage-collected heap, which will have higher overheads. (See
    Chapters [7](ch07.xhtml#ch_object_lifetime) and [9](ch09.xhtml#ch_delegates_lambdas_events)
    for more details.) If you want to avoid any such overheads, you can always just
    not share any variables between the inner and outer methods. You can tell the
    compiler that this is your intention by applying the `static` keyword to the local
    function, as [Example 3-72](#local_function) does with `GetDistance`. This will
    cause the compiler to report an error if the method attempts to use a variable
    from its containing method.
  prefs: []
  type: TYPE_NORMAL
- en: Besides providing a way to split methods up for readability, local functions
    are sometimes used to work around some limitations with iterators (see [Chapter 5](ch05.xhtml#ch_collections))
    and `async` methods ([Chapter 17](ch17.xhtml#ch_asynchronous_language_features)).
    These are methods that might return partway through execution and then continue
    later, which means the compiler needs to arrange to store all of their local variables
    in an object living on the heap so that those variables can survive for as long
    as is required. This prevents these kinds of methods from declaring variables
    of certain types, such as reference variables, or `Span<T>` (described in [Chapter 18](ch18.xhtml#ch_memory_efficiency)).
    In cases where you need to use both `async` and `Span<T>`, it is common to move
    code using the latter into a local, non-`async` function that lives inside the
    `async` function. This enables the local function to use local variables with
    these constrained types.
  prefs: []
  type: TYPE_NORMAL
- en: Expression-bodied methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you write a method simple enough to consist of nothing more than a single
    return statement, you can use a more concise syntax. [Example 3-73](#expression_bodied_method)
    shows an alternative way to write the `GetDistanceFromReference` method from [Example 3-72](#local_function).
    (If you’re reading this book in order, you’ve probably noticed that I’ve already
    used this in a few other examples.) By the way, I can’t do this for `GetDistance`
    because that contains multiple statements.
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-73\. An expression-bodied method
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: Instead of a method body, you write `=>` followed by the expression that would
    otherwise have followed the `return` keyword. This `=>` syntax intentionally resembles
    the lambda syntax you can use for writing inline functions and building expression
    trees. These are discussed in [Chapter 9](ch09.xhtml#ch_delegates_lambdas_events).
    But when using `=>` to write an expression-bodied member, it’s just a convenient
    shorthand. The code works exactly as if you had written a full method containing
    just a `return` statement.
  prefs: []
  type: TYPE_NORMAL
- en: Extension methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: C# lets you write methods that appear to be new members of existing types. *Extension
    methods*, as they are called, look like normal static methods but with the `this`
    keyword added before the first parameter. You are allowed to define extension
    methods only in a static class. [Example 3-74](#extension_method) adds a not especially
    useful extension method to the `string`, called `Show`.
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-74\. An extension method
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'I’ve shown the namespace declaration in this example because namespaces are
    significant: extension methods are available only if you’ve written a `using`
    directive for the namespace in which the extension is defined, or if the code
    you’re writing is defined in the same namespace. In code that does neither of
    these things, the `string` class will look normal and will not acquire the `Show`
    method defined by [Example 3-74](#extension_method). However, code such as [Example 3-75](#extension_method_available_due_to_namesp),
    which is defined in the same namespace as the extension method, will find that
    the method is available.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-75\. Extension method available due to namespace declaration
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: The code in [Example 3-76](#extension_method_available_due_to_using) is in a
    different namespace, but it also has access to the extension method, thanks to
    a `using` directive.
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-76\. Extension method available due to `using` directive
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: Extension methods are not really members of the class for which they are defined—the
    `string` class does not truly gain an extra method in these examples. It’s just
    an illusion maintained by the C# compiler, one that it keeps up even in situations
    where method invocation happens implicitly. This is particularly useful with C#
    features that require certain methods to be available. In [Chapter 2](ch02.xhtml#ch_basic_coding),
    you saw that `foreach` loops depend on a `GetEnumerator` method. Many of the LINQ
    features we’ll look at in [Chapter 10](ch10.xhtml#ch_linq) also depend on certain
    methods being present, as do the asynchronous language features described in [Chapter 17](ch17.xhtml#ch_asynchronous_language_features).
    In all cases, you can enable these language features for types that do not support
    them directly by writing suitable extension methods.
  prefs: []
  type: TYPE_NORMAL
- en: Properties
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Classes and structs can define *properties*, which are really just methods in
    disguise. To access a property, you use a syntax that looks like field access
    but ends up invoking a method. Properties can be useful for signaling intent.
    When something is exposed as a property, the implication is that it represents
    information about the object, rather than an operation the object performs, so
    reading a property is usually inexpensive and should have no significant side
    effects. Methods, on the other hand, are more likely to cause an object to do
    something.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, since properties are just a kind of method, nothing enforces this.
    You are free to write a property that takes hours to run and makes significant
    changes to your application’s state whenever its value is read, but that would
    be a pretty lousy way to design code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Properties typically provide a pair of methods: one to get the value and one
    to set it. [Example 3-77](#class_with_simple_property) shows a very common pattern:
    a property with `get` and `set` methods that provide access to a field. Why not
    just make the field public? That’s often frowned upon, because it makes it possible
    for external code to change an object’s state without the object knowing about
    it. It might be that in future revisions of the code, the object needs to do something—perhaps
    update the UI—every time the value changes. In any case, because properties contain
    code, they offer more flexibility than public fields. For example, you might want
    to store the data in a different format than is returned by the property, or you
    may even be able to implement a property that calculates its value from other
    properties. Another reason for using properties is simply that some systems require
    it—for example, some UI databinding systems are only prepared to consume properties.
    Also, some types do not support instance fields; later in this chapter, I’ll show
    how to define an abstract type using an *interface*, and interfaces can contain
    properties but not instance fields.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-77\. Class with simple property
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Inside a `set` accessor, `value` has a special meaning. It’s a *contextual keyword*—text
    that the language treats as a keyword in certain contexts. Outside of a property,
    you can use `value` as an identifier, but within a property, it represents the
    value that the caller wants to assign to the property.
  prefs: []
  type: TYPE_NORMAL
- en: In cases where the entire body of the `get` is just a return statement, or where
    the `set` is a single expression statement, you can use the *expression-bodied
    member* syntax shown in [Example 3-78](#expression_bodied_accessors). (This is
    very similar to the method syntax shown in [Example 3-73](#expression_bodied_method).)
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-78\. Expression-bodied `get` and `set`
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: The pattern in Examples [3-77](#class_with_simple_property) and [3-78](#expression_bodied_accessors)
    is so common that C# can write most of it for you. [Example 3-79](#auto-property)
    is more or less equivalent—the compiler generates a field for us and produces
    `get` and `set` methods that retrieve and modify the value just like those in
    [Example 3-77](#class_with_simple_property). The only difference is that code
    elsewhere in the same class can’t get directly at the field in [Example 3-79](#auto-property),
    because the compiler hides it. The official name in the language specification
    for this is an *automatically implemented property*, but these are typically referred
    to as just *auto-properties*.
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-79\. An auto-property
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: Whether you use explicit or automatic properties, this is just a fancy syntax
    for a pair of methods. The `get` method returns a value of the property’s declared
    type—an `int`, in this case—while the setter takes a single argument of that type
    through the implicit `value` parameter. [Example 3-77](#class_with_simple_property)
    makes use of that argument to update the field. You’re not obliged to store the
    value in a field, of course. In fact, nothing even forces you to make the `get`
    and `set` methods related in any way—you could write a getter that returns random
    values and a setter that completely ignores the value you supply. However, just
    because you *can* doesn’t mean you *should*. In practice, anyone using your class
    will expect properties to remember the values they’ve been given, not least because
    in use, properties look just like fields, as [Example 3-80](#using_a_property)
    shows.
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-80\. Using a property
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: If you’re using the full syntax shown in [Example 3-77](#class_with_simple_property)
    to implement a property, or the expression-bodied form shown in [Example 3-78](#expression_bodied_accessors),
    you can leave out either the `set` or the `get` to make a read-only or write-only
    property. Read-only properties can be useful for aspects of an object that are
    fixed for its lifetime, such as an identifier, or that are calculated from other
    properties. Write-only properties are less useful, although they can crop up in
    dependency injection systems. You can’t make a write-only property with the auto-property
    syntax shown in [Example 3-79](#auto-property), because you wouldn’t be able to
    do anything useful with the value being set.
  prefs: []
  type: TYPE_NORMAL
- en: There are two variations on read-only properties. Sometimes it is useful to
    have a property that is publicly read-only but that your class is free to change.
    You can define a property where the getter is public but the setter is not (or
    vice versa for a write-only property). You can do this with either the full or
    the automatic syntax. [Example 3-81](#auto-property_with_private_setter) shows
    how this looks with the latter.
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-81\. Auto-property with private setter
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: If you want your property to be read-only in the sense that its value never
    changes after construction, you can leave out the setter entirely when using the
    auto-property syntax, as [Example 3-82](#auto-property_with_no_setter) shows.
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-82\. Auto-property with no setter
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: With no setter and no directly accessible field, you may be wondering how you
    can set the value of such a property. The answer is that inside your object’s
    constructor, the property appears to be settable. (There isn’t really a setter
    if you omit the `set`—the compiler generates code that just sets the backing field
    directly when you “set” the property in the constructor.) A get-only auto-property
    is effectively equivalent to a `readonly` field wrapped with an ordinary get-only
    property. As with fields, you can also write an initializer to provide an initial
    value. [Example 3-83](#initializing_an_auto-property_with_no_se) uses both styles;
    if you use the constructor that takes no arguments, the property’s value will
    be 42, and if you use the other constructor, it will have whatever value you supply.
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-83\. Initializing an auto-property with no setter
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: This initializer syntax works for read-write properties, by the way. You can
    also use it if you want to create a `record` type that uses the positional syntax
    but that wants the properties to be writable, as [Example 3-84](#positional_record_with_writeable_properties)
    shows. This is slightly unusual, since the features offered by record types are
    mainly intended to make it easier to define immutable data types. But mutability
    is supported, and it can be useful to require certain properties to be initialized
    even when they are writable, to avoid the nullable reference type system complaining
    that your non-nullable property might initially have a null value.
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-84\. Record requiring initial values but allowing later modification
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the positional syntax is ultimately just a way to define a constructor,
    you might be tempted in cases like [Example 3-84](#positional_record_with_writeable_properties)
    to use more conventionally cased names for the constructor arguments, e.g., `name`
    and `favoriteColor`. But the effect of that would be to create a record with four
    properties: `name`, `Name`, `favoriteColor`, and `FavoriteColor`. If you use the
    positional syntax, your record type will have all of the properties named in that
    syntax. It might look here like we’ve defined the same properties twice, but in
    fact the duplicate names are how C# knows that we are just saying we want something
    other than the normal generated properties here.'
  prefs: []
  type: TYPE_NORMAL
- en: There’s a variation on the theme of read-only properties shown in [Example 3-85](#auto-property_with_init_setter).
    In place of the `set`, we have the `init` keyword. (This is how properties generated
    in a record type due to the positional syntax look if you don’t customize them,
    by the way.)
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-85\. Class with auto-property with init-only setter
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'This is almost identical to a read-only property: it indicates that the property
    is not to be modified after the object is initialized. However, there’s one significant
    difference: the compiler generates a public setter when you use this syntax. It
    refuses to compile code that attempts to modify the property after the object
    has been initialized, so for most scenarios it behaves just like a read-only property,
    but this enables one critical scenario: it lets you set the property in an *object
    initializer*. I’ll be describing object initializers in full later, but [Example 3-86](#setting_init_only_property)
    shows a simple example.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-86\. Setting an init-only property
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: This is the one extra place you can use an init-only property—besides this you
    can only set them in places where it would also be permissible to set a read-only
    property.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The restrictions on init-only properties are enforced only by the compiler.
    From the CLR’s perspective, they are read-write properties, meaning that if you
    were to use this sort of property from some language that did not recognize this
    init-only feature (which was new in C# 9.0), or using indirect means such as reflection
    (see [Chapter 13](ch13.xhtml#ch_reflection)), it would be able to set the property
    at any time, not just during initialization.
  prefs: []
  type: TYPE_NORMAL
- en: Init-only properties provide a way to enable immutable `struct` types to use
    the same `with` syntax that is available to record types. [Example 3-87](#a_readonly_struct_with_init_only_props)
    shows another variation on the `Point` type used in various earlier examples,
    this time featuring init-only properties.
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-87\. A `readonly struct` with init-only properties
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: This defines setters for the properties, which would normally not be allowed
    with a `readonly struct`, but because they can be set only during initialization,
    they don’t cause a problem here. And they enable code such as [Example 3-88](#with_syntax_on_non_record_struct).
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-88\. Using the `with` syntax on a nonrecord `readonly struct`
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Since you can use the `with` syntax with a nonrecord `struct`, you might be
    wondering whether it also works for a nonrecord `class`. It doesn’t. The `with`
    keyword depends on the ability to create a copy of an existing instance. This
    is not a problem with `struct` types—their defining feature is that they can be
    copied. But there is no reliable general-purpose way to clone an instance of a
    `class`, so with reference types, `with` only works on records, because record
    types *are* reliably cloneable.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes it is useful to write a read-only property with a value calculated
    entirely in terms of other properties. For example, if you have written a type
    representing a vector with properties called `X` and `Y`, you could add a property
    that returns the magnitude of the vector, calculated from those other two properties,
    as shown in [Example 3-89](#calculated_property).
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-89\. A calculated property
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'There is a more compact way of writing this. We could use the expression-bodied
    syntax shown in [Example 3-78](#expression_bodied_accessors), but for a read-only
    property, we can go one step further: you can put the `=>` and expression directly
    after the property name. (This enables us to leave out the braces and the `get`
    keyword.) [Example 3-90](#expression_bodied_readonly_property) is exactly equivalent
    to [Example 3-89](#calculated_property).'
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-90\. An expression-bodied read-only property
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: Speaking of read-only properties, there’s an important issue to be aware of
    involving properties, value types, and immutability.
  prefs: []
  type: TYPE_NORMAL
- en: Properties and mutable value types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As I mentioned earlier, value types tend to be more straightforward if they’re
    immutable, but it’s not a requirement. One reason to avoid modifiable value types
    is that you can end up accidentally modifying a copy of the value rather than
    the one you meant, and this issue becomes apparent if you define a property that
    uses a mutable value type. The `Point` struct in the `System.Windows` namespace
    is modifiable, so we can use it to illustrate the problem. [Example 3-91](#property_using_a_mutable_value_type)
    defines a `Location` property of this type.
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-91\. A property using a mutable value type
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: The `Point` type defines read/write properties called `X` and `Y`, so given
    a variable of type `Point`, you can set these properties. However, if you try
    to set either of these properties via another property, the code will not compile.
    [Example 3-92](#error_cannot_modify_a_property_of_a_valu) tries this—it attempts
    to modify the `X` property of a `Point` retrieved from an `Item` object’s `Location`
    property.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example 3-92\. Error: cannot modify a property of a value type property'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'This example produces the following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: C# considers fields to be variables as well as local variables and method arguments,
    so if we were to modify [Example 3-91](#property_using_a_mutable_value_type) so
    that `Location` was a public field rather than a property, [Example 3-92](#error_cannot_modify_a_property_of_a_valu)
    would then compile and would work as expected. But why doesn’t it work with a
    property? Remember that properties are just methods, so [Example 3-91](#property_using_a_mutable_value_type)
    is more or less equivalent to [Example 3-93](#replacing_a_property_with_methods).
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-93\. Replacing a property with methods
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: Since `Point` is a value type, `get_Location` returns a copy. You might be wondering
    if we could use the `ref` return feature described earlier. We certainly could
    with plain methods, but there are a couple of constraints to doing this with properties.
    First, you cannot define an auto-property with a `ref` type. Second, you cannot
    define a writable property with a `ref` type. However, you can define a read-only
    `ref` property, as [Example 3-94](#ref_type_property) shows.
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-94\. A property returning a reference
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: With this implementation of `Item`, the code in [Example 3-92](#error_cannot_modify_a_property_of_a_valu)
    now works fine. (Ironically, to make the property modifiable, we had to turn it
    into a read-only property.)
  prefs: []
  type: TYPE_NORMAL
- en: Before `ref` returns were added in C# 7.0, there was no way to make this work.
    All possible implementations of the property would end up returning a copy of
    the property value, so if the compiler did allow [Example 3-92](#error_cannot_modify_a_property_of_a_valu)
    to compile, we would be setting the `X` property on the copy returned by the property,
    and not the actual value in the `Item` object that the property represents. [Example 3-95](#making_the_copy_explicit)
    makes this explicit, and it will in fact compile—the compiler will let us shoot
    ourselves in the foot if we make it sufficiently clear that we really want to.
    And with this version of the code, it’s quite obvious that this will not modify
    the value in the `Item` object.
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-95\. Making the copy explicit
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: However, with the property implementation in [Example 3-94](#ref_type_property),
    the code in [Example 3-92](#error_cannot_modify_a_property_of_a_valu) does compile
    and ends up behaving like the code shown in [Example 3-96](#making_the_ref_explicit).
    Here we can see that we’ve retrieved a reference to a `Point`, so when we set
    its `X` property, we’re acting on whatever that refers to (the `_location` field
    in the `Item` in this case), rather than a local copy.
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-96\. Making the reference explicit
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: 'Thanks to fairly recent additions to the language, it’s possible to make it
    work, although there is arguably a loss of encapsulation here: the behavior is
    now more or less equivalent to defining a public field. It’s also easy to get
    it wrong. Fortunately, most value types are immutable, and this problem arises
    only with mutable value types.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Immutability doesn’t exactly solve the problem—you still can’t write the code
    you might want to, such as `item.Location.X = 123`. But at least immutable structs
    don’t mislead you by making it look like you should be able to do that.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since all properties are really just methods (typically in pairs), in theory
    they could accept more arguments in addition to the implicit `value` argument
    used by `set` methods. The CLR allows this, but C# does not support it except
    for one special kind of property: an indexer.'
  prefs: []
  type: TYPE_NORMAL
- en: Indexers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An *indexer* is a property that takes one or more arguments and is accessed
    with the same syntax as is used for arrays. This is useful when you’re writing
    a class that contains a collection of objects. [Example 3-97](#using_an_indexer)
    uses one of the collection classes provided by the runtime libraries, `List<T>`.
    It is essentially a variable-length array, and it feels like a native array thanks
    to its indexer, used on the second and third lines. (I’ll describe arrays and
    collection types in detail in [Chapter 5](ch05.xhtml#ch_collections). And I’ll
    describe generic types, of which `List<T>` is an example, in [Chapter 4](ch04.xhtml#ch_generics).)
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-97\. Using an indexer
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: From the CLR’s point of view, an indexer is a property much like any other,
    except that it has been designated as the *default property*. This concept is
    a holdover from the old COM-based versions of Visual Basic that got carried over
    into .NET, and that C# mostly ignores. Indexers are the only C# feature that treats
    default properties as being special. If a class designates a property as being
    the default one, and if the property accepts at least one argument, C# will let
    you use that property through the indexer syntax.
  prefs: []
  type: TYPE_NORMAL
- en: The syntax for declaring indexers is somewhat idiosyncratic. [Example 3-98](#class_with_indexer)
    shows a read-only indexer. You could add a `set` accessor to make it read/write,
    just like with any other property.^([7](ch03.xhtml#idm45884827660912))
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-98\. Class with indexer
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: C# supports multidimensional indexers. These are indexers with more than one
    parameter—since properties are really just methods, you can define indexers with
    any number of parameters. You are free to use any mixture of types for the parameters.
    Indexers also support overloading, so you can define any number of indexers, as
    long as each takes a distinct set of parameter types.
  prefs: []
  type: TYPE_NORMAL
- en: As you may recall from [Chapter 2](ch02.xhtml#ch_basic_coding), C# offers *null-conditional*
    operators. In that chapter, we saw this used to access properties and fields—e.g.,
    `myString?.Length` will be of type `int?`—and its value will be `null` if `myString`
    is `null`, and the value of the `Length` property otherwise. There is one other
    form of null-conditional operator, which can be used with an indexer, shown in
    [Example 3-99](#null_conditional_index_access).
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-99\. Null-conditional index access
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: As with the null-conditional field or property access, this generates code that
    checks whether the lefthand part (`objectWithIndexer` in this case) is null. If
    it is, the whole expression evaluates to null; it only invokes the indexer if
    the lefthand part of the expression is not null. It is effectively equivalent
    to the code shown in [Example 3-100](#code_equivalent_to_null_conditional_inde).
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-100\. Code equivalent to null-conditional index access
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: This null-conditional index syntax also works with arrays.
  prefs: []
  type: TYPE_NORMAL
- en: Initializer syntax
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You will often want to set certain properties when you create an object, because
    it might not be possible to supply all relevant information through constructor
    arguments. This is particularly common with objects that represent settings for
    controlling some operation. For example, the `ProcessStartInfo` type enables you
    to configure many different aspects of a newly created OS process. It has 16 properties,
    but you would typically only need to set a few of these in any particular scenario.
    Even if you assume that the name of the file to run should always be present,
    there are still 32,768 possible combinations of properties. You wouldn’t want
    to have a constructor for every one of those.
  prefs: []
  type: TYPE_NORMAL
- en: In practice, a class might offer constructors for a handful of particularly
    common combinations, but for everything else, you just set the properties after
    construction. C# offers a succinct way to create an object and set some of its
    properties in a single expression. [Example 3-101](#using_an_object_initializer)
    uses this *object initializer* syntax. This also works with fields, although it’s
    relatively unusual to have writable public fields.
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-101\. Using an object initializer
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: You can supply constructor arguments too. [Example 3-102](#using_an_object_initializer_with_ctor)
    has the same effect as [Example 3-101](#using_an_object_initializer) but chooses
    to supply the filename as a constructor argument. (This is one of the few properties
    `ProcessStartInfo` lets you supply that way.)
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-102\. Using a constructor and an object initializer
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: The object initializer syntax can remove the need for a separate variable to
    refer to the object while you set the properties you need. As Examples [3-101](#using_an_object_initializer)
    and [3-102](#using_an_object_initializer_with_ctor) show, you can pass an object
    initialized in this way directly as an argument to a method. More generally, this
    style of initialization can be contained entirely within a single expression.
    This is important in scenarios that use expression trees, which we’ll be looking
    at in [Chapter 9](ch09.xhtml#ch_delegates_lambdas_events). Another important benefit
    of initializers is that they can use an `init` accessor—when a property defines
    an `init` accessor and if there are no constructor overloads available that can
    set that property, the object initializer syntax is the only mechanism available
    for setting that property.
  prefs: []
  type: TYPE_NORMAL
- en: There’s a variation on the object initializer syntax that enables you to supply
    values to an indexer in an object initializer. [Example 3-103](#using_an_indexer_in_an_object_initialize)
    uses this to initialize a dictionary. ([Chapter 5](ch05.xhtml#ch_collections)
    describes dictionaries and other collection types in detail.)
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-103\. Using an indexer in an object initializer
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: Operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Classes and structs can define customized meanings for operators. I showed
    some custom operators earlier: [Example 3-29](#support_custom_comparison) supplied
    definitions for `==` and `!=`. A class or struct can support almost all of the
    arithmetic, logical, and relational operators introduced in [Chapter 2](ch02.xhtml#ch_basic_coding).
    Of the operators shown in Tables [2-3](ch02.xhtml#basic_arithmetic_operators),
    [2-4](ch02.xhtml#binary_integer_operators), [2-5](ch02.xhtml#operators_for_bool),
    and [2-6](ch02.xhtml#relational_operators), you can define custom meanings for
    all except the conditional AND (`&&`) and conditional OR (`||`) operators. Those
    operators are evaluated in terms of other operators, however, so by defining logical
    AND (`&`), logical OR (`|`), and also the logical `true` and `false` operators
    (described shortly), you can control the way that `&&` and `||` work for your
    type, even though you cannot implement them directly.'
  prefs: []
  type: TYPE_NORMAL
- en: All custom operator implementations follow a certain pattern. They look like
    static methods, but in the place where you’d normally expect the method name,
    you instead have the `operator` keyword followed by the operator for which you
    want to define a custom meaning. After that comes a parameter list, where the
    number of parameters is determined by the number of operands the operator requires.
    [Example 3-104](#implementing_the_plus_operator) shows how the binary `+` operator
    would look for the `Counter` class defined earlier in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-104\. Implementing the `+` operator
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: Although the argument count must match the number of operands the operator requires,
    only one of the arguments has to be the same as the defining type. [Example 3-105](#supporting_other_operand_types)
    exploits this to allow the `Counter` class to be added to an `int`.
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-105\. Supporting other operand types
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: C# requires certain operators to be defined in pairs. We already saw this with
    the `==` and `!=` operators—it is illegal to define one and not the other. Likewise,
    if you define the `>` operator for your type, you must also define the `<` operator,
    and vice versa. The same is true for `>=` and `<=`. (There’s one more pair, the
    `true` and `false` operators, but they’re slightly different; I’ll get to those
    shortly.)
  prefs: []
  type: TYPE_NORMAL
- en: When you overload an operator for which a compound assignment operator exists,
    you are in effect defining behavior for both. For example, if you define custom
    behavior for the `+` operator, the `+=` operator will automatically work too.
  prefs: []
  type: TYPE_NORMAL
- en: The `operator` keyword can also define custom conversions—methods that convert
    your type to or from some other type. For example, if we wanted to be able to
    convert `Counter` objects to and from `int`, we could add the two methods in [Example 3-106](#conversion_operators)
    to the class.
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-106\. Conversion operators
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: I’ve used the `explicit` keyword here, which means that these conversions are
    accessed with the cast syntax, as [Example 3-107](#using_explicit_conversion_operators)
    shows.
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-107\. Using explicit conversion operators
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: 'If you use the `implicit` keyword instead of `explicit`, your conversion will
    be able to happen without needing a cast. In [Chapter 2](ch02.xhtml#ch_basic_coding)
    we saw that some conversions happen implicitly: in certain situations, C# will
    automatically promote numeric types. For example, you can use an `int` where a
    `long` is expected, perhaps as an argument for a method or in an assignment. Conversion
    from `int` to `long` will always succeed and can never lose information, so the
    compiler will automatically generate code to perform the conversion without requiring
    an explicit cast. If you write `implicit` conversion operators, the C# compiler
    will silently use them in exactly the same way, enabling your custom type to be
    used in places where some other type was expected. (In fact, the C# specification
    defines numeric promotions such as conversion from `int` to `long` as built-in
    implicit conversions.)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Implicit conversion operators are something you shouldn’t need to write very
    often. You should do so only when you can meet the same standards as built-in
    promotions: the conversion must always be possible and should never throw an exception.
    Moreover, the conversion should be unsurprising—`implicit` conversions are a little
    sneaky in that they allow you to cause methods to be invoked in code that doesn’t
    look like it’s calling a method. So unless you’re intending to confuse other developers,
    you should write implicit conversions only where they seem to make unequivocal
    sense.'
  prefs: []
  type: TYPE_NORMAL
- en: 'C# recognizes two more operators: `true` and `false`. If you define either
    of these, you are required to define both. These are a bit of an oddball pair,
    because although the C# specification defines them as unary operator overloads,
    they don’t correspond directly to any operator you can write in an expression.
    They come into play in two scenarios.'
  prefs: []
  type: TYPE_NORMAL
- en: If you have not defined an implicit conversion to `bool`, but you have defined
    the `true` and `false` operators, C# will use the `true` operator if you use your
    type as the expression for an `if` statement or a `do` or `while` loop, or as
    the condition expression in a `for` loop. However, the compiler prefers the implicit
    `bool` operator, so this is not the main reason the `true` and `false` operators
    exist.
  prefs: []
  type: TYPE_NORMAL
- en: The main scenario for the `true` and `false` operators is to enable your custom
    type to be used as an operand of a conditional Boolean operator (either `&&` or
    `||`). Remember that these operators will evaluate their second operand only if
    the first outcome does not fully determine the result. If you want to customize
    the behavior of these operators, you cannot implement them directly. Instead,
    you must define the nonconditional versions of the operators (`&` and `|`), and
    you must also define the `true` and `false` operators. When evaluating `&&`, C#
    will use your `false` operator on the first operand, and if that indicates that
    the first operand is false, then it will not bother to evaluate the second operand.
    If the first operand is not false, it will evaluate the second operand and then
    pass both into your custom `&` operator. The `||` operator works in much the same
    way but with the `true` and `|` operators, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: You may be wondering why we need special `true` and `false` operators—couldn’t
    we just define an implicit conversion to the `bool` type? In fact we can, and
    if we do that instead of providing `&`, `|`, `true`, and `false`, C# will use
    that to implement `&&` and `||` for our type. However, some types may want to
    represent values that are neither true nor false—there may be a third value representing
    an unknown state. The `true` operator allows C# to ask the question “Is this definitely
    true?” and for the object to be able to answer “no” without implying that it’s
    definitely false. A conversion to `bool` does not support that.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The `true` and `false` operators have been present since the first version of
    C#, and their main application was to enable the implementation of types that
    support nullable Boolean values with similar semantics to those offered by many
    databases. The nullable type support added in C# 2.0 provides a better solution,
    so these operators are no longer particularly useful, but there are still some
    old parts of the runtime libraries that depend on them.
  prefs: []
  type: TYPE_NORMAL
- en: No other operators can be overloaded. For example, you cannot define custom
    meanings for the `.` operator used to access members of a method, or the conditional
    (`? :`) or null coalescing (`??`) operators.
  prefs: []
  type: TYPE_NORMAL
- en: Events
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Structs and classes can declare *events*. This kind of member enables a type
    to provide notifications when interesting things happen, using a subscription-based
    model. For example, a UI object representing a button might define a `Click` event,
    and you can write code that subscribes to that event.
  prefs: []
  type: TYPE_NORMAL
- en: Events depend on delegates, and since [Chapter 9](ch09.xhtml#ch_delegates_lambdas_events)
    is dedicated to these topics, I won’t go into any detail here. I’m mentioning
    them only because this section on type members would otherwise be incomplete.
  prefs: []
  type: TYPE_NORMAL
- en: Nested Types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The final kind of member we can define in a class, a struct, or a record is
    a nested type. You can define nested classes, structs, or any of the other types
    described later in this chapter. A nested type can do anything its normal counterpart
    would do, but it gets a couple of additional features.
  prefs: []
  type: TYPE_NORMAL
- en: When a type is nested, you have more choices for accessibility. A type defined
    at global scope can be only `public` or `internal`—`private` would make no sense,
    because that makes something accessible only from within its containing type,
    and there is no containing type when you define something at global scope. But
    a nested type does have a containing type, so if you define a nested type and
    make it `private`, that type can be used only from inside the type within which
    it is nested. [Example 3-108](#private_nested_class) shows a private class.
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-108\. A private nested class
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: Private classes can be useful in scenarios like this where you are using an
    API that requires an implementation of a particular interface, and either you
    don’t want to make that interface part of your type or, as in this case, you couldn’t
    even if you wanted to. (My `FileSorter` type is `static`, so I can’t create an
    instance of it to pass to `Array.Sort`.) In this case, I’m calling `Array.Sort`
    to sort a list of files by the lengths of their names. (This is not useful, but
    it looks nice.) I’m providing the custom sort order in the form of an object that
    implements the `IComparer<string>` interface. I’ll describe interfaces in detail
    in the next section, but this interface is just a description of what the `Array.Sort`
    method needs us to provide. I’ve written a custom class to implement this interface.
    This class is just an implementation detail of the rest of my code, so I don’t
    want to make it public. A nested private class is just what I need.
  prefs: []
  type: TYPE_NORMAL
- en: Code in a nested type is allowed to use nonpublic members of its containing
    type. However, an instance of a nested type does not automatically get a reference
    to an instance of its containing type. If you need nested instances to have a
    reference to their container, then you will need to declare a field to hold that
    and arrange for it to be initialized; this would work in exactly the same way
    as any object that wants to hold a reference to another object. Obviously, it’s
    an option only if the outer type is a reference type.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve looked only at classes, records, and structs, but there are some
    other ways to define custom types in C#. One of these is complicated enough to
    warrant getting its own chapter, but there are a couple of simpler ones that I’ll
    discuss here.
  prefs: []
  type: TYPE_NORMAL
- en: Interfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: C#’s `interface` keyword defines a programming interface. Interfaces are very
    often entirely devoid of implementation, although you can define default implementations
    for some or all methods. You can also define nested types and static fields. (Interfaces
    cannot define nonstatic fields, though.) Classes can choose to implement interfaces.
    If you write code that works in terms of an interface, it will be able to work
    with anything that implements that interface, instead of being limited to working
    with one particular type.
  prefs: []
  type: TYPE_NORMAL
- en: For example, the .NET runtime libraries include an interface called `IEnumerable<T>`,
    which defines a minimal set of members for representing sequences of values. (It’s
    a generic interface, so it can represent sequences of anything. For example, an
    `IE⁠num⁠era⁠ble​<st⁠rin⁠g>` is a sequence of strings. Generic types are discussed
    in [Chapter 4](ch04.xhtml#ch_generics).) If a method has a parameter of type `IEnumerable<string>`,
    you can pass it a reference to an instance of any type that implements the interface,
    which means that a single method can work with arrays, various collection classes
    provided by the .NET runtime libraries, certain LINQ features, and many other
    things.
  prefs: []
  type: TYPE_NORMAL
- en: An interface declares methods, properties, and events, but it doesn’t have to
    define their bodies, as [Example 3-109](#interface) shows. Properties indicate
    whether getters and/or setters should be present, but we have semicolons in place
    of the bodies. An interface is effectively a list of the members that a type will
    need to provide if it wants to implement the interface. Be aware that on .NET
    Framework, these method-like members are the only kinds of members interfaces
    can have. I’ll discuss the additional member types available on .NET Core and
    .NET shortly, but the majority of interfaces you are likely to come across today
    only contain these kinds of members.
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-109\. An interface
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: Individual method-like members are not allowed accessibility modifiers—their
    accessibility is controlled at the level of the interface itself. (Like classes,
    interfaces are either `public` or `internal`, unless they are nested, in which
    case they can have any accessibility.) Interfaces cannot declare constructors—an
    interface only gets to say what services an object should supply once it has been
    constructed.
  prefs: []
  type: TYPE_NORMAL
- en: By the way, most interfaces in .NET follow the convention that their name starts
    with an uppercase `I` followed by one or more words in PascalCasing.
  prefs: []
  type: TYPE_NORMAL
- en: A class declares the interfaces that it implements in a list after a colon following
    the class name, as [Example 3-110](#implementing_an_interface) shows. It must
    provide implementations of all the members listed in the interface. You’ll get
    a compiler error if you leave any out. Record types can also implement interfaces,
    using a similar syntax. If the record type uses the positional syntax, the colon
    and interface list come after the positional parameter list.
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-110\. Implementing an interface
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: When we implement an interface in C#, we typically define each of that interface’s
    methods as a public member of our class. However, sometimes you may want to avoid
    this. Occasionally, some API may require you to implement an interface that you
    feel pollutes the purity of your class’s API. Or, more prosaically, you may already
    have defined a member with the same name and signature as a member required by
    the interface, but that does something different from what the interface requires.
    Or worse, you may need to implement two different interfaces, both of which define
    members that have the same name and signature but require different behavior.
    You can solve any of these problems with a technique called *explicit implementation*
    to define members that implement a member of a specific interface without being
    public. [Example 3-111](#explicit_implementation_of_an_interface) shows the syntax
    for this, with an implementation of one of the methods from the interface in [Example 3-109](#interface).
    With explicit implementations, you do not specify the accessibility, and you prefix
    the member name with the interface name.
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-111\. Explicit implementation of an interface member
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: When a type uses explicit interface implementation, those members cannot be
    used through a reference of the type itself. They become visible only when referring
    to an object through an expression of the interface’s type.
  prefs: []
  type: TYPE_NORMAL
- en: When a class implements an interface, it becomes implicitly convertible to that
    interface type. So you can pass any expression of type `DoStuff` from [Example 3-110](#implementing_an_interface)
    as a method argument of type `IDoStuff`, for example.
  prefs: []
  type: TYPE_NORMAL
- en: Interfaces are reference types. Despite this, you can implement interfaces on
    both classes and structs. However, you need to be careful when doing so with a
    struct, because when you get hold of an interface-typed reference to a struct,
    it will be a reference to a *box*, which is effectively an object that holds a
    copy of a struct in a way that can be referred to via a reference. We’ll look
    at boxing in [Chapter 7](ch07.xhtml#ch_object_lifetime).
  prefs: []
  type: TYPE_NORMAL
- en: Default Interface Implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An interface definition can include some implementation details. This relatively
    new feature (added in C# 8.0) relies on runtime support, so it is only available
    in code that targets .NET Core 3.1 or later, or .NET Standard 2.1 or later, so
    you can’t use this on .NET Framework. But as long as you’re using a suitable runtime,
    your interface definition can supply static fields, nested types, and bodies for
    methods, property accessors, and the `add` and `remove` methods for events (which
    I will describe in [Chapter 9](ch09.xhtml#ch_delegates_lambdas_events)). [Example 3-112](#interface_with_default_implementation)
    shows this in use to define a default implementation of a property.
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-112\. An interface with a default property implementation
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: If a class chooses to implement `INamed`, it will only be required to provide
    an implementation for this interface’s `Id` property. It can also supply a `Name`
    property if it wants to, but this is optional. If the class does not define its
    own `Name`, the definition from the interface will be used instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'Default interface implementations provide a partial solution to a long-standing
    limitation of interfaces: if you define an interface that you then make available
    for other code to use (e.g., via a class library), adding new members to that
    interface could cause problems for existing code that uses it. Code that invokes
    methods on the interface won’t have a problem because it will be blissfully unaware
    that new members were added, but any class that implements your interface would,
    prior to C# 8.0, be broken if you were to add new members. A concrete class is
    required to supply all the members of an interface it implements, so if the interface
    gets new members, formerly complete implementations will now be incomplete. Unless
    you have some way of reaching out to everyone who has written types that implement
    your interface and getting them to add the missing members, you will cause them
    problems if they upgrade to the new version.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You might think that this would only be a problem if the authors of code that
    works with an interface deliberately upgraded to the library containing the updated
    interface, at which point they’d have an opportunity to fix the problem. However,
    library upgrades can sometimes be forced on code. If you write an application
    that uses multiple libraries, each of which was built against different versions
    of some common library, then at least one of those is going to end up getting
    a different version of that common library at runtime than the version it was
    compiled against. (The poster child for this is the Json.NET library for parsing
    JSON. It’s extremely widely used and has had many versions released, so it’s common
    for a single application to use multiple libraries, each with a dependency on
    a different version of Json.NET. Only one version is used at runtime, so they
    can’t all have their expectations met.) This means that even if you use schemes
    such as semantic versioning, in which breaking changes are always accompanied
    by a change to the component’s major version number, that might not be enough
    to avoid trouble: you might find yourself needing to use two components where
    one wants the v1.0 flavor of some interface, while another wants the v2.0 edition.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The upshot of this was that interfaces were essentially frozen: you couldn’t
    add new members over time, even across major version changes. But default interface
    implementations loosen this restriction: you can add a new member to an existing
    interface if you also provide a default implementation for it. That way, existing
    types that implemented the older version were able to supply a complete implementation
    of the updated definition, because they automatically pick up the default implementation
    of the newly added member without needing to be modified in any way. (There is
    a small fly in the ointment, making it still sometimes preferable to use the older
    solution to this problem, abstract base classes. [Chapter 6](ch06.xhtml#ch_inheritance)
    describes these issues. So although default interface implementation can provide
    a useful escape hatch, you should still avoid modifying published interfaces if
    at all possible.)'
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to providing extra flexibility for backward compatibility, the
    default interface implementation feature adds three more capabilities: interfaces
    can now define constants, static fields, and types. [Example 3-113](#interface_with_const_and_nested_type)
    shows an interface that contains a nested constant and type.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-113\. An interface with a `const` and a nested type
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: With non-method-like members such as these, we need to specify the accessibility,
    because in some cases you may want to introduce these nested members purely for
    the benefit of default method implementations, in which case you’d want them to
    be `private`. In this case, I want the relevant members to be accessible to all,
    since they form part of the API defined by this interface, so I have marked them
    as `public`. You might be looking at that nested `Outcome` type and wondering
    what’s going on. Wonder no more.
  prefs: []
  type: TYPE_NORMAL
- en: Enums
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `enum` keyword declares a very simple type that defines a set of named values.
    [Example 3-114](#enum_with_mutually_exclusive_options) shows an `enum` that defines
    a set of mutually exclusive choices. You could say that this *enumerates* the
    options, which is where the `enum` keyword gets its name.
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-114\. An `enum` with mutually exclusive options
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: An `enum` can be used in most places you might use any other type—it could be
    the type of a local variable, a field, or a method parameter, for example. But
    one of the most common ways to use an `enum` is in a `switch` statement, as [Example 3-115](#switching_with_an_enum)
    shows.
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-115\. Switching with an `enum`
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: As this illustrates, to refer to enumeration members, you must qualify them
    with the type name. In fact, an `enum` is really just a fancy way of defining
    a load of `const` fields. The members are all just `int` values under the covers.
    You can even specify the values explicitly, as [Example 3-116](#explicit_enum_values)
    shows.
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-116\. Explicit `enum` values
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: This example also shows an alternative way to use an `enum`. The options in
    [Example 3-116](#explicit_enum_values) are not mutually exclusive. I’ve used binary
    constants here, so you can see that each value corresponds to a particular bit
    position being set to 1\. This makes it easy to combine them—`Eggs` and `Bacon`
    would be 3 (11 in binary), while `Eggs`, `Bacon`, `Sausages`, `BlackPudding`,
    and `BakedBeans` (my preferred combination) would be 103 (1100111 in binary, or
    0x67 in hex).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: When combining flag-based enumeration values, we normally use the bitwise OR
    operator. For example, you could write `Ing⁠red⁠ien⁠ts.​Eg⁠gs|⁠Ing⁠red⁠ien⁠ts.⁠Ba⁠con`.
    Not only is this significantly easier to read than using the numeric values, but
    it also works well with the search tools in IDEs—you can find all the places a
    particular symbol is used by right-clicking its definition and choosing Find All
    References or Go to References, respectively, from the context menu. You might
    come across code that uses `+` instead of `|`. This works for some combinations;
    however, `Ingredients.TheFullEnglish + Ingredients.Eggs` would be a value of 128,
    which does not correspond to anything, so it is safer to stick with `|`.
  prefs: []
  type: TYPE_NORMAL
- en: When you declare an `enum` that’s designed to be combined in this way, you’re
    supposed to annotate it with the `Flags` attribute, which is defined in the `System`
    namespace. ([Chapter 14](ch14.xhtml#ch_attributes) will describe attributes in
    detail.) [Example 3-116](#explicit_enum_values) does this, although in practice,
    it doesn’t matter greatly if you forget, because the C# compiler doesn’t care,
    and in fact, there are very few tools that pay any attention to it. The main benefit
    is that if you call `ToString` on an `enum` value, it will notice when the `Flags`
    attribute is present. For this `Ingredients` type, `ToString` would convert the
    value of 3 to the string `Eggs, Bacon`, which is also how the debugger would show
    the value, whereas without the `Flags` attribute, it would be treated as an unrecognized
    value, and you would just get a string containing the digit `3`.
  prefs: []
  type: TYPE_NORMAL
- en: With this sort of flags-style enumeration, you can run out of bits fairly quickly.
    By default, `enum` uses `int` to represent the value, and with a sequence of mutually
    exclusive values, that’s usually sufficient. It would be a fairly complicated
    scenario that needed billions of different values in a single enumeration type.
    However, with 1 bit per flag, an `int` provides space for just 32 flags. Fortunately,
    you can get a little more breathing room, because you can specify a different
    underlying type—you can use any built-in integer type, meaning that you can go
    up to 64 bits. As [Example 3-117](#six4-bit_enum) shows, you can specify the underlying
    type after a colon following the `enum` type name.
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-117\. 64-bit `enum`
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: All `enum` types are value types, incidentally, like the built-in numeric types
    or any struct. But they are very limited. You cannot define any members other
    than the constant values—no methods or properties, for example.
  prefs: []
  type: TYPE_NORMAL
- en: Enumeration types can sometimes enhance the readability of code. A lot of APIs
    accept a `bool` to control some aspect of their behavior but might often have
    done better to use an `enum`. Consider the code in [Example 3-118](#unhelpful_use_of_bool).
    It constructs a `StreamReader`, a class for working with data streams that contain
    text. The second constructor argument is a `bool`.
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-118\. Unhelpful use of the `bool` type
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: It’s not remotely obvious what that second argument does. If you happen to be
    familiar with `StreamReader`, you may know that this argument determines whether
    byte ordering in a multibyte text encoding should be set explicitly from the code
    or determined from a preamble at the start of the stream. (Using the named argument
    syntax would help here.) And if you’ve got a really good memory, you might even
    know which of those choices `true` happens to select. But most mere mortal developers
    will probably have to reach for IntelliSense or even the documentation to work
    out what that argument does. Compare that experience with [Example 3-119](#clarity_with_an_enum),
    which shows a different type.
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-119\. Clarity with an `enum`
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: This constructor’s second argument uses an enumeration type, which makes for
    rather less opaque code. It doesn’t take an eidetic memory to work out that this
    code intends to append data to an existing file.
  prefs: []
  type: TYPE_NORMAL
- en: As it happens, because this particular API has more than two options, it couldn’t
    use a `bool`. So `FileMode` really had to be an `enum`. But these examples illustrate
    that even in cases where you’re selecting between just two choices, it’s well
    worth considering defining an `enum` for the job so that it’s completely obvious
    which choice is being made when you look at the code.
  prefs: []
  type: TYPE_NORMAL
- en: Other Types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We’re almost done with our survey of types and what goes in them. There’s one
    kind of type that I’ll not discuss until [Chapter 9](ch09.xhtml#ch_delegates_lambdas_events):
    delegates. We use delegates when we need a reference to a function, but the details
    are somewhat involved.'
  prefs: []
  type: TYPE_NORMAL
- en: I’ve also not mentioned pointers. C# supports pointers that work in a pretty
    similar way to C-style pointers, complete with pointer arithmetic. (If you’re
    not familiar with these, they provide a reference to a particular location in
    memory.) These are a little weird, because they are slightly outside of the rest
    of the type system. For example, in [Chapter 2](ch02.xhtml#ch_basic_coding), I
    mentioned that a variable of type `object` can refer to “almost anything.” The
    reason I had to qualify that is that pointers are one of the two exceptions—`object`
    can work with any C# data type except a pointer or a `ref struct`. ([Chapter 18](ch18.xhtml#ch_memory_efficiency)
    discusses the latter.)
  prefs: []
  type: TYPE_NORMAL
- en: But now we really are done. Some types in C# are special, including the fundamental
    types discussed in [Chapter 2](ch02.xhtml#ch_basic_coding) and the records, structs,
    interfaces, enums, delegates, and pointers just described, but everything else
    looks like a class. There are a few classes that get special handling in certain
    circumstances—notably attribute classes ([Chapter 14](ch14.xhtml#ch_attributes))
    and exception classes ([Chapter 8](ch08.xhtml#ch_exceptions))—but except for certain
    special scenarios, even those are otherwise completely normal classes. Even though
    we’ve seen all the kinds of types that C# supports, there’s one way to define
    a class that I’ve not shown yet.
  prefs: []
  type: TYPE_NORMAL
- en: Anonymous Types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'C# offers two mechanisms for grouping a handful of values together. You’ve
    already seen tuples, which were described in [Chapter 2](ch02.xhtml#ch_basic_coding).
    These were introduced in C# 7.0, but there is an alternative that has been available
    since C# 3.0: [Example 3-120](#anonymous_type) shows how to create an instance
    of an *anonymous type* and how to use it.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-120\. An anonymous type
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we use the `new` keyword without specifying a type name. Instead,
    we just use the object initializer syntax. The C# compiler will provide a type
    that has one read-only property for each entry inside the initializer. So in [Example 3-120](#anonymous_type),
    the variable `x` will refer to an object that has two properties, `Title` and
    `Surname`, both of type `string`. (You do not state the property types explicitly
    in an anonymous type. The compiler infers each property’s type from the initialization
    expression in the same way it does for the `var` keyword.) Since these are just
    normal properties, we can access them with the usual syntax, as the final line
    of the example shows.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The `with` syntax available for record types and `struct` types also works with
    anonymous types. The reason `with` is not available for all reference types is
    the lack of a general, universal cloning mechanism, but that’s not a problem with
    anonymous types. They are always generated by the compiler, so the compiler knows
    exactly how to copy them.
  prefs: []
  type: TYPE_NORMAL
- en: The compiler generates a fairly ordinary class definition for each anonymous
    type. It is immutable, because all the properties are read-only. Much like a record,
    it overrides `Equals` so that you can compare instances by value, and it also
    provides a matching `GetHashCode` implementation. The only unusual thing about
    the generated class is that it’s not possible to refer to the type by name in
    C#. Running [Example 3-120](#anonymous_type) in the debugger, I find that the
    compiler has chosen the name `<>f__AnonymousType0'2`. This is not a legal identifier
    in C# because of those angle brackets (`<>`) at the start. C# uses names like
    this whenever it wants to create something that is guaranteed not to collide with
    any identifiers you might use in your own code, or that it wants to prevent you
    from using directly. This sort of identifier is called, rather magnificently,
    an *unspeakable name*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because you cannot write the name of an anonymous type, a method cannot declare
    that it returns one, or that it requires one to be passed as an argument (unless
    you use an anonymous type as an inferred generic type argument, something we’ll
    see in [Chapter 4](ch04.xhtml#ch_generics)). Of course, an expression of type
    `object` can refer to an instance of an anonymous type, but only the method that
    defines the type can use its properties (unless you use the `dynamic` type described
    in [Chapter 2](ch02.xhtml#ch_basic_coding)). So anonymous types are of somewhat
    limited value. They were added to the language for LINQ’s benefit: they enable
    a query to select specific columns or properties from some source collection and
    also to define custom grouping criteria, as you’ll see in [Chapter 10](ch10.xhtml#ch_linq).'
  prefs: []
  type: TYPE_NORMAL
- en: These limitations provide a clue as to why Microsoft felt the need to add tuples
    in C# 7.0 when the language already had a pretty similar-looking feature. However,
    if the inability to use anonymous types as parameters or return types was the
    only problem, an obvious solution might have been to introduce a syntax enabling
    them to be identified. The syntax for referring to tuples could arguably have
    worked—we can now write `(string Name, double Age)` to refer to a tuple type,
    but why introduce a whole new concept? Why not just use that syntax to name anonymous
    types? (Obviously we’d no longer be able to call them anonymous types, but at
    least we wouldn’t have ended up with two confusingly similar language features.)
    However, the lack of names isn’t the only problem with anonymous types.
  prefs: []
  type: TYPE_NORMAL
- en: 'As C# has been used in increasingly diverse applications, and across a broader
    range of hardware, efficiency has become more of a concern. In the database access
    scenarios for which anonymous types were originally introduced, the cost of object
    allocations would have been a relatively small part of the picture, but the basic
    concept—a small bundle of values—is potentially useful in a much wider range of
    scenarios, some of which are more performance sensitive. However, anonymous types
    are all reference types, and while in many cases that’s not a problem, it can
    rule them out in some hyper-performance-sensitive scenarios. Tuples, on the other
    hand, are all value types, making them viable even in code where you are attempting
    to minimize the number of allocations. (See [Chapter 7](ch07.xhtml#ch_object_lifetime)
    for more detail on memory management and garbage collection, and [Chapter 18](ch18.xhtml#ch_memory_efficiency)
    for information about some of the newer language features aimed at enabling more
    efficient memory usage.) Also, since tuples are all based on a set of generic
    types under the covers, they may end up reducing the runtime overhead required
    to keep track of loaded types: with anonymous types, you can end up with a lot
    more distinct types loaded. For related reasons, anonymous types would have problems
    with compatibility across component boundaries.'
  prefs: []
  type: TYPE_NORMAL
- en: Does this mean that anonymous types are no longer of any use? In fact, they
    still offer some advantages. The most significant one is that you cannot use a
    tuple in a lambda expression that will be converted into an expression tree. This
    issue is described in detail in [Chapter 9](ch09.xhtml#ch_delegates_lambdas_events),
    but the practical upshot is that you cannot use tuples in the kinds of LINQ queries
    mentioned earlier that anonymous types were added to support.
  prefs: []
  type: TYPE_NORMAL
- en: 'More subtle is the fact that with tuples, property names are a convenient fiction,
    whereas with anonymous types, they are real. This has two upshots. One regards
    equivalence: the tuples `(X: 10, Y:20)` and `(W:10, H:20)` are considered interchangeable,
    where any variable capable of holding one is capable of holding the other. That
    is not true for anonymous types: `new { X = 10, Y = 20 }` has a different type
    than `new { W = 10, H = 20 }`, and attempting to pass one to code that expects
    the other will cause a compiler error. This difference can make tuples more convenient,
    but it can also make them more error prone, because the compiler looks only at
    the shape of the data when asking whether you’re using the right type. Anonymous
    types can still enable errors: if you have two types with exactly the same property
    names and types but that are semantically different, there’s no way to express
    that with anonymous types. (In practice you’d probably just define two record
    types to deal with this.) The second upshot of anonymous types offering genuine
    properties is that you can pass them to code that inspects an object’s properties.
    Many reflection-driven features such as certain serialization frameworks, or UI
    framework databinding, depend on being able to discover properties at runtime
    through reflection (see [Chapter 13](ch13.xhtml#ch_reflection)). Anonymous types
    may work better with these frameworks than tuples, in which the properties’ real
    names are all things like `Item1`, `Item2`, etc.'
  prefs: []
  type: TYPE_NORMAL
- en: Partial Types and Methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There’s one last topic I want to discuss relating to types. C# supports what
    it calls a *partial type declaration*. This is a very simple concept: it means
    that the type declaration might span multiple files. If you add the `partial`
    keyword to a type declaration, C# will not complain if another file defines the
    same type—it will simply act as though all the members defined by the two files
    had appeared in a single declaration in one file.'
  prefs: []
  type: TYPE_NORMAL
- en: This feature exists to make it easier to write code-generation tools. Various
    features in Visual Studio can generate bits of your class for you. This is particularly
    common with UIs. UI applications typically have markup that defines the layout
    and content of each part of the UI, and you can choose for certain UI elements
    to be accessible in your code. You usually achieve this by adding a field to a
    class associated with the markup file. To keep things simple, all the parts of
    the class that Visual Studio generates go in a separate file from the parts that
    you write. This means that the generated parts can be remade from scratch whenever
    needed without any risk of overwriting the code that you’ve written. Before partial
    types were introduced to C#, all the code for a class had to go in one file, and
    from time to time, code generation tools would get confused, leading to loss of
    code.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Partial classes are not limited to code-generation scenarios, so you can of
    course use this to split your own class definitions across multiple files. However,
    if you’ve written a class so large and complex that you feel the need to split
    it into multiple source files just to keep it manageable, that’s probably a sign
    that the class is too complex. A better response to this problem might be to change
    your design. However, it can be useful if you need to maintain code that is built
    in different ways for different target platforms: you can use partial classes
    to put target-specific parts in separate files.'
  prefs: []
  type: TYPE_NORMAL
- en: Partial methods are also designed for code-generation scenarios, but they are
    slightly more complex. They allow one file, typically a generated file, to declare
    a method, and for another file to implement the method. (Strictly speaking, the
    declaration and implementation are allowed to be in the same file, but they usually
    won’t be.) This may sound like the relationship between an interface and a class
    that implements that interface, but it’s not quite the same. With partial methods,
    the declaration and implementation are in the same class—they’re in different
    files only because the class has been split across multiple files.
  prefs: []
  type: TYPE_NORMAL
- en: If you do not provide an implementation of a partial method, then as long as
    the method definition does not specify any accessibility, has a `void` return
    type, and no `out` arguments, the compiler acts as though the method isn’t there
    at all, and any code that invokes the method is ignored at compile time. The main
    reason for this is to support code-generation mechanisms that are able to offer
    many kinds of notifications but where you want zero runtime overhead for notifications
    that you don’t need. Partial methods enable this by letting the code generator
    declare a partial method for each kind of notification it provides and to generate
    code that invokes all of these partial methods where necessary. All code relating
    to notifications for which you do not write a handler method will be stripped
    out at compile time.
  prefs: []
  type: TYPE_NORMAL
- en: It’s an idiosyncratic mechanism, but it was driven by frameworks that provide
    extremely fine-grained notifications and extension points. There are some more
    obvious runtime techniques you could use instead, such as interfaces, or features
    that I’ll cover in later chapters, such as callbacks or virtual methods. However,
    any of these would impose a relatively high cost for unused features. Unused partial
    methods get stripped out at compile time, reducing the cost of the bits you don’t
    use to nothing, which is a considerable improvement.
  prefs: []
  type: TYPE_NORMAL
- en: Up until recently, partial methods were required not to specify their accessibility
    and not return any data. C# 9.0 relaxed this to support additional code-generation
    scenarios, in which a developer writes a partial method in the expectation that
    a code-generation tool will supply the implementation. When a partial method specifies
    the accessibility (even if it is `private` and returns no data), it is an error
    for the method not to be implemented.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You’ve now seen most of the kinds of types you can write in C# and the sorts
    of members they support. Classes are the most widely used, but structs are useful
    if you need value-like semantics for assignment and arguments; both support the
    same member types—namely, fields, constructors, methods, properties, indexers,
    events, custom operators, and nested types. Records provide a more convenient
    syntax for defining types that consist mostly of properties, especially if you
    want to be able to compare the values of such types. And while they do not have
    to be immutable, record types make it easier to define and work with immutable
    data. Interfaces are abstract, so at the instance level they support only methods,
    properties, indexers, and events. They can also provide static fields, nested
    types, and default implementations for other members. And enums are very limited,
    providing just a set of known values.
  prefs: []
  type: TYPE_NORMAL
- en: There’s another feature of the C# type system that makes it possible to write
    very flexible types, called generic types. We’ll look at these in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: ^([1](ch03.xhtml#idm45884853473568-marker)) Specifically, it generates a method
    with a special name, `<Clone>$`. That name is an illegal identifier in C#, so
    this method is in effect hidden from your code, but you will be using it indirectly
    if you use the `with` syntax to build a modified copy of a record.
  prefs: []
  type: TYPE_NORMAL
- en: ^([2](ch03.xhtml#idm45884832593360-marker)) There are certain exceptions, described
    in [Chapter 18](ch18.xhtml#ch_memory_efficiency).
  prefs: []
  type: TYPE_NORMAL
- en: ^([3](ch03.xhtml#fn19-marker)) You wouldn’t want it to be a value type, because
    strings can be large, so passing them by value would be expensive. In any case,
    it cannot be a struct, because strings vary in length. However, that’s not a factor
    you need to consider, because you can’t write your own variable-length data types
    in C#. Only strings and array types have variable size.
  prefs: []
  type: TYPE_NORMAL
- en: ^([4](ch03.xhtml#idm45884832211984-marker)) If you omit the initializer for
    a `readonly` field, you should set it in the constructor or a property’s `init`
    accessor instead; otherwise it’s not very useful.
  prefs: []
  type: TYPE_NORMAL
- en: ^([5](ch03.xhtml#fn20-marker)) There are two exceptions. If a class supports
    a CLR feature called *serialization*, objects of that type can be deserialized
    directly from a data stream, bypassing constructors. But even here, you can dictate
    what data is required. And there’s the `MemberwiseClone` method described in [Chapter 6](ch06.xhtml#ch_inheritance).
  prefs: []
  type: TYPE_NORMAL
- en: '^([6](ch03.xhtml#idm45884830549600-marker)) The CLR calls this kind of reference
    a *Managed Pointer*, to distinguish it from the kind of reference that refers
    to an object on the heap. Unfortunately, C#’s terminology is less clear: it calls
    both of these things *references*.'
  prefs: []
  type: TYPE_NORMAL
- en: ^([7](ch03.xhtml#idm45884827660912-marker)) Incidentally, the default property
    has a name, because all properties are required to. C# calls the indexer property
    `Item` and automatically adds the annotation indicating that it’s the default
    property. You won’t normally refer to an indexer by name, but the name is visible
    in some tools. The .NET documentation lists indexers under `Item`, even though
    it’s rare to use that name in code.
  prefs: []
  type: TYPE_NORMAL
