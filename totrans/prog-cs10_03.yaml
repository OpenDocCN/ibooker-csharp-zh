- en: Chapter 3\. Types
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三章\. 类型
- en: 'C# does not limit us to the built-in data types shown in [Chapter 2](ch02.xhtml#ch_basic_coding).
    You can define your own types. In fact, you have no choice: if you want to write
    code at all, C# requires that code to be inside a type. Everything we write, and
    any functionality we consume from the .NET runtime libraries (or any other .NET
    library), will belong to a type.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: C# 不限制我们使用[第二章](ch02.xhtml#ch_basic_coding)中展示的内置数据类型。你可以定义自己的类型。实际上，你别无选择：如果要编写任何代码，C#
    要求该代码必须在一个类型内。我们编写的所有内容，以及我们从 .NET 运行库（或任何其他 .NET 库）中消耗的任何功能，都将属于某一类型。
- en: C# recognizes multiple kinds of types. I’ll begin with the most important.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: C# 识别多种类型。我将从最重要的类型开始介绍。
- en: Classes
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类
- en: Most of the types you work with in C# will be *classes*. A class can contain
    both code and data, and it can choose to make some of its features publicly available
    while keeping others accessible only to code within the class. So classes offer
    a mechanism for *encapsulation*—they can define a clear public programming interface
    for other people to use while keeping internal implementation details inaccessible.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C# 中，你处理的大多数类型将是*类*。类可以同时包含代码和数据，可以选择公开一些特性同时保持其他特性仅在类内可访问。因此，类提供了一种*封装*机制——它们可以为其他人定义一个清晰的公共编程接口，同时保持内部实现细节不可访问。
- en: If you’re familiar with object-oriented languages, this will all seem very ordinary.
    If you’re not, then you might want to read a more introductory-level book first,
    because this book is not meant to teach programming. I’ll just describe the details
    specific to C# classes.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你熟悉面向对象的语言，这一切看起来非常普通。如果不熟悉，你可能需要先阅读一本更入门级的书籍，因为本书不旨在教授编程。我将只描述特定于 C# 类的细节。
- en: I’ve already shown examples of classes in earlier chapters, but let’s look at
    the structure in more detail. [Example 3-1](#simple_class) shows a simple class.
    (See the sidebar [“Naming Conventions”](#naming_conventions) for information about
    names for types and their members.)
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经在早期章节中展示了类的示例，但让我们更详细地查看结构。[示例 3-1](#simple_class) 展示了一个简单的类。（参见侧边栏 [“命名约定”](#naming_conventions)
    以获取有关类型及其成员名称的信息。）
- en: Example 3-1\. A simple class
  id: totrans-7
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-1\. 一个简单的类
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Class definitions always contain the `class` keyword followed by the name of
    the class. C# does not require the name to match the containing file, nor does
    it limit you to having one class in a file. That said, most C# projects make the
    class and filenames match by convention. In any case, class names must follow
    the basic rules described in [Chapter 2](ch02.xhtml#ch_basic_coding) for identifiers
    such as variables; e.g., they cannot start with a number.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 类定义总是包含关键字 `class`，后跟类的名称。C# 不要求名称与包含文件匹配，也不限制文件中只能有一个类。尽管如此，大多数 C# 项目按约定使类名和文件名匹配。无论如何，类名必须遵循[第二章](ch02.xhtml#ch_basic_coding)中描述的标识符基本规则，例如，它们不能以数字开头。
- en: 'The first line of [Example 3-1](#simple_class) contains an additional keyword:
    `public`. Class definitions can optionally specify *accessibility*, which determines
    what other code is allowed to use the class. Ordinary classes have just two choices
    here: `public` and `internal`, with the latter being the default. (As I’ll show
    later, you can nest classes inside other types, and nested classes have a slightly
    wider range of accessibility options.) An internal class is available for use
    only within the component that defines it. So if you are writing a class library,
    you are free to define classes that exist purely as part of your library’s implementation:
    by marking them as `internal`, you prevent the rest of the world from using them.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 3-1](#simple_class) 的第一行包含了额外的关键字：`public`。类定义可以选择指定*可访问性*，确定其他代码是否可以使用该类。普通类在这里只有两个选择：`public`
    和 `internal`，后者是默认值。（稍后我将展示，你可以将类嵌套在其他类型内，嵌套类的可访问性选项稍宽泛。）内部类仅可在定义它的组件中使用。因此，如果你正在编写一个类库，可以自由定义作为库实现一部分的类：通过将它们标记为
    `internal`，你可以阻止外部世界使用它们。'
- en: Note
  id: totrans-11
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can choose to make your internal types visible to selected external components.
    Microsoft sometimes does this with its libraries. The runtime libraries are spread
    across numerous DLLs, each of which defines many internal types, but some internal
    features are used by other DLLs in the library. This is made possible by annotating
    a component with the `[assembly: Int⁠ern⁠als​Vis⁠ibl⁠eTo("*name*")]` attribute,
    specifying the name of the component with which you wish to share. ([Chapter 14](ch14.xhtml#ch_attributes)
    describes this in more detail.) For example, you might want to make every class
    in your application visible to a test project so that you can write unit tests
    for code that you don’t intend to make publicly available.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '您可以选择将内部类型对选定的外部组件可见。微软有时会在其库中使用此功能。运行库分布在许多 DLL 中，每个 DLL 定义许多内部类型，但某些内部功能由库中的其他
    DLL 使用。通过使用 `[assembly: Int⁠ern⁠als​Vis⁠ibl⁠eTo("*name*")]` 属性对组件进行注释，指定希望共享的组件名称。（[第 14 章](ch14.xhtml#ch_attributes)
    更详细地描述了此内容。）例如，您可能希望使应用程序中的每个类对测试项目可见，以便可以编写针对不打算公开的代码的单元测试。'
- en: The `Counter` class in [Example 3-1](#simple_class) has chosen to be `public`,
    but that doesn’t mean it has to make everything accessible. It defines two members—a
    field called `_count` that holds an `int` and a method called `GetNextValue` that
    operates on the information in that field. (The CLR will automatically initialize
    this field to 0 when a `Counter` is created.) As you can see, both of these members
    have accessibility qualifiers too. As is very common with object-oriented programming,
    this class has chosen to make the data member private, exposing public functionality
    through a method.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 3-1](#simple_class) 中的 `Counter` 类选择了 `public`，但这并不意味着它必须使所有内容都可访问。它定义了两个成员——一个名为
    `_count` 的字段，保存一个 `int`，以及一个名为 `GetNextValue` 的方法，操作该字段中的信息。（当创建 `Counter` 时，CLR
    将自动将此字段初始化为 0。）如您所见，这两个成员都有可访问性修饰符。正如面向对象编程非常常见的那样，该类选择将数据成员设为私有，并通过方法公开公共功能。'
- en: 'Accessibility modifiers are optional for members, just as they are for classes,
    and again, they default to the most restrictive option available: `private`, in
    this case. So I could have left off the `private` keyword in [Example 3-1](#simple_class)
    without changing the meaning, but I prefer to be explicit. (If you leave it unspecified,
    people reading your code may wonder whether the omission was deliberate or accidental.)'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 成员的可访问性修饰符对于成员是可选的，就像对于类一样，如果未指定，则默认为最严格的选项：在这种情况下是 `private`。所以我本可以在 [示例 3-1](#simple_class)
    中省略 `private` 关键字而不改变其含义，但我更喜欢明确指出。（如果您不指定，阅读您代码的人可能会想知道这是故意还是偶然。）
- en: Fields hold data. They are a kind of variable, but unlike a local variable,
    whose scope and lifetime is determined by its containing method, a field is tied
    to its containing type. [Example 3-1](#simple_class) is able to refer to the `_count`
    field by its unqualified name because fields are in scope within their defining
    class. But what about the lifetime? We know that each invocation of a method gets
    its own set of local variables. How many sets of a class’s fields are there? There
    are a couple of possibilities, depending on how you define the field, and in this
    case, it’s one per instance. [Example 3-2](#using_a_custom_class) uses the `Counter`
    class from [Example 3-1](#simple_class) to illustrate this.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 字段保存数据。它们是一种变量，但不像局部变量那样，其作用域和生命周期由其所在的方法决定，字段与其所在的类型相关联。[示例 3-1](#simple_class)
    能够通过其未限定名称引用 `_count` 字段，因为字段在其定义的类中是可见的。但是生命周期如何呢？我们知道，每次方法调用都会得到其自己的一组局部变量。一个类的字段有多少组？这取决于如何定义字段，在这种情况下，每个实例一个。[示例 3-2](#using_a_custom_class)
    使用 [示例 3-1](#simple_class) 中的 `Counter` 类来说明这一点。
- en: Example 3-2\. Using a custom class
  id: totrans-16
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-2\. 使用自定义类
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This uses the `new` operator to create new instances of my class. Since I use
    `new` twice, I get two `Counter` objects, and each has its own `_count` field.
    So we get two independent counts, as the program’s output shows:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `new` 运算符创建我的类的新实例。由于我使用 `new` 两次，所以我得到两个 `Counter` 对象，每个对象都有自己的 `_count`
    字段。因此，正如程序的输出所示，我们得到两个独立的计数：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As you’d expect, it begins counting up, and then a new sequence starts at 1
    when we switch to the second counter. But when we go back to the first counter,
    it carries on from where it left off. This demonstrates that each instance has
    its own `_count`. But what if we don’t want that? Sometimes you will want to keep
    track of information that doesn’t relate to any single object.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所预期的那样，它开始计数，然后在我们切换到第二个计数器时，新的序列从 1 开始。但当我们回到第一个计数器时，它会从中断处继续。这表明每个实例都有自己的
    `_count`。但如果我们不希望如此呢？有时，您会希望跟踪与任何单个对象无关的信息。
- en: Static Members
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 静态成员
- en: The `static` keyword lets us declare that a member is not associated with any
    particular instance of the class. [Example 3-3](#class_with_static_members) shows
    a modified version of the `Counter` class from [Example 3-1](#simple_class). I’ve
    added two new members, both static, for tracking and reporting counts across all
    instances.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`static` 关键字允许我们声明成员不与类的任何特定实例相关联。[示例 3-3](#class_with_static_members) 显示了从[示例 3-1](#simple_class)
    修改的 `Counter` 类的修改版本。我添加了两个新成员，均为静态成员，用于跟踪和报告所有实例的计数。'
- en: Example 3-3\. Class with static members
  id: totrans-23
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-3\. 具有静态成员的类
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '`TotalCount` reports the count, but it doesn’t do any work—it just returns
    a value that the class keeps up to date, and as I’ll explain in [“Properties”](#properties),
    this makes it an ideal candidate for being a property rather than a method. The
    static field `_totalCount` keeps track of the total number of calls to `GetNextValue`,
    unlike the nonstatic `_count`, which just tracks calls to the current instance.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`TotalCount` 只报告计数，但它并不执行任何操作 —— 它只是返回类保持更新的一个值。正如我将在[“属性”](#properties)中解释的那样，这使它成为一个理想的属性候选项，而不是一个方法。静态字段
    `_totalCount` 跟踪调用 `GetNextValue` 的总次数，与非静态 `_count` 不同，后者只跟踪当前实例的调用次数。'
- en: Note
  id: totrans-26
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The `=>` syntax in the `TotalCount` property lets us define the property with
    a single expression—in this case, whenever code reads the `Counter.TotalCount`
    property, the result will be the value of the `_totalCount` field. As we’ll see
    later, there are ways to write more complex properties, but this is a common approach
    for simple, read-only properties.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`=>` 语法在 `TotalCount` 属性中让我们使用单个表达式定义属性 —— 在这种情况下，每当代码读取 `Counter.TotalCount`
    属性时，结果将是 `_totalCount` 字段的值。正如我们将在后面看到的，有更复杂的属性编写方法，但这是简单只读属性的常见方法。'
- en: Notice that I’m free to use that static field inside `GetNextValue` in exactly
    the same way as I use the nonstatic `_count`. The difference in behavior is clear
    if I add the line of code shown in [Example 3-4](#using_a_static_property) to
    the end of the code in [Example 3-2](#using_a_custom_class).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我可以在 `GetNextValue` 中以与非静态 `_count` 相同的方式使用该静态字段。如果我在 [示例 3-2](#using_a_custom_class)
    的代码末尾添加所示的代码行到 [示例 3-4](#using_a_static_property)，则行为差异显而易见。
- en: Example 3-4\. Using a static property
  id: totrans-29
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-4\. 使用静态属性
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This line displays 5, the sum of the two counts. To access a static member,
    I just write `*ClassName*.*MemberName*`. In fact, [Example 3-4](#using_a_static_property)
    uses two static members—as well as my class’s `TotalCount` property, it uses the
    `Console` class’s static `WriteLine` method.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 此行显示 5，即两个计数的总和。要访问静态成员，我只需写 `*ClassName*.*MemberName*`。事实上，[示例 3-4](#using_a_static_property)
    使用了两个静态成员 —— 除了我的类的 `TotalCount` 属性，还使用了 `Console` 类的静态 `WriteLine` 方法。
- en: 'Because I’ve declared `TotalCount` as a static property, the code it contains
    has access only to other static members. If it tried to use the nonstatic `_count`
    field or call the nonstatic `GetNextValue` method, the compiler would complain.
    Replacing `_totalCount` with `_count` in the `TotalCount` property results in
    this error:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我将 `TotalCount` 声明为静态属性，所以它包含的代码只能访问其他静态成员。如果它尝试使用非静态 `_count` 字段或调用非静态 `GetNextValue`
    方法，编译器会抱怨。将 `TotalCount` 属性中的 `_totalCount` 替换为 `_count` 将导致此错误：
- en: '[PRE5]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Since nonstatic fields are associated with a particular instance of a class,
    C# needs to know which instance to use. With a nonstatic method or property, that’ll
    be whichever instance the method or property itself was invoked on. So in [Example 3-2](#using_a_custom_class),
    I wrote either `c1.GetNextValue()` or `c2.GetNextValue()` to choose which of my
    two objects to use. C# passed the reference stored in either `c1` or `c2`, respectively,
    as an implicit hidden first argument. You can get hold of that reference from
    code inside a class by using the `this` keyword. [Example 3-5](#this_keyword)
    shows an alternative way we could have written the first line of `GetNextValue`
    from [Example 3-3](#class_with_static_members), indicating explicitly that we
    believe `_count` is a member of the instance on which the `GetNextValue` method
    was invoked.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 由于非静态字段与类的特定实例相关联，C#需要知道使用哪个实例。对于非静态方法或属性，将是调用该方法或属性的实例。因此，在[示例3-2](#using_a_custom_class)中，我写了`c1.GetNextValue()`或`c2.GetNextValue()`以选择使用我两个对象中的哪一个。C#将存储在`c1`或`c2`中的引用作为隐含的隐藏第一个参数传递。您可以通过使用`this`关键字从类内部的代码获取该引用。[示例3-5](#this_keyword)展示了我们可以如何以替代方式编写来自[示例3-3](#class_with_static_members)的`GetNextValue`方法的第一行，显式指示我们相信`_count`是在调用`GetNextValue`方法的实例中的成员。
- en: Example 3-5\. The `this` keyword
  id: totrans-35
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例3-5\. `this`关键字
- en: '[PRE6]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Explicit member access through `this` is sometimes necessary due to name collisions.
    Although all the members of a class are in scope for any code in the same class,
    the code in a method does not share a *declaration space* with the class. Remember
    from [Chapter 2](ch02.xhtml#ch_basic_coding) that a declaration space is a region
    of code in which a single name must not refer to two different entities, and since
    methods do not share theirs with the containing class, you are allowed to declare
    local variables and method parameters that have the same name as class members.
    This can easily happen if you don’t use a convention such as an underscore prefix
    for field names. You don’t get an error in this case—locals and parameters just
    hide the class members. But you can still get at the class members by qualifying
    access with `this`.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 有时由于名称冲突，需要通过`this`进行显式成员访问。尽管类的所有成员对同一类中的任何代码都在范围内，但方法中的代码与类不共享*声明空间*。从[第2章](ch02.xhtml#ch_basic_coding)中记住，声明空间是一个代码区域，在其中单个名称不能引用两个不同的实体，因为方法不与包含类共享它们的空间，您可以声明与类成员名称相同的局部变量和方法参数。如果不使用下划线前缀等约定，这很容易发生。在这种情况下，您不会收到错误提示——局部变量和参数只是隐藏类成员。但您仍然可以通过使用`this`限定访问来访问类成员。
- en: Static methods don’t get to use the `this` keyword, because they are not associated
    with any particular instance.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 静态方法不能使用`this`关键字，因为它们不与任何特定实例相关联。
- en: Static Classes
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 静态类
- en: Some classes only provide static members. There are several examples in the
    `Sys⁠tem.​Thr⁠ead⁠ing` namespace, which contains various classes that offer multithreading
    utilities. For example, the `Interlocked` class provides atomic, lock-free, read-modify-write
    operations; the `LazyInitializer` class provides helper methods for performing
    deferred initialization in a way that guarantees to avoid double initialization
    in multithreaded environments. These classes provide services only through static
    methods. It makes no sense to create instances of these types, because there’s
    no useful per-instance information they could hold.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 有些类仅提供静态成员。在`Sys⁠tem.​Thr⁠ead⁠ing`命名空间中有几个示例，其中包含提供多线程工具的各种类。例如，`Interlocked`类提供原子、无锁、读取-修改-写入操作；`LazyInitializer`类提供在保证避免多线程环境中的双重初始化的情况下执行延迟初始化的辅助方法。这些类仅通过静态方法提供服务。创建这些类型的实例没有意义，因为它们无法保存有用的每个实例信息。
- en: You can declare that your class is intended to be used this way by putting the
    `static` keyword in front of the `class` keyword. This compiles the class in a
    way that prevents instances of it from being constructed. Anyone attempting to
    construct instances of a class designed to be used this way clearly doesn’t understand
    what it does, so the compiler error will be a useful prod in the direction of
    the documentation.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在`class`关键字前加上`static`关键字，您可以声明您的类意在以此方式使用。这种编译方式会阻止对其进行实例化。任何试图构造此类实例的人显然不理解其功能，因此编译器错误将是对文档的有用提示。
- en: You can declare that you want to be able to invoke static methods on certain
    classes without naming the class every time. This can be useful if you are writing
    code that makes heavy use of the static methods supplied by a particular type.
    (This isn’t limited to static classes, by the way. You can use this technique
    with any class that has static members, but it is likely to be most useful with
    classes whose members are all static.) [Example 3-6](#using_static_members_normally)
    uses a static method (`Sin`) and a static property (`PI`) of the `Math` class
    (in the `System` namespace). It also uses the `Console` class’s static `WriteLine`
    method. (I’m showing the entire source file in this and the next example because
    the `using` directives are particularly important. The first example doesn’t need
    a `using System;` because default implicit global usings make this available everywhere.)
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以声明希望能够在某些类上调用静态方法，而无需每次都命名类。如果您正在编写大量使用特定类型提供的静态方法的代码，则这可能会很有用。（顺便说一句，这不仅限于静态类。您可以将此技术用于具有静态成员的任何类，但对其成员全为静态的类最有用。）[示例 3-6](#using_static_members_normally)使用了`Math`类（位于`System`命名空间）的静态方法（`Sin`）和静态属性（`PI`）。它还使用了`Console`类的静态`WriteLine`方法。（我在这个例子和下一个例子中展示了整个源文件，因为`using`指令特别重要。第一个例子不需要`using
    System;`，因为默认的隐式全局`using`使其在任何地方都可用。）
- en: Example 3-6\. Using static members normally
  id: totrans-43
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-6\. 正常使用静态成员
- en: '[PRE7]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[Example 3-7](#using_static_members_without_explicit_qu) is exactly equivalent,
    but the line that invokes the three static members does not qualify any of them
    with their defining class’s name.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 3-7](#using_static_members_without_explicit_qu)完全等效，但调用三个静态成员的行没有使用其定义类的名称限定。'
- en: Example 3-7\. Using static members without explicit qualification
  id: totrans-46
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 3-7\. 使用静态成员而不进行显式限定
- en: '[PRE8]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: To utilize this less verbose alternative, you must declare which classes you
    want to use in this way with `using static` directives. Whereas `using` directives
    normally specify a namespace, enabling types in that namespace to be used without
    qualification, `using static` directives specify a class, enabling its static
    members to be used without qualification. By the way, as you saw in [Chapter 1](ch01.xhtml#ch_introducing_csharp),
    C# 10.0 lets you add the `global` keyword to `using` directives. That works for
    `using static` directives too, so if you want, say, the `Math` type’s static members
    to be available without qualification in any file in your project, you can write
    `global using static System.Math;` in just one file, and it will apply to all
    of them.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用这种更简洁的替代方法，必须使用`using static`指令声明要以这种方式使用的类。虽然`using`指令通常指定一个命名空间，使该命名空间中的类型无需限定即可使用，但`using
    static`指令指定一个类，使其静态成员无需限定即可使用。顺便说一句，正如您在[第1章](ch01.xhtml#ch_introducing_csharp)中看到的，C#
    10.0允许您在`using`指令中添加`global`关键字。这对`using static`指令也有效，因此，如果您希望`Math`类型的静态成员在项目中的任何文件中无需限定即可使用，只需在一个文件中编写`global
    using static System.Math;`，它将适用于所有文件。
- en: Records
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 记录
- en: Although encapsulation is a powerful tool for managing complexity in software
    development, it can sometimes be useful to have types that just hold information.
    We might want to represent a message sent over a network, or a row from a table
    in a database, for example. Types designed for this are sometimes referred to
    as *POD types*, where POD stands for plain old data. We might try to do this by
    writing a class containing nothing but public fields, as [Example 3-8](#pod_all_public_fields)
    shows.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管封装是软件开发中管理复杂性的强大工具，有时仅使用保存信息的类型可能也很有用。例如，我们可能希望表示通过网络发送的消息，或者数据库中表中的一行。专为此设计的类型有时被称为*POD类型*，其中POD代表简单旧数据。我们可以尝试通过编写一个只包含公共字段的类来实现这一点，正如[示例 3-8](#pod_all_public_fields)所示。
- en: Example 3-8\. Plain old data, using public fields
  id: totrans-51
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-8\. 简单旧数据，使用公共字段
- en: '[PRE9]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Some developers will recoil in horror at the lack of encapsulation here. There’s
    nothing to stop anyone from reaching into a `Person` instance and just changing
    the fields—oh, the humanity! In a type that was doing anything more than just
    holding some data, that could indeed cause problems. The type’s methods might
    contain code that relies on those fields being used in particular ways, and the
    problem with making fields public is that anything could change them, making it
    hard to know what state they will be in. But this type has no code—its only job
    is to hold some data, so this won’t be the end of the world. That said, this example
    has created a problem: these fields contain strings, but I’ve had to put a `?`
    after the type name. This signifies the fact that these fields might contain the
    special value `null`. If I don’t add those `?` qualifiers, the compiler will issue
    a warning telling me that I’ve done nothing to ensure that these fields are suitably
    initialized, and so I shouldn’t go around claiming that they are definitely going
    to contain strings. If I wanted to require that these fields always have non-null
    values, I’d need to take control of how the type is initialized, which I can do
    by writing a *constructor*. I’ll be describing these in more detail later in the
    chapter, but [Example 3-9](#ctor_enforcing_field_initialization) shows a simple
    example that ensures that the fields are initialized, enabling us to remove the
    `?` qualifiers.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这里可能会有些开发人员对缺乏封装性感到恐惧。没有阻止任何人直接访问`Person`实例并改变字段的方法——哦，天哪！在做任何不仅仅是保存一些数据的类型时，这确实可能会引发问题。类型的方法可能包含依赖于这些字段以特定方式使用的代码，而将字段公开的问题在于任何东西都可能改变它们，使得难以知道它们将处于什么状态。但是这种类型没有代码——它的唯一工作就是保存一些数据，所以这并不会是世界末日。话虽如此，这个例子确实带来了一个问题：这些字段包含字符串，但我必须在类型名称后面加上一个`?`。这表示这些字段可能包含特殊值`null`。如果我不添加这些`?`修饰符，编译器会警告我，告诉我没有做任何事情来确保这些字段被适当初始化，因此我不应该声称它们肯定包含字符串。如果我想要确保这些字段始终具有非空值，我需要控制类型如何初始化，这可以通过编写*构造函数*来实现。稍后在本章节中我会更详细地描述这些内容，但是[示例 3-9](#ctor_enforcing_field_initialization)
    展示了一个简单的示例，确保这些字段被初始化，使我们能够移除`?`修饰符。
- en: Example 3-9\. Enforcing initialization of fields with a constructor
  id: totrans-54
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-9\. 通过构造函数强制初始化字段
- en: '[PRE10]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This is now looking rather verbose. Record types offer a much simpler way to
    write a plain old data type, as [Example 3-10](#record_type_enforcing_initialization)
    shows.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来现在有些啰嗦了。记录类型提供了编写普通数据类型的更简单方式，就像[示例 3-10](#record_type_enforcing_initialization)
    所示。
- en: Example 3-10\. A record type with positional syntax
  id: totrans-57
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-10\. 一种具有位置语法的记录类型
- en: '[PRE11]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[Example 3-11](#using_a_record_type) shows how we can use this record type.
    If we have a variable referring to a `Person`, like the `p` argument in the `ShowPerson`
    method, we can write `p.Name` and `p.FavoriteColor` to access the data it contains,
    just as we would if `Person` were defined as in Examples [3-8](#pod_all_public_fields)
    or [3-9](#ctor_enforcing_field_initialization). (My record type isn’t exactly
    equivalent. Those earlier examples both define public fields, but [Example 3-11](#using_a_record_type)
    is better aligned with normal .NET practice, because it defines `Name` and `FavoriteColor`
    as properties. I’ll be describing properties in more detail later in this chapter.)
    As you can see, we create instances of record types with the `new` keyword, just
    as we do with a class. When a record type is defined in the way [Example 3-10](#record_type_enforcing_initialization)
    shows, we have to pass in all of the properties to the constructor, and in the
    right order. This way of defining a record is called the *positional syntax*.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 3-11](#using_a_record_type) 展示了我们如何使用这种记录类型。如果我们有一个变量指向一个`Person`，比如`ShowPerson`方法中的`p`参数，我们可以写`p.Name`和`p.FavoriteColor`来访问它包含的数据，就像在示例
    [3-8](#pod_all_public_fields) 或 [3-9](#ctor_enforcing_field_initialization) 中定义`Person`一样。（我的记录类型并非完全等价。之前的示例都定义了公共字段，但是[示例 3-11](#using_a_record_type)
    更符合正常的 .NET 实践，因为它将`Name`和`FavoriteColor`定义为属性。我稍后在本章节将更详细地描述属性。）如您所见，我们使用`new`关键字创建记录类型的实例，就像创建类一样。当记录类型定义方式如[示例 3-10](#record_type_enforcing_initialization)
    所示时，我们必须按正确的顺序将所有属性传递给构造函数。这种定义记录的方式称为*位置语法*。'
- en: Example 3-11\. Using a record type
  id: totrans-60
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-11\. 使用记录类型
- en: '[PRE12]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'When you use the syntax in [Example 3-10](#record_type_enforcing_initialization),
    the resulting record type is immutable: if you wrote code that tried to modify
    either of the properties of an existing `Person`, the compiler would report an
    error. Immutable data types can make it much easier to analyze code, especially
    multithreaded code, because you can count on them not to change under your feet.
    This is one of the reasons strings are immutable in .NET. However, before record
    types were introduced, immutable custom types have typically been inconvenient
    to work with in C#. For example, if you need to produce some new value that is
    a modified version of an existing value, you can be in for a lot of tedious work.
    Whereas the built-in `string` type provides numerous methods for producing new
    strings built out of existing strings (e.g., substrings, or conversions to lower-
    or uppercase), you’re on your own when you write a class.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用[示例 3-10](#record_type_enforcing_initialization)中的语法时，生成的记录类型是不可变的：如果您编写了试图修改现有`Person`的任一属性的代码，编译器将报告错误。不可变数据类型可以使代码分析变得更加容易，尤其是多线程代码，因为您可以确保它们在您脚下不会改变。这也是
    .NET 中字符串不可变的原因之一。然而，在引入记录类型之前，在 C# 中使用不可变自定义类型通常是不方便的。例如，如果您需要生成某个新值，它是现有值的修改版本，那么您可能需要进行大量乏味的工作。而内置的`string`类型提供了许多方法来生成由现有字符串构建的新字符串（例如子字符串，或转换为小写或大写），而在编写类时，您就需要自己实现这些方法。
- en: For example, suppose you are writing an application in which you’ve defined
    a data type representing the state of someone’s payment account at a particular
    moment in time. If you define this as an immutable type, then when processing
    a new transaction, you will need to make a copy that’s identical except for the
    current balance. Historically, doing this in C# meant you ended up needing to
    write code to copy over any unchanged data when creating the new instance. The
    main purpose of record types is to make it much easier to define and use immutable
    data types, so they offer an easy way to create a copy of an existing instance
    but with certain properties modified. As [Example 3-12](#modified_copy_of_record_type)
    shows, you can write `with` after a record expression, followed by a brace-delimited
    list of the properties you’d like to change.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设您正在编写一个应用程序，其中定义了一种数据类型，表示某人在特定时间点的支付账户状态。如果将其定义为不可变类型，则在处理新交易时，您需要创建一个除当前余额外完全相同的副本。在
    C# 中，以往的做法意味着在创建新实例时需要编写代码来复制任何未更改的数据。记录类型的主要目的之一是更容易地定义和使用不可变数据类型，因此它们提供了一种简便的方法来创建具有某些属性修改的现有实例的副本，正如[示例
    3-12](#modified_copy_of_record_type)所示，您可以在记录表达式之后写上`with`，然后是一对大括号括起来的您想要更改的属性列表。
- en: Example 3-12\. Making a modified copy of an immutable record
  id: totrans-64
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-12\. 创建一个不可变记录的修改副本
- en: '[PRE13]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In this particular case, our type has only two properties, so this isn’t dramatically
    better than just writing `new Person(startingRecord.Name, "Green")`. However,
    for records with larger numbers of properties, this syntax is much more convenient
    than rebuilding the whole thing every time.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种特定情况下，我们的类型只有两个属性，所以与仅写`new Person(startingRecord.Name, "Green")`相比，并没有显著的改进。然而，对于具有更多属性的记录而言，这种语法比每次重新构建整个对象要方便得多。
- en: While records make it much easier to create and use immutable data types, they
    don’t have to be immutable. [Example 3-13](#mutable_record_type) shows a `Person`
    record in which the properties can be modified after construction. (The `{ get;
    set; }` syntax indicates that these are auto-implemented properties. I’ll be describing
    them in more detail later, but they are essentially just simple read/write properties.)
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然记录类型使得创建和使用不可变数据类型变得更加容易，但它们并不一定非要是不可变的。如[示例 3-13](#mutable_record_type)所示，`Person`记录允许在构建后修改属性。（`{
    get; set; }`语法表示这些是自动实现的属性。我稍后会更详细地描述它们，但它们基本上只是简单的读/写属性。）
- en: Example 3-13\. A record type with modifiable properties
  id: totrans-68
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-13\. 具有可修改属性的记录类型
- en: '[PRE14]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: At this point, we’re very nearly back to what we had in [Example 3-9](#ctor_enforcing_field_initialization),
    with the only difference being that `Name` and `FavoriteColor` are now properties
    instead of fields. We could just replace the `record` keyword in this example
    with `class` and it would still compile. So what exactly changes when we make
    this a `record`?
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们几乎回到了[示例 3-9](#ctor_enforcing_field_initialization)中的情况，唯一的区别是`Name`和`FavoriteColor`现在是属性而不是字段。在这个示例中，我们只需将`record`关键字替换为`class`，代码仍然可以编译。那么，当我们将其定义为`record`时究竟发生了什么呢？
- en: Although the primary purpose of records is to make it easy to build immutable
    data types, the `record` keyword also adds a couple of useful features. In addition
    to the `with` syntax for building modified copies, records get built-in support
    for equality testing and a `ToString` implementation that reports all of the property
    values. The equality testing enables you to use the `==` operator to compare two
    records, and as long as all their properties have the same values, they are considered
    to be equal. The same functionality is available through the `Equals` method.
    All types provide an `Equals` method (which I’ll describe in more detail later),
    and records arrange for this method to provide value-based comparison. You might
    wonder why record types are special in this regard—wouldn’t `Equals` work the
    same way for all types? Not so. Look at [Example 3-14](#comparing_instances).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管记录的主要目的是简化构建不可变数据类型，`record`关键字还增加了一些有用的特性。除了用于构建修改副本的`with`语法外，记录还获得了内置的相等性测试支持和一个`ToString`实现，该实现报告所有属性值。相等性测试使您能够使用`==`运算符比较两个记录，只要它们的所有属性值相同，它们就被视为相等。通过`Equals`方法也可以实现相同的功能。所有类型都提供一个`Equals`方法（稍后我会更详细地描述），记录安排了这个方法来提供基于值的比较。您可能想知道为什么记录类型在这方面是特殊的——`Equals`对所有类型都起作用吗？并非如此。看看[示例 3-14](#comparing_instances)。
- en: Example 3-14\. Comparing two instances of a type
  id: totrans-72
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-14\. 比较两个类型的实例
- en: '[PRE15]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'If you run this against any of the `Person` types defined in earlier examples
    as a `record` type, it will display the text `Equal`. However, if you were to
    use the definition of `Person` in [Example 3-9](#ctor_enforcing_field_initialization)
    (which defines it as a `class`), this will not display that message. Even though
    all the properties have the same value, `Equals` will report that they are not
    equal in that case. That’s because the default comparison behavior for classes
    is identity based: two variables are equal only if they refer to the very same
    object. When variables refer to two different objects, then even if those objects
    are of exactly the same type and have all the same property and field values,
    they are still distinct, and `Equals` reflects that. You can change this behavior
    when you write a class, but you have to write your own `Equals` method. With `record`,
    the compiler generates that for you.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您对早期示例中定义的任何`Person`类型之一运行此代码，作为`record`类型，它将显示文本`Equal`。但是，如果您使用[示例 3-9](#ctor_enforcing_field_initialization)中`Person`的定义（它定义为`class`），则不会显示该消息。即使所有属性都具有相同的值，`Equals`也会报告它们在这种情况下不相等。这是因为类的默认比较行为是基于标识的：只有当两个变量引用完全相同的对象时它们才相等。当变量引用两个不同的对象时，即使这些对象具有完全相同的类型和所有相同的属性和字段值，它们仍然是不同的，`Equals`反映了这一点。您可以在编写类时更改此行为，但必须编写自己的`Equals`方法。对于`record`，编译器会为您生成这个方法。
- en: The other behavior `record` gives you is a specialized `ToString` implementation.
    All types in .NET offer a `ToString` method, and you can call this either directly
    or through some mechanism that invokes it implicitly, such as string interpolation.
    In types that don’t provide their own `ToString`, the default implementation just
    returns the type name, so if you call `ToString` on the class defined in [Example 3-9](#ctor_enforcing_field_initialization),
    it will always return `"Person"`, no matter what value the members have. Types
    are free to supply their own `ToString`, and the compiler does this for you for
    any record type. So if you call `ToString` on either of the `Person` instances
    created in [Example 3-14](#comparing_instances), it will return `"Person { Name
    = Ian, FavoriteColor = Blue }"`.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 记录还提供的另一种行为是专门的`ToString`实现。.NET中的所有类型都提供`ToString`方法，您可以直接调用它，也可以通过某些隐式调用它的机制，比如字符串插值。对于不提供自己的`ToString`的类型，默认实现只是返回类型名称，因此如果您在[示例 3-9](#ctor_enforcing_field_initialization)中定义的类上调用`ToString`，它将始终返回`"Person"`，无论成员的值是什么。类型可以提供自己的`ToString`，编译器会为任何记录类型为您执行此操作。因此，如果您在[示例 3-14](#comparing_instances)中创建的任何一个`Person`实例上调用`ToString`，它将返回`"Person
    { Name = Ian, FavoriteColor = Blue }"`。
- en: You can define records with properties whose types are also record types. [Example 3-15](#nested_records)
    defines a `Person` record type, and also a `Relation` record type to indicate
    some way in which two people are related.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以定义具有其类型也是记录类型的属性的记录。[示例 3-15](#nested_records)定义了一个`Person`记录类型，还定义了一个`Relation`记录类型，用于指示两个人之间的某种关系。
- en: Example 3-15\. Nested record types
  id: totrans-77
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-15\. 嵌套记录类型
- en: '[PRE16]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: When you have this sort of composite structure—records within records—both `Equals`
    and `ToString` traverse into nested records. [Example 3-16](#using_nested_records)
    demonstrates this.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 当你有这种复合结构——记录内部的记录——`Equals` 和 `ToString` 都会遍历到嵌套记录中。[示例 3-16](#using_nested_records)演示了这一点。
- en: Example 3-16\. Using nested record types
  id: totrans-80
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-16\. 使用嵌套记录类型
- en: '[PRE17]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Running this produces the following output (with lines split up to fit on the
    page):'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此示例将产生以下输出（为了适应页面而将行拆分）：
- en: '[PRE18]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: As you can see, the `Relation` type’s `ToString` has shown all of the properties
    of each of its nested `Person` records (and also the `RelationshipType` property,
    which is just a plain `string`). Likewise, the comparison logic works for nested
    records. Nothing special is happening here—a record type compares each property
    in turn by calling `Equals` on its value for that property, passing in the corresponding
    property from the record with which it is being compared. So when it happens to
    reach a record-type property, it calls its `Equals` method just as it would any
    other property, at which point that record type’s own `Equals` implementation
    will execute, comparing each nested property in turn.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，`Relation` 类型的 `ToString` 方法展示了每个嵌套 `Person` 记录的所有属性（以及 `RelationshipType`
    属性，它只是一个普通的 `string`）。同样，比较逻辑也适用于嵌套记录。 这里没有什么特别的情况——记录类型逐个属性进行比较，通过对比每个属性的值调用该属性的
    `Equals` 方法，传递与其比较的记录相应的属性。因此，当它碰巧到达记录类型属性时，它会像对待任何其他属性一样调用其 `Equals` 方法，在这一点上，该记录类型自己的
    `Equals` 实现将执行，逐个比较每个嵌套属性。
- en: None of the `record` keyword features I’ve described do anything you couldn’t
    have done by hand. It would be tedious but uncomplicated to write equivalent implementations
    of `ToString` and `Equals` by hand. (The compiler also provides implementations
    of the `==` and `!=` operators and methods called `GetHashCode` and `Deconstruct`
    that I’ll be describing later. But you could write all of those by hand too.)
    And as far as the .NET runtime is concerned, there’s nothing special about record
    types—it just sees them as ordinary classes.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我描述的 `record` 关键字的特性，你都可以手动实现。编写相应的 `ToString` 和 `Equals` 的等效实现虽然很繁琐，但并不复杂。
    （编译器还提供了 `==` 和 `!=` 操作符的实现以及名为 `GetHashCode` 和 `Deconstruct` 的方法，稍后我将描述这些方法。但你也可以手动编写所有这些内容。）就
    .NET 运行时而言，记录类型没有什么特别之处——它只是将它们视为普通类。
- en: Record types are a language-level feature. The C# compiler generates these types
    in such a way that it can recognize when types in external libraries were declared
    as records,^([1](ch03.xhtml#idm45884853473568)) but they are essentially just
    classes for which the compiler generates a few extra members. In fact, you can
    be explicit about this by declaring the type as `record class` instead of just
    `record`—these two syntaxes are equivalent.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 记录类型是一种语言级别的特性。 C# 编译器以这种方式生成这些类型，以便它可以识别外部库中声明为记录的类型，^([1](ch03.xhtml#idm45884853473568))
    但它们本质上只是编译器为其生成了一些额外成员的类。 实际上，你可以通过将类型声明为 `record class` 而不仅仅是 `record` 来明确此点——这两种语法是等效的。
- en: References and Nulls
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引用和空值
- en: Any type defined with the `class` keyword will be a *reference type* (as will
    any type declared as `record`, or the equivalent `record class`). A variable of
    any reference type will not contain the data that makes up an instance of the
    type; instead, it can contain a *reference* to an instance of the type. Consequently,
    assignments don’t copy the object; they just copy the reference. [Example 3-17](#copying_references)
    contains almost the same code as [Example 3-2](#using_a_custom_class), except
    instead of using the `new` keyword to initialize the `c2` variable, it initializes
    it with a copy of `c1`.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `class` 关键字定义的任何类型都将是*引用类型*（同样适用于声明为 `record` 或等效的 `record class`）。任何引用类型的变量都不会包含构成类型实例的数据；相反，它可以包含对类型实例的*引用*。因此，赋值操作不会复制对象，只会复制引用。[示例 3-17](#copying_references)几乎包含与
    [示例 3-2](#using_a_custom_class) 相同的代码，但是不是使用 `new` 关键字初始化 `c2` 变量，而是用 `c1` 的副本初始化它。
- en: Example 3-17\. Copying references
  id: totrans-89
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-17\. 复制引用
- en: '[PRE19]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Because this example uses `new` just once, there is only one `Counter` instance,
    and the two variables both refer to this same instance. So we get different output:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 因为此示例仅使用了一次 `new`，所以只有一个 `Counter` 实例，并且两个变量都引用同一个实例。因此，我们得到不同的输出：
- en: '[PRE20]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: It’s not just locals that do this—if you use a reference type for any other
    kind of variable, such as a field or property, assignment works the same way,
    copying the reference and not the whole object. This is the defining characteristic
    of a reference type, and it is different from the behavior we saw with the built-in
    numeric types in [Chapter 2](ch02.xhtml#ch_basic_coding). With those, each variable
    contains a value, not a reference to a value, so assignment necessarily involves
    copying the value. (This value-copying behavior is not available for most reference
    types—see the next sidebar, [“Copying Instances”](#copying_instances).)
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅是局部变量会这样—如果您为任何其他类型的变量使用引用类型，例如字段或属性，赋值方式也是相同的，复制的是引用而不是整个对象。这是引用类型的定义特征，与我们在
    [第2章](ch02.xhtml#ch_basic_coding) 中看到的内置数值类型的行为不同。对于内置数值类型，每个变量包含一个值而不是值的引用，因此赋值必然涉及到复制该值。（这种值复制行为对于大多数引用类型是不可用的—请参见下一个侧边栏，“复制实例”。）
- en: We can write code that detects whether two references refer to the same thing.
    [Example 3-18](#comparing_references) arranges for three variables to refer to
    two counters with the same count, and then compares their identities. By default,
    the `==` operator does exactly this sort of object identity comparison when its
    operands are reference types. However, types are allowed to redefine the `==`
    operator. The `string` type changes `==` to perform value comparisons, so if you
    pass two distinct string objects as the operands of `==`, the result will be true
    if they contain identical text. If you want to force comparison of object identity,
    you can use the static `object.ReferenceEquals` method.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以编写代码来检测两个引用是否指向同一个东西。 [示例 3-18](#comparing_references) 安排了三个变量引用两个具有相同计数的计数器，然后比较它们的标识。默认情况下，当其操作数为引用类型时，`==`
    运算符确实执行这种对象标识比较。然而，类型允许重新定义 `==` 运算符。 `string` 类型更改 `==` 以执行值比较，因此如果将两个不同的字符串对象作为
    `==` 的操作数传递，如果它们包含相同的文本，则结果将为真。如果要强制进行对象标识比较，可以使用静态的 `object.ReferenceEquals`
    方法。
- en: Example 3-18\. Comparing references
  id: totrans-95
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-18\. 比较引用
- en: '[PRE21]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The first three lines of output confirm that all three variables refer to counters
    with the same count:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 输出的前三行证实了所有三个变量都引用具有相同计数的计数器：
- en: '[PRE22]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: It also illustrates that while they all have the same count, only `c1` and `c2`
    are considered to be the same thing. That’s because we assigned `c1` into `c2`,
    meaning that `c1` and `c2` will both refer to the same object, which is why the
    first comparison succeeds. But `c3` refers to a different object entirely (even
    though it happens to have the same value), which is why the second comparison
    fails. (I’ve used both the `==` and `object.ReferenceEquals` comparisons here
    to illustrate that they do the same thing in this case, because `Counter` has
    not defined a custom meaning for `==`.)
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 它还说明了，尽管它们都有相同的计数，只有 `c1` 和 `c2` 被认为是同一件事。这是因为我们将 `c1` 赋值给了 `c2`，这意味着 `c1` 和
    `c2` 都将引用同一个对象，这就是为什么第一个比较成功的原因。但是 `c3` 引用的是完全不同的对象（即使它恰好具有相同的值），这就是第二个比较失败的原因。（我在这里同时使用了
    `==` 和 `object.ReferenceEquals` 比较来说明它们在这种情况下是一样的，因为 `Counter` 没有定义 `==` 的自定义含义。）
- en: We could try the same thing with `int` instead of a `Counter`, as [Example 3-19](#comparing_values)
    shows. (This initializes the variables in a slightly idiosyncratic way in order
    to resemble [Example 3-18](#comparing_references) as closely as possible.)
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以尝试用 `int` 而不是 `Counter` 做同样的事情，正如 [示例 3-19](#comparing_values) 所示。（这样做是为了尽可能地模仿
    [示例 3-18](#comparing_references) 的初始化变量方式。）
- en: Example 3-19\. Comparing values
  id: totrans-101
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-19\. 比较值
- en: '[PRE23]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'As before, we can see that all three variables have the same value:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前一样，我们可以看到所有三个变量具有相同的值：
- en: '[PRE24]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This also illustrates that the `int` type defines a special meaning for `==`.
    With `int`, this operator compares the values, so those three comparisons succeed.
    But `obj⁠ect.​Ref⁠ere⁠nce⁠Equ⁠als` never succeeds for value types—in fact, I’ve
    added an extra, fourth comparison here, where I compare `c1` with itself, and
    even that fails! That surprising result occurs because it’s not meaningful to
    perform a reference comparison with `int`—it’s not a reference type. The compiler
    has to perform implicit conversions from `int` to `object` for the last four lines
    of [Example 3-19](#comparing_values): it has wrapped each argument to `object.ReferenceEquals`
    in something called a *box*, which we’ll be looking at in [Chapter 7](ch07.xhtml#ch_object_lifetime).
    Each argument gets a distinct box, which is why even the final comparison fails.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这也说明了`int`类型为`==`定义了一种特殊含义。对于`int`，此运算符比较值，因此这三个比较都成功了。但对于值类型，`object.ReferenceEquals`永远不会对值类型成功—事实上，在这里我添加了一个额外的第四个比较，将`c1`与自身进行比较，甚至那个也失败了！这个令人惊讶的结果是因为使用`int`进行引用比较是没有意义的—它不是引用类型。编译器必须对[示例
    3-19](#comparing_values)中的最后四行执行从`int`到`object`的隐式转换：它对`object.ReferenceEquals`的每个参数进行了称为*装箱*的操作，我们将在[第
    7 章](ch07.xhtml#ch_object_lifetime)中详细讨论这一点。每个参数都获得了一个独立的装箱，这就是为什么即使最后的比较也失败的原因。
- en: There’s another difference between reference types and types like `int`. By
    default, any reference type variable can contain a special value, `null`, meaning
    that the variable does not refer to any object at all. You cannot assign this
    value into any of the built-in numeric types (although see the next sidebar, [“Nullable<T>”](#nullableless_thantgreater_than)).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 引用类型和`int`等类型之间还有另一个区别。默认情况下，任何引用类型变量都可以包含特殊值`null`，这意味着变量根本不引用任何对象。您无法将此值分配给任何内置数值类型（尽管请参见下一侧边栏，“`Nullable<T>`”）。
- en: Banishing Null with Non-Nullable References
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用非可空引用消除空值
- en: The widespread availability of null references in programming languages dates
    back to 1965, when computer scientist Tony Hoare added them to the highly influential
    ALGOL language. He has since apologized for this invention, which he described
    as his “billion-dollar mistake.” The possibility that a reference type variable
    might contain `null` makes it hard to know whether it’s safe to attempt to perform
    an action with that variable. (C# programs will throw a `NullReferenceException`
    if you attempt this, which will typically crash your program. [Chapter 8](ch08.xhtml#ch_exceptions)
    discusses exceptions.) Some modern programming languages avoid the practice of
    allowing references to be nullable by default, offering instead some system for
    optional values through an explicit opt-in mechanism in the type system. In fact,
    as you’ve seen with `Nullable<T>`, this is already the case for built-in numeric
    types (and also, as we’ll see, any custom value types that you define), but until
    recently, nullability has not been optional for all reference type variables.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 程序设计语言中广泛存在空引用的可能性可以追溯到 1965 年，当时计算机科学家 Tony Hoare 将其添加到具有高度影响力的 ALGOL 语言中。他后来为此发明道歉，称这是他的“十亿美元错误”。引用类型变量可能包含`null`的可能性使得难以确定是否安全地尝试使用该变量执行操作。（在
    C# 程序中，如果尝试这样做，将抛出`NullReferenceException`，通常会导致程序崩溃。[第 8 章](ch08.xhtml#ch_exceptions)讨论了异常。）一些现代编程语言通过类型系统中的显式选择性机制，避免了默认允许引用为空的做法，而是提供某种可选值系统。事实上，就像你在`Nullable<T>`中看到的那样，对于内置数值类型（以及我们将看到的任何自定义值类型），这已经是事实，但直到最近，对于所有引用类型变量来说，空性并不是可选的。
- en: 'C# 8.0 introduced a significant new feature to the language that extends the
    type system to make a distinction between references that may be null and ones
    that must not be. Before C# 10.0, this feature was disabled by default, but now
    when you create a new project, it will be enabled. The feature’s name is *nullable
    references*, which seems odd, because references have been able to contain `null`
    since C# 1.0\. However, this name refers to the fact that with this feature enabled,
    nullability becomes an opt-in feature: a reference will never contain `null` unless
    it is explicitly defined as a nullable reference. At least, that’s the theory.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: C# 8.0 引入了一个重要的新功能，可以扩展语言的类型系统，以区分可能为空的引用和不得为空的引用。在 C# 10.0 之前，默认情况下此功能是禁用的，但现在创建新项目时将启用此功能。这个功能被称为*可空引用*，这个名字似乎有些奇怪，因为自
    C# 1.0 起引用就能包含`null`。然而，这个名字指的是启用此功能后，空引用成为一种选择性功能：一个引用不会包含`null`，除非明确定义为可空引用。至少，这是理论上的说法。
- en: Warning
  id: totrans-110
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: Enabling the type system to distinguish between nullable and non-nullable references
    was always going to be a tricky thing to retrofit to a language almost two decades
    into its life. So the reality is that C# cannot always guarantee that a non-nullable
    reference will never contain a `null`. However, it can make the guarantee if certain
    constraints hold, and more generally it will significantly reduce the chances
    of encountering a `NullReferenceException` even in cases where it cannot absolutely
    rule this out.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 让类型系统能够区分可空和非可空引用始终是一件棘手的事情，特别是在语言已有近二十年历史的情况下。因此，事实上 C# 不能始终保证非可空引用永远不会包含 `null`。然而，如果满足某些约束条件，它可以做出这种保证，而且更一般地说，即使在无法绝对排除这种情况的情况下，它也将显著减少遇到
    `NullReferenceException` 的机会。
- en: Enabling non-nullability is a radical change, which is why the feature was,
    until recently, switched off until you enabled it explicitly. (Even now, the change
    with C# 10.0 is that newly created *.csproj* files include the setting that turns
    this feature on. Without that setting, the feature continues to be off by default.)
    Switching it on can have a dramatic impact on existing code, so it is possible
    to control the feature at a fine-grained level to enable a gradual transition
    between the old world and the new nullable-references-aware world.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 启用非空性是一项重大变革，这也是为什么直到最近，该功能默认情况下是关闭的，直到您明确启用它为止。（即使现在，使用 C# 10.0，新创建的 *.csproj*
    文件包含打开此功能的设置。没有该设置，该功能仍然默认关闭。）打开它可能会对现有代码产生显著影响，因此可以在更细粒度的级别控制此功能，以在旧世界和新的可空引用感知世界之间实现渐进过渡。
- en: C# provides two dimensions of control, which it calls the *nullable annotation
    context* and the *nullable warning context*. Each line of code in a C# program
    is associated with one of each kind of context. The default is that all your code
    is in a *disabled* nullable annotation context and a *disabled* nullable warning
    context. You can change these defaults at a project level (and a newly created
    C# 10.0 project will do that). You can also use the `#nullable` directive to change
    either of the nullable annotation contexts at a more fine-grained level—a different
    one every line if you want. So how do these two contexts work?
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: C# 提供了两个控制维度，它称之为*可空注解上下文*和*可空警告上下文*。C# 程序中的每行代码都与这两种上下文中的一种相关联。默认情况下，所有代码都处于*禁用*的可空注解上下文和*禁用*的可空警告上下文中。您可以在项目级别更改这些默认设置（新创建的
    C# 10.0 项目将会这样做）。您还可以使用 `#nullable` 指令在更精细的级别更改任一可空注解上下文，如果需要的话，甚至可以每行代码都不同。那么这两个上下文是如何工作的呢？
- en: The nullable annotation context determines whether we get to declare the nullability
    of a particular variable that uses a reference type. (I’m using C#’s broader definition
    of *variable* here, which includes not just local variables but also fields, parameters,
    and properties.) In a disabled annotation context (the default), we cannot express
    this, and all references are implicitly nullable. The official categorization
    describes these as *oblivious* to nullability, distinguishing them from references
    you have deliberately annotated as being nullable. However, in an enabled annotation
    context, we get to choose. [Example 3-20](#specifying_nullability) shows how.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 可空注解上下文确定我们是否可以声明使用引用类型的特定变量的可空性。（我在这里使用 C# 更广泛的*变量*定义，不仅包括局部变量，还包括字段、参数和属性。）在禁用的注解上下文中（默认情况下），我们无法表达这一点，所有引用都被隐式地视为可空。官方分类将这些描述为对空性*无视*，将其与您故意注释为可空的引用区分开来。然而，在启用的注解上下文中，我们可以选择。[示例 3-20](#specifying_nullability)
    展示了如何实现这一点。
- en: Example 3-20\. Specifying nullability
  id: totrans-115
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-20\. 指定可空性
- en: '[PRE25]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This mirrors the syntax for nullability of built-in numeric types and custom
    value types. If you just write the type name, that denotes something non-nullable.
    If you want it to be nullable, you append a `?`.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这与内置数值类型和自定义值类型的空值语法相呼应。如果您只写类型名称，则表示非可空。如果您希望其可空，则附加一个 `?`。
- en: The most important point to notice here is that in an enabled nullable annotation
    context, the old syntax gets the new behavior, and if you want the old behavior,
    you need to use the new syntax. This means that if you take existing code originally
    written without any awareness of nullability, and you put it into an enabled annotation
    context, *all* reference type variables are now effectively annotated as being
    non-nullable, the opposite of how the compiler treated the exact same code before.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这里最重要的一点是，在启用的可空注解上下文中，旧语法将获得新行为，如果您需要旧行为，则需要使用新语法。这意味着，如果您将原本没有任何空值感知的现有代码放入启用的注解上下文中，*所有*
    引用类型变量现在实际上被标注为非可空，这与编译器在之前对完全相同代码的处理方式相反。
- en: The most direct way to put code into an enabled nullable annotation context
    is with a `#nullable enable annotations` directive. You can put this at the top
    of a source file to enable it for the whole file, or you can use it more locally,
    followed by a `#nullable restore annotations` to put back the project-wide default.
    On its own this will produce no visible change. The compiler won’t act on these
    annotations if the nullable warning context is disabled, and it is disabled by
    default. You can enable it locally with `#nullable enable warnings` (and `#nullable
    restore warnings` reverts to the project-wide default). You can control the project-wide
    defaults in the *.csproj* file by adding a `<Nullable>` property. [Example 3-21](#enabling_nullable_warnings_in_csproj)
    sets the defaults to an enabled nullable warning context and an enabled nullable
    annotation context. You will find a setting like this in any newly created C#
    10.0 project (whether created from Visual Studio or using the `dotnet new` at
    the command line).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 将代码放入启用的可空注解上下文的最直接方式是使用 `#nullable enable annotations` 指令。您可以将其放在源文件的顶部以启用整个文件，或者可以更局部地使用它，然后跟随
    `#nullable restore annotations` 来恢复项目范围的默认设置。单独使用此指令不会产生任何可见变化。如果禁用了可空警告上下文（默认情况下是禁用的），编译器不会对这些注解进行处理。您可以使用
    `#nullable enable warnings` 在本地启用它（`#nullable restore warnings` 可以恢复为项目范围的默认设置）。您可以通过在
    *.csproj* 文件中添加 `<Nullable>` 属性来控制项目范围的默认设置。[示例 3-21](#enabling_nullable_warnings_in_csproj)
    将默认设置为启用的可空警告上下文和启用的可空注解上下文。您将在任何新创建的 C# 10.0 项目中找到此类设置（无论是从 Visual Studio 创建还是使用命令行的
    `dotnet new`）。
- en: Example 3-21\. Specifying enabled nullable warning and annotation contexts as
    the project-wide default
  id: totrans-120
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例   示例 3-21\. 指定作为项目范围默认启用的可空警告和注解上下文
- en: '[PRE26]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This means that all code will be in an enabled nullable warning context and
    also in an enabled nullable annotation context unless it explicitly opts out.
    Other project-wide settings are `disable` (which has the same effect as not setting
    `<Nullable>` at all), `warnings` (enables warnings but not annotations), and `annotations`
    (enables annotations but not warnings).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着所有代码将位于启用的可空警告上下文和启用的可空注解上下文中，除非明确选择退出。其他项目范围的设置包括 `disable`（与不设置 `<Nullable>`
    具有相同效果）、`warnings`（启用警告但不启用注解）和 `annotations`（启用注解但不启用警告）。
- en: If you’ve specified an enabled annotation context at the project level, you
    can use `#nullable disable annotations` to opt out in individual files. Likewise,
    if you’ve specified an enabled warning context at the project level, you can opt
    out with `#nullable disable warnings`.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在项目级别指定了启用的注解上下文，可以使用 `#nullable disable annotations` 来在单个文件中退出。同样，如果您在项目级别指定了启用的警告上下文，可以使用
    `#nullable disable warnings` 来退出。
- en: We have all this fine-grained control to make it easier to enable non-nullability
    for existing code. If you just fully enable the feature for an entire project
    in one step, you’re likely to encounter a lot of warnings. In practice, it may
    make more sense to put all code in the project in an enabled warning context but
    not to enable annotations anywhere to begin with. Since all of your references
    will be deemed *oblivious* to nullability checking, the only warnings you’ll see
    will relate to use of libraries. And any warnings at this stage are quite likely
    to be indicative of potential problems, e.g., missing tests for null. Once you’ve
    addressed these, you can start to move your own code into an enabled annotation
    context one file at a time (or in even smaller chunks if you prefer), making any
    necessary changes.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们拥有这些精细的控制功能，使得在现有代码中启用非空性变得更加容易。如果你一步到位地为整个项目完全启用了这一功能，可能会遇到大量警告。实际操作中，更有意义的做法可能是将项目中所有代码放在启用警告的上下文中，但不要一开始就启用任何注解。因为你的所有引用都将对空值检查视而不见，你所看到的唯一警告将与库的使用有关。在这个阶段，任何警告很可能都表明存在潜在问题，例如，缺少空值的测试。一旦解决了这些问题，你可以开始逐个文件（或者更小的块，如果你喜欢的话）将自己的代码移到启用注解的上下文中，并进行必要的更改。
- en: Over time, the goal would be to get all the code to the point where you can
    fully enable non-nullable support at the project level. And for newly created
    projects, it is usually best to have nullable references enabled from the start
    so that you can prevent problematic null handling ever getting into your code—that’s
    why new projects have this feature enabled.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 随着时间的推移，目标是使所有代码达到可以在项目级别完全启用非空支持的程度。对于新创建的项目，最好从一开始就启用可空引用，以防止问题的空值处理进入你的代码——这就是为什么新项目默认启用此功能的原因。
- en: What does the compiler do for us in code where we’ve fully enabled non-nullability
    support? We get two main things. First, the compiler uses rules similar to the
    definite assignment rules to ensure that we don’t attempt to dereference a variable
    without first checking to see whether it’s null. [Example 3-22](#dereferencing_nullable_reference)
    shows some cases the compiler will accept and some that would cause warnings in
    an enabled nullable warning context, assuming that `mayBeNull` was declared in
    an enabled nullable annotation context as being nullable.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们完全启用了非空性支持的代码中，编译器对我们做了什么？我们主要得到了两个东西。首先，编译器使用类似于确定赋值规则的规则，以确保我们在尝试解引用变量之前先检查它是否为空。[示例 3-22](#dereferencing_nullable_reference)
    展示了一些编译器将接受的情况，以及在启用了可空性警告上下文的情况下会导致警告的情况，假设 `mayBeNull` 在启用了可空性注解上下文中声明为可空。
- en: Example 3-22\. Dereferencing a nullable reference
  id: totrans-127
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-22\. 解引用可空引用
- en: '[PRE27]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Second, in addition to checking whether dereferencing (use of `.` to access
    a member) is safe, the compiler will also warn you when you’ve attempted to assign
    a reference that might be null into something that requires a non-nullable reference,
    or if you pass one as an argument to a method when the corresponding parameter
    is declared as non-nullable.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，除了检查解引用（使用 `.` 访问成员）是否安全外，编译器还会在你尝试将可能为空的引用分配给需要非空引用的位置时发出警告，或者当你将一个可能为 null
    的引用作为参数传递给方法时，该方法的相应参数声明为非空时也会发出警告。
- en: 'Sometimes, you’ll run into a roadblock on the path to moving all your code
    into fully enabled nullability contexts. Perhaps you depend on some component
    that is unlikely to be upgraded with nullability annotations in the foreseeable
    future, or perhaps there’s a scenario in which C#’s conservative safety rules
    incorrectly decide that some code is not safe. What can you do in these cases?
    You wouldn’t want to disable warnings for the entire project, and it would be
    irritating to have to leave the code peppered with `#nullable` directives. And
    while you can prevent warnings by adding explicit checks for `null`, this is undesirable
    in cases where you are confident that they are unnecessary. There is an alternative:
    you can tell the C# compiler that you know something it doesn’t. If you have a
    reference that the compiler presumes could be null but that you have good reason
    to believe will never be null, you can tell the compiler this by using the *null
    forgiving operator*, which you can see near the end of the second line of [Example 3-23](#null_forgiving_operator).
    It is sometimes known informally as the *dammit operator*, because being an exclamation
    mark makes it look like a slightly exasperated kind of assertion.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，在将所有代码移入完全启用的空安全上下文的道路上，您会遇到障碍。也许您依赖于一些组件，这些组件在可预见的将来不太可能被升级为带有空安全注解，或者可能存在一些情况，C#
    的保守安全规则错误地认定某些代码不安全。在这些情况下，您可以怎么做？您不希望为整个项目禁用警告，并且在代码中留下`#nullable`指令将会很烦人。虽然您可以通过添加对`null`的显式检查来防止警告，但在您确信这些检查是不必要的情况下，这种方式并不理想。还有一种替代方案：您可以告诉
    C# 编译器您知道一些它不知道的事情。如果您有一个引用，编译器假定它可能为 null，但您有充分理由相信它永远不会为 null，您可以通过使用*空值宽容运算符*来告知编译器，您可以在[示例 3-23](#null_forgiving_operator)的第二行末尾看到它。它有时被非正式地称为*该死的运算符*，因为它看起来像是一种略带恼怒的断言。
- en: Example 3-23\. The null forgiving operator
  id: totrans-131
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-23\. 空值宽容运算符
- en: '[PRE28]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: You can use the null forgiving operator in any enabled nullable annotation context.
    It has the effect of converting a nullable reference to a non-nullable reference.
    You can then go on to dereference that non-nullable reference or otherwise use
    it in places where a nullable reference would not be allowed without causing any
    compiler warnings.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何启用了可空注解的上下文中，您可以使用空值宽容运算符。它的作用是将可空引用转换为非可空引用。然后，您可以继续对该非可空引用进行解引用或在不允许可空引用的地方使用它，而不会引发任何编译器警告。
- en: Warning
  id: totrans-134
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: The null forgiving operator does not check its input. If you apply this in a
    scenario where the value turns out to be null at runtime, it will not detect this.
    Instead, you will get a runtime error at the point where you try to use the reference.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 空值宽容运算符不会检查其输入。如果您在运行时应用于值为 null 的情况，它将不会检测到这一点。相反，在您尝试使用引用的位置时，将会在运行时出现错误。
- en: 'While the null forgiving operator can be useful at the boundary between nullable-aware
    code and old code that you don’t control, there’s another way to let the compiler
    know when an apparently nullable expression will not in fact be null: nullable
    attributes. .NET defines several attributes that you can use to annotate code
    to describe when it will or won’t return null values. Consider the code in [Example 3-24](#nullability_try_pattern).
    If you do not enable the nullable reference type features, this works fine, but
    if you turn them on, you will get a warning. (This uses a dictionary, a collection
    type that is described in detail in [Chapter 5](ch05.xhtml#ch_collections).)'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然空值宽容运算符在可空感知代码与您无法控制的旧代码之间的边界处很有用，但还有另一种方法可以告诉编译器，明显可为空的表达式实际上不会为 null：可空属性。
    .NET 定义了几个属性，您可以使用它们来注释代码，描述它们何时会或不会返回 null 值。考虑[示例 3-24](#nullability_try_pattern)中的代码。如果您没有启用可空引用类型功能，这将运行正常，但如果您启用它们，您将收到警告。（这使用了一个字典，这是一种在[第
    5 章](ch05.xhtml#ch_collections)中详细描述的集合类型。）
- en: Example 3-24\. Nullability and the Try pattern—before nullable reference types
  id: totrans-137
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-24\. 空安全性与尝试模式——在可空引用类型之前
- en: '[PRE29]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: With nullability fully enabled, the compiler will complain at the `out string
    s`. It will tell you, correctly, that `TryGetValue` might pass a `null` through
    that `out` argument. (This kind of argument is discussed later; it provides a
    way to return additional values besides the function’s main return value.) This
    function checks whether the dictionary contains an entry with the specified key.
    If it does, it will return `true` and put the relevant value into the `out` argument,
    but if not, it returns `false` and sets that `out` argument to `null`. We can
    modify our code to reflect this fact by putting a `?` after the `out string`.
    [Example 3-25](#try_pattern_nullable_aware) shows this modification.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 当完全启用了可空性时，编译器会抱怨 `out string s`。它会正确地告诉你，`TryGetValue` 可能通过 `out` 参数传递 `null`。
    （这种参数稍后会讨论；它提供了一种在主返回值之外返回额外值的方式。）此函数检查字典是否包含指定键的条目。如果有，它将返回 `true` 并将相关值放入 `out`
    参数中，但如果没有，则返回 `false` 并将 `out` 参数设置为 `null`。我们可以修改我们的代码以反映这一事实，方法是在 `out string`
    后面加一个 `?`。[示例 3-25](#try_pattern_nullable_aware) 显示了这个修改。
- en: Example 3-25\. Nullable-aware use of the Try pattern
  id: totrans-140
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-25\. 使用 Try 模式时注意可空性
- en: '[PRE30]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: You might expect this to cause a new problem. Our `Get` method returns a `string`,
    not a `string?`, so how can that `return s` be correct? We just modified our code
    to indicate that `s` might be null, so won’t the compiler complain when we try
    to return this possibly null value from a method that declares that it won’t return
    `null`? But in fact this compiles. The compiler accepts this because it knows
    that `TryGetValue` will only set that `out` argument to `null` if it returns `false`.
    That means that the compiler knows that although the `s` variable’s type is `string?`,
    it will not be `null` inside the body of the `if` statement. It knows this thanks
    to a nullable attribute applied to the `TryGetValue` method’s definition. (Attributes
    are described in [Chapter 14](ch14.xhtml#ch_attributes).) [Example 3-26](#nullable_attribute)
    shows the attribute in the method’s declaration. (This method is part of a generic
    type, which is why we see `TKey` and `TValue` here and not the `int` and `string`
    types I used in my examples. [Chapter 4](ch04.xhtml#ch_generics) discusses this
    kind of method in detail. In the examples at hand, `TKey` and `TValue` are, in
    effect, `int` and `string`.)
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会期待这会带来一个新问题。我们的 `Get` 方法返回一个 `string`，而不是 `string?`，那么 `return s` 怎么可能正确呢？我们刚刚修改了代码以指示
    `s` 可能为 null，那么当我们试图从声明不返回 `null` 的方法中返回这个可能为 null 的值时，编译器难道不会抱怨吗？但事实上，这个是可以编译通过的。编译器接受这个是因为它知道
    `TryGetValue` 只会在返回 `false` 时将 `out` 参数设置为 `null`。这意味着编译器知道虽然 `s` 变量的类型是 `string?`，但在
    `if` 语句体内它不会是 `null`。它知道这一点是因为在 `TryGetValue` 方法的定义中应用了一个可空属性。（属性在[第 14 章](ch14.xhtml#ch_attributes)中描述。）[示例
    3-26](#nullable_attribute) 显示了该方法声明中的属性。（这个方法是泛型类型的一部分，这就是为什么我们看到这里的是 `TKey` 和
    `TValue` 而不是我例子中使用的 `int` 和 `string` 类型。[第 4 章](ch04.xhtml#ch_generics)详细讨论了这种方法。在手头的例子中，`TKey`
    和 `TValue` 实际上是 `int` 和 `string`。）
- en: Example 3-26\. A nullable attribute
  id: totrans-143
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-26\. 可空属性示例
- en: '[PRE31]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This annotation is how C# knows that the value might be `null` if `TryGetValue`
    returns `false` but won’t be if it returns `true`. Without this attribute, [Example 3-24](#nullability_try_pattern)
    would have compiled successfully even with nullable warnings enabled, because
    by writing `IDictionary<int, string>` (and not `IDictionary<int, string?>`) I
    am indicating that my dictionary does not permit null values. So normally, C#
    will assume that when a method returns a value from the dictionary, it will also
    produce a `string`. But `TryGetValue` sometimes has no value to return, which
    is why it needs this annotation. [Table 3-1](#nullable_attributes) describes the
    various attributes you can apply to give the C# compiler more information about
    what may or may not be `null`.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这个注解告诉 C# 如果 `TryGetValue` 返回 `false`，值可能是 `null`，但如果返回 `true`，则不会是 `null`。如果没有这个属性，即使启用了可空警告，[示例
    3-24](#nullability_try_pattern) 也会成功编译，因为我使用 `IDictionary<int, string>` 而不是 `IDictionary<int,
    string?>` 表示我的字典不允许空值。因此，通常情况下，C# 会假设当方法从字典返回值时，它也会产生一个 `string`。但是 `TryGetValue`
    有时没有值可返回，这就是为什么它需要这个注解。[表 3-1](#nullable_attributes) 描述了可以应用的各种属性，以便向 C# 编译器提供有关可能是
    `null` 或不是 `null` 的更多信息。
- en: Table 3-1\. Nullable attributes
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 表 3-1\. 可空属性
- en: '| **Type** | **Usage** |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| **类型** | **用法** |'
- en: '| --- | --- |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `AllowNull` | Code is allowed to supply `null` even when the type is non-nullable.
    |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| `AllowNull` | 即使类型不可空，代码也允许提供 `null`。'
- en: '| `DisallowNull` | Code must not supply `null` even when the type is nullable.
    |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| `DisallowNull` | 即使类型可为空，代码也不能提供 `null`。 |'
- en: '| `MaybeNull` | Code should be prepared for this to return the `null` value
    even when the type is non-nullable. |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| `MaybeNull` | 代码应准备好即使类型为非可空也可能返回 `null` 值。 |'
- en: '| `MaybeNullWhen` | Used only with `out` or `ref` parameters; the output may
    be `null` if the method returns the specified `bool` value. |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| `MaybeNullWhen` | 仅与 `out` 或 `ref` 参数一起使用；如果方法返回指定的 `bool` 值，则输出可能为 `null`。
    |'
- en: '| `NotNull` | Used with parameters. If the method returns without error, the
    argument was not `null`. (With `out` or `ref` parameters, this typically means
    the method makes sure to set them; with an inbound-only parameter, this implies
    the method checks the value and only returns without error if it was not `null`.)
    |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| `NotNull` | 用于参数。如果方法返回而没有错误，则参数不是`null`。（对于带有 `out` 或 `ref` 参数，这通常意味着方法确保设置它们；对于仅入站参数，这意味着方法检查值并且仅在其不是
    `null` 时返回而没有错误。） |'
- en: '| `NotNullWhen` | Used only with `out` or `ref` parameters; the output may
    not be `null` if the method returns the specified `bool` value. |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| `NotNullWhen` | 仅与 `out` 或 `ref` 参数一起使用；如果方法返回指定的 `bool` 值，则输出可能不为 `null`。
    |'
- en: '| `NotNullIfNotNull` | If you pass a non-null value as the argument for the
    parameter that this attribute names, the value returned by this attribute’s target
    will not be `null`. |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '| `NotNullIfNotNull` | 如果将非 `null` 值作为此属性命名的参数的参数传递，则此属性目标返回的值不会为 `null`。 |'
- en: These attributes have been applied where appropriate to most of the .NET runtime
    libraries to reduce the friction involved in adopting nullable references.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这些属性已经适用于大多数 .NET 运行时库，以减少采用可空引用时涉及的摩擦。
- en: 'Moving code into enabled nullable warning and annotation contexts can provide
    a significant boost to code quality. Many developers who migrate existing codebases
    often uncover some latent bugs in the process, thanks to the additional checks
    the compiler performs. However, it is not perfect. There are two holes worth being
    aware of, caused by the fact that nullability was not baked into the type system
    from the start. The first is that legacy code introduces blind spots—even if all
    your code is in an enabled nullable annotation context, if it uses APIs that are
    not, references it obtains from those will be oblivious to nullability. If you
    need to use the null forgiving operator to keep the compiler happy, there’s always
    the possibility that you are mistaken, at which point you’ll end up with a `null`
    in what is supposed to be a non-nullable variable. The second is more vexing in
    that you can hit it in brand-new code, even if you fully enabled this feature
    from the start: certain storage locations in .NET have their memory filled with
    zero values when they are initialized. If these locations are of a reference type,
    they will end up starting out with a `null` value, and there’s currently no way
    that the C# compiler can enforce their non-nullability. Arrays have this issue.
    Look at [Example 3-27](#nullable_arrays).'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 将代码移到已启用的可空警告和注释上下文中可以显著提高代码质量。许多将现有代码库迁移的开发人员通常在此过程中发现一些潜在的错误，这要归功于编译器执行的额外检查。然而，它并非完美。需要注意的是有两个盲点，因为从一开始就没有在类型系统中包含可空性。首先是遗留代码引入的问题，即使您的所有代码都在启用了可空注释上下文中，如果使用的
    API 不是，则从中获取的引用将对可空性视而不见。如果需要使用空值宽容操作符来使编译器满意，那么总有可能出错，到那时您将会在一个应该是非空变量的地方得到一个
    `null`。第二个问题更为恼人，即使您从一开始就完全启用了此功能，某些 .NET 中的存储位置在初始化时会填充零值。如果这些位置是引用类型，则最终将以 `null`
    值开始，目前 C# 编译器无法强制执行其非空性。数组存在此问题。参见 [例子 3-27](#nullable_arrays)。
- en: Example 3-27\. Arrays and nullability
  id: totrans-158
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 例 3-27\. 数组和可空性
- en: '[PRE32]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This code declares two arrays of strings. The first uses `string?`, so it allows
    nullable references. The second does not. However, in .NET you have to create
    arrays before you can put anything in them, and a newly created array’s memory
    is always zero-initialized. This means that our `nonNullableStrings` array will
    start life full of nulls. There is no way to avoid this because of how arrays
    work in .NET. One way to mitigate this problem is to avoid using arrays directly.
    If you use `List<string>` instead (see [Chapter 5](ch05.xhtml#ch_collections)),
    it will contain only items that you have added—unlike an array, a `List<T>` does
    not provide a way to initialize it with empty slots. But you can’t always substitute
    a `List<T>` for an array. Sometimes you will simply need to take care that you
    initialize all the elements in an array.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码声明了两个字符串数组。第一个使用了`string?`，因此允许可空引用。第二个则不允许。然而，在.NET中，您必须先创建数组，然后才能放置任何内容，并且新创建的数组的内存始终是零初始化的。这意味着我们的`nonNullableStrings`数组在初始时会被填满`null`。由于.NET中数组的工作方式，无法避免这一点。减轻这个问题的一种方法是避免直接使用数组。如果使用`List<string>`代替（参见[第5章](ch05.xhtml#ch_collections)），它将仅包含您添加的项
    —— 不像数组，`List<T>`不提供一种初始化它的空槽的方法。但是，并不总是可以用`List<T>`替代数组。有时您只需确保初始化数组的所有元素。
- en: A similar problem exists with fields in value types, which are described in
    the following section. If they have reference type fields, there are situations
    in which you cannot prevent them from being initialized to `null`. So the nullable
    references feature is not perfect. It is nonetheless very useful. Teams that have
    made the necessary changes to existing projects to use it have reported that this
    process tends to uncover many previously undiscovered bugs. It is an important
    tool for improving the quality of your code.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在值类型的字段中存在类似问题，在下一节中进行了描述。如果它们具有引用类型的字段，则存在无法防止其初始化为`null`的情况。因此，可空引用功能并不完美。尽管如此，它仍然非常有用。已经对现有项目进行了必要的更改以使用它的团队报告称，这个过程往往会发现许多以前未发现的错误。这是提高代码质量的重要工具。
- en: Although non-nullable references diminish one of the distinctions between reference
    types and built-in numeric types, important differences remain. A variable of
    type `int` is not a reference to an `int`. It contains the value of the `int`—there
    is no indirection. In some languages, this choice between reference-like and value-like
    behavior is determined by the way in which you use a type, but in C#, it is a
    fixed feature of the type. Any particular type is either a reference type or a
    *value type*. The built-in numeric types are all value types, as is `bool`, whereas
    a `class` is always a reference type. But this is not a distinction between built-in
    and custom types. You can write custom value types.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管非空引用减少了引用类型和内置数值类型之间的某些区别，但仍然存在重要差异。`int`类型的变量不是指向`int`的引用。它包含`int`的值 —— 没有间接引用。在某些语言中，引用类型和值类型的行为选择取决于类型的使用方式，但在C#中，这是类型的固定特性。任何特定类型要么是引用类型，要么是*值类型*。所有内置数值类型都是值类型，如`bool`，而`class`始终是引用类型。但这并不是内置类型和自定义类型之间的区别。您可以编写自定义值类型。
- en: Structs
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结构体
- en: Sometimes it will be appropriate for a custom type to get the same value-like
    behavior as the built-in value types. The most obvious example would be a custom
    numeric type. Although the CLR offers various intrinsic numeric types, some kinds
    of calculations require a bit more structure than these provide. For example,
    many scientific and engineering calculations work with complex numbers. The runtime
    does not define an intrinsic representation for these, but the runtime libraries
    support them with the `Complex` type. It would be unhelpful if a numeric type
    such as this behaved significantly differently from the built-in types. Fortunately,
    it doesn’t, because it is a value type. The way to write a custom value type is
    to use the `struct` keyword instead of `class`.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，对于自定义类型来说，使其具有与内置值类型相同的行为是合适的。最明显的例子是自定义数值类型。虽然CLR提供各种内置数值类型，但某些类型的计算需要比它们提供的更多结构。例如，许多科学和工程计算使用复数。运行时不定义这些的内在表示，但运行时库通过`Complex`类型支持它们。如果像这样的数值类型表现与内置类型显著不同，这将是没有帮助的。幸运的是，它并没有，因为它是一个值类型。编写自定义值类型的方法是使用`struct`关键字，而不是`class`。
- en: 'A struct can have most of the same features as a class; it can contain methods,
    fields, properties, constructors, and any of the other member types supported
    by classes (described in [“Members”](#members)), and we can use the same accessibility
    keywords, such as `public` and `internal`. There are a few restrictions, but with
    the simple `Counter` type I wrote earlier, I *could* just replace the `class`
    keyword with `struct`. However, this would not be a useful transformation. Remember,
    one of the main distinctions between reference types (classes) and value types
    is that the former have identity: it might be useful for me to create multiple
    `Counter` objects so that I can count different kinds of things. But with value
    types (either the built-in ones or custom structs), the assumption is that they
    can be copied freely. If I have an instance of the `int` type (e.g., 4) and I
    store that in several fields, there’s no expectation that this value has a life
    of its own: one instance of the number 4 is indistinguishable from another. The
    variables that hold values have their own identities and lifetimes, but the values
    that they hold do not. This is different from how reference types work: not only
    do the variables that refer to them have identities and lifetimes, the objects
    they refer to have their own identities and lifetimes independent of any particular
    variable.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 一个结构体可以拥有与类几乎相同的特性；它可以包含方法、字段、属性、构造函数和类支持的任何其他成员类型（在[“Members”](#members)中描述），我们可以使用相同的访问权限关键字，如`public`和`internal`。有一些限制，但是对于我之前编写的简单`Counter`类型，我*可能*只需将`class`关键字替换为`struct`。然而，这不会是一个有用的转换。记住，引用类型（类）和值类型之间的主要区别之一是前者具有身份：我可能需要创建多个`Counter`对象，以便可以计算不同类型的事物。但是对于值类型（内置的或自定义的结构体），假设它们可以自由复制。如果我有一个`int`类型的实例（例如4），并且将其存储在几个字段中，没有期望这个值具有自己的生命周期：数字4的一个实例与另一个实例无法区分。持有值的变量有它们自己的身份和生命周期，但它们持有的值没有。这与引用类型的工作方式不同：不仅引用它们的变量具有身份和生命周期，它们引用的对象也有自己的独立身份和生命周期，与任何特定变量无关。
- en: If I add one to the `int` value 4, the result is a completely different `int`
    value. If I call `GetNextValue()` on a `Counter`, its count goes up by one, but
    it remains the same `Counter` instance. So although replacing `class` with `struct`
    in [Example 3-3](#class_with_static_members) would compile, we really don’t want
    our `Counter` type to become a struct. [Example 3-28](#simple_struct) shows a
    better candidate.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我将`int`值4加1，结果将是一个完全不同的`int`值。如果我在`Counter`上调用`GetNextValue()`，它的计数会增加1，但它仍然是同一个`Counter`实例。因此，虽然在[示例 3-3](#class_with_static_members)中用`struct`替换`class`会编译通过，但我们真的不希望我们的`Counter`类型变成一个结构体。[示例 3-28](#simple_struct)展示了一个更好的候选项。
- en: Example 3-28\. A simple struct
  id: totrans-167
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-28\. 一个简单的结构体
- en: '[PRE33]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This represents a point in two-dimensional space. And while it’s certainly possible
    to imagine wanting the ability to represent particular points with their own identity
    (in which case we’d want a `class`), it’s perfectly reasonable to want to have
    a value-like type representing a point’s location.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这代表二维空间中的一个点。虽然可以想象希望能够表示具有自己标识的特定点的能力（在这种情况下，我们会想要一个`class`），但希望有一个类似值的类型来表示点的位置是完全合理的。
- en: 'Although [Example 3-28](#simple_struct) is OK as far as it goes, it’s common
    for values to support comparison. As mentioned earlier, C# defines a default meaning
    for the `==` operator for reference types: it is equivalent to `object.ReferenceEquals`,
    which compares identities. That’s not meaningful for value types, so C# does not
    automatically support `==` for a `struct`. You are not strictly required to provide
    a definition, but the built-in value types all do, so if we’re trying to make
    a type with similar characteristics to those, we should do this. If you add an
    `==` operator on its own, the compiler will inform you that you are required to
    define a matching `!=` operator. You might think C# would define `!=` as the inverse
    of `==`, since they appear to mean the opposite. However, some types will return
    `false` for both operators for certain pairs of operands, so C# requires us to
    define both independently. As [Example 3-29](#support_custom_comparison) shows,
    to define a custom meaning for an operator, we use the `operator` keyword followed
    by the operator we’d like to customize. This example defines the behavior for
    `==` and `!=`, which are very straightforward for our simple type. (Since all
    of the new methods in this example do nothing more than returning the value of
    a single expression, I’ve implemented them using the `=>` syntax, just as I’ve
    done with various properties in preceding examples.)'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然[示例 3-28](#simple_struct)仅限于目前的内容，但常见的值支持比较。如前所述，C#为引用类型定义了`==`运算符的默认含义：它等同于`object.ReferenceEquals`，用于比较标识。这对值类型没有意义，因此C#不会自动支持`==`用于`struct`。你不一定需要提供定义，但内置的值类型都这样做了，所以如果我们试图创建一个具有类似特性的类型，我们应该这样做。如果你单独添加了`==`运算符，编译器会提醒你必须定义一个匹配的`!=`运算符。你可能会认为C#会将`!=`定义为`==`的反义，因为它们似乎意味着相反的含义。然而，某些类型对于某些操作数对将同时返回`false`，因此C#要求我们独立定义两者。正如[示例 3-29](#support_custom_comparison)所示，要定义运算符的自定义含义，我们使用`operator`关键字，后跟我们想要自定义的运算符。本例为我们简单类型定义了`==`和`!=`的行为，非常直接。（由于本例中的所有新方法都只返回单个表达式的值，我使用了`=>`语法来实现它们，就像在之前的示例中用于各种属性一样。）
- en: Example 3-29\. Support custom comparison
  id: totrans-171
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-29\. 支持自定义比较
- en: '[PRE34]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'If you just add the `==` and `!=` operators, you’ll find that the compiler
    generates warnings recommending that you define two methods called `Equals` and
    `GetHashCode`. `Equals` is a standard method available on all .NET types, and
    if you have defined a custom meaning for `==`, you should ensure that `Equals`
    does the same thing. [Example 3-29](#support_custom_comparison) does this, and
    as you can see, it contains the same logic as the `==` operator, but it has to
    do some extra work. The `Equals` method permits comparison with any type, so we
    first check to see if our `Point` is being compared with another `Point`. I’ve
    used a declaration pattern to perform this check and also to get the incoming
    `obj` argument into a variable of type `Point` in the case where the pattern matches.
    In fact it implements two versions of `Equals`: the standard method that accepts
    any `object` and a more specialized one that allows comparison only with other
    `Point` values. This allows for more efficient comparisons by avoiding boxing
    (which is described in [Chapter 7](ch07.xhtml#ch_object_lifetime)), and as is
    common practice when offering this second form of `Equals`, I’ve declared support
    for the `IEquatable<Point>` interface; I’ll be describing interfaces in [“Interfaces”](#interfaces).
    [Example 3-29](#support_custom_comparison) also implements `GetHashCode`, which
    we’re required to do if we implement `Equals`. See the next sidebar, [“GetHashCode”](#gethashcode),
    for details.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只是添加了`==`和`!=`运算符，你会发现编译器会生成警告，建议你定义两个名为`Equals`和`GetHashCode`的方法。`Equals`是所有.NET类型上都可用的标准方法，如果你为`==`定义了自定义含义，应确保`Equals`也执行同样的操作。[示例 3-29](#support_custom_comparison)做到了这一点，正如你所见，它包含与`==`运算符相同的逻辑，但需要做一些额外的工作。`Equals`方法允许与任何类型进行比较，因此我们首先检查我们的`Point`是否与另一个`Point`进行比较。我使用了声明模式来执行此检查，并在模式匹配的情况下将传入的`obj`参数转换为`Point`类型的变量。事实上，它实现了两个版本的`Equals`：接受任何`object`的标准方法和仅允许与其他`Point`值进行比较的更专业的方法。这通过避免装箱（在[第7章](ch07.xhtml#ch_object_lifetime)中描述）实现了更高效的比较，并且如常见做法一样，在提供这第二种形式的`Equals`时，我声明了对`IEquatable<Point>`接口的支持；我将在[“接口”](#interfaces)中描述接口。[示例 3-29](#support_custom_comparison)还实现了`GetHashCode`，如果我们实现了`Equals`，我们就必须这样做。有关详细信息，请参阅下一节边栏[“GetHashCode”](#gethashcode)。
- en: With the version of `Point` in [Example 3-29](#support_custom_comparison), we
    can run a few tests. [Example 3-30](#comparing_structs) works similarly to Examples
    [3-18](#comparing_references) and [3-19](#comparing_values).
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 [示例 3-29](#support_custom_comparison) 中的 `Point` 版本，我们可以运行几个测试。[示例 3-30](#comparing_structs)
    的工作方式类似于示例 [3-18](#comparing_references) 和 [3-19](#comparing_values)。
- en: Example 3-30\. Comparing struct instances
  id: totrans-175
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-30\. 比较结构实例
- en: '[PRE35]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Running that code produces this output:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 运行该代码会产生以下输出：
- en: '[PRE36]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: All three instances have the same value. With `p2` that’s because I initialized
    it by assigning `p1` into it, and with `p3` I constructed it from scratch but
    with the same arguments. Then we have the first three comparisons, which, remember,
    use `==`. Since [Example 3-29](#support_custom_comparison) defines a custom implementation
    that compares values, all the comparisons succeed. And all the `object.ReferenceEquals`
    values fail, because this is a value type, just like `int`. In fact, this is the
    same behavior we saw with [Example 3-19](#comparing_values), which used `int`
    instead of `Counter`. (Again, the compiler has generated implicit conversions
    here that produce boxes, which we will look at in [Chapter 7](ch07.xhtml#ch_object_lifetime).)
    So we have achieved our goal of defining a type with similar behavior to built-in
    value types such as `int`.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 所有三个实例具有相同的值。对于 `p2`，这是因为我通过将 `p1` 分配给它进行了初始化，而对于 `p3`，我从头开始构建它，但使用相同的参数。然后我们有前三个比较，记住，它们使用
    `==`。由于 [示例 3-29](#support_custom_comparison) 定义了一个自定义实现来比较值，所有比较都成功了。而所有 `object.ReferenceEquals`
    的值都失败了，因为这是一个值类型，就像 `int` 一样。事实上，这与我们在 [示例 3-19](#comparing_values) 中看到的行为相同，那里使用的是
    `int` 而不是 `Counter`。（同样，编译器在这里生成了隐式转换，产生了箱子，我们将在 [第 7 章](ch07.xhtml#ch_object_lifetime)
    中看到。）因此，我们已经实现了定义一种与内置值类型（如 `int`）具有类似行为的类型的目标。
- en: When to Write a Value Type
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写值类型的时机
- en: I’ve shown some of the differences in observable behavior between a reference
    type (`class` or `record`) and a `struct`, but although I argued why `Counter`
    was a poor candidate for being a `struct`, I’ve not fully explained what makes
    a good one. The short answer is that there are only two circumstances in which
    you should write a value type. First, if you need to represent something value-like,
    such as a number, a struct is likely to be ideal. Second, if you have determined
    that a struct has usefully better performance characteristics for the scenario
    in which you will use the type, a struct may not be ideal but might still be a
    good choice. But it’s worth understanding the pros and cons in more detail. And
    I will also address a surprisingly persistent myth about value types.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我展示了引用类型（`class`或`record`）与`struct`之间在可观察行为上的一些差异，但尽管我辩称为什么`Counter`不适合作为`struct`，我还没有完全解释什么才是一个好的`struct`。简短的答案是，只有两种情况下你应该编写值类型。首先，如果你需要表示类似值的东西，比如数字，`struct`可能是理想的选择。其次，如果你已经确定在你将使用该类型的场景中，`struct`具有更好的性能特征，那么`struct`可能并不是理想的，但仍然可能是一个不错的选择。但值得更详细地了解其利弊。我还将解释一个关于值类型令人意外地持久的神话。
- en: With reference types, an object is distinct from a variable that refers to it.
    This can be very useful, because we often use objects as models for real things
    with identities of their own. But this has some performance implications. An object’s
    lifetime is not necessarily directly related to the lifetime of a variable that
    refers to it. You can create a new object, store a reference to it in a local
    variable, and then later copy that reference to a static field. The method that
    originally created the object might then return, so the local variable that first
    referred to the object no longer exists, but the object needs to stay alive because
    it’s still possible to reach it by other means.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 对于引用类型，对象与引用它的变量是不同的。这可能非常有用，因为我们经常使用对象作为具有自己身份的真实事物的模型。但这对性能有一些影响。对象的生命周期不一定直接与引用它的变量的生命周期相关联。你可以创建一个新对象，将其引用存储在局部变量中，然后稍后将该引用复制到静态字段中。最初创建对象的方法可能会返回，因此最初引用对象的局部变量不再存在，但对象需要保持活动状态，因为仍然可以通过其他方式访问它。
- en: The CLR goes to considerable lengths to ensure that the memory an object occupies
    is not reclaimed prematurely but is eventually freed once the object is no longer
    in use. This is a fairly complex process (described in detail in [Chapter 7](ch07.xhtml#ch_object_lifetime)),
    and .NET applications can end up causing the CLR to consume a considerable amount
    of CPU time just tracking objects in order to work out when they fall out of use.
    Creating lots of objects increases this overhead. Adding complexity in certain
    ways can also increase the costs of object tracking—if a particular object remains
    alive only because it is reachable through some very convoluted path, the CLR
    may need to follow that path each time it tries to work out what memory is still
    in use. Each level of indirection you add generates extra work. A reference is
    by definition indirect, so every reference type variable creates work for the
    CLR.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: CLR 会极力确保对象占用的内存不会过早回收，而是在对象不再使用时最终释放。这是一个相当复杂的过程（在[第 7 章](ch07.xhtml#ch_object_lifetime)中详细描述），.NET
    应用程序可能会导致 CLR 消耗大量 CPU 时间来跟踪对象，以确定它们何时不再使用。创建大量对象会增加这种开销。在某些方式中增加复杂性也会增加对象跟踪的成本——如果某个对象之所以保持活跃是因为它通过一些非常复杂的路径可达，CLR
    可能需要每次尝试确定仍在使用的内存时都跟随该路径。你添加的每个间接层都会产生额外的工作。引用本质上是间接的，因此每个引用类型变量都会为 CLR 创建工作量。
- en: 'Value types can often be handled in a much simpler way. For example, consider
    arrays. If you declare an array of some reference type, you end up with an array
    of references. This is very flexible—elements can be null if you want, and you’re
    also free to have multiple different elements all referring to the same item.
    But if what you actually need is a simple sequential collection of items, that
    flexibility is just overhead. A collection of 1,000 reference type instances requires
    1,001 blocks of memory: one block to hold an array of references, and then 1,000
    objects for those references to refer to. But with value types, a single block
    can hold all the values. This simplifies things for memory management purposes—either
    the array is still in use or it’s not, and there’s no need for the CLR to check
    the 1,000 individual elements separately.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 值类型通常可以以更简单的方式处理。例如，考虑数组。如果你声明了某个引用类型的数组，最终你得到的是一个引用的数组。这是非常灵活的——元素可以是空的，而且你也可以自由地有多个不同的元素都引用同一个项目。但如果你实际上需要的是一个简单的顺序项目集合，这种灵活性只是额外的开销。一个包含
    1,000 个引用类型实例的集合需要 1,001 个内存块：一个用于保存引用数组的块，然后 1,000 个用于这些引用的对象。但是对于值类型来说，一个单独的块就可以容纳所有的值。这简化了内存管理的目的——数组要么仍在使用，要么就不在使用，CLR
    不需要单独检查这 1,000 个元素。
- en: It’s not just arrays that can benefit from this sort of efficiency. There’s
    also an advantage for fields. Consider a class that contains 10 fields, all of
    type `int`. The 40 bytes required to hold those fields’ values can live directly
    inside the memory allocated for an instance of the containing class. Compare that
    with 10 fields of some reference type. Although those references can be stored
    inside the object instance’s memory, the objects they refer to will be separate
    entities, so if the fields are all non-null and all refer to different objects,
    you’ll now have 11 blocks of memory—one for the instance that contains all the
    fields, and then one for each object those fields refer to. [Figure 3-1](#references_versus_values)
    illustrates these differences between references and values for both arrays and
    objects (with smaller examples, because the same principle applies even with a
    handful of instances).
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅仅是数组可以从这种效率中受益。字段也有优势。考虑一个包含 10 个 `int` 类型字段的类。用于保存这些字段值所需的 40 个字节可以直接存在包含类实例的内存中。与之相比，如果有
    10 个某种引用类型的字段。虽然这些引用可以存储在对象实例的内存中，但它们所引用的对象将是独立的实体，因此如果字段都是非空并且都引用不同的对象，你现在将有
    11 个内存块——一个用于包含所有字段的实例，然后每个字段引用的对象各有一个。[图 3-1](#references_versus_values) 说明了这些在数组和对象方面引用与值之间的差异（以较小的示例来说明，因为即使在少数实例中也适用相同的原则）。
- en: Value types can also sometimes simplify lifetime handling. Often, the memory
    allocated for local variables can be freed as soon as a method returns (although,
    as we’ll see in [Chapter 9](ch09.xhtml#ch_delegates_lambdas_events), anonymous
    functions mean that it’s not always that simple). This means the memory for local
    variables can often live on the stack, which typically has much lower overheads
    than the heap. For reference types, the memory for a variable is only part of
    the story—the object it refers to cannot be handled so easily, because that object
    may continue to be reachable by other paths after the method exits.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 值类型有时还可以简化生命周期处理。通常情况下，为局部变量分配的内存可以在方法返回时立即释放（尽管如我们将在[第9章](ch09.xhtml#ch_delegates_lambdas_events)中看到的，匿名函数意味着情况并不总是那么简单）。这意味着局部变量的内存通常可以存放在堆栈上，而堆栈的开销通常比堆小得多。对于引用类型来说，变量的内存只是故事的一部分——它所引用的对象并不那么容易处理，因为该对象在方法退出后可能仍然可通过其他路径访问到。
- en: '![References versus values](assets/pc10_0301.png)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![引用与值](assets/pc10_0301.png)'
- en: Figure 3-1\. References versus values
  id: totrans-188
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3-1\. 引用与值
- en: In fact, the memory for a value may be reclaimed even before a method returns.
    New value instances often overwrite older instances. For example, C# can normally
    just use a single piece of memory to represent a variable, no matter how many
    different values you put in there. Creating a new instance of a value type doesn’t
    necessarily mean allocating more memory, whereas with reference types, a new instance
    means a new heap block. This is why it’s OK for each operation we perform with
    a value type—every integer addition or subtraction, for example—to produce a new
    instance.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，一个值的内存可能在方法返回之前就被回收。新值实例通常会覆盖旧实例。例如，C#通常可以只使用一块内存来表示一个变量，不管你往里面放多少不同的值。创建一个值类型的新实例并不一定意味着分配更多内存，而对于引用类型来说，新实例意味着一个新的堆块。这就是为什么每次我们使用值类型进行操作——比如整数加法或减法——都会产生一个新实例。
- en: One of the most persistent myths about value types says that values are allocated
    on the stack, unlike objects. It’s true that objects always live on the heap,
    but value types don’t always live on the stack,^([2](ch03.xhtml#idm45884832593360))
    and even in the situations where they do, that’s an implementation detail, not
    a fundamental feature of C#. [Figure 3-1](#references_versus_values) shows two
    counterexamples. An `int` value inside an array of type `int[]` does not live
    on the stack; it lives inside the array’s heap block. Likewise, if a class declares
    a nonstatic `int` field, the value of that `int` lives inside the heap block for
    its containing object instance. And even local variables of value types don’t
    necessarily end up on the stack. For example, optimizations may make it possible
    for the value of a local variable to live entirely inside the CPU’s registers,
    rather than needing to go on the stack. And as you’ll see in Chapters [9](ch09.xhtml#ch_delegates_lambdas_events)
    and [17](ch17.xhtml#ch_asynchronous_language_features), locals can sometimes live
    on the heap.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 关于值类型的一个最持久的误解之一是认为值是分配在堆栈上的，而不像对象。事实上，对象总是存在于堆上，但值类型并不总是存在于堆栈上^([2](ch03.xhtml#idm45884832593360))，即使在它们存在于堆栈上的情况下，这只是一种实现细节，而不是C#的基本特性。[图3-1](#references_versus_values)展示了两个反例。在类型为`int[]`的数组内部的一个`int`值并不位于堆栈上，它存在于数组的堆块内部。同样地，如果一个类声明了一个非静态的`int`字段，该`int`的值存在于其所包含的对象实例的堆块内部。甚至值类型的局部变量并不一定最终位于堆栈上。例如，优化可能使得局部变量的值完全存在于CPU的寄存器内，而不需要放在堆栈上。正如你将在第[9章](ch09.xhtml#ch_delegates_lambdas_events)和[17章](ch17.xhtml#ch_asynchronous_language_features)看到的，局部变量有时也可以存在于堆上。
- en: You might be tempted to summarize the preceding few paragraphs as “there are
    some complex details, but in essence, value types are more efficient.” But that
    would be a mistake. There are some situations in which value types are significantly
    more expensive. Remember that a defining feature of a value type is that values
    get copied on assignment. If the value type is big, that will be relatively expensive.
    For example, the runtime libraries define the `Guid` type to represent the 16-byte
    *globally unique identifiers* that crop up in lots of bits of Windows. This is
    a `struct`, so any assignment statement involving a `Guid` is asking to make a
    copy of a 16-byte data structure. This is likely to be more expensive than making
    a copy of a reference, because the CLR uses a pointer-based implementation for
    references; a pointer typically takes 4 or 8 bytes, but more importantly, it’ll
    be something that fits naturally into a single CPU register.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会诱惑将前面几段总结为“有一些复杂的细节，但本质上，值类型更有效率”。但那是一个错误。在某些情况下，值类型会显著更昂贵。请记住，值类型的一个定义特征是在赋值时会复制数值。如果值类型很大，那么复制将会相对昂贵。例如，运行时库定义了`Guid`类型来表示
    Windows 中许多地方出现的 16 字节的*全局唯一标识符*。这是一个`struct`，所以涉及`Guid`的任何赋值语句都会请求复制一个 16 字节的数据结构。这可能比复制引用更昂贵，因为CLR对引用使用基于指针的实现；一个指针通常占据
    4 或 8 字节，但更重要的是，它将自然适合单个CPU寄存器。
- en: It’s not just assignment that causes values to be copied. Passing a value type
    argument to a method may require a copy. As it happens, with method invocation,
    it is actually possible to pass a reference to a value, although as we’ll see
    later, it’s a slightly limited kind of reference, and the restrictions it imposes
    are sometimes undesirable, so you may end up deciding that the cost of the copy
    is preferable. This is why Microsoft’s design guidelines suggest that you should
    not make a type a `struct` unless it “has an instance size under 16 bytes” (a
    guideline that the `Guid` type technically violates, being exactly 16 bytes in
    size). But this is not a hard-and-fast rule—it really depends on how you will
    be using it, and since more recent versions of C# provide more flexibility for
    using values types indirectly, it is increasingly common for performance-sensitive
    code to ignore this restriction and instead to take care to minimize copying.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅赋值会导致值被复制。将值类型参数传递给方法可能需要复制。事实上，通过方法调用，实际上可以传递一个值的引用，尽管我们稍后会看到，这是一种稍微有限的引用类型，它所施加的限制有时是不希望的，因此您可能最终决定复制的成本更可取。这就是为什么微软的设计指南建议，除非“实例大小小于
    16 字节”，否则不应将类型定义为`struct`（技术上`Guid`类型违反了这一指南，因为它的确刚好是 16 字节大小）。但这不是一个死板的规则——这实际上取决于您将如何使用它，而且由于C#的更新版本提供了更多间接使用值类型的灵活性，因此在性能敏感的代码中忽略这一限制并致力于最小化复制现在变得越来越普遍。
- en: 'Value types are not automatically going to be more efficient than reference
    types, so in most cases, your choice should be driven by the behavior you require.
    The most important question is this: Does the identity of an instance matter to
    you? In other words, is the distinction between one object and another object
    important? For our `Counter` example, the answer is yes: if we want something
    to keep count for us, it’s simplest if that counter is a distinct thing with its
    own identity. (Otherwise, our `Counter` type adds nothing beyond what `int` gives
    us.) But for our `Point` type, the answer is no, so it’s a reasonable candidate
    for being a value type.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 值类型并不自动比引用类型更有效率，所以在大多数情况下，您的选择应该由您需要的行为驱动。最重要的问题是：实例的身份对您是否重要？换句话说，一个实例与另一个实例之间的区别是否重要？对于我们的`Counter`示例，答案是肯定的：如果我们想要一个来为我们计数的东西，最简单的方法就是将该计数器作为一个具有自己身份的独立物体。但对于我们的`Point`类型，答案是否定的，所以它是作为值类型的一个合理候选。
- en: 'An important and related question is: Does an instance of your type contain
    state that changes over time? Modifiable value types tend to be problematic, because
    it’s all too easy to end up working with some copy of a value and not the instance
    you meant to. (I’ll show an important example of this problem later, in [“Properties
    and mutable value types”](#properties_and_mutable_value_types), and another when
    I describe `List<T>` in [Chapter 5](ch05.xhtml#ch_collections).) So it’s usually
    a good idea for value types to be immutable. This doesn’t mean that variables
    of these types cannot be modified; it just means that to modify the variable,
    you must replace its contents entirely with a different value. For something simple
    like an `int`, this will seem like splitting hairs, but the distinction is important
    with structs that contain multiple fields, such as .NET’s `Complex` type, which
    represents numbers that combine a real and an imaginary component. You cannot
    change the `Real` or `Imaginary` property of an existing `Complex` instance, because
    the type is immutable. And the `Point` type shown earlier works the same way.
    If the value you’ve got isn’t the value you want, immutability just means you
    need to create a new value, because you can’t tweak the existing instance.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 一个重要且相关的问题是：你的类型的实例是否包含随时间变化的状态？可修改的值类型往往是有问题的，因为很容易会意外地使用某个值的副本而不是你想要的实例。（稍后我会展示一个关于这个问题的重要例子，在[“属性和可变值类型”](#properties_and_mutable_value_types)中，并且在描述`List<T>`时我会在[第5章](ch05.xhtml#ch_collections)中再次描述。）因此，对于值类型来说，通常最好是不可变的。这并不意味着这些类型的变量不能被修改；它只意味着要修改变量，你必须完全用不同的值替换其内容。对于像`int`这样简单的东西，这似乎是纠缠细节，但是在包含多个字段的结构体中这一区别是重要的，例如.NET的`Complex`类型，它表示一个由实部和虚部组成的数。你不能改变现有`Complex`实例的`Real`或`Imaginary`属性，因为该类型是不可变的。之前展示的`Point`类型也是一样的。如果你手头的值不是你想要的值，不可变性意味着你需要创建一个新的值，因为你不能调整现有的实例。
- en: Immutability does not necessarily mean you should write a struct—the built-in
    `string` type is immutable, and that’s a class.^([3](ch03.xhtml#fn19)) However,
    because C# often does not need to allocate new memory to hold new instances of
    a value type, value types are able to support immutability more efficiently than
    classes in scenarios where you’re creating lots of new values (e.g., in a loop).
    Immutability is not an absolute requirement for structs—there are some unfortunate
    exceptions in .NET’s runtime libraries. But value types should normally be immutable,
    so a requirement for mutability is usually a good sign that you want a class rather
    than a struct.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 不可变性并不一定意味着你应该编写一个结构体——内置的`string`类型是不可变的，这是一个类。^([3](ch03.xhtml#fn19)) 然而，因为在C#中通常不需要为了保存值类型的新实例而分配新的内存，值类型在需要创建大量新值的场景（例如循环中）比类更有效地支持不可变性。对于结构体来说，不可变性并非绝对要求——在.NET运行时库中存在一些不幸的例外情况。但通常应该使值类型是不可变的，因此对可变性的需求通常是你应该选择类而不是结构体的一个良好迹象。
- en: A type should only be a struct if it represents something that is very clearly
    similar in nature to other things that are value types. (In most cases it should
    also be fairly small, because passing large types by value is expensive.) For
    example, in the runtime libraries, `Complex` is a struct, which is unsurprising
    because it’s a numeric type, and all of the built-in numeric types are value types.
    `TimeSpan` is also a value type, which makes sense because it’s effectively just
    a number that happens to represent a length of time. In the UI framework WPF,
    types used for simple geometric data such as `Point` and `Rect` are structs. But
    if in doubt, write a class.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 一个类型只有在它代表的东西与其他值类型非常相似时才应该是一个结构体。（在大多数情况下，它还应该相当小，因为通过值传递大型类型是昂贵的。）例如，在运行时库中，`Complex`是一个结构体，这并不奇怪，因为它是一个数值类型，而所有内置数值类型都是值类型。`TimeSpan`也是一个值类型，这是合理的，因为它实际上只是一个表示时间长度的数字。在UI框架WPF中，用于简单几何数据的类型，如`Point`和`Rect`，都是结构体。但如果不确定的话，就编写一个类。
- en: Guaranteeing Immutability
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 保证不可变性
- en: 'You can declare your intention to make a struct read-only by adding the `readonly`
    keyword in front of `struct`, as [Example 3-31](#a_readonly_struct) shows. This
    is similar to the `Point` type shown in [Example 3-28](#simple_struct), but I’ve
    made a couple of other alterations. In addition to adding the `readonly` qualifier,
    I’ve also used read-only auto-properties to reduce the clutter—the compiler will
    generate code equivalent to the earlier example for these. I’ve also added a member
    function for reasons that will soon become clear. Like the earlier version, this
    has a constructor, and in this case that was mandatory: the constructor provides
    the only opportunity to supply values for a `Point`’s properties, so this type
    would be useless without one.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过在 `struct` 前添加 `readonly` 关键字来声明将结构体设置为只读，就像[示例 3-31](#a_readonly_struct)所示。这类似于[示例 3-28](#simple_struct)中显示的
    `Point` 类型，但我进行了一些其他修改。除了添加 `readonly` 限定符外，我还使用了只读自动属性来减少混乱——编译器将为这些属性生成与先前示例相当的代码。出于即将明确的原因，我还添加了一个成员函数。与早期版本类似，这个版本有一个构造函数，在这种情况下是强制性的：构造函数提供了为
    `Point` 属性提供值的唯一机会，因此没有构造函数的话，这种类型将毫无用处。
- en: Example 3-31\. A read-only struct
  id: totrans-199
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-31\. 只读结构体
- en: '[PRE37]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Applying the `readonly` keyword to a `struct` has two effects. First, the C#
    compiler will keep you honest, preventing modification either from outside or
    from within. If you declare any fields, the compiler will generate an error unless
    these are also marked `readonly`. Similarly, if you try to define a settable auto-property
    (one with a `set;` as well as a `get;`), the compiler will produce an error.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `readonly` 关键字应用于 `struct` 具有两个效果。首先，C# 编译器会确保你的诚实，防止外部或内部的修改。如果声明了任何字段，除非这些字段也标记为
    `readonly`，否则编译器将生成错误。类似地，如果尝试定义可设置的自动属性（包括 `set;` 和 `get;`），编译器也会产生错误。
- en: Second, read-only structs enjoy certain optimizations. If in some other type
    you declare a `readonly` field (either directly or indirectly with a read-only
    auto-property) whose type is a `readonly struct`, the compiler may be able to
    avoid making a copy of the data when something uses that field. Consider the class
    in [Example 3-32](#readonly_struct_in_readonly_property).
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 第二，只读结构体享有某些优化。如果在某些其他类型中声明一个 `readonly` 字段（直接或间接使用只读自动属性），其类型为 `readonly struct`，当某些内容使用该字段时，编译器可以避免复制数据。考虑[示例 3-32](#readonly_struct_in_readonly_property)中的类。
- en: Example 3-32\. A read-only struct in a read-only property
  id: totrans-203
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-32\. 只读结构体在只读属性中
- en: '[PRE38]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Suppose you had a variable `r` containing a reference to a `LocationData`. What
    would happen if you wrote the expression `r.Location.DistanceFromOrigin()`? Logically,
    we’re asking `r.Location` to retrieve the `Point`, and since `Point` is a value
    type, that would entail making a copy of the value. Normally, C# will generate
    code that really does make a copy because it cannot in general know whether invoking
    some member of a `struct` will modify it. These are known as *defensive copies*,
    and they ensure that expressions like this can’t cause a nasty surprise such as
    changing the value of a property or field that appears to be read-only. However,
    since `Point` is a `readonly struct`, the compiler can know that it does not need
    to create a defensive copy here. In this case, it would be safe for either the
    C# compiler or the JIT compiler (or AoT code generator) to optimize this code
    by invoking `DistanceFromOrigin` directly on the value stored inside the `LocationData`
    without first making a copy.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您有一个变量 `r`，其中包含对 `LocationData` 的引用。如果写入表达式 `r.Location.DistanceFromOrigin()`，会发生什么呢？从逻辑上讲，我们正在请求
    `r.Location` 检索 `Point`，由于 `Point` 是值类型，这将涉及复制值。通常情况下，C# 会生成确实进行复制的代码，因为通常情况下它无法知道调用
    `struct` 的某些成员是否会修改它。这些称为*防御性复制*，它们确保像这样的表达式不会引起意外，比如更改看似只读的属性或字段的值。然而，由于 `Point`
    是 `readonly struct`，编译器可以知道在这里不需要创建防御性复制。在这种情况下，C# 编译器或 JIT 编译器（或 AoT 代码生成器）可以通过直接在
    `LocationData` 中存储的值上调用 `DistanceFromOrigin` 来优化这段代码，而无需首先创建复制品。
- en: Tip
  id: totrans-206
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: You are allowed to use a `readonly struct` in writable fields and properties
    if you want to. The `readonly` keyword guarantees only that any particular value
    of this type will not change. If you want to overwrite an existing value with
    a completely different value, that’s up to you.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 如果愿意，可以在可写字段和属性中使用 `readonly struct`。`readonly` 关键字仅保证此类型的任何特定值不会更改。如果想要用完全不同的值覆盖现有值，完全由你决定。
- en: Record Structs
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 记录结构体
- en: When you saw [Example 3-29](#support_custom_comparison), you might have thought
    to yourself that this seems a lot like the kind of work that the compiler can
    do for us in a `record` type. Can we get it do the same work with a `struct`?
    Starting with C# 10.0, we can declare a `record struct` type, which adds the same
    comparison behavior that we get with a `class`-based record—the compiler would
    write `GetHashCode` and both forms of the `Equals` methods for you, along with
    the `==` and `!=` operators.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 当您看到[示例 3-29](#support_custom_comparison)时，您可能会想到，这似乎很像编译器可以为我们在`record`类型中执行的工作。我们是否可以用`struct`做同样的工作？从C#
    10.0开始，我们可以声明一个`record struct`类型，它添加了与基于`class`的`record`相同的比较行为 - 编译器将为您编写`GetHashCode`和两种形式的`Equals`方法，以及`==`和`!=`运算符。
- en: Besides the usual differences between classes and value types already described,
    there are some other more subtle differences between `record` and `record struct`
    types. For example, because `struct` types have a way to declare explicitly that
    they are immutable (the `readonly` qualifier), when you use the positional syntax
    with a `record struct`, the compiler assumes that if you want a read-only type,
    you’ll say so by declaring it as `readonly record struct`. So although properties
    defined with the positional syntax are immutable on a `readonly record struct`
    (just as they are on a `record`), they are modifiable on a `record struct`. So
    whereas you cannot modify the `X` and `Y` properties of a `PointRecord` type in
    [Example 3-33](#readonly_vs_mutable_records) after construction, you could change
    the properties of a `PointStructRecord`. But `Poi⁠ntR⁠ead⁠on⁠ly​Str⁠uct⁠Rec⁠ord`
    gets immutable properties, just like `PointRecord`.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 除了已经描述的类和值类型之间的常规区别之外，`record`和`record struct`类型之间还有一些其他更微妙的区别。例如，由于`struct`类型有一种明确声明它们是不可变的方式（使用`readonly`修饰符），当您在`record
    struct`中使用位置语法时，编译器假设如果您想要一个只读类型，您将通过声明`readonly record struct`来表明。因此，尽管使用位置语法定义的属性在`readonly
    record struct`上是不可变的（就像在`record`上一样），但在`record struct`上是可修改的。因此，虽然您不能在构造后修改`PointRecord`类型的`X`和`Y`属性（见[示例 3-33](#readonly_vs_mutable_records)），但您可以更改`PointStructRecord`的属性。但是`Poi⁠ntR⁠ead⁠on⁠ly​Str⁠uct⁠Rec⁠ord`获取到的是不可变属性，就像`PointRecord`一样。
- en: Example 3-33\. A read-only `record`, a mutable `record struct`, and a `readonly
    record struct`
  id: totrans-211
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-33. 一个只读的`record`，一个可变的`record struct`和一个`readonly record struct`
- en: '[PRE39]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '`record structs` also have some subtle differences around constructors, which
    I’ll describe in [“Constructors”](#constructors).'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '`record struct`还在构造函数周围有一些微妙的差异，我将在[“构造函数”](#constructors)中描述。'
- en: Class, Structs, Records, or Tuples?
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类、结构、记录或元组？
- en: As you’ve now seen, C# offers many ways to define types. How should we choose
    between them? Suppose your code needs to work with a pair of coordinates representing
    a position in two-dimensional space? How should you represent this in C#?
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您现在所看到的，C# 提供了许多定义类型的方式。我们应该如何在它们之间进行选择？假设您的代码需要处理表示二维空间中位置的坐标对？在C#中应该如何表示这个？
- en: 'The simplest possible answer would be to declare two variables of type `double`,
    one for each dimension. This certainly works, but your code will fail to capture
    something important: the two values are not two separate things. If your chosen
    type doesn’t represent the fact that these two numbers are a single entity, that
    will cause problems. It is inconvenient when you want to write methods that take
    a position as an argument—you end up needing two arguments. If you accidentally
    pass the X value from one coordinate pair and the Y value from a different one,
    the compiler will have no way of knowing this is wrong. Using two separate values
    is especially troublesome if you want a function to return a position, because
    C# methods can return only a single value.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的答案可能是声明两个`double`类型的变量，一个表示每个维度。这当然可以工作，但是您的代码将无法捕获到一个重要的东西：这两个值不是两个独立的东西。如果您选择的类型不能表示这两个数字是单个实体的事实，这将会导致问题。当您想编写以位置作为参数的方法时，这是不方便的
    - 您最终会需要两个参数。如果您意外地传递一个坐标对的X值和另一个坐标对的Y值，编译器将无法知道这是错误的。如果您想要一个函数返回一个位置，使用两个独立的值尤其麻烦，因为C#方法只能返回单个值。
- en: 'Tuples, which were described in [Chapter 2](ch02.xhtml#ch_basic_coding), can
    solve the problems I just described because a single value can contain a pair
    of numbers: `(1.0, 2.0)`. While this is certainly an improvement, the problem
    with tuples is that they are unable to distinguish between different kinds of
    data that happen to have the same structure. This isn’t unique to tuples: built-in
    types have the same issue. A `double` representing a distance in feet has the
    same C# type as one representing a distance in meters, even though there is a
    significant difference in meaning. (NASA lost a space probe in 1999 due to confusion
    over values with identical types but different units.) But these problems go beyond
    mismatched units. Suppose you have a tuple `(X: 10.0, Y: 10.0)` representing the
    position of a rectangle in meters, and another, `(Width: 2.0, Height: 1.0)` representing
    its size, also in meters. The units are the same here, but position and size are
    quite different concepts, and yet these two tuples have exactly the same type.
    This can seem particularly surprising when the members of the tuples have different
    names—the first has `X` and `Y`, but the second has `Width` and `Height`. However,
    as you saw in the preceding chapter, these tuple member names are a fiction the
    C# compiler provides for our convenience. The real names are `Item1` and `Item2`.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '元组在[第2章](ch02.xhtml#ch_basic_coding)中描述，可以解决我刚刚描述的问题，因为单个值可以包含一对数字：`(1.0, 2.0)`。虽然这确实是一个改进，但元组的问题在于它们无法区分具有相同结构的不同类型的数据。这并非元组特有：内置类型也有相同的问题。一个表示英尺距离的`double`具有与表示米距离的`double`相同的C#类型，尽管它们在含义上有显著差异。（NASA在1999年因为对相同类型但不同单位的值混淆而丢失了一枚太空探测器。）但这些问题超出了不匹配的单位。假设你有一个元组`(X:
    10.0, Y: 10.0)`表示矩形在米中的位置，另一个`(Width: 2.0, Height: 1.0)`表示其大小，同样也是以米为单位。这里单位相同，但位置和大小是完全不同的概念，然而这两个元组恰好具有完全相同的类型。当元组成员具有不同名称时，这可能特别令人惊讶——第一个有`X`和`Y`，但第二个有`Width`和`Height`。然而，正如你在前一章中看到的，这些元组成员名称是C#编译器为我们方便提供的虚构名称。真正的名称是`Item1`和`Item2`。'
- en: 'Given the limitations of tuples, it may be more appropriate to ask: When would
    you ever want to use a tuple instead of a specialized type such as a record? I
    have found tuples very useful in private implementation details in places where
    there is little chance of the structural equivalence of conceptually unrelated
    tuple types causing a problem. For example, when using the `Dictionary<TKey, TValue>`
    container type described in [Chapter 5](ch05.xhtml#ch_collections), it is sometimes
    useful for the dictionary key to be made up of more than one value. Tuples are
    ideal for this sort of compound key. They can also be useful when a method needs
    to return multiple related pieces of data in cases where defining a whole new
    type seems like overkill. For example, if the method is a private one called in
    only one or two places, is it really worth defining a whole type just to act as
    the return type of that one method?'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于元组的局限性，可能更合适的问题是：何时才会选择使用元组而不是专用类型，例如记录？我发现在私有实现细节中，元组非常有用，特别是在概念上不相关的元组类型的结构等价性几乎不会引起问题的地方。例如，在使用[第5章](ch05.xhtml#ch_collections)中描述的`Dictionary<TKey,
    TValue>`容器类型时，有时将字典键组合成多个值是有用的。元组非常适合这种复合键的情况。它们还可以在方法需要返回多个相关数据的情况下非常有用，而定义全新类型似乎有些过头。例如，如果方法是一个私有方法，在只调用一两次的情况下，定义一个完整的类型真的值得吗？
- en: 'Record types would work better than tuples for our structurally similar but
    conceptually different position and dimension examples: if we define `public record
    Position(double X, double Y)` and `public record Dimensions(double Width, double
    Height)`, we now have two distinct types to represent these two separate kinds
    of data. If we accidentally try to use positions when dimensions are required,
    the compiler will point out the mistake. Moreover, unlike the locally defined
    names we can give tuple members, the names of a record’s properties are real,
    so code using `Dimensions` will always to refer to its members as `Width` and
    `Height`. Record types automatically implement equality comparisons and hash codes,
    so they work just as well as tuples as compound keys in dictionaries. There are
    really only two reasons you might choose a tuple over a record. One is when you
    actually want the structural equivalence—there are some occasions where deliberately
    being a bit vague about types can provide extra flexibility that might justify
    the possible reduction in safety. And the second is in cases where defining a
    type seems like overkill (e.g., when using a compound key for a dictionary that
    is used only inside one method).'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 记录类型将比元组更适合于我们结构上类似但概念上不同的位置和尺寸示例：如果我们定义`public record Position(double X, double
    Y)`和`public record Dimensions(double Width, double Height)`，现在我们有两种不同的类型来表示这两种不同的数据。如果我们不小心在需要尺寸时使用位置，编译器将指出错误。此外，与我们可以为元组成员给出的局部定义名称不同，记录属性的名称是真实的，因此使用`Dimensions`的代码将始终引用其成员为`Width`和`Height`。记录类型自动实现相等比较和哈希码，因此它们在字典中作为复合键的工作与元组一样出色。您可能选择元组而不是记录只有两个原因。一种是当您实际上希望结构上的等价性时——有些情况下，故意对类型模糊提供额外的灵活性可能会证明可以接受安全性可能降低的情况下。第二种情况是在定义类型似乎过于繁琐时（例如，在仅在一个方法内部使用的字典的复合键）。
- en: Since record types are full .NET types, they can contain more than just properties—they
    can contain any of the other member types described in the following section.
    Our `Dimensions` record type could include a method that calculates the area,
    for example. And we are free to choose between defining a reference type or a
    value type by using either `record` or `record struct`.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 由于记录类型是完整的 .NET 类型，它们可以包含不仅仅是属性，还可以包含以下部分描述的任何其他成员类型。例如，我们的`Dimensions`记录类型可以包括一个计算面积的方法。而且我们可以自由选择使用`record`或者`record
    struct`来定义引用类型或值类型。
- en: 'When would we use a class (or struct) instead of a record? One reason might
    be that you don’t want the equality logic. If your application has entities with
    their own identities—perhaps certain objects correspond to people or to particular
    devices—the value-based comparison logic generated for record types will be inappropriate,
    because two items can be distinct even if they happen to share the same characteristics.
    (Imagine objects representing shapes in a drawing program. If you clone a shape,
    you will have two identical objects, but it’s important that they are still considered
    different because the cloned item may then go on to be moved or otherwise modified.)
    So you might want to ask: does your type represent a thing, or does it just hold
    some information? If it represents some information, a record type is likely to
    be a good choice, but a class may well be a better bet for entities that represent
    some real entity, especially if instances of the type have behavior of their own.
    For example, when building a user interface, an interactive element such as a
    button would be better modeled as a `class` than a `record`. It’s not that a record
    type couldn’t be made to work—they can be made to do more or less anything ordinary
    classes and structs can do; it’s just that they are likely to be a less good fit.'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 什么时候我们会使用类（或结构体）而不是记录？一个原因可能是您不想要等式逻辑。如果您的应用程序有具有自己标识的实体——也许某些对象对应于人或特定设备——为记录类型生成的基于值的比较逻辑将不合适，因为即使两个项目具有相同的特征，它们也可能是不同的。
    （想象一下代表绘图程序中形状的对象。如果您克隆一个形状，您将有两个相同的对象，但重要的是它们仍被认为是不同的，因为克隆的项目可能会继续移动或以其他方式修改。）所以您可能想问：您的类型是否代表一种事物，还是仅仅包含一些信息？如果它代表一些信息，记录类型可能是一个不错的选择，但是对于表示某个真实实体的实体，类可能是更好的选择，特别是如果类型的实例具有自己的行为。例如，在构建用户界面时，像按钮这样的交互元素最好建模为`class`而不是`record`。并不是说记录类型不能工作——它们可以做与普通类和结构体几乎一样的事情；只是它们可能不太合适。
- en: Members
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 成员
- en: Whether you’re writing a class, a struct, or a record, there are several different
    kinds of members you can put in a custom type. We’ve seen examples of some already,
    but let’s take a closer and more comprehensive look.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 无论您是编写类、结构体还是记录，您都可以在自定义类型中放置几种不同类型的成员。我们已经看到了一些示例，但让我们更仔细和全面地查看一下。
- en: Accessibility
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可访问性
- en: 'You can specify the accessibility for most class and struct members. Just as
    a type can be `public` or `internal`, so can each member. Members may also be
    declared as `private`, making them accessible only to code inside the type, and
    this is the default accessibility. As we’ll see in [Chapter 6](ch06.xhtml#ch_inheritance),
    inheritance adds three more accessibility levels for members: `protected`, `protected
    internal`, and `protected private`.'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以为大多数类和结构成员指定访问权限。就像类型可以是`public`或`internal`一样，每个成员也可以是这样。成员也可以声明为`private`，这样它们只能在类型内部的代码中访问，这是默认的访问权限。正如我们将在[第6章](ch06.xhtml#ch_inheritance)中看到的那样，继承为成员添加了另外三个可访问性级别：`protected`、`protected
    internal`和`protected private`。
- en: Fields
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字段
- en: You’ve already seen that fields are named storage locations that hold either
    values or references depending on their type. By default, each instance of a type
    gets its own set of fields, but if you want a field to be singular, rather than
    having one per instance, you can use the `static` keyword. You can also apply
    the `readonly` keyword to a field, which states that it can be set only during
    initialization and cannot change thereafter.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经看到字段是命名存储位置，根据其类型可以保存值或引用。默认情况下，每个类型的实例都有其自己的一组字段，但是如果您希望一个字段是唯一的，而不是每个实例都有一个，则可以使用`static`关键字。您还可以将`readonly`关键字应用于字段，该关键字表示它只能在初始化期间设置，并且之后不能更改。
- en: Warning
  id: totrans-228
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: The `readonly` keyword does not make any absolute guarantees. There are mechanisms
    by which it is possible to contrive a change in the value of a `readonly` field.
    The reflection mechanisms discussed in [Chapter 13](ch13.xhtml#ch_reflection)
    provide one way, and unsafe code, which lets you work directly with raw pointers,
    provides another. The compiler will prevent you from modifying a field accidentally,
    but with sufficient determination, you can bypass this protection. And even without
    such subterfuge, a `readonly` field is free to change during construction.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '`readonly`关键字并不提供绝对保证。有一些机制可以通过它们来设法改变`readonly`字段的值。本章的反射机制提供了一种方法，而不安全代码则允许您直接使用原始指针，提供了另一种方法。编译器将阻止您意外修改字段，但是如果有足够的决心，您可以绕过此保护。即使没有这种诡计，`readonly`字段在构造过程中仍然可以自由更改。'
- en: 'C# offers a keyword that seems, superficially, to be similar: you can define
    a `const` field. However, this is designed for a somewhat different purpose. A
    `readonly` field is initialized and then never changed, whereas a `const` field
    defines a value that is invariably the same. A `readonly` field is much more flexible:
    it can be of any type, and its value can be calculated at runtime, which means
    you can define either per-instance or `static` fields as `readonly`. A `const`
    field’s value is determined at compile time, which means it is defined at the
    class level (because there’s no way for individual instances to have different
    values). This also limits the available types. For most reference types, the only
    supported `const` value is `null`, so in practice, it’s normally only useful to
    use `const` with types intrinsically supported by the compiler. (Specifically,
    if you want to use values other than `null`, a `const`’s type must be one of the
    built-in numeric types, `bool`, `string`, or an enumeration type, as described
    later in this chapter.)'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: C#提供了一个关键字，表面上看似乎类似：您可以定义一个`const`字段。然而，这是为了一个稍有不同的目的而设计的。`readonly`字段在初始化后就不会再改变，而`const`字段定义的值始终不变。`readonly`字段更加灵活：它可以是任何类型，并且其值可以在运行时计算，这意味着您可以将其定义为每个实例或者静态字段。`const`字段的值在编译时确定，这意味着它是在类级别定义的（因为没有办法使单个实例具有不同的值）。这也限制了可用的类型。对于大多数引用类型，唯一支持的`const`值是`null`，因此在实践中，通常仅将`const`与编译器本身支持的类型一起使用（具体来说，如果要使用除`null`之外的值，`const`的类型必须是内置的数值类型、`bool`、`string`或枚举类型，如本章后面所述）。
- en: 'This makes a `const` field rather more limited than a `readonly` one, so you
    could reasonably ask: What’s the point? Well, although a `const` field is inflexible,
    it makes a strong statement about the unchanging nature of the value. For example,
    .NET’s `Math` class defines a `const` field of type `double` called `PI` that
    contains as close an approximation to the mathematical constant π as a `double`
    can represent. That’s a value that’s fixed forever—thus it is a constant in a
    very strong sense.'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得`const`字段比`readonly`字段更加受限，因此你可能会合理地问：意义何在？嗯，尽管`const`字段不太灵活，但它确实强烈表明了值的不变性。例如，.NET的`Math`类定义了一个`double`类型的`const`字段，称为`PI`，它包含尽可能接近数学常量π的近似值，这是一个永远固定的值，因此在非常强的意义上是一个常量。
- en: When it comes to less inherently constant values, you need to be a bit careful
    about `const` fields; the C# specification allows the compiler to assume that
    the value really will never change. Code that reads the value of a `readonly`
    field will fetch the value from the memory containing the field at runtime. But
    when you use a `const` field, the compiler can read the value at compile time
    and copy it into the IL as though it were a literal. So if you write a library
    component that declares a `const` field and you later change its value, this change
    will not necessarily be picked up by code using your library unless that code
    gets recompiled.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到不太固定的值时，你需要对`const`字段稍加小心；C#规范允许编译器假设该值确实永远不会改变。当代码读取`readonly`字段的值时，它会在运行时从包含字段的内存中获取值。但当你使用`const`字段时，编译器可以在编译时读取值，并将其复制到IL中，就好像它是一个字面常量。因此，如果你编写一个声明了`const`字段的库组件，并且稍后更改其值，除非重新编译该代码，否则使用您的库的代码可能不会立即反映这一变化。
- en: One of the benefits of a `const` field is that it is eligible for use in certain
    contexts in which a `readonly` field is not. For example, if you want to use a
    constant pattern ([Chapter 2](ch02.xhtml#ch_basic_coding) introduced patterns),
    perhaps in the label for a `case` in a `switch` statement, the value you specify
    has to be fixed at compile time. So a constant pattern cannot refer to a `readonly`
    field, but you can use a suitably typed `const` field. You can also use `const`
    fields in the expression defining the value of another `const` field (as long
    as you don’t introduce any circular references).
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '`const`字段的一个好处是，在某些`readonly`字段不可用的情况下，它可以在特定的上下文中使用。例如，如果你想要在`switch`语句的`case`标签中使用常量模式（引入自[第2章](ch02.xhtml#ch_basic_coding)的模式），你指定的值必须在编译时固定。因此，常量模式不能引用`readonly`字段，但可以使用适当类型的`const`字段。你还可以在定义另一个`const`字段的值的表达式中使用`const`字段（只要不引入循环引用）。'
- en: A `const` field is required to contain an expression defining its value, such
    as the one shown in [Example 3-34](#const_field).
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '`const`字段需要包含定义其值的表达式，例如[示例 3-34](#const_field)中所示的表达式。'
- en: Example 3-34\. A `const` field
  id: totrans-235
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-34\. 一个`const`字段
- en: '[PRE40]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: While mandatory for a `const`, this initializer expression is optional for a
    class’s ordinary and `readonly`^([4](ch03.xhtml#idm45884832211984)) fields. If
    you omit the initializing expression, the field will automatically be initialized
    to a default value. (That’s 0 for numeric values and the equivalents for other
    types—`false`, `null`, etc.)
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管对于一个`const`来说，这个初始化表达式是必需的，但对于类的普通和`readonly`^([4](ch03.xhtml#idm45884832211984))字段来说是可选的。如果你省略了初始化表达式，字段将自动初始化为默认值。（对于数值，这是0，对于其他类型如`false`、`null`等则是相应的等价值。）
- en: Instance field initializers run as part of construction, i.e., when you use
    the `new` keyword (or some equivalent mechanism such as constructing an instance
    through reflection, as described in [Chapter 13](ch13.xhtml#ch_reflection)). This
    means you should be wary of using field initializers in value types. A `struct`
    can be initialized implicitly, in which case its instance fields are set to 0
    (or `false`, etc.). Starting with C# 10.0, you can write instance field initializers
    in a `struct`, but these will only run if that `struct` is *explicitly* initialized.
    If you create an array whose elements are some value type with field initializers,
    all the fields of all the elements in the array will start out with values of
    0; if you want the field initializers to run, you’ll need to write a loop that
    uses `new` to initialize each element in the array. Likewise when you use a `struct`
    type as a field, it will be zero-initialized, and its field initializers will
    run only if you explicitly initialize the field with the `new` keyword. (Instance
    field initializers in a `class` also run only when that `class` is constructed,
    but the big difference is that it’s not possible to get hold of an instance of
    a `class` without running one of its constructors.^([5](ch03.xhtml#fn20)) There
    are common situations in which you will be able to use a `struct` instance that
    was implicitly zero-initialized.) Initializers for noninstance fields (i.e., `const`
    and `static` fields) will always be executed for structs, though.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 实例字段初始化器作为构造的一部分运行，即当你使用`new`关键字（或某些等效机制，如通过反射构造实例，如[第13章](ch13.xhtml#ch_reflection)中所述）时。这意味着你应该小心使用值类型的字段初始化器。`struct`可以隐式初始化，此时它的实例字段设置为0（或`false`等）。从C#
    10.0开始，你可以在`struct`中编写实例字段初始化器，但这些只会在*显式*初始化`struct`时运行。如果你创建一个数组，其元素是带有字段初始化器的某个值类型，则数组中所有元素的所有字段将以值0开始；如果你希望字段初始化器运行，你需要编写一个循环，使用`new`初始化数组中的每个元素。同样，当你将`struct`类型用作字段时，它将被零初始化，并且只有在使用`new`关键字显式初始化字段时，其字段初始化器才会运行。（`class`中的实例字段初始化器也仅在构造该`class`时运行，但主要区别在于，不可能在不运行其构造函数之一的情况下获取`class`的实例。^([5](ch03.xhtml#fn20))
    有常见情况下，你将能够使用隐式零初始化的`struct`实例。）对于非实例字段（即`const`和`static`字段），初始化器始终对`struct`执行。
- en: If you do supply an initializer expression for a non-`const` field, it does
    not need to be evaluable at compile time, so it can do runtime work such as calling
    methods or reading properties. Of course, this sort of code can have side effects,
    so it’s important to be aware of the order in which initializers run.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你为非`const`字段提供了初始化表达式，它不需要在编译时可评估，因此它可以进行运行时工作，比如调用方法或读取属性。当然，这种代码可能具有副作用，因此重要的是要注意初始化器运行的顺序。
- en: 'Nonstatic field initializers run for each instance you create, and they execute
    in the order in which they appear in the file, immediately before the constructor
    runs. Static field initializers execute no more than once, no matter how many
    instances of the type you create. They also execute in the order in which they
    are declared, but it’s harder to pin down exactly when they will run. If your
    class has no static constructor, C# guarantees to run field initializers before
    the first time a field in the class is accessed, but it doesn’t necessarily wait
    until the last minute—it retains the right to run field initializers as early
    as it likes. (The exact moment at which this happens has varied across releases
    of .NET.) But if a static constructor does exist, then things are slightly clearer:
    static field initializers run immediately before the static constructor runs,
    but that merely raises the questions: What’s a static constructor, and when does
    it run? So we had better take a look at constructors.'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 非静态字段初始化器会在每个创建的实例中运行，并且它们按照文件中出现的顺序执行，在构造函数运行之前立即执行。静态字段初始化器最多只执行一次，无论你创建该类型的实例多少个。它们也按照声明的顺序执行，但很难确定它们确切的运行时间。如果你的类没有静态构造函数，C#保证在访问类中的字段之前运行字段初始化器，但不一定等到最后一刻——它保留在喜欢的任何时间运行字段初始化器的权利。（这一切发生的确切时机在不同版本的.NET中有所不同。）但是如果存在静态构造函数，情况稍微清晰些：静态字段初始化器会在静态构造函数运行之前立即执行，但这只是提出了一个问题：什么是静态构造函数，以及它何时运行？所以我们最好看一下构造函数。
- en: Constructors
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构造函数
- en: A newly created object may require some information to do its job. For example,
    the `Uri` class in the `System` namespace represents a *Uniform Resource Identifier*
    (URI) such as a URL. Since its entire purpose is to contain and provide information
    about a URI, there wouldn’t be much point in having a `Uri` object that didn’t
    know what its URI was. So it’s not actually possible to create one without providing
    a URI. If you try the code in [Example 3-35](#error_failing_to_provide_a_uri_with_its),
    you’ll get a compiler error.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 新创建的对象可能需要一些信息来完成其工作。例如，`System`命名空间中的`Uri`类表示统一资源标识符（URI），如URL。由于它的整个目的是包含并提供关于URI的信息，因此如果一个`Uri`对象不知道其URI是什么，那么创建它就没有多大意义。因此，不提供URI的情况下是不可能创建一个`Uri`对象的。如果尝试运行[示例 3-35](#error_failing_to_provide_a_uri_with_its)，将会得到编译器错误。
- en: 'Example 3-35\. Error: failing to provide a `Uri` with its URI'
  id: totrans-243
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-35\. 错误：未提供带有其URI的`Uri`
- en: '[PRE41]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The `Uri` class defines several *constructors*, members that contain code that
    initializes a new instance of a type. If a particular class requires certain information
    to work, you can enforce this requirement through constructors. Creating an instance
    of a class almost always involves using a constructor at some point, so if the
    constructors you define all demand certain information, developers will have to
    provide that information if they want to use your class. So all of the `Uri` class’s
    constructors need to be given the URI in one form or another.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '`Uri`类定义了多个*构造函数*，这些成员包含初始化类型的新实例的代码。如果某个类需要特定信息才能工作，你可以通过构造函数来强制执行这一要求。几乎总是在创建一个类的实例时会使用构造函数，因此如果你定义的所有构造函数都要求某些信息，那么开发人员在想要使用你的类时就必须提供这些信息。因此，`Uri`类的所有构造函数都需要以某种形式提供URI。'
- en: 'To define a constructor, you first specify the accessibility (`public`, `private`,
    `internal`, etc.) and then the name of the containing type. This is followed by
    a list of parameters in parentheses (which can be empty). [Example 3-36](#class_with_one_constructor)
    shows a class that defines a single constructor that requires two arguments: one
    of type `decimal` and one of type `string`. The argument list is followed by a
    block containing code. So constructors look a lot like methods but with the containing
    type name in place of the usual return type and method name.'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 要定义一个构造函数，首先指定可访问性（`public`、`private`、`internal`等），然后是包含类型的名称。然后是括号中的参数列表（可以为空）。[示例 3-36](#class_with_one_constructor)展示了一个定义了单个构造函数的类，该构造函数需要两个参数：一个是`decimal`类型，另一个是`string`类型。参数列表后面是包含代码的块。因此，构造函数看起来很像方法，但其返回类型和方法名称的位置由包含类型名称代替。
- en: Example 3-36\. A class with one constructor
  id: totrans-247
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-36\. 具有一个构造函数的类
- en: '[PRE42]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'This constructor is pretty simple: it just copies its arguments to fields.
    A lot of constructors do no more than that. You’re free to put as much code in
    there as you like, but by convention, developers usually expect the constructor
    to do very little—its main job is to ensure that the object is in a valid initial
    state. That might involve checking the arguments and throwing an exception if
    there’s a problem, but not much else. You are likely to surprise developers who
    use your class if you write a constructor that does something nontrivial, such
    as adding data to a database or sending a message over the network.'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 这个构造函数非常简单：它只是将其参数复制到字段中。许多构造函数不做更多的事情。你可以在其中放置任意数量的代码，但是按照惯例，开发人员通常希望构造函数做的事情很少——其主要工作是确保对象处于有效的初始状态。这可能涉及检查参数并在出现问题时抛出异常，但不会做其他太多事情。如果你编写了一个执行非平凡操作的构造函数，比如向数据库添加数据或通过网络发送消息，可能会让使用你的类的开发人员感到惊讶。
- en: '[Example 3-37](#using_a_constructor) shows how to use the constructor defined
    by [Example 3-36](#class_with_one_constructor). We just use the `new` operator,
    passing in suitably typed values as arguments.'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 3-37](#using_a_constructor)展示了如何使用[示例 3-36](#class_with_one_constructor)定义的构造函数。我们只需使用`new`运算符，并适当地传递类型匹配的值作为参数。'
- en: Example 3-37\. Using a constructor
  id: totrans-251
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-37\. 使用构造函数
- en: '[PRE43]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'You can define multiple constructors, but it must be possible to distinguish
    between them: you cannot define two constructors that both take the same number
    of arguments of the same types, because there would be no way for the `new` keyword
    to know which one you meant.'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以定义多个构造函数，但必须能够区分它们：不能定义两个构造函数，它们都接受相同数量和类型的参数，因为`new`关键字无法知道你指的是哪一个。
- en: Earlier, I showed how a record type can require certain properties to be present.
    [Example 3-38](#record_type_generated_constructor) shows a `record` similar to
    the `Item` class from [Example 3-36](#class_with_one_constructor) (although this
    makes the relevant data public). When you do this, you are in effect defining
    a constructor.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 早些时候，我展示了记录类型如何要求某些属性必须存在。[示例 3-38](#record_type_generated_constructor)展示了一个类似于[示例 3-36](#class_with_one_constructor)中`Item`类的`record`（尽管这会使相关数据公开）。这样做实际上是在定义一个构造函数。
- en: Example 3-38\. Record type with compiler-generated constructors
  id: totrans-255
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-38\. 使用编译器生成的构造函数的记录类型
- en: '[PRE44]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: With this example, the compiler will emit a constructor taking a `decimal` and
    a `string` argument. The generated constructor will use those arguments to initialize
    the `Price` and `Name` properties. As you saw earlier in [Example 3-13](#mutable_record_type),
    you’re free to supply your own constructor if you want to, but in cases where
    the compiler-generated one does what you need, it’s very convenient. This is not
    the only kind of constructor that the compiler can generate for you.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此示例，编译器将生成一个接受`decimal`和`string`参数的构造函数。生成的构造函数将使用这些参数来初始化`Price`和`Name`属性。正如您之前在[示例 3-13](#mutable_record_type)中看到的，如果需要，您可以自己提供构造函数，但在编译器生成的构造函数能够满足需求的情况下，这非常方便。这并不是编译器为您可以生成的唯一类型的构造函数。
- en: Default constructors and zero-argument constructors
  id: totrans-258
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 默认构造函数和零参数构造函数
- en: If you do not define any constructors at all, C# will provide a *default constructor*
    that is equivalent to an empty constructor that takes no arguments. And if you’re
    writing a struct, you’ll get that even if you do define other constructors.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您根本不定义任何构造函数，C#将提供一个*默认构造函数*，它相当于一个不带参数的空构造函数。如果您编写的是结构体，即使您定义了其他构造函数，也会得到这个默认构造函数。
- en: Note
  id: totrans-260
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Although the C# specification unambiguously defines a default constructor as
    one generated for you by the compiler, be aware that there’s another widely used
    meaning. You will often see the term *default constructor* used to mean any public,
    parameterless constructor, regardless of whether it was generated by the compiler.
    There’s some logic to this—when using a class, it’s not possible to tell the difference
    between a compiler-generated constructor and an explicit zero-argument constructor,
    so if the term *default constructor* is to mean anything useful from that perspective,
    it can mean only a public constructor that takes no arguments. However, that’s
    not how the C# specification defines the term.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管C#规范明确定义了默认构造函数是由编译器为您生成的构造函数，但请注意还有另一种广泛使用的含义。您经常会看到术语*默认构造函数*用于指任何公共的无参数构造函数，不管它是由编译器生成的还是显式定义的。从这个角度来看，这也有一些逻辑——当使用一个类时，无法区分编译器生成的构造函数和显式的零参数构造函数，因此，如果术语*默认构造函数*要从这个角度上有任何有用的含义，它只能指一个公共的不带参数的构造函数。然而，这并不是C#规范定义的术语含义。
- en: The compiler-generated default constructor does nothing beyond the zero initialization
    of fields, which is the starting point for all new objects. However, there are
    some situations in which it is necessary to write your own parameterless constructor.
    You might need the constructor to execute some code. [Example 3-39](#nonempty_zero-argument_constructor)
    sets an `_id` field based on a static field that it increments for each new object
    to give each instance a distinct ID. This doesn’t require any arguments to be
    passed in, but it does involve running some code.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器生成的默认构造函数除了对字段进行零初始化外，什么也不做，这是所有新对象的起始点。然而，在某些情况下，编写自己的无参数构造函数是必要的。您可能需要构造函数来执行一些代码。[示例 3-39](#nonempty_zero-argument_constructor)根据一个静态字段设置了`_id`字段，该字段在每个新对象中递增，以使每个实例具有不同的ID。这不需要传入任何参数，但确实涉及运行一些代码。
- en: Example 3-39\. A nonempty zero-argument constructor
  id: totrans-263
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-39\. 非空的零参数构造函数
- en: '[PRE45]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'There is another way to achieve the same effect as [Example 3-39](#nonempty_zero-argument_constructor).
    I could have written a static method called `GetNextId`, and then used that in
    the `_id` field initializer. Then I wouldn’t have needed to write this constructor.
    However, there is one advantage to putting code in the constructor: field initializers
    are not allowed to invoke the object’s own nonstatic methods but constructors
    are. That’s because the object is in an incomplete state during field initialization,
    so it may be dangerous to call its nonstatic methods—they may rely on fields having
    valid values. But an object is allowed to call its own nonstatic methods inside
    a constructor, because although the object’s still not fully built yet, it’s closer
    to completion, and so the dangers are reduced.'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一种方法可以实现与[示例 3-39](#nonempty_zero-argument_constructor)相同的效果。我本可以编写一个名为`GetNextId`的静态方法，并在`_id`字段的初始化器中使用它。那么我就不需要编写这个构造函数了。然而，将代码放在构造函数中有一个优势：字段初始化器不允许调用对象自身的非静态方法，但构造函数可以。这是因为在字段初始化期间，对象处于不完全状态，调用其非静态方法可能是危险的——它们可能依赖于字段具有有效值。但对象允许在构造函数中调用自己的非静态方法，因为尽管对象仍未完全构建，但它更接近完成状态，因此风险减少了。
- en: There are other reasons for writing your own zero-argument constructor. If you
    define at least one constructor for a class, this will disable the default constructor
    generation. If you need your class to provide parameterized construction, but
    you still want to offer a no-arguments constructor, you’ll need to write one,
    even if it’s empty. Alternatively, if you want to write a class whose only constructor
    is an empty, zero-argument one, but with a protection level other than the default
    of `public`—you might want to make it `private` so that only your code can create
    instances, for example—you would need to write the constructor explicitly even
    if it is empty so that you have somewhere to specify the protection level.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 编写自己的零参数构造函数还有其他原因。如果你为一个类定义了至少一个构造函数，这将禁用默认的构造函数生成。如果你的类需要提供带参数的构造，但仍希望提供一个无参数的构造函数，即使是空的，你也需要编写一个。或者，如果你想编写一个类，其唯一的构造函数是一个空的、零参数的构造函数，但访问级别不是默认的`public`，比如你可能想将其设置为`private`，以便只有你的代码可以创建实例，那么即使它是空的，你也需要显式地编写这个构造函数以便指定访问级别。
- en: Note
  id: totrans-267
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Some frameworks can use only classes that provide a public, zero-argument constructor.
    For example, if you build a UI with Windows Presentation Foundation (WPF), classes
    that can act as custom UI elements usually need such a constructor.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 有些框架只能使用提供公共的、零参数构造函数的类。例如，如果你用 Windows Presentation Foundation (WPF) 构建用户界面，那些可以作为自定义
    UI 元素的类通常需要这样的构造函数。
- en: 'With structs, zero-argument constructors work slightly differently, because
    value types need to support implicit initialization. When a value type is used
    as a field of some other type, or the element type of an array, the memory that
    holds the value is part of the containing object, and when you create a new object
    or array, the CLR always fills its memory with zeros. This means that it is always
    possible to initialize a value without passing any constructor arguments. So whereas
    C# removes the default constructor for a class when you add a constructor that
    takes arguments, it does not do this for a struct (including `record struct` types)—even
    if it did hide it, you’d still be able to invoke this implicit initialization
    indirectly, e.g., by creating a one-element array of that type: `MyStruct s =
    (new MyStruct[1])[0];`. Since implicit initialization is always available for
    a struct, there would be no sense in the compiler hiding the corresponding constructor.'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 对于结构体，零参数构造函数的工作方式略有不同，因为值类型需要支持隐式初始化。当值类型用作其他类型的字段或数组的元素类型时，保存值的内存是包含对象的一部分，当你创建一个新的对象或数组时，CLR
    总是将其内存填充为零。这意味着始终可以初始化一个值而不需要传递任何构造函数参数。因此，尽管在类中添加了带参数的构造函数会移除默认构造函数，但对于结构体（包括`record
    struct`类型），C# 并不会这样做——即使它隐藏了它，你仍然可以间接调用这种隐式初始化，例如通过创建该类型的单元素数组：`MyStruct s = (new
    MyStruct[1])[0];`。由于结构体始终支持隐式初始化，编译器隐藏相应的构造函数就没有意义了。
- en: 'Up until C# 10.0, you weren’t allowed to write a zero-argument constructor
    for a struct because there are so many scenarios in which that constructor would
    not run. (This is the same reason that structs didn’t use to support instance
    field initializers: it’s essentially the same issue because field initializers
    run as part of construction.) You can now write a zero-argument constructor for
    a struct, but as with field initializers, be aware that it will only run in cases
    where your code explicitly invokes the constructor. The CLR’s zero initialization
    is used in most cases.'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 直到C# 10.0，你不允许为`struct`编写零参数构造函数，因为存在许多情况下该构造函数不会运行。（这与`struct`以前不支持实例字段初始化器的原因相同：本质上是相同的问题，因为字段初始化器作为构造的一部分运行。）现在你可以为`struct`编写零参数构造函数了，但与字段初始化器一样，要注意它只会在你的代码明确调用构造函数的情况下运行。CLR的零初始化在大多数情况下被使用。
- en: 'There’s one more important compiler-generated constructor type to be aware
    of: when you write a `record` or `record class`, the compiler generates a constructor
    that gets used to create a duplicate whenever you use the `with` syntax shown
    back in [Example 3-12](#modified_copy_of_record_type). (This is known as a *copy
    constructor*, although if you’re familiar with C++, don’t be misled: this is used
    only within `record` types and is not a general-purpose copy mechanism. C# has
    no support for using a copy constructor in an ordinary class.) It performs a shallow
    copy by default, much as you get when copying a `struct`, but if you want to,
    you can write your own implementation, as [Example 3-40](#record_custom_copy_constructor)
    shows.'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一种重要的由编译器生成的构造函数类型需要注意：当你编写一个`record`或`record class`时，编译器生成一个构造函数，用于在使用[示例 3-12](#modified_copy_of_record_type)中展示的`with`语法创建副本时使用。（这被称为*拷贝构造函数*，尽管如果你熟悉C++，不要被误导：这仅在`record`类型内部使用，不是通用的拷贝机制。C#不支持在普通类中使用拷贝构造函数。）它默认执行浅拷贝，就像复制`struct`时一样，但如果你愿意，你可以写自己的实现，就像[示例 3-40](#record_custom_copy_constructor)展示的那样。
- en: Example 3-40\. Record type with customized copy constructor
  id: totrans-272
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-40\. 带有自定义拷贝构造函数的记录类型
- en: '[PRE46]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: This prevents the compiler from generating the usual copy constructor. Yours
    will be used whenever the `with` syntax causes a copy of your type to be created.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以防止编译器生成通常的拷贝构造函数。你的构造函数将在`with`语法导致创建类型副本时使用。
- en: The compiler does not generate a copy constructor for a `record struct`. There’s
    no need, because all `struct` types are inherently copyable. And although nothing
    stops you from writing a constructor similar to the one in [Example 3-40](#record_custom_copy_constructor)
    for a `record struct`, the compiler will not use it.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器不会为`record struct`生成拷贝构造函数。这是没有必要的，因为所有`struct`类型都是内部可复制的。虽然你可以写一个类似[示例 3-40](#record_custom_copy_constructor)中的构造函数给`record
    struct`，但编译器不会使用它。
- en: Chaining constructors
  id: totrans-276
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 链接构造函数
- en: If you write a type that offers several constructors, you may find that they
    have a certain amount in common—there are often initialization tasks that all
    constructors have to perform. The class in [Example 3-39](#nonempty_zero-argument_constructor)
    calculates a numeric identifier for each object in its constructor, and if it
    were to provide multiple constructors, they might all need to do that same work.
    Moving the work into a field initializer would be one way to solve that, but what
    if only some constructors wanted to do it? You might have work that was common
    to most constructors, but you might want to make an exception by having one constructor
    that allows the ID to be specified rather than calculated. The field initializer
    approach would no longer be appropriate, because you’d want individual constructors
    to be able to opt in or out. [Example 3-41](#optional_chaining_of_constructors)
    shows a modified version of the code from [Example 3-39](#nonempty_zero-argument_constructor),
    defining two extra constructors.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你编写的类型提供了多个构造函数，你可能会发现它们有一些共同之处——通常都有一些初始化任务需要执行。在[示例 3-39](#nonempty_zero-argument_constructor)中的类在其构造函数中为每个对象计算一个数值标识符，如果它提供多个构造函数，它们可能都需要执行相同的工作。将这项工作移到字段初始化程序中是一种解决方法，但如果只有一些构造函数想要执行它呢？你可能有一些对大多数构造函数通用的工作，但你可能希望通过允许某个构造函数允许指定ID而不是计算来进行例外。字段初始化程序的方法就不再合适了，因为你希望各个构造函数可以选择加入或退出。[示例 3-41](#optional_chaining_of_constructors)展示了从[示例 3-39](#nonempty_zero-argument_constructor)修改后的代码，定义了两个额外的构造函数。
- en: Example 3-41\. Optional chaining of constructors
  id: totrans-278
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-41\. 构造函数的可选链接
- en: '[PRE47]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: If you look at the second constructor in [Example 3-41](#optional_chaining_of_constructors),
    its parameter list is followed by a colon and then `this()`, which invokes the
    first constructor. A constructor can invoke any other constructor that way. [Example 3-42](#chained_constructor_arguments)
    shows a different way to structure all three constructors, illustrating how to
    pass arguments.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看[示例 3-41](#optional_chaining_of_constructors)中的第二个构造函数，其参数列表后面跟着一个冒号，然后是`this()`，它调用第一个构造函数。构造函数可以以这种方式调用任何其他构造函数。[示例 3-42](#chained_constructor_arguments)展示了不同的结构化所有三个构造函数的方式，演示了如何传递参数。
- en: Example 3-42\. Chained constructor arguments
  id: totrans-281
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-42\. 链式构造函数参数
- en: '[PRE48]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The two-argument constructor here is now the only one that actually does any
    work. The other constructors just pick suitable arguments for that main constructor.
    This is arguably a cleaner solution than the previous examples, because the work
    of initializing the fields is done in just one place, rather than having different
    constructors each performing their own smattering of field initialization.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的两参数构造函数现在是唯一实际执行任何工作的构造函数。其他构造函数只是为该主构造函数选择合适的参数。这可以说是比前面的例子更清晰的解决方案，因为初始化字段的工作只在一个地方完成，而不是每个构造函数都执行自己的字段初始化。
- en: Notice that I’ve made the two-argument constructor in [Example 3-42](#chained_constructor_arguments)
    `private`. At first glance, it can look a bit odd to define a way of building
    an instance of a class and then make it inaccessible, but it makes perfect sense
    when chaining constructors. And there are other scenarios in which a private constructor
    might be useful—we might want to write a method that makes a clone of an existing
    `ItemWithId`, in which case that constructor would be useful, but by keeping it
    private, we retain control of exactly how new objects get created. It can sometimes
    even be useful to make all of a type’s constructors `private`, forcing users of
    the type to go through what’s sometimes called a *factory method* (a `static`
    method that creates an object) to get hold of an instance. There are two common
    reasons for doing this. One is if full initialization of the object requires additional
    work of a kind that is inadvisable in a constructor (e.g., if you need to do slow
    work that uses the asynchronous language features described in [Chapter 17](ch17.xhtml#ch_asynchronous_language_features),
    you cannot put that code inside a constructor). Another is if you want to use
    inheritance (see [Chapter 6](ch06.xhtml#ch_inheritance)) to provide multiple variations
    on a type, but you want to be able to decide at runtime which particular type
    is returned.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我已经将[示例 3-42](#chained_constructor_arguments)中的两参数构造函数设为`private`。乍一看，定义一个创建类实例的方法然后将其设为不可访问可能看起来有些奇怪，但在链式构造函数中这是完全合理的。而且，在其他场景中私有构造函数可能也很有用
    —— 我们可能想写一个方法来创建一个现有的`ItemWithId`的克隆，在这种情况下该构造函数将很有用，但通过将其设为私有，我们保留了如何创建新对象的控制权。有时甚至将类型的所有构造函数都设为`private`也可能很有用，强制类型的用户通过所谓的*工厂方法*（一个创建对象的`static`方法）获取实例。这样做的两个常见原因是：一是如果对象的完全初始化需要额外的工作，这种工作不适合在构造函数中执行（例如，如果需要使用第17章描述的异步语言特性进行缓慢的工作，那么不能将该代码放在构造函数中）。另一个原因是如果想要使用继承（见第6章）为类型提供多个变体，但希望在运行时决定返回哪个具体类型。
- en: Static constructors
  id: totrans-285
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 静态构造函数
- en: The constructors we’ve looked at so far run when a new instance of an object
    is created. Classes and structs can also define a static constructor. This runs
    at most once in the lifetime of the application. You do not invoke it explicitly—C#
    ensures that it runs automatically at some point before you first use the class.
    So, unlike an instance constructor, there’s no opportunity to pass arguments.
    Since static constructors cannot take arguments, there can be only one per class.
    Also, because these are never accessed explicitly, you do not declare any kind
    of accessibility for a static constructor. [Example 3-43](#class_with_static_constructor)
    shows a class with a static constructor.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止我们看过的构造函数在创建对象的新实例时运行。类和结构体也可以定义静态构造函数。这在应用程序的生命周期中最多运行一次。你不需要显式调用它 ——
    C# 会在你首次使用类之前的某个时刻自动运行它。因此，不像实例构造函数，没有传递参数的机会。由于静态构造函数不能接受参数，每个类只能有一个静态构造函数。而且，因为这些永远不会被显式访问，所以不需要为静态构造函数声明任何类型的可访问性。[示例 3-43](#class_with_static_constructor)展示了一个带有静态构造函数的类。
- en: Example 3-43\. Class with static constructor
  id: totrans-287
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-43\. 带有静态构造函数的类
- en: '[PRE49]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Just as an instance constructor puts the instance into a useful initial state,
    the static constructor provides an opportunity to initialize any static fields.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 就像实例构造函数将实例置于有用的初始状态一样，静态构造函数提供了初始化任何静态字段的机会。
- en: By the way, you’re not obliged to ensure that a constructor (static or instance)
    initializes every field. When a new instance of a class is created, the instance
    fields are initially all set to 0 (or the equivalent, such as `false` or `null`).
    Likewise, a type’s static fields are all zeroed out before the class is first
    used. Unlike with local variables, you only need to initialize fields if you want
    to set them to something other than the default zero-like value.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，你不必确保构造函数（静态或实例）初始化每个字段。当创建类的新实例时，实例字段最初都设置为0（或等效值，如`false`或`null`）。同样，类型的静态字段在类首次使用之前都被清零。与局部变量不同，你只需要初始化字段，如果你希望将它们设置为与默认的零值不同的值。
- en: Even then, you may not need a constructor. A field initializer may be sufficient.
    However, it’s useful to know exactly when constructors and field initializers
    run. I mentioned earlier that the behavior varies according to whether constructors
    are present, so now that we’ve looked at constructors in a bit more detail, I
    can finally show a more complete picture of initialization. (There will still
    be more to come—as [Chapter 6](ch06.xhtml#ch_inheritance) describes, inheritance
    adds another dimension.)
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 即便如此，你可能并不需要构造函数。字段初始化程序可能已经足够了。然而，了解构造函数和字段初始化程序运行的确切时间是很有用的。我之前提到过行为因构造函数的存在而有所不同，所以现在我们稍微详细看过构造函数之后，我终于可以展示初始化的更完整的图片了。（还会有更多内容—正如[第6章](ch06.xhtml#ch_inheritance)所描述的，继承添加了另一个维度。）
- en: At runtime, a type’s static fields will first be set to 0 (or equivalent values).
    Next, the field initializers run in the order in which they are written in the
    source file. This ordering matters if one field’s initializer refers to another.
    In [Example 3-44](#significant_ordering_of_static_fields), fields `a` and `c`
    both have the same initializer expression, but they end up with different values
    (1 and 42, respectively) due to the order in which initializers run.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行时，类型的静态字段将首先设置为0（或等效值）。接下来，字段初始化程序按照它们在源文件中编写的顺序运行。如果一个字段的初始化程序引用另一个字段，这种顺序很重要。在[示例3-44](#significant_ordering_of_static_fields)中，字段`a`和`c`都有相同的初始化表达式，但由于初始化程序运行的顺序不同，它们最终具有不同的值（分别是1和42）。
- en: Example 3-44\. Significant ordering of static fields
  id: totrans-293
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-44\. 静态字段的重要顺序
- en: '[PRE50]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The exact moment at which static field initializers run depends on whether
    there’s a static constructor. As mentioned earlier, if there isn’t, then the timing
    is not defined—C# guarantees to run them no later than the first access to one
    of the type’s fields, but it reserves the right to run them arbitrarily early.
    The presence of a static constructor changes matters: in that case, the static
    field initializers run immediately before the constructor. So when does the constructor
    run? It will be triggered by one of two events, whichever occurs first: creating
    an instance or accessing any static member of the class.'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 静态字段初始化程序确切的运行时刻取决于是否有静态构造函数。如前所述，如果没有，那么时机未定义—C#保证在访问类型的字段之前运行它们，但保留任意早地运行它们的权利。静态构造函数的存在改变了情况：在这种情况下，静态字段初始化程序会在构造函数之前立即运行。那么构造函数何时运行呢？它将由两个事件中的任意一个触发，哪个事件先发生：创建一个实例或访问类的任何静态成员。
- en: 'For nonstatic fields, the story is similar: the fields are first all initialized
    to 0 (or equivalent values), and then field initializers run in the order in which
    they appear in the source file, and this happens before the constructor runs.
    The difference is that instance constructors are invoked explicitly, so it’s clear
    when this initialization occurs.'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 对于非静态字段，情况类似：字段首先全部初始化为0（或等效值），然后字段初始化程序按照它们在源文件中出现的顺序运行，这发生在构造函数运行之前。不同之处在于实例构造函数是显式调用的，因此清楚这种初始化发生的时机。
- en: I’ve written a class called `InitializationTestClass` designed to illustrate
    this construction behavior, shown in [Example 3-45](#initialization_order). The
    class has both static and nonstatic fields, all of which call a method, `GetValue`,
    in their initializers. That method always returns the same value, 1, but it prints
    out a message so we can see when it is called. The class also defines a no-arguments
    instance constructor and a static constructor, both of which print out messages.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 我编写了一个名为 `InitializationTestClass` 的类，旨在说明这种构造行为，显示在 [示例 3-45](#initialization_order)
    中。该类既有静态字段也有非静态字段，它们的初始化器都调用一个名为 `GetValue` 的方法。该方法始终返回相同的值 1，但会打印出一条消息，以便我们能够看到它何时被调用。该类还定义了一个无参数的实例构造函数和一个静态构造函数，它们都打印出消息。
- en: Example 3-45\. Initialization order
  id: totrans-298
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-45\. 初始化顺序
- en: '[PRE51]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The `Main` method prints out a message, calls a static method defined by `Ini⁠tia⁠liz⁠ati⁠on​Tes⁠tCla⁠ss`,
    and then constructs a couple of instances. Running the program, I see the following
    output:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '`Main` 方法打印出一个消息，调用由 `Ini⁠tia⁠liz⁠ati⁠on​Tes⁠tCla⁠ss` 定义的静态方法，然后构造几个实例。运行程序时，我看到以下输出：'
- en: '[PRE52]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Notice that both static field initializers and the static constructor run before
    the call to the static method (`Foo`) begins. The field initializers run before
    the static constructor, and as expected, they run in the order in which they appear
    in the source file. Because this class includes a static constructor, we know
    when static initialization will begin—it is triggered by the first use of that
    type, which in this example is when our `Main` method calls `InitializationTestClass.Foo`.
    You can see that it happens immediately before that point and no earlier, because
    our `Main` method manages to print out its first message before the static initialization
    occurs. If this example did not have a static constructor, and had only static
    field initializers, there would be no guarantee that static initialization would
    happen at the exact same point; the C# specification allows the initialization
    to happen earlier.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，静态字段的初始化器和静态构造函数都会在调用静态方法（`Foo`）之前运行。字段的初始化器在静态构造函数之前运行，而且按照它们在源文件中出现的顺序运行，这是预期的行为。因为这个类包含一个静态构造函数，我们知道静态初始化将在何时开始——它是由该类型的第一次使用触发的，例如本例中当我们的
    `Main` 方法调用 `InitializationTestClass.Foo` 时。你可以看到它恰好在这一点之前发生，而且不会更早，因为我们的 `Main`
    方法成功打印出了它的第一个消息，然后静态初始化才发生。如果这个示例没有静态构造函数，只有静态字段的初始化器，那么不能保证静态初始化将在完全相同的点发生；C#
    规范允许初始化发生得更早。
- en: 'You need to be careful about what you do in code that runs during static initialization:
    it may run earlier than you expect. For example, suppose your program uses some
    sort of diagnostic logging mechanism, and you need to configure this when the
    program starts in order to enable logging of messages to the proper location.
    There’s always a possibility that code that runs during static initialization
    could execute before you’ve managed to do this, meaning that diagnostic logging
    will not yet be working correctly. That might make problems in this code hard
    to debug. Even when you narrow down C#’s options by supplying a static constructor,
    it’s relatively easy to run that earlier than you intended. Use of any static
    member of a class will trigger its initialization, and you can find yourself in
    a situation where your static constructor is kicked off by static field initializers
    in some other class that doesn’t have a static constructor—this could happen before
    your `Main` method even starts.'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 在静态初始化期间运行的代码需要小心：它可能比你预期的要早。例如，假设您的程序使用某种诊断日志记录机制，并且您需要在程序启动时配置它以便将消息记录到正确的位置。静态初始化期间运行的代码有可能在您成功执行此操作之前就开始执行，这意味着诊断日志记录可能还不起作用。这可能会使得调试这段代码变得困难。即使通过提供静态构造函数来缩小
    C# 的选项，也很容易比您打算的更早运行它。使用类的任何静态成员都会触发其初始化，您可能会发现自己处于一个情况中，其中您的静态构造函数是由其他没有静态构造函数的类中的静态字段初始化器触发的——这可能发生在您的
    `Main` 方法开始之前。
- en: 'You could try to fix this by initializing the logging code in its own static
    initialization. Because C# guarantees to run initialization before the first use
    of a type, you might think that this would ensure that the logging initialization
    would complete before the static initialization of any code that uses the logging
    system. However, there’s a potential problem: C# guarantees only when it will
    *start* static initialization for any particular class. It doesn’t guarantee to
    wait for it to finish. It cannot make such a guarantee, because if it did, code
    such as the peculiarly British [Example 3-46](#circular_static_dependencies) would
    put it in an impossible situation.'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以尝试通过将其自己的静态初始化代码初始化为日志记录代码来修复此问题。因为 C# 保证在类型的第一次使用之前运行初始化，您可能会认为这将确保在任何使用日志记录系统的代码的静态初始化完成之前，日志记录初始化将完成。然而，这里有一个潜在的问题：C#
    仅保证何时开始对任何特定类的静态初始化。它不保证等待它完成。它无法作出这样的保证，因为如果这样做，像异常的英国示例 3-46这样的代码会使其处于不可能的情况中。
- en: Example 3-46\. Circular static dependencies
  id: totrans-305
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-46\. 循环静态依赖
- en: '[PRE53]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'There is a circular relationship between the two types in this example: both
    have static constructors that attempt to use a static field defined by the other
    class. The behavior will depend on which of these two classes the program tries
    to use first. In a program that uses `AfterYou` first, I see the following output:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，这两种类型之间存在循环依赖关系：它们都有试图使用另一个类定义的静态字段的静态构造函数。行为将取决于程序首先尝试使用这两个类中的哪一个。在一个首先使用
    `AfterYou` 的程序中，我看到以下输出：
- en: '[PRE54]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: As you’d expect, the static constructor for `AfterYou` runs first, because that’s
    the class my program is trying to use. It prints out its first message, but then
    it tries to use the `NoAfterYou.Value` field. That means the static initialization
    for `NoAfterYou` now has to start, so we see the first message from its static
    constructor. It then goes on to retrieve the `AfterYou.Value` field, even though
    the `AfterYou` static constructor hasn’t finished yet. (It retrieved the value
    set by the field initializer, 42, and not the value set by the static constructor,
    123.) That’s allowed, because the ordering rules say only when static initialization
    is triggered, and they do not guarantee when it will finish. If they tried to
    guarantee complete initialization, this code would be unable to proceed—the `NoAfterYou`
    static constructor could not move forward, because the `AfterYou` static construction
    is not yet complete, but that couldn’t move forward, because it would be waiting
    for the `NoAfterYou` static initialization to finish.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所预期的那样，`AfterYou` 的静态构造函数首先运行，因为这是我的程序要使用的类。它打印出第一条消息，但然后它尝试使用 `NoAfterYou.Value`
    字段。这意味着现在必须开始 `NoAfterYou` 的静态初始化，因此我们看到它的静态构造函数的第一条消息。然后它继续检索 `AfterYou.Value`
    字段，尽管 `AfterYou` 的静态构造函数还没有完成。（它检索了字段初始化器设置的值 42，并不是静态构造函数设置的值 123。）这是允许的，因为排序规则只有在触发静态初始化时才有效，并且它们不保证何时完成。如果它们试图保证完整初始化，这段代码将无法继续进行——`NoAfterYou`
    的静态构造函数无法继续前进，因为 `AfterYou` 的静态构造尚未完成，但这不能前进，因为它将等待 `NoAfterYou` 的静态初始化完成。
- en: The moral of this story is that you should not get too ambitious about what
    you try to achieve during static initialization. It can be hard to predict the
    exact order in which things will happen.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 这个故事的寓意是，您不应该对静态初始化期间尝试实现的目标过于雄心勃勃。很难预测事情发生的确切顺序。
- en: Tip
  id: totrans-311
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 小贴士
- en: The `Microsoft.Extensions.Hosting` NuGet package provides a much better way
    to handle initialization problems with its `HostBuilder` class. It is beyond the
    scope of this chapter, but it is well worth finding and exploring.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '`Microsoft.Extensions.Hosting` NuGet 包通过其 `HostBuilder` 类提供了处理初始化问题的更好方法。这超出了本章的范围，但是找到并探索它是非常值得的。'
- en: Deconstructors
  id: totrans-313
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解构器
- en: In [Chapter 2](ch02.xhtml#ch_basic_coding), we saw how to deconstruct a tuple
    into its component parts, but deconstruction is not just for tuples. You can enable
    deconstruction for any type you write by adding a suitable `Deconstruct` member,
    as shown in [Example 3-47](#enabling_deconstruction).
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第二章](ch02.xhtml#ch_basic_coding)中，我们看到了如何将元组解构为其组件部分，但解构不仅适用于元组。通过添加适当的 `Deconstruct`
    成员，您可以为任何您编写的类型启用解构，如[示例 3-47](#enabling_deconstruction)所示。
- en: Example 3-47\. Enabling deconstruction
  id: totrans-315
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-47\. 启用解构
- en: '[PRE55]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: C# recognizes this convention of a method named `Deconstruct` with a list of
    `out` arguments (the next section will describe `out` in more detail) and enables
    you to use the same deconstruction syntax as you can with tuples. [Example 3-48](#using_custom_deconstruction)
    uses this to extract the component values of a `Size` to enable it to express
    succinctly the calculation it performs.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: C#识别了具有`out`参数列表的名为`Deconstruct`的方法的约定（下一节将更详细描述`out`），并使您能够像对元组一样使用相同的解构语法。[Example 3-48](#using_custom_deconstruction)使用这一特性提取`Size`的组件值，以使其能够简洁地表达其执行的计算。
- en: Example 3-48\. Using a custom deconstructor
  id: totrans-318
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 3-48\. 使用自定义解构器
- en: '[PRE56]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Types with a deconstructor can also use positional pattern matching. [Chapter 2](ch02.xhtml#ch_basic_coding)
    showed how you can use a syntax very similar to deconstruction in a pattern to
    match tuples. Any type with a custom deconstructor can use this same syntax. [Example 3-49](#pattern_match_custom_deconstruction)
    uses the `Size` type’s custom deconstructor to define various patterns for a `Size`
    in a switch expression.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 具有解构器的类型还可以使用位置模式匹配。[Chapter 2](ch02.xhtml#ch_basic_coding)展示了如何使用与解构非常相似的语法，在模式中匹配元组。任何具有自定义解构器的类型都可以使用相同的语法。[Example 3-49](#pattern_match_custom_deconstruction)使用`Size`类型的自定义解构器在switch表达式中定义`Size`的各种模式。
- en: Example 3-49\. Positional pattern using a custom deconstructor
  id: totrans-321
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 3-49\. 使用自定义解构器的位置模式
- en: '[PRE57]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Recall from [Chapter 2](ch02.xhtml#ch_basic_coding) that positional patterns
    are recursive: each position within the pattern contains a nested pattern. Since
    `Size` deconstructs into two elements, each positional pattern has two positions
    in which to put child patterns. [Example 3-49](#pattern_match_custom_deconstruction)
    variously uses constant patterns, a discard, and a declaration pattern.'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下[Chapter 2](ch02.xhtml#ch_basic_coding)，位置模式是递归的：模式中的每个位置包含一个嵌套模式。由于`Size`解构为两个元素，因此每个位置模式都有两个位置用于放置子模式。[Example 3-49](#pattern_match_custom_deconstruction)使用了常量模式、弃置模式和声明模式。
- en: To use a deconstructor in a pattern, C# needs to know the type to be deconstructed
    at compile time. This works in [Example 3-49](#pattern_match_custom_deconstruction)
    because the input to the switch expression is of type `Size`. If a positional
    pattern’s input is of type `object`, the compiler will presume that you’re trying
    to match a tuple instead, unless you explicitly name the type, as [Example 3-50](#pattern_match_explicit_deconstructor)
    does.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 要在模式中使用解构器，C#需要在编译时知道要解构的类型。这在[Example 3-49](#pattern_match_custom_deconstruction)中起作用，因为switch表达式的输入类型为`Size`。如果位置模式的输入类型为`object`，除非您显式命名类型，否则编译器会假定您正在尝试匹配元组，正如[Example 3-50](#pattern_match_explicit_deconstructor)所示。
- en: Example 3-50\. Positional pattern with explicit type
  id: totrans-325
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 3-50\. 具有显式类型的位置模式
- en: '[PRE58]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: If you write a `record` type (either class-based or a `record struct`) that
    uses the positional syntax, i.e., it requires certain properties to be supplied
    on initialization as [Example 3-51](#record_struct_positional_syntax) does, the
    compiler generates a `Deconstruct` method for you. So just as with a tuple, any
    `record` defined in this way is automatically deconstructable.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您编写一个`record`类型（无论是基于类的还是`record struct`），并且使用位置语法，即需要在初始化时提供特定属性，例如[Example 3-51](#record_struct_positional_syntax)，编译器会为您生成一个`Deconstruct`方法。因此，就像元组一样，以这种方式定义的任何`record`都可以自动解构。
- en: Example 3-51\. `record struct` using positional syntax
  id: totrans-328
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 3-51\. 使用位置语法的`record struct`
- en: '[PRE59]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Although the compiler provides special handling for the `Deconstruct` member
    that these examples rely on, from the runtime’s perspective, this is just an ordinary
    method. So this would be a good time to look in more detail at methods.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管编译器为这些示例依赖的`Deconstruct`成员提供了特殊处理，但从运行时的角度来看，这只是一个普通方法。因此，现在是更详细地查看方法的好时机。
- en: Methods
  id: totrans-331
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 方法
- en: '*Methods* are named bits of code that can optionally return a result and that
    may take arguments. C# makes the fairly common distinction between *parameters*
    and *arguments*: a method defines a list of the inputs it expects—the parameters—and
    the code inside the method refers to these parameters by name. The values seen
    by the code could be different each time the method is invoked, and the term *argument*
    refers to the specific value supplied for a parameter in a particular invocation.'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: '*方法*是可以选择返回结果并且可能接受参数的命名代码块。C#做了一个非常普遍的区分，即*参数*和*参数值*：方法定义了它所期望的输入列表——参数——而方法内的代码则按名称引用这些参数。代码看到的值在每次调用方法时可能不同，术语*参数值*指的是特定调用中为参数提供的特定值。'
- en: As you’ve already seen, when an accessibility specifier, such as `public` or
    `private`, is present, it appears at the start of the method declaration. The
    optional `static` keyword comes next, where present. After that, the method declaration
    states the return type. As with many C-family languages, you can write methods
    that return nothing, and you indicate this by putting the `void` keyword in place
    of the return type. Inside the method, you use the `return` keyword followed by
    an expression to specify the value for the method to return. In the case of a
    `void` method, you can use the `return` keyword without an expression to terminate
    the method, although this is optional, because when execution reaches the end
    of a `void` method, it terminates automatically. You normally only use `return`
    in a `void` method if your code decides to exit early.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您已经看到的那样，当存在诸如 `public` 或 `private` 这样的可访问性修饰符时，它出现在方法声明的开头。接下来是可选的 `static`
    关键字（如果存在）。然后，方法声明指定返回类型。与许多 C 家族语言一样，您可以编写不返回任何内容的方法，并通过将 `void` 关键字放在返回类型的位置来指示这一点。在方法内部，您使用
    `return` 关键字后跟一个表达式来指定方法返回的值。对于 `void` 方法，如果您的代码决定提前退出，可以使用 `return` 关键字而不带表达式来终止方法，尽管这是可选的，因为当执行到
    `void` 方法的末尾时，它会自动终止。通常情况下，只有在 `void` 方法中，如果您的代码决定提前退出，才会使用 `return`。
- en: Passing arguments by reference
  id: totrans-334
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过引用传递参数
- en: Methods can return only one item directly in C#. If you want to return multiple
    values, you can of course make that item a tuple. Alternatively, you can designate
    parameters as being for output rather than input. [Example 3-52](#returning_multiple_values_with_out)
    returns two values, both produced by integer division. The main return value is
    the quotient, but it also returns the remainder through its final parameter, which
    has been annotated with the `out` keyword.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C# 中，方法只能直接返回一个项。如果要返回多个值，可以将该项作为元组返回。或者，您可以将参数指定为输出而不是输入。[示例 3-52](#returning_multiple_values_with_out)
    返回两个值，都是整数除法产生的。主要返回值是商，但还通过其最后一个带有 `out` 关键字的参数返回余数。
- en: Example 3-52\. Returning multiple values with `out`
  id: totrans-336
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-52\. 使用 `out` 返回多个值
- en: '[PRE60]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Because tuples were only introduced in C# 7, whereas `out` parameters have been
    around since the start, `out` crops up a lot in class libraries in scenarios where
    tuples might have been simpler. For example, you’ll see lots of methods following
    a similar pattern to `int.TryParse`, in which the return type is a `bool` indicating
    success or failure, with the actual result being passed through an `out` parameter.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 因为元组仅在 C# 7 中引入，而 `out` 参数从一开始就存在，所以在类库中，`out` 在元组可能更简单的场景中经常出现。例如，您会看到许多方法遵循类似于
    `int.TryParse` 的模式，其中返回类型是一个 `bool`，指示成功或失败，实际结果通过 `out` 参数传递。
- en: '[Example 3-53](#out_parameter_into_new_variable) shows one way to call a method
    with an `out` parameter. Instead of supplying an expression as we do with arguments
    for normal parameters, we’ve written the `out` keyword followed by a variable
    declaration. This introduces a new variable, which becomes the argument for this
    `out` parameter. So in this case, we end up with a new variable `r` initialized
    to 1 (the remainder of the division operation).'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 3-53](#out_parameter_into_new_variable) 展示了使用 `out` 参数调用方法的一种方式。与正常参数的参数化表达式不同，我们使用
    `out` 关键字后跟一个变量声明。这引入了一个新变量，成为此 `out` 参数的参数。因此，在这种情况下，我们得到一个新的变量 `r`，初始化为1（除法运算的余数）。'
- en: Example 3-53\. Putting an `out` parameter’s result into a new variable
  id: totrans-340
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-53\. 将 `out` 参数的结果放入新变量中
- en: '[PRE61]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: A variable declared in an `out` argument follows the usual scoping rules, so
    in [Example 3-53](#out_parameter_into_new_variable), `r` will remain in scope
    for as long as `q`. Less obviously, `r` is available in the rest of the expression.
    [Example 3-54](#use_out_result_in_expression) uses this to attempt to parse some
    text as an integer, returning the parsed result if that succeeds and a fallback
    value of –1 if parsing fails.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: '`out` 参数中声明的变量遵循通常的作用域规则，因此在 [示例 3-53](#out_parameter_into_new_variable) 中，`r`
    的作用域将与 `q` 一样长。更不明显的是，`r` 在表达式的其余部分也是可用的。[示例 3-54](#use_out_result_in_expression)
    利用这一点尝试将一些文本解析为整数，如果解析成功，则返回解析结果，否则返回–1作为回退值。'
- en: Example 3-54\. Using an `out` parameter’s result in the same expression
  id: totrans-343
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-54\. 在同一表达式中使用 `out` 参数的结果
- en: '[PRE62]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: When you pass an `out` argument, this works by passing a reference to the local
    variable. When [Example 3-53](#out_parameter_into_new_variable) calls `Divide`,
    and when that method assigns a value into `remainder`, it’s really assigning it
    into the caller’s `r` variable. This is an `int`, which is a value type, so it
    would not normally be passed by reference, and this kind of reference is limited
    compared to what you can do with a reference type.^([6](ch03.xhtml#idm45884830549600))
    For example, you can’t declare a field in a class that can hold this kind of reference,
    because the local `r` variable will cease to exist when it goes out of scope,
    whereas an instance of a class can live indefinitely in a heap block. C# has to
    ensure that you cannot put a reference to a local variable in something that might
    outlive the variable it refers to.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 当传递一个 `out` 参数时，这是通过传递对局部变量的引用来实现的。当 [示例 3-53](#out_parameter_into_new_variable)
    调用 `Divide` 方法时，当该方法将值分配给 `remainder` 时，实际上是将其分配给调用者的 `r` 变量。这是一个值类型 `int`，通常不会按引用传递，这种引用与引用类型的能力相比受到限制。^([6](ch03.xhtml#idm45884830549600))
    例如，你不能声明一个类中的字段来保存这种引用，因为局部变量 `r` 在作用域结束时将会消失，而类的实例可以在堆块中永久存在。C# 必须确保你不能在可能超出变量生存期的地方放置对局部变量的引用。
- en: Warning
  id: totrans-346
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: Methods annotated with the `async` keyword (described in [Chapter 17](ch17.xhtml#ch_asynchronous_language_features))
    cannot have any `out` arguments. This is because asynchronous methods may implicitly
    return to their caller before they complete, continuing their execution some time
    later. This in turn means that the caller may also have returned before the `async`
    method runs again, in which case the variables passed by reference might no longer
    exist by the time the asynchronous code is ready to set them. The same restriction
    applies to anonymous functions (described in [Chapter 9](ch09.xhtml#ch_delegates_lambdas_events)).
    Both kinds of methods are allowed to pass `out` arguments into methods that they
    call, though.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: '`async` 关键字标注的方法（在 [第17章](ch17.xhtml#ch_asynchronous_language_features) 中描述）不能有任何
    `out` 参数。这是因为异步方法在完成之前可能会隐式返回给调用者，稍后再继续执行。这意味着调用者在 `async` 方法再次运行时可能已经返回，此时传递的引用变量可能已经不存在了。匿名函数（在
    [第9章](ch09.xhtml#ch_delegates_lambdas_events) 中描述）也适用相同的限制。这两种方法允许将 `out` 参数传递给它们调用的方法。'
- en: You won’t always want to declare a new variable for each `out` argument. As
    [Example 3-55](#existing_variable_as_out_argument) shows, you can just write `out`
    followed by the name of an existing variable. (This was once the only way to use
    `out` arguments, so you’ll sometimes see code that declares a new variable in
    a separate statement immediately before using it as an `out` argument, even though
    the form shown in [Example 3-53](#out_parameter_into_new_variable) would be simpler.)
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 并非每次都想为每个 `out` 参数声明一个新变量。如 [示例 3-55](#existing_variable_as_out_argument) 所示，你只需写上
    `out` 后面跟现有变量的名称即可。（曾经这是使用 `out` 参数的唯一方式，所以有时你会看到在使用之前另外声明一个新变量的代码，尽管 [示例 3-53](#out_parameter_into_new_variable)
    中的形式会更简单。）
- en: Example 3-55\. Putting an `out` parameter’s result into an existing variable
  id: totrans-349
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-55\. 将 `out` 参数的结果放入现有变量中
- en: '[PRE63]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Note
  id: totrans-351
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: When invoking a method with an `out` parameter, we are required to indicate
    explicitly that we are aware of how the method uses the argument. Regardless of
    whether we use an existing variable or declare a new one, we must use the `out`
    keyword at the call site as well as in the declaration.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用带有 `out` 参数的方法时，我们必须明确指出我们知道该方法如何使用这个参数。无论我们使用现有变量还是声明一个新变量，我们在调用处以及声明处都必须使用
    `out` 关键字。
- en: Sometimes you will want to invoke a method that has an `out` argument that you
    have no use for—maybe you only need the main return value. As [Example 3-56](#out_argument_discard)
    shows, you can put just an underscore after the `out` keyword. This tells C# to
    discard the result.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 有时你可能希望调用一个具有 `out` 参数的方法，而你却不需要它——也许你只需要主返回值。如 [示例 3-56](#out_argument_discard)
    所示，你可以在 `out` 关键字后面直接放一个下划线。这告诉 C# 丢弃这个结果。
- en: Example 3-56\. Discarding an `out` parameter’s result
  id: totrans-354
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-56\. 丢弃 `out` 参数的结果
- en: '[PRE64]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Tip
  id: totrans-356
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: You should avoid using `_` (a single underscore) as the name of something in
    C#, because it can prevent the compiler from interpreting it as a discard. If
    a local variable of this name is in scope, writing `out _` has, since C# 1.0,
    indicated that you want to assign an `out` result into that variable, so for backward
    compatibility, current versions of C# have to retain that behavior. You can only
    use this form of discard if there is no symbol named `_` in scope.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 在C#中应避免使用`_`（单个下划线）作为某物的名称，因为它可能会阻止编译器将其解释为丢弃。如果在范围内有名为`_`的局部变量，那么自C# 1.0以来，写入`out
    _`表明你希望将`out`结果分配给该变量，因此为了向后兼容，当前版本的C#必须保留这种行为。只有在范围内没有名为`_`的符号时，才能使用这种形式的丢弃。
- en: An `out` reference requires information to flow from the method back to the
    caller, so if you try to write a method that returns without assigning something
    into all of its `out` arguments, you’ll get a compiler error. C# uses the *definite
    assignment* rules mentioned in [Chapter 2](ch02.xhtml#ch_basic_coding) to check
    this. (This requirement does not apply if the method throws an exception instead
    of returning.) There’s a related keyword, `ref`, that has similar reference semantics
    but allows information to flow bidirectionally. With a `ref` argument, it’s as
    though the method has direct access to the variable the caller passed in—we can
    read its current value, as well as modify it. (The caller is obliged to ensure
    that variables passed with `ref` contain a value before making the call, so in
    this case, the method is not required to set it before returning.) If you call
    a method with a parameter annotated with `ref` instead of `out`, you have to make
    clear at the call site that you meant to pass a reference to a variable as the
    argument, as [Example 3-57](#calling_a_method_with_a_ref_argument) shows.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: '`out`引用需要信息从方法返回到调用者，因此如果尝试编写一个方法，在其所有`out`参数中都未分配内容的情况下返回，将会得到编译错误。C#使用[第
    2 章](ch02.xhtml#ch_basic_coding)中提到的“明确分配”规则来检查这一点。（如果方法抛出异常而不是返回，则不适用此要求。）还有一个相关的关键字`ref`，具有类似的引用语义，但允许信息双向流动。对于`ref`参数，就好像方法直接访问调用者传入的变量一样——我们可以读取其当前值，也可以修改它。（调用者必须确保在调用之前，用`ref`传递的变量包含一个值，因此在这种情况下，方法在返回前不需要设置它。）如果使用`ref`而不是`out`参数调用方法，必须在调用点清楚地表明你想要传递一个变量的引用作为参数，就像[示例
    3-57](#calling_a_method_with_a_ref_argument)展示的那样。'
- en: Example 3-57\. Calling a method with a `ref` argument
  id: totrans-359
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-57. 使用`ref`参数调用方法
- en: '[PRE65]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'There’s a third way to add a level of indirection to an argument: you can apply
    the `in` keyword. Whereas `out` only enables information to flow out of the method,
    `in` only allows it to flow in. It’s like a `ref` argument but where the called
    method is not allowed to modify the variable the argument refers to. This may
    seem redundant: if there’s no way to pass information back through the argument,
    why pass it by reference? An `in int` argument doesn’t sound usefully different
    than an ordinary `int` argument. In fact, you wouldn’t use `in` with `int`. You
    only use it with relatively large types. As you know, value types are normally
    passed by value, meaning a copy has to be made when passing a value as an argument.
    The `in` keyword enables us to avoid this copy by passing a reference instead.
    In the past, people have sometimes used the `ref` keyword to avoid making copies
    of data, but this creates a risk that the method might modify the value when the
    caller might not want that. C# 7.2 introduced `in`, giving us the same in-only
    semantics we get when passing values the normal way but with the potential efficiency
    gains of not having to pass the whole value.'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 有第三种方法可以为参数增加一层间接性：可以使用`in`关键字。`out`仅允许信息从方法中流出，而`in`则只允许信息流入。这类似于`ref`参数，但调用的方法不允许修改参数所引用的变量。这看起来可能有些多余：如果没有办法通过参数返回信息，为什么要通过引用传递呢？`in
    int`参数听起来并没有和普通的`int`参数有实质上的不同。实际上，你不会将`in`用于`int`。它只用于比较大的类型。如你所知，值类型通常是按值传递的，这意味着在传递值作为参数时需要进行复制。`in`关键字使我们可以避免通过引用而不是复制来传递参数。过去，有时候人们使用`ref`关键字来避免复制数据，但这会增加方法可能修改值的风险，而调用方可能不希望如此。C#
    7.2引入了`in`，使我们可以通过这种方式实现仅限输入的语义，与通过常规方式传递值时获得的相同效果，但有可能提高效率，因为不需要传递整个值。
- en: You should only use `in` for types that are larger than a pointer. This is why
    `in int` is not useful. An `int` is 32 bits long, so passing a reference to an
    `int` doesn’t save us anything. In a 32-bit process, that reference will be a
    32-bit pointer, so we have saved nothing, and we end up with the slight extra
    inefficiency involved in using a value indirectly through a reference. In a 64-bit
    process, the reference will be a 64-bit pointer, so we’ve ended up having to pass
    more data into the method than we would have done if we had just passed the `int`
    directly! (Sometimes the CLR can inline the method and avoid the costs of creating
    the pointer, but this means that at best `in int` would cost the same as an `int`.
    And since `in` is purely about performance, that’s why `in` is not useful for
    small types such as `int`.)
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该只在大于指针的类型上使用`in`。这就是为什么`in int`没有用处。一个`int`是32位长，所以通过引用传递`int`并没有节省任何东西。在32位进程中，该引用将是一个32位指针，因此我们什么也没节省，而且通过引用间接使用值会导致轻微的额外低效性。在64位进程中，该引用将是一个64位指针，因此我们最终必须传入比直接传递`int`更多的数据到方法中！（有时CLR可以内联方法并避免创建指针的成本，但这意味着最好情况下`in
    int`的成本与`int`相同。由于`in`完全是关于性能的，这就是为什么对于像`int`这样的小类型，`in`没有用处。）
- en: '[Example 3-58](#large_struct) defines a fairly large value type. It contains
    four `double` values, each of which is 8 bytes in size, so each instance of this
    type occupies 32 bytes. The .NET design guidelines have always recommended avoiding
    making value types this large, and the main reason for this is that passing them
    as arguments is inefficient. Older versions of C# did not support this use of
    the `in` keyword, making this guideline more important, but now that `in` can
    reduce those costs, in some cases it might make sense to define a `struct` this
    large.'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 3-58](#large_struct) 定义了一个相当大的值类型。它包含四个`double`值，每个值大小为8字节，因此该类型的每个实例占用32字节。.NET设计指南一直建议避免使值类型变得如此庞大，主要原因是将它们作为参数传递效率低下。早期版本的C#不支持`in`关键字的这种用法，使得这一指南更为重要，但现在`in`可以减少这些成本，在某些情况下定义这么大的`struct`可能是有意义的。'
- en: Example 3-58\. A large value type
  id: totrans-364
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 3-58\. 一个大值类型
- en: '[PRE66]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[Example 3-59](#method_with_in_parameter) shows a method that calculates the
    area of a rectangle represented by the `Rect` type defined in [Example 3-58](#large_struct).
    We really wouldn’t want to have to copy all 32 bytes to call this very simple
    method, especially since it only uses half of the data in the `Rect`. Since this
    method annotates its parameter with `in`, no such copying will occur: the argument
    will be passed by reference, which in practice means that only a pointer needs
    to be passed—either 4 or 8 bytes, depending on whether the code is running in
    a 32-bit or a 64-bit process.'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 3-59](#method_with_in_parameter) 展示了一个计算矩形面积的方法，该矩形由[示例 3-58](#large_struct)
    中定义的`Rect`类型表示。我们真的不想复制所有32字节来调用这个非常简单的方法，特别是因为它只使用了`Rect`中的一半数据。由于此方法用`in`标注其参数，因此不会发生此类复制：参数将通过引用传递，实际上意味着只需传递一个指针——无论代码是在32位还是64位进程中运行，其大小分别为4或8字节。'
- en: Example 3-59\. A method with an `in` parameter
  id: totrans-367
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 3-59\. 具有`in`参数的方法
- en: '[PRE67]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: You might expect that calling a method with `in` parameters would require the
    call site to indicate that it knows that the argument will be passed by reference
    by putting `in` in front of the argument, just like we need to write `out` or
    `ref` at the call site for the other two by-reference styles. And as [Example 3-60](#passing_an_in_argument)
    shows, you can do this, but it is optional. If you want to be explicit about the
    by-reference invocation, you can be, but unlike with `ref` and `out`, the compiler
    just passes the argument by reference anyway if you don’t add `in`.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会期望调用具有`in`参数的方法需要调用方指示它知道参数将通过引用传递，就像我们需要在调用点写`out`或`ref`来进行另外两种引用样式一样。正如[示例 3-60](#passing_an_in_argument)
    所示，你可以这样做，但这是可选的。如果你想明确表达通过引用调用，你可以这样做，但与`ref`和`out`不同，如果不添加`in`，编译器仍然会通过引用传递参数。
- en: Example 3-60\. Calling a method with an `in` parameter
  id: totrans-370
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 3-60\. 调用具有`in`参数的方法
- en: '[PRE68]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: The `in` keyword is optional at the call site because defining such a parameter
    as `in` is only a performance optimization that does not change the behavior,
    unlike `out` and `ref`. Microsoft wanted to make it possible for developers to
    introduce a source-level-compatible change in which an existing method is modified
    by adding `in` to a parameter. This is a breaking change at the binary level,
    but in scenarios where you can be sure people will in any case need to recompile
    (e.g., when all the code is under your control), it might be useful to introduce
    such a change for performance reasons. Of course, as with all such enhancements
    you should measure performance before and after the change to see if it has the
    intended effect.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: '`in` 关键字在调用站点是可选的，因为将参数定义为 `in` 只是一种性能优化，不会改变行为，不像 `out` 和 `ref`。微软希望开发人员能够引入源级兼容的更改，在现有方法的参数中添加
    `in`。这在二进制级别是一个破坏性变更，但在您可以确保需要重新编译的情况下（例如，当所有代码都在您的控制下时），出于性能原因引入这样的更改可能很有用。当然，像所有这样的增强功能一样，您应该在更改前后测量性能，以确定其是否产生预期的效果。'
- en: 'Although the examples just shown work as intended, `in` sets a trap for the
    unwary. It works only because I marked the `struct` in [Example 3-58](#large_struct)
    as `readonly`. If instead of defining my own `Rect` I had used the very similar-looking
    `struct` with the same name from the `System.Windows` namespace (part of the WPF
    UI framework), [Example 3-60](#passing_an_in_argument) would not avoid the copy.
    It would have compiled and produced the correct results at runtime, but it would
    not offer any performance benefit. That’s because `System.Windows.Rect` is not
    read-only. Earlier, I discussed the defensive copies that C# makes when you use
    a `readonly` field containing a mutable value type. The same principle applies
    here, because an `in` argument is in effect read-only: code that passes arguments
    expects them not to be modified unless they are explicitly marked as `out` or
    `ref`. So the compiler must ensure that `in` arguments are not modified even though
    the method being called has a reference to the caller’s variable. When the type
    in question is already read-only, the compiler doesn’t have to do any extra work.
    But if it is a mutable value type, then if the method to which this argument was
    passed in turn invokes a method on that value, the compiler generates code that
    makes a copy and invokes the method on that, because it can’t know whether the
    method might modify the value. You might think that the compiler could enforce
    this by preventing the method with the `in` parameter from doing anything that
    might modify the value, but in practice that would mean stopping it from invoking
    any methods on the value—the compiler cannot in general determine whether any
    particular method call might modify the value. (And even if it doesn’t today,
    maybe it will in a future version of the library that defines the type.) Since
    properties are methods in disguise, this makes `in` arguments more or less useless
    when used with mutable types.'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然刚才展示的示例能正常工作，但 `in` 对于不注意的人来说是个陷阱。它之所以工作，仅因为我将 [Example 3-58](#large_struct)
    中的 `struct` 标记为 `readonly`。如果我没有自己定义 `Rect`，而是使用了 `System.Windows` 命名空间（WPF UI
    框架的一部分）中同名的非常相似的 `struct`，那么 [Example 3-60](#passing_an_in_argument) 将无法避免复制。它会编译并在运行时产生正确的结果，但不会提供任何性能优势。这是因为
    `System.Windows.Rect` 不是只读的。早些时候，我讨论了当您使用包含可变值类型的 `readonly` 字段时，C# 所做的防御性拷贝。同样的原理也适用于这里，因为
    `in` 参数实际上是只读的：传递参数的代码期望它们不会被修改，除非显式标记为 `out` 或 `ref`。因此，编译器必须确保 `in` 参数不被修改，即使被调用的方法具有对调用者变量的引用。当涉及的类型已经是只读时，编译器不需要额外的工作。但如果它是一个可变的值类型，那么如果传递该参数的方法反过来调用该值的方法，编译器会生成使得拷贝并在其上调用方法的代码，因为它不能知道方法是否会修改该值。您可能认为编译器可以通过阻止具有
    `in` 参数的方法执行可能修改值的任何操作来强制执行这一点，但实际上这意味着阻止它调用该值上的任何方法——通常编译器无法确定任何特定方法调用是否可能修改值。（即使今天不会，也可能在定义类型的库的未来版本中会这样做。）由于属性本质上是方法，因此在与可变类型一起使用时，`in`
    参数或多或少是无用的。
- en: Tip
  id: totrans-374
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: You should use `in` only with `readonly` value types, because mutable value
    types can undo the performance benefits. (Mutable value types are typically a
    bad idea in any case.)
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该仅在 `readonly` 值类型中使用 `in`，因为可变值类型可能会消除性能优势。（通常来说，可变值类型本身就不是一个好主意。）
- en: C# offers a feature that can loosen this constraint a little. It allows the
    `readonly` keyword to be applied to members so that they can declare that they
    will not modify the value of which they are a member. This makes it possible to
    avoid these defensive copies on mutable values.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: C# 提供了一个功能，可以稍微放宽这个约束。它允许在成员上应用`readonly`关键字，以便它们声明不会修改它们所属的值。这样可以避免在可变值上进行这些防御性拷贝。
- en: You can use the `out` and `ref` keywords with reference types too. That may
    sound redundant, but it can be useful. It provides double indirection—the method
    receives a reference to a variable that holds a reference. When you pass a reference
    type argument to a method, that method gets access to whatever object you choose
    to pass it. While the method can use members of that object, it can’t normally
    replace it with a different object. But if you mark a reference type argument
    with `ref`, the method has access to your variable, so it could replace it with
    a reference to a completely different object.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以将`out`和`ref`关键字用于引用类型。这听起来可能多余，但它确实有用。它提供了双重间接性——方法接收一个指向保存引用的变量的引用。当您将引用类型参数传递给方法时，该方法可以访问您选择传递的任何对象。虽然方法可以使用该对象的成员，但通常不能用不同的对象替换它。但是，如果您用`ref`标记引用类型参数，方法就可以访问您的变量，因此它可以用指向完全不同对象的引用替换它。
- en: It’s technically possible for constructors to have `out` and `ref` parameters
    too, although it’s unusual. Also, just to be clear, the `out` or `ref` qualifiers
    are part of the method or constructor signature. A caller can pass an `out` (or
    `ref`) argument if and only if the parameter was declared as `out` (or `ref`).
    Callers can’t decide unilaterally to pass an argument by reference to a method
    that does not expect it.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数也可以有`out`和`ref`参数，尽管这很少见。此外，请明确，`out`或`ref`限定符是方法或构造函数签名的一部分。只有在参数声明为`out`（或`ref`）时，调用者才能传递`out`（或`ref`）参数。调用者不能单方面决定将参数按引用传递给不期望它的方法。
- en: Reference variables and return values
  id: totrans-379
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 引用变量和返回值
- en: Now that you’ve seen various ways in which you can pass a method a reference
    to a value (or a reference to a reference), you might be wondering whether you
    can get hold of these references in other ways. You can, as [Example 3-61](#ref_local)
    shows, but there are some constraints.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经看到了传递方法值的引用（或引用的引用）的各种方法，也许您想知道是否可以以其他方式获取这些引用。正如[示例 3-61](#ref_local)所示，您可以，但存在一些限制。
- en: Example 3-61\. A local `ref` variable
  id: totrans-381
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-61\. 本地`ref`变量
- en: '[PRE69]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'This example declares a variable called `rose`. It then declares a new variable
    of type `ref string`. The `ref` here has exactly the same effect as it does on
    a method parameter: it indicates that this variable is a reference to some other
    variable. Since the code initializes it with `ref rose`, the variable `rosaIndica`
    is a reference to that `rose` variable. So when the code assigns a value into
    `rosaIndica`, that value goes into the `rose` variable that `rosaIndica` refers
    to. When the final line reads the value of the `rose` variable, it will see the
    value that was written by the preceding line.'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例声明了一个名为`rose`的变量。然后它声明了一个类型为`ref string`的新变量。这里的`ref`与方法参数上的效果完全相同：它表示此变量是对另一个变量的引用。由于代码用`ref
    rose`初始化它，变量`rosaIndica`是对该`rose`变量的引用。因此，当代码向`rosaIndica`赋值时，该值将存入`rosa`引用的`rose`变量中。当最后一行读取`rose`变量的值时，它将看到前一行写入的值。
- en: So what are the constraints? C# has to ensure that you cannot put a reference
    to a local variable in something that might outlive the variable it refers to.
    So you cannot use this keyword on a field. Static fields live for as long as their
    defining type is loaded (typically until the process exits), and member fields
    of classes live on the heap enabling them to outlive any particular method call.
    (This is also true of most structs. It is not true of a `ref struct`, but even
    those do not currently support the `ref` keyword on a field.) And even in cases
    where you might think lifetime isn’t a problem (because the target of the reference
    is itself a field in an object, for example), it turns out that the runtime simply
    doesn’t support storing this kind of reference in a field, or as an element type
    in an array. More subtly, this also means you can’t use a `ref` local variable
    in a context where C# would store the variable in a class. That rules out their
    use in `async` methods and iterators and also prevents them being captured by
    anonymous functions (which are described in Chapters [17](ch17.xhtml#ch_asynchronous_language_features),
    [5](ch05.xhtml#ch_collections), and [9](ch09.xhtml#ch_delegates_lambdas_events),
    respectively).
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 那么约束条件是什么呢？C#必须确保您不能将对局部变量的引用放入可能超出其所引用的变量生存期的地方。因此，您不能在字段上使用此关键字。静态字段的生存期与其定义的类型加载时间一样长（通常直到进程退出），类的成员字段存储在堆上，使它们能够比任何特定方法调用更长寿。（大多数结构体也是如此。但是对于`ref
    struct`并非如此，即使这些结构体目前也不支持在字段上使用`ref`关键字。）即使在您认为生命周期不是问题的情况下（例如，引用的目标本身是对象中的字段），结果表明运行时根本不支持将这种引用存储在字段中或作为数组中的元素类型。更隐晦的是，这也意味着您不能在C#会将变量存储在类中的上下文中使用`ref`局部变量。这排除了它们在`async`方法和迭代器中的使用，也防止它们被匿名函数捕获（分别在第[17](ch17.xhtml#ch_asynchronous_language_features)章、[5](ch05.xhtml#ch_collections)章和[9](ch09.xhtml#ch_delegates_lambdas_events)章中描述）。
- en: Although types cannot define fields with `ref`, they can define methods that
    return a `ref`-style reference (and since properties are methods in disguise,
    a property getter may also return a reference). As always, the C# compiler has
    to ensure that a reference cannot outlive the thing it refers to, so it will prevent
    use of this feature in cases where it cannot be certain that it can enforce this
    rule. [Example 3-62](#ref_returns) shows various uses of `ref` return types, some
    of which the compiler accepts, and some it does not.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然类型不能定义具有`ref`的字段，但它们可以定义返回`ref`样式引用的方法（并且因为属性是伪装的方法，所以属性getter也可以返回引用）。像往常一样，C#编译器必须确保引用不能超出其所引用的内容，因此它将阻止在无法确定能够强制执行此规则的情况下使用此特性。[例子3-62](#ref_returns)展示了`ref`返回类型的各种用法，编译器接受了其中的一些用法，而另一些则没有。
- en: Example 3-62\. Valid and invalid uses of `ref` returns
  id: totrans-386
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 3-62\. `ref` 返回值的有效和无效用法
- en: '[PRE70]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: The methods that return a reference to an `int` that is a field, or an element
    in an array, are allowed, because `ref`-style references can always refer *to*
    items inside objects on the heap. (They just can’t live *in* them.) Heap objects
    can exist for as long as they are needed (and the garbage collector, discussed
    in [Chapter 7](ch07.xhtml#ch_object_lifetime), is aware of these kinds of references
    and will ensure that heap objects with references pointing to their interiors
    are kept alive). A method can return any of its `ref` arguments, because the caller
    was already required to ensure that they remain valid for the duration of the
    call. However, a method cannot return a reference to one of its local variables,
    because in cases where those variables end up living on the stack, the stack frame
    will cease to exist when the method returns. It would be a problem if a method
    could return a reference to a variable in a now-defunct stack frame.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 允许返回指向堆上对象内部的`ref`样式引用的方法返回一个`int`字段或数组中的元素，因为`ref`样式引用始终可以引用堆上对象内部的项（它们只是不能生存于其中）。堆对象可以在需要时存在（并且垃圾收集器，在[第7章](ch07.xhtml#ch_object_lifetime)中讨论过，知道这些引用类型并确保保持引用其内部的堆对象存活）。方法可以返回其任何`ref`参数，因为调用者已经要求它们在调用期间保持有效。但是，方法不能返回对其局部变量之一的引用，因为在这些变量最终存在于堆栈上的情况下，当方法返回时，堆栈帧将不再存在。如果方法可以返回对现在已废弃的堆栈帧中变量的引用，那将是个问题。
- en: 'The rules get a little more subtle when it comes to returning a reference that
    was obtained from some other method. The final two methods in [Example 3-62](#ref_returns)
    both attempt to return the reference returned by `GetBackSameRef`. One works,
    and the other does not. The outcome makes sense: `WillAlsoNotCompile` needs to
    be rejected for the same reason `WillNotCompile` was: both attempt to return a
    reference to a local variable, and `WillAlsoNotCompile` is just trying to disguise
    this by going through another method, `GetBackSameRef`. In cases like these, the
    C# compiler makes the conservative assumption that any method that returns a `ref`
    and that also takes one or more `ref` arguments might choose to return a reference
    to one of those arguments. So the compiler disallows the call to `GetBackSameRef`
    in `WillAlsoNotCompile` on the grounds that it might return a reference to the
    same local variable that was passed in by reference. (And it happens to be right
    in this case. But it would reject any call of this form even if the method in
    question returned a reference to something else entirely.) But it allows `WillCompile`
    to return the `ref` returned by `GetBackSameRef` because in that case, the reference
    we pass in is one we would be allowed to return directly.'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及返回从其他方法获取的引用时，规则变得更加微妙。[示例 3-62](#ref_returns)中的最后两种方法都试图返回由`GetBackSameRef`返回的引用。一种有效，而另一种无效。结果是有道理的：`WillAlsoNotCompile`需要被拒绝，原因与`WillNotCompile`相同：两者都试图返回对局部变量的引用，并且`WillAlsoNotCompile`仅仅通过另一个方法`GetBackSameRef`进行了伪装。在这些情况下，C#编译器做出了保守的假设，即任何返回`ref`并且还接受一个或多个`ref`参数的方法，可能会选择返回其中一个参数的引用。因此，编译器不允许在`WillAlsoNotCompile`中调用`GetBackSameRef`，理由是它可能返回对通过引用传递的同一局部变量的引用（在这种情况下，编译器是正确的。但即使方法返回对完全不同东西的引用，它也会拒绝这种形式的任何调用）。但它允许`WillCompile`返回`GetBackSameRef`返回的`ref`，因为在这种情况下，我们传递的引用是可以直接返回的。
- en: As with `in` arguments, the main reason for using `ref` returns is that they
    can enable greater runtime efficiency by avoiding copies. Instead of returning
    the entire value, methods of this kind can just return a pointer to the existing
    value. It also has the effect of enabling callers to modify whatever is referred
    to. For example, in [Example 3-62](#ref_returns), I can assign a value into the
    `FieldRef` property, even though the property appears to be read-only. The absence
    of a setter doesn’t matter in this case because its type is `ref int`, which is
    valid as the target of an assignment. So by writing `r.FieldRef = 42;` (where
    `r` is of type `Referable`), I get to modify the `i` field. Likewise, the reference
    returned by `GetArrayElementRef` can be used to modify the relevant element in
    the array. If this is not your intention, you can make the return type `ref readonly`
    instead of just `ref`. In this case, the compiler will not allow the resulting
    reference to be used as the target of an assignment.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 与`in`参数一样，使用`ref`返回值的主要原因是它们可以通过避免拷贝来实现更大的运行时效率。这类方法不会返回整个值，而是可以返回指向现有值的指针。这还可以使调用者能够修改所引用的内容。例如，在[示例 3-62](#ref_returns)中，我可以将一个值赋给`FieldRef`属性，尽管该属性看起来是只读的。在这种情况下，缺少setter并不重要，因为其类型为`ref
    int`，可以作为赋值的目标。因此，通过编写`r.FieldRef = 42;`（其中`r`的类型是`Referable`），我可以修改`i`字段。同样，可以使用`GetArrayElementRef`返回的引用来修改数组中的相关元素。如果这不是你的意图，可以将返回类型改为`ref
    readonly`而不是仅仅是`ref`。在这种情况下，编译器将不允许将结果引用用作赋值的目标。
- en: Tip
  id: totrans-391
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: You should only use `ref readonly` returns with a `readonly struct`, because
    otherwise you will run into the same defensive copy issues we saw earlier.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 只应在`readonly struct`中使用`ref readonly`返回值，否则会遇到我们之前见过的防御性拷贝问题。
- en: Optional arguments
  id: totrans-393
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 可选参数
- en: You can make non-`out`, non-`ref` arguments optional by defining default values.
    The method in [Example 3-63](#method_with_optional_arguments) specifies the values
    that the arguments should have if the caller doesn’t supply them.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 通过定义默认值，可以使非`out`、非`ref`参数变为可选。在[示例 3-63](#method_with_optional_arguments)中的方法指定了如果调用者未提供参数时参数应该具有的值。
- en: Example 3-63\. A method with optional arguments
  id: totrans-395
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-63\. 带可选参数的方法
- en: '[PRE71]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: This method can then be invoked with no arguments, one argument, or both arguments.
    [Example 3-64](#omitting_one_argument) just supplies the first, taking the default
    for the `problem` argument.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法可以不带参数、带一个参数或两个参数调用。[示例 3-64](#omitting_one_argument)只提供第一个参数，采用`problem`参数的默认值。
- en: Example 3-64\. Omitting one argument
  id: totrans-398
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-64\. 省略一个参数
- en: '[PRE72]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Normally, when invoking a method, you specify the arguments in order. However,
    what if you want to call the method in [Example 3-63](#method_with_optional_arguments),
    but you want to provide a value only for the second argument, using the default
    value for the first? You can’t just leave the first argument empty—if you tried
    to write `Blame( , "everything")`, you’d get a compiler error. Instead, you can
    specify the name of the argument you’d like to supply, using the syntax shown
    in [Example 3-65](#specifying_an_argument_name). C# will fill in the arguments
    you omit with the specified default values.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在调用方法时，你按顺序指定参数。但是，如果你想调用 [示例 3-63](#method_with_optional_arguments) 中的方法，但只想为第二个参数提供一个值，而第一个参数使用默认值呢？你不能简单地将第一个参数留空——如果尝试写
    `Blame( , "everything")`，会导致编译器错误。相反，你可以指定想要提供的参数的名称，使用 [示例 3-65](#specifying_an_argument_name)
    中显示的语法。C# 将使用指定的默认值填充你省略的参数。
- en: Example 3-65\. Specifying an argument name
  id: totrans-401
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-65\. 指定参数名称
- en: '[PRE73]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Obviously, you can omit arguments like this only when you’re invoking methods
    that define default argument values. However, you are free to specify argument
    names when invoking any method—sometimes it can be useful to do this even when
    you’re not omitting any arguments, because it can make it easier to see what the
    arguments are for when reading the code. This is particularly helpful if you’re
    faced with an API that takes arguments of type `bool` and it’s not immediately
    clear what they mean. [Example 3-66](#not_naming_arguments) constructs a `StreamReader`
    and a `StreamWriter` (described in [Chapter 15](ch15.xhtml#ch_files_and_streams)),
    each using constructors taking many arguments. It’s arguably clear enough what
    the `stream`, `filepath`, and the `Encoding.UTF8` arguments represent, but the
    others are likely to be something of a mystery to anyone reading the code, unless
    they happen to have committed all 13 `StreamReader` and 10 `StreamWriter` constructor
    overloads to memory. (The *using declaration* syntax shown here is described in
    [Chapter 7](ch07.xhtml#ch_object_lifetime).)
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，只有在调用定义了默认参数值的方法时，你才能像这样省略参数。但是，你可以在调用任何方法时指定参数名称——有时即使没有省略任何参数，这样做也很有用，因为它可以在阅读代码时更容易看到参数的含义。如果你面对一个接受
    `bool` 类型参数的 API，并且它不立即清楚它们的含义，这将特别有帮助。[示例 3-66](#not_naming_arguments) 创建了一个
    `StreamReader` 和一个 `StreamWriter`（在 [第 15 章](ch15.xhtml#ch_files_and_streams)
    中描述），分别使用了多个参数的构造函数。显然，`stream`、`filepath` 和 `Encoding.UTF8` 参数的含义相当明确，但对于其他参数，除非读者恰好将所有
    13 个 `StreamReader` 和 10 个 `StreamWriter` 构造函数重载都记在心中，否则可能会是个谜。（此处显示的 *using declaration*
    语法在 [第 7 章](ch07.xhtml#ch_object_lifetime) 中有描述。）
- en: Example 3-66\. Unclear arguments
  id: totrans-404
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-66\. 参数不清晰
- en: '[PRE74]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Although argument names are not required here, we can make it much easier to
    understand what the code does by including some anyway. As [Example 3-67](#clarity_by_naming_arguments)
    shows, we’re free just to name the more cryptic ones, as long as we’re supplying
    arguments for all of the parameters.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然此处不需要参数名称，但我们可以通过包含一些参数名称使代码更易于理解。如 [示例 3-67](#clarity_by_naming_arguments)
    所示，我们可以自由地命名那些比较神秘的参数，只要我们为所有参数提供参数。
- en: Example 3-67\. Improving clarity by naming arguments
  id: totrans-407
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-67\. 通过命名参数来提高清晰度
- en: '[PRE75]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: It’s important to understand how C# implements default argument values because
    it has an impact on evolving library design. When you invoke a method without
    providing all the arguments, as [Example 3-65](#specifying_an_argument_name) does,
    the compiler generates code that passes a full set of arguments as normal. It
    effectively rewrites your code, adding back in the arguments you left out. The
    significance of this is that if you write a library that defines default argument
    values like this, you will run into problems if you ever change the defaults.
    Code that was compiled against the old version of the library will have copied
    the old defaults into the call sites and won’t pick up the new values unless it
    is recompiled.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 了解 C# 如何实现默认参数值非常重要，因为它对库的设计演进有影响。当你调用一个方法但未提供所有参数时，就像 [示例 3-65](#specifying_an_argument_name)
    一样，编译器会生成代码，按照正常方式传递一整套参数。它实际上重写了你的代码，添加了你省略的参数。这一点的重要性在于，如果你编写了定义此类默认参数值的库，如果你更改了默认值，就会遇到问题。使用旧版本库编译的代码将把旧的默认值复制到调用位置，并且不会在不重新编译的情况下获取新值。
- en: Overloading
  id: totrans-410
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 过载
- en: 'You will sometimes see an alternative mechanism used for allowing arguments
    to be omitted, which avoids baking default values into call sites: *overloading*.
    This is a slightly histrionic term for the rather mundane idea that a single name
    or symbol can be given multiple meanings. In fact, we already saw this technique
    with constructors—in [Example 3-42](#chained_constructor_arguments), I defined
    one main constructor that did the real work, and then two other constructors that
    called into that one. We can use the same trick with methods, as [Example 3-68](#overloaded_method)
    shows.'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 有时您会看到另一种允许省略参数的机制的替代方法，它避免在调用点将默认值固定到其中：*重载*。这是一个略显煽情的术语，用来描述一个单一的名称或符号可以被赋予多个含义的相当平凡的想法。实际上，我们在构造函数中已经看到了这种技术——在[示例3-42](#chained_constructor_arguments)中，我定义了一个主要构造函数来完成实际工作，然后定义了另外两个调用该构造函数的构造函数。我们可以在方法中使用同样的技巧，正如[示例3-68](#overloaded_method)所示。
- en: Example 3-68\. Overloaded method
  id: totrans-412
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例3-68\. 方法重载
- en: '[PRE76]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'In one sense, this is slightly less flexible than default argument values,
    because code calling the `Blame` method no longer has any way to specify a value
    for the `problem` argument while picking up the default `perpetrator` (although
    it would be easy enough to solve that by just adding a method with a different
    name). On the other hand, method overloading offers two potential advantages:
    it allows you to decide on the default values at runtime if necessary, and it
    also provides a way to make `out` and `ref` arguments optional. Those require
    references to local variables, so there’s no way to define a default value, but
    you can always provide overloads with and without those arguments if you need
    to. And you can use a mixture of the two techniques—you might rely mainly on optional
    arguments, using overloads only to enable `out` or `ref` arguments to be omitted.'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 在某种意义上，这比默认参数值略显不灵活，因为调用`Blame`方法的代码不再有任何方法可以为`problem`参数指定一个值，同时获取默认的`perpetrator`（尽管通过添加一个不同名称的方法很容易解决）。另一方面，方法重载提供了两个潜在的优势：它允许您在必要时在运行时决定默认值，并且还提供了一种使`out`和`ref`参数变为可选的方法。这些参数需要对局部变量的引用，因此无法定义默认值，但是如果需要，您总是可以提供有和没有这些参数的重载。而且您可以同时使用这两种技术——您可以主要依赖于可选参数，仅在需要时使用重载来使`out`或`ref`参数被省略。
- en: Variable argument count with the params keyword
  id: totrans-415
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用`params`关键字的可变参数数量
- en: Some methods need to be able to accept different amounts of data in different
    situations. Take the mechanism that I’ve used a few times in this book to display
    information. In most cases, I’ve passed a simple string to `Console.WriteLine`,
    and when I’ve wanted to format and display other pieces of information, I’ve used
    string interpolation to embed expressions in strings. However, as you may recall
    from [Chapter 2](ch02.xhtml#ch_basic_coding), in cases where we want to embed
    a large number of expressions into a string, string interpolation can become unwieldy,
    and it might be preferable instead to use the older `string.Format` method, shown
    in [Example 3-69](#string_formatting).
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 有些方法需要能够根据不同情况接受不同数量的数据。例如，我在本书中多次使用的显示信息的机制。在大多数情况下，我向`Console.WriteLine`传递一个简单的字符串，当我想要格式化和显示其他信息时，我使用字符串插值将表达式嵌入到字符串中。然而，正如你在[第2章](ch02.xhtml#ch_basic_coding)中记得的那样，在我们想要将大量表达式嵌入到字符串中时，字符串插值可能变得笨拙，可能更适合使用较旧的`string.Format`方法，如[示例3-69](#string_formatting)所示。
- en: Example 3-69\. String formatting
  id: totrans-417
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例3-69\. 字符串格式化
- en: '[PRE77]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: If you look at the documentation for `string.Format`, you’ll see that it offers
    several overloads taking various numbers of arguments. The number of overloads
    has to be finite, but if you try it, you’ll find that this is nonetheless an open-ended
    arrangement. You can pass as many arguments as you like after the string, and
    the numbers in the placeholders can go as high as necessary to refer to these
    arguments. The final line of [Example 3-69](#string_formatting) passes four arguments
    after the string, and even though the `string` class does not define an overload
    accepting that many arguments, it works.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看`string.Format`的文档，你会发现它提供了几种不同数量参数的重载。重载的数量必须是有限的，但是如果你尝试一下，你会发现这仍然是一个开放式的安排。你可以在字符串后面传递任意多的参数，并且占位符中的数字可以随需要而高到引用这些参数。在[示例3-69](#string_formatting)的最后一行，在字符串后面传递了四个参数，即使`string`类没有定义接受那么多参数的重载，它也能正常工作。
- en: 'One particular overload of the `string.Format` method takes over once you pass
    more than a certain number of arguments after the string (more than three, as
    it happens). This overload just takes two arguments: a `string` and an `object[]`
    array. The code that the compiler creates to invoke the method builds an array
    to hold all the arguments after the string and passes that. So the final statement
    of [Example 3-69](#string_formatting) is effectively equivalent to the code in
    [Example 3-70](#explicitly_passing_multiple_arguments_as). ([Chapter 5](ch05.xhtml#ch_collections)
    describes arrays.)'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: '`string.Format` 方法的一个特定重载在您传递字符串后的参数数量超过一定数量（实际上是超过三个）时接管操作。这个重载只接受两个参数：一个
    `string` 和一个 `object[]` 数组。编译器为调用该方法创建的代码会构建一个数组来容纳字符串后的所有参数，并传递该数组。因此，[示例 3-69](#string_formatting)
    的最终语句实际上等效于 [示例 3-70](#explicitly_passing_multiple_arguments_as) 中的代码。([第 5 章](ch05.xhtml#ch_collections)
    描述了数组。)'
- en: Example 3-70\. Explicitly passing multiple arguments as an array
  id: totrans-421
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-70\. 明确传递多个参数作为数组
- en: '[PRE78]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: The compiler will do this only with parameters that are annotated with the `params`
    keyword. [Example 3-71](#params_keyword) shows how the relevant `string.Format`
    method’s declaration looks.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器只会对用 `params` 关键字注释的参数执行此操作。[示例 3-71](#params_keyword) 显示了相关 `string.Format`
    方法声明的样子。
- en: Example 3-71\. The `params` keyword
  id: totrans-424
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-71\. `params` 关键字
- en: '[PRE79]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: The `params` keyword can appear only on a method’s final parameter, and that
    parameter type must be an array. In this case, it’s an `object[]`, meaning that
    we can pass objects of any type, but you can be more specific to limit what can
    be passed in.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: '`params` 关键字只能出现在方法的最后一个参数上，并且该参数的类型必须是数组。在这种情况下，它是 `object[]`，这意味着我们可以传递任何类型的对象，但您可以更具体地限制可以传递的内容。'
- en: Note
  id: totrans-427
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: When a method is overloaded, the C# compiler looks for the method whose parameters
    best match the arguments supplied. It will consider using a method with a `params`
    argument only if a more specific match is not available.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 当方法被重载时，C# 编译器会寻找最匹配提供的参数的方法。只有在没有更具体的匹配时，它才会考虑使用带有 `params` 参数的方法。
- en: You may be wondering why the `string` class bothers to offer overloads that
    accept one, two, or three `object` arguments. The presence of this `params` version
    seems to make those redundant—it lets you pass any number of arguments after the
    string, so what’s the point of the ones that take a specific number of arguments?
    Those overloads exist to make it possible to avoid allocating an array. That’s
    not to say that arrays are particularly expensive; they cost no more than any
    other object of the same size. However, allocating memory is not free. Every object
    you allocate will eventually have to be freed by the garbage collector (except
    for objects that hang around for the whole life of the program), so reducing the
    number of allocations is usually good for performance. Because of this, most APIs
    in the runtime libraries that accept a variable number of arguments through `params`
    also offer overloads that allow a small number of arguments to be passed without
    needing to allocate an array to hold them.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会想知道为什么 `string` 类要提供接受一个、两个或三个 `object` 参数的重载。这个 `params` 版本的存在似乎使它们变得多余
    —— 它允许您在字符串后传递任意数量的参数，那么接受特定数量参数的重载有什么意义呢？这些重载存在的目的是为了避免分配数组。这并不意味着数组特别昂贵；它们的成本不比相同大小的其他对象更高。然而，分配内存并非免费。您分配的每个对象最终都必须由垃圾收集器释放（除了整个程序生命周期内都存在的对象），因此减少分配次数通常有利于性能。因此，运行库中大多数接受通过
    `params` 变量数量参数的 API 也提供了不需要分配数组即可传递少量参数的重载。
- en: Local functions
  id: totrans-430
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 本地函数
- en: You can define methods inside other methods. These are called *local functions*,
    and [Example 3-72](#local_function) defines two of them. (You can also put them
    inside other method-like features, such as constructors or property accessors.)
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在其他方法内部定义方法。这些称为*本地函数*，[示例 3-72](#local_function) 定义了其中的两个。（您还可以将它们放在其他类似方法的功能中，如构造函数或属性访问器中。）
- en: Example 3-72\. Local functions
  id: totrans-432
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-72\. 本地函数
- en: '[PRE80]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: One reason for using local functions is that they can make the code easier to
    read by moving steps into named methods—it’s easier to see what’s happening when
    there’s a method call to `GetDistance` than it is if we just have the calculations
    inline. Be aware that there can be overheads, although in this particular example,
    when I run the Release build of this code on .NET 6.0, the JIT compiler is smart
    enough to inline both of the local calls here, so the two local functions vanish,
    and `Get⁠Ave⁠ra⁠ge​Dis⁠tan⁠ceF⁠rom` ends up being just one method. So we’ve paid
    no penalty here, but with more complex nested functions, the JIT compiler may
    decide not to inline. And when that happens, it’s useful to know how the C# compiler
    enables this code to work.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 使用局部函数的一个原因是它们可以通过将步骤移到命名方法中使代码更易于阅读——通过调用`GetDistance`方法来看到发生了什么比在内联计算时更容易。请注意可能存在开销，尽管在这个特定的例子中，当我在.NET
    6.0上运行此代码的发布版本时，JIT编译器足够聪明，可以内联这里的两个局部调用，因此这两个局部函数消失了，而`Get⁠Ave⁠ra⁠ge​Dis⁠tan⁠ceF⁠rom`最终只是一个方法。所以我们在这里没有付出任何代价，但是对于更复杂的嵌套函数，JIT编译器可能决定不内联。当这种情况发生时，了解C#编译器如何使这段代码工作是很有用的。
- en: The `GetDistanceFromReference` method here takes a single tuple argument, but
    it uses the `referencePoint` variable defined by its containing method. For this
    to work, the C# compiler moves that variable into a generated `struct`, which
    it passes by reference to the `GetDistanceFromReference` method as a hidden argument.
    This is how a single local variable can be accessible to both methods. Since this
    generated `struct` is passed by reference, the `referencePoint` variable can still
    remain on the stack in this example. However, if you obtain a delegate referring
    to a local method, any variables shared in this way have to move into a `class`
    that lives on the garbage-collected heap, which will have higher overheads. (See
    Chapters [7](ch07.xhtml#ch_object_lifetime) and [9](ch09.xhtml#ch_delegates_lambdas_events)
    for more details.) If you want to avoid any such overheads, you can always just
    not share any variables between the inner and outer methods. You can tell the
    compiler that this is your intention by applying the `static` keyword to the local
    function, as [Example 3-72](#local_function) does with `GetDistance`. This will
    cause the compiler to report an error if the method attempts to use a variable
    from its containing method.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的`GetDistanceFromReference`方法接受一个元组参数，但它使用由其包含方法定义的`referencePoint`变量。为了使其工作，C#编译器将该变量移动到一个生成的`struct`中，并作为隐藏参数传递给`GetDistanceFromReference`方法。这就是单个局部变量可以被两个方法访问的方式。由于这个生成的`struct`是通过引用传递的，所以在这个例子中，`referencePoint`变量仍然可以保留在堆栈上。然而，如果获取指向本地方法的委托，以这种方式共享的任何变量必须移动到一个存在于垃圾回收堆上的`class`中，这将产生更高的开销。（详见第[7](ch07.xhtml#ch_object_lifetime)章和第[9](ch09.xhtml#ch_delegates_lambdas_events)章了解更多详情。）如果你想避免这种开销，你可以始终不在内外方法之间共享任何变量。你可以通过将`static`关键字应用于局部函数来告诉编译器这是你的意图，就像[示例 3-72](#local_function)中的`GetDistance`所做的那样。这将导致如果方法尝试使用其包含方法的变量，编译器将报告错误。
- en: Besides providing a way to split methods up for readability, local functions
    are sometimes used to work around some limitations with iterators (see [Chapter 5](ch05.xhtml#ch_collections))
    and `async` methods ([Chapter 17](ch17.xhtml#ch_asynchronous_language_features)).
    These are methods that might return partway through execution and then continue
    later, which means the compiler needs to arrange to store all of their local variables
    in an object living on the heap so that those variables can survive for as long
    as is required. This prevents these kinds of methods from declaring variables
    of certain types, such as reference variables, or `Span<T>` (described in [Chapter 18](ch18.xhtml#ch_memory_efficiency)).
    In cases where you need to use both `async` and `Span<T>`, it is common to move
    code using the latter into a local, non-`async` function that lives inside the
    `async` function. This enables the local function to use local variables with
    these constrained types.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 除了提供一种分割方法以提升可读性的方式外，局部函数有时也用于解决一些迭代器的限制（见第[5](ch05.xhtml#ch_collections)章）和`async`方法（见第[17](ch17.xhtml#ch_asynchronous_language_features)章）。这些是可能在执行过程中返回部分结果然后稍后继续的方法，这意味着编译器需要安排将它们的所有局部变量存储在一个对象中，该对象存储在堆上，以便这些变量可以存活所需的时间。这阻止这些方法声明某些类型的变量，例如引用变量或`Span<T>`（在第[18](ch18.xhtml#ch_memory_efficiency)章中描述）。在需要同时使用`async`和`Span<T>`的情况下，将使用后者的代码移动到位于`async`函数内部的局部非`async`函数是常见的。这使得局部函数能够使用这些受限制类型的局部变量。
- en: Expression-bodied methods
  id: totrans-437
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 表达式主体方法
- en: If you write a method simple enough to consist of nothing more than a single
    return statement, you can use a more concise syntax. [Example 3-73](#expression_bodied_method)
    shows an alternative way to write the `GetDistanceFromReference` method from [Example 3-72](#local_function).
    (If you’re reading this book in order, you’ve probably noticed that I’ve already
    used this in a few other examples.) By the way, I can’t do this for `GetDistance`
    because that contains multiple statements.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您编写的方法足够简单，仅由单个返回语句组成，您可以使用更简洁的语法。[示例 3-73](#expression_bodied_method) 展示了从[示例 3-72](#local_function)的`GetDistanceFromReference`方法的另一种编写方式。（如果您按顺序阅读本书，您可能已经注意到我在其他一些示例中已经使用了这种方式。）顺便说一句，我不能为`GetDistance`这个方法做同样的事情，因为它包含多个语句。
- en: Example 3-73\. An expression-bodied method
  id: totrans-439
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-73\. 表达式主体方法
- en: '[PRE81]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Instead of a method body, you write `=>` followed by the expression that would
    otherwise have followed the `return` keyword. This `=>` syntax intentionally resembles
    the lambda syntax you can use for writing inline functions and building expression
    trees. These are discussed in [Chapter 9](ch09.xhtml#ch_delegates_lambdas_events).
    But when using `=>` to write an expression-bodied member, it’s just a convenient
    shorthand. The code works exactly as if you had written a full method containing
    just a `return` statement.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以写`=>`，后面跟随本来应该跟在`return`关键字后面的表达式，而不是方法体。这种`=>`语法故意类似于您可以用于编写内联函数和构建表达式树的lambda语法。这些在[第9章](ch09.xhtml#ch_delegates_lambdas_events)中讨论。但是，在使用`=>`编写表达式主体成员时，它只是一种方便的缩写。代码的工作方式完全就像您编写了一个只包含`return`语句的完整方法一样。
- en: Extension methods
  id: totrans-442
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 扩展方法
- en: C# lets you write methods that appear to be new members of existing types. *Extension
    methods*, as they are called, look like normal static methods but with the `this`
    keyword added before the first parameter. You are allowed to define extension
    methods only in a static class. [Example 3-74](#extension_method) adds a not especially
    useful extension method to the `string`, called `Show`.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: C#允许您编写看起来像是现有类型的新成员的方法。*扩展方法*就是这样的方法，看起来像普通的静态方法，但在第一个参数之前加了`this`关键字。您只能在静态类中定义扩展方法。[示例 3-74](#extension_method)
    添加了一个名为`Show`的不太有用的扩展方法到`string`中。
- en: Example 3-74\. An extension method
  id: totrans-444
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-74\. 扩展方法
- en: '[PRE82]'
  id: totrans-445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'I’ve shown the namespace declaration in this example because namespaces are
    significant: extension methods are available only if you’ve written a `using`
    directive for the namespace in which the extension is defined, or if the code
    you’re writing is defined in the same namespace. In code that does neither of
    these things, the `string` class will look normal and will not acquire the `Show`
    method defined by [Example 3-74](#extension_method). However, code such as [Example 3-75](#extension_method_available_due_to_namesp),
    which is defined in the same namespace as the extension method, will find that
    the method is available.'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 我在这个例子中展示了命名空间声明，因为命名空间很重要：只有在为扩展定义的命名空间编写了`using`指令，或者您正在编写的代码与扩展方法定义在同一个命名空间中时，扩展方法才可用。在既不做这些事情的代码中，`string`类看起来将很正常，并且不会获得[示例 3-74](#extension_method)定义的`Show`方法。然而，像[示例 3-75](#extension_method_available_due_to_namesp)这样的代码，定义在与扩展方法相同的命名空间中，将会发现该方法是可用的。
- en: Example 3-75\. Extension method available due to namespace declaration
  id: totrans-447
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-75\. 由于命名空间声明可用的扩展方法
- en: '[PRE83]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: The code in [Example 3-76](#extension_method_available_due_to_using) is in a
    different namespace, but it also has access to the extension method, thanks to
    a `using` directive.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 在[示例 3-76](#extension_method_available_due_to_using)中的代码位于不同的命名空间，但也可以访问扩展方法，这要归功于`using`指令。
- en: Example 3-76\. Extension method available due to `using` directive
  id: totrans-450
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-76\. 由于`using`指令可用的扩展方法
- en: '[PRE84]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: Extension methods are not really members of the class for which they are defined—the
    `string` class does not truly gain an extra method in these examples. It’s just
    an illusion maintained by the C# compiler, one that it keeps up even in situations
    where method invocation happens implicitly. This is particularly useful with C#
    features that require certain methods to be available. In [Chapter 2](ch02.xhtml#ch_basic_coding),
    you saw that `foreach` loops depend on a `GetEnumerator` method. Many of the LINQ
    features we’ll look at in [Chapter 10](ch10.xhtml#ch_linq) also depend on certain
    methods being present, as do the asynchronous language features described in [Chapter 17](ch17.xhtml#ch_asynchronous_language_features).
    In all cases, you can enable these language features for types that do not support
    them directly by writing suitable extension methods.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展方法并不真正成为它们所定义的类的成员——在这些示例中，`string`类并没有真正获得额外的方法。这只是C#编译器维护的一种错觉，即使在隐式方法调用发生的情况下也是如此。这在需要特定方法的C#功能中特别有用。在[第2章](ch02.xhtml#ch_basic_coding)中，您看到`foreach`循环依赖于`GetEnumerator`方法。我们将在[第10章](ch10.xhtml#ch_linq)中看到的许多LINQ功能也依赖于特定方法的存在，正如在[第17章](ch17.xhtml#ch_asynchronous_language_features)中描述的异步语言功能一样。在所有这些情况下，您可以通过编写适当的扩展方法为不直接支持它们的类型启用这些语言功能。
- en: Properties
  id: totrans-453
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 属性
- en: Classes and structs can define *properties*, which are really just methods in
    disguise. To access a property, you use a syntax that looks like field access
    but ends up invoking a method. Properties can be useful for signaling intent.
    When something is exposed as a property, the implication is that it represents
    information about the object, rather than an operation the object performs, so
    reading a property is usually inexpensive and should have no significant side
    effects. Methods, on the other hand, are more likely to cause an object to do
    something.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 类和结构体可以定义*属性*，实质上它们只是伪装成方法。要访问属性，您使用看起来像是访问字段的语法，但实际上会调用一个方法。属性可以用于传达意图。当某物被公开为属性时，暗示它代表对象的信息，而不是对象执行的操作，因此读取属性通常是廉价的，并且不应该具有重大的副作用。另一方面，方法更有可能导致对象执行某些操作。
- en: Of course, since properties are just a kind of method, nothing enforces this.
    You are free to write a property that takes hours to run and makes significant
    changes to your application’s state whenever its value is read, but that would
    be a pretty lousy way to design code.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，由于属性只是一种方法，没有任何强制规定这一点。您可以自由地编写一个需要运行数小时并且在读取其值时会显著更改应用程序状态的属性，但这将是设计代码的一种相当糟糕的方式。
- en: 'Properties typically provide a pair of methods: one to get the value and one
    to set it. [Example 3-77](#class_with_simple_property) shows a very common pattern:
    a property with `get` and `set` methods that provide access to a field. Why not
    just make the field public? That’s often frowned upon, because it makes it possible
    for external code to change an object’s state without the object knowing about
    it. It might be that in future revisions of the code, the object needs to do something—perhaps
    update the UI—every time the value changes. In any case, because properties contain
    code, they offer more flexibility than public fields. For example, you might want
    to store the data in a different format than is returned by the property, or you
    may even be able to implement a property that calculates its value from other
    properties. Another reason for using properties is simply that some systems require
    it—for example, some UI databinding systems are only prepared to consume properties.
    Also, some types do not support instance fields; later in this chapter, I’ll show
    how to define an abstract type using an *interface*, and interfaces can contain
    properties but not instance fields.'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 属性通常提供一对方法：一个用于获取值，另一个用于设置值。[示例 3-77](#class_with_simple_property)展示了一个非常常见的模式：一个具有`get`和`set`方法的属性，用于访问字段。为什么不直接将字段设为公共的？通常不建议这样做，因为这样会使外部代码有可能在对象不知情的情况下改变其状态。可能在代码的未来版本中，对象需要在每次值更改时执行某些操作——比如更新UI。无论如何，由于属性包含代码，它们比公共字段更灵活。例如，您可能希望以与属性返回值不同的格式存储数据，或者甚至可以实现一个属性，它根据其他属性计算其值。使用属性的另一个原因是一些系统要求这样做——例如，一些UI数据绑定系统只能接受属性。此外，一些类型不支持实例字段；本章后面将展示如何使用*接口*定义抽象类型，接口可以包含属性但不能包含实例字段。
- en: Example 3-77\. Class with simple property
  id: totrans-457
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-77\. 具有简单属性的类
- en: '[PRE85]'
  id: totrans-458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: Note
  id: totrans-459
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Inside a `set` accessor, `value` has a special meaning. It’s a *contextual keyword*—text
    that the language treats as a keyword in certain contexts. Outside of a property,
    you can use `value` as an identifier, but within a property, it represents the
    value that the caller wants to assign to the property.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 在`set`访问器内部，`value`具有特殊含义。它是*上下文关键字*—在某些上下文中，语言将其视为关键字。在属性外部，您可以将`value`用作标识符，但在属性内部，它代表调用者希望分配给属性的值。
- en: In cases where the entire body of the `get` is just a return statement, or where
    the `set` is a single expression statement, you can use the *expression-bodied
    member* syntax shown in [Example 3-78](#expression_bodied_accessors). (This is
    very similar to the method syntax shown in [Example 3-73](#expression_bodied_method).)
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 在整个`get`体仅为一个返回语句的情况下，或者`set`是一个单一表达式语句的情况下，您可以使用[示例 3-78](#expression_bodied_accessors)中显示的*表达式体成员*语法。（这与[示例 3-73](#expression_bodied_method)中显示的方法语法非常相似。）
- en: Example 3-78\. Expression-bodied `get` and `set`
  id: totrans-462
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-78\. 表达式体`get`和`set`
- en: '[PRE86]'
  id: totrans-463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: The pattern in Examples [3-77](#class_with_simple_property) and [3-78](#expression_bodied_accessors)
    is so common that C# can write most of it for you. [Example 3-79](#auto-property)
    is more or less equivalent—the compiler generates a field for us and produces
    `get` and `set` methods that retrieve and modify the value just like those in
    [Example 3-77](#class_with_simple_property). The only difference is that code
    elsewhere in the same class can’t get directly at the field in [Example 3-79](#auto-property),
    because the compiler hides it. The official name in the language specification
    for this is an *automatically implemented property*, but these are typically referred
    to as just *auto-properties*.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 示例[3-77](#class_with_simple_property)和[3-78](#expression_bodied_accessors)中的模式非常常见，以至于C#可以为您大部分写好。
    [示例 3-79](#auto-property)或多或少是等效的——编译器为我们生成一个字段，并生成`get`和`set`方法，用于检索和修改与[示例 3-77](#class_with_simple_property)中相同的值。唯一的区别是，同一类中的其他代码不能直接访问[示例 3-79](#auto-property)中的字段，因为编译器将其隐藏。在语言规范中，官方名称称为*自动实现属性*，但通常简称为*自动属性*。
- en: Example 3-79\. An auto-property
  id: totrans-465
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-79\. 自动属性
- en: '[PRE87]'
  id: totrans-466
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: Whether you use explicit or automatic properties, this is just a fancy syntax
    for a pair of methods. The `get` method returns a value of the property’s declared
    type—an `int`, in this case—while the setter takes a single argument of that type
    through the implicit `value` parameter. [Example 3-77](#class_with_simple_property)
    makes use of that argument to update the field. You’re not obliged to store the
    value in a field, of course. In fact, nothing even forces you to make the `get`
    and `set` methods related in any way—you could write a getter that returns random
    values and a setter that completely ignores the value you supply. However, just
    because you *can* doesn’t mean you *should*. In practice, anyone using your class
    will expect properties to remember the values they’ve been given, not least because
    in use, properties look just like fields, as [Example 3-80](#using_a_property)
    shows.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 无论您使用显式还是自动属性，这只是一对方法的花哨语法。 `get`方法返回属性声明类型的值—在本例中是`int`—而setter通过隐式的`value`参数接收该类型的单个参数。
    [示例 3-77](#class_with_simple_property)利用该参数更新字段。当然，您并不强制将值存储在字段中。事实上，没有任何东西甚至要求您以任何方式使`get`和`set`方法相关联—您可以编写一个返回随机值的getter和一个完全忽略您提供的值的setter。但是，仅仅因为您*能够*这样做，并不意味着您*应该*这样做。实际上，任何使用您的类的人都希望属性能够记住它们被赋予的值，至少因为在使用中，属性看起来就像字段一样，如[示例 3-80](#using_a_property)所示。
- en: Example 3-80\. Using a property
  id: totrans-468
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 3-80\. 使用属性
- en: '[PRE88]'
  id: totrans-469
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: If you’re using the full syntax shown in [Example 3-77](#class_with_simple_property)
    to implement a property, or the expression-bodied form shown in [Example 3-78](#expression_bodied_accessors),
    you can leave out either the `set` or the `get` to make a read-only or write-only
    property. Read-only properties can be useful for aspects of an object that are
    fixed for its lifetime, such as an identifier, or that are calculated from other
    properties. Write-only properties are less useful, although they can crop up in
    dependency injection systems. You can’t make a write-only property with the auto-property
    syntax shown in [Example 3-79](#auto-property), because you wouldn’t be able to
    do anything useful with the value being set.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用完整语法（如[示例 3-77](#class_with_simple_property)所示）或表达式体形式（如[示例 3-78](#expression_bodied_accessors)所示）来实现属性，则可以省略`set`或`get`中的任一项，以创建只读或只写属性。只读属性对于对象生命周期内固定的方面（如标识符或从其他属性计算而来的属性）非常有用。只写属性则不太常见，尽管它们可能在依赖注入系统中出现。使用[示例 3-79](#auto-property)中显示的自动属性语法无法创建只写属性，因为您无法对设置的值执行有用的操作。
- en: There are two variations on read-only properties. Sometimes it is useful to
    have a property that is publicly read-only but that your class is free to change.
    You can define a property where the getter is public but the setter is not (or
    vice versa for a write-only property). You can do this with either the full or
    the automatic syntax. [Example 3-81](#auto-property_with_private_setter) shows
    how this looks with the latter.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 只读属性有两种变体。有时，拥有公共只读属性但是您的类可以自由更改其值是很有用的。您可以定义一个属性，其中 getter 是公共的，但 setter 不是（或者对于写入属性而言反之亦然）。您可以使用完整语法或自动语法来实现此目的。[示例 3-81](#auto-property_with_private_setter)展示了后者的外观。
- en: Example 3-81\. Auto-property with private setter
  id: totrans-472
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-81\. 带私有 setter 的自动属性
- en: '[PRE89]'
  id: totrans-473
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: If you want your property to be read-only in the sense that its value never
    changes after construction, you can leave out the setter entirely when using the
    auto-property syntax, as [Example 3-82](#auto-property_with_no_setter) shows.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 如果希望属性在构造后其值不再改变（即只读属性），则可以在使用自动属性语法时完全省略 setter，如[示例 3-82](#auto-property_with_no_setter)所示。
- en: Example 3-82\. Auto-property with no setter
  id: totrans-475
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-82\. 没有 setter 的自动属性
- en: '[PRE90]'
  id: totrans-476
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: With no setter and no directly accessible field, you may be wondering how you
    can set the value of such a property. The answer is that inside your object’s
    constructor, the property appears to be settable. (There isn’t really a setter
    if you omit the `set`—the compiler generates code that just sets the backing field
    directly when you “set” the property in the constructor.) A get-only auto-property
    is effectively equivalent to a `readonly` field wrapped with an ordinary get-only
    property. As with fields, you can also write an initializer to provide an initial
    value. [Example 3-83](#initializing_an_auto-property_with_no_se) uses both styles;
    if you use the constructor that takes no arguments, the property’s value will
    be 42, and if you use the other constructor, it will have whatever value you supply.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 没有 setter 且没有直接访问的字段时，您可能会想知道如何设置此类属性的值。答案是，在对象的构造函数内部，该属性看起来是可设置的（如果省略`set`，实际上并没有
    setter —— 当您在构造函数中“设置”属性时，编译器生成的代码只是直接设置后备字段）。只读自动属性实际上等效于包装在普通只读属性中的`readonly`字段。与字段一样，您还可以编写初始化程序来提供初始值。[示例 3-83](#initializing_an_auto-property_with_no_se)使用了这两种风格；如果使用不带参数的构造函数，则属性的值将为
    42；如果使用其他构造函数，则属性将具有您提供的任何值。
- en: Example 3-83\. Initializing an auto-property with no setter
  id: totrans-478
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-83\. 使用没有 setter 的自动属性初始化
- en: '[PRE91]'
  id: totrans-479
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: This initializer syntax works for read-write properties, by the way. You can
    also use it if you want to create a `record` type that uses the positional syntax
    but that wants the properties to be writable, as [Example 3-84](#positional_record_with_writeable_properties)
    shows. This is slightly unusual, since the features offered by record types are
    mainly intended to make it easier to define immutable data types. But mutability
    is supported, and it can be useful to require certain properties to be initialized
    even when they are writable, to avoid the nullable reference type system complaining
    that your non-nullable property might initially have a null value.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一下，这种初始化程序语法适用于可读写属性。您还可以在希望使用位置语法但希望属性可写入的`record`类型中使用它，正如[示例 3-84](#positional_record_with_writeable_properties)所示。这略有不同，因为记录类型提供的功能主要旨在更轻松地定义不可变数据类型。但是支持可变性，并且在要求某些属性在初始化时必须初始化为非空引用类型时，可设置的功能可能会很有用。
- en: Example 3-84\. Record requiring initial values but allowing later modification
  id: totrans-481
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 3-84\. 要求初始值但允许稍后修改的记录
- en: '[PRE92]'
  id: totrans-482
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Since the positional syntax is ultimately just a way to define a constructor,
    you might be tempted in cases like [Example 3-84](#positional_record_with_writeable_properties)
    to use more conventionally cased names for the constructor arguments, e.g., `name`
    and `favoriteColor`. But the effect of that would be to create a record with four
    properties: `name`, `Name`, `favoriteColor`, and `FavoriteColor`. If you use the
    positional syntax, your record type will have all of the properties named in that
    syntax. It might look here like we’ve defined the same properties twice, but in
    fact the duplicate names are how C# knows that we are just saying we want something
    other than the normal generated properties here.'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 由于位置语法最终只是定义构造函数的一种方式，在像[示例 3-84](#positional_record_with_writeable_properties)这样的情况下，您可能会诱使使用更常规的大小写名称来命名构造函数参数，例如，`name`
    和 `favoriteColor`。但是，这样做的效果将是创建一个具有四个属性的记录：`name`、`Name`、`favoriteColor` 和 `FavoriteColor`。如果您使用位置语法，则记录类型将具有该语法中命名的所有属性。这里看起来我们定义了相同的属性两次，但实际上重复的名称是C#知道我们只是在说我们希望在此处有一些不同于正常生成的属性。
- en: There’s a variation on the theme of read-only properties shown in [Example 3-85](#auto-property_with_init_setter).
    In place of the `set`, we have the `init` keyword. (This is how properties generated
    in a record type due to the positional syntax look if you don’t customize them,
    by the way.)
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 在[示例 3-85](#auto-property_with_init_setter)中展示了只读属性主题的变体。在`set`的位置，我们使用了 `init`
    关键字。（顺便说一下，这是由于位置语法而生成的属性在您没有自定义它们时的样子。）
- en: Example 3-85\. Class with auto-property with init-only setter
  id: totrans-485
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 3-85\. 具有只读属性初始化的类
- en: '[PRE93]'
  id: totrans-486
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'This is almost identical to a read-only property: it indicates that the property
    is not to be modified after the object is initialized. However, there’s one significant
    difference: the compiler generates a public setter when you use this syntax. It
    refuses to compile code that attempts to modify the property after the object
    has been initialized, so for most scenarios it behaves just like a read-only property,
    but this enables one critical scenario: it lets you set the property in an *object
    initializer*. I’ll be describing object initializers in full later, but [Example 3-86](#setting_init_only_property)
    shows a simple example.'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 这与只读属性几乎完全相同：它指示对象初始化后不得修改属性。但是，有一个重要的区别：当您使用此语法时，编译器会生成一个公共设置器。在对象初始化程序中尝试修改属性后，编译器会拒绝编译代码，因此对于大多数场景，它的行为就像只读属性一样，但这使得一个关键场景成为可能：它允许您在*对象初始化程序*中设置属性。稍后我将详细描述对象初始化程序，但[示例 3-86](#setting_init_only_property)显示了一个简单的示例。
- en: Example 3-86\. Setting an init-only property
  id: totrans-488
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 3-86\. 设置只读属性初始化
- en: '[PRE94]'
  id: totrans-489
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: This is the one extra place you can use an init-only property—besides this you
    can only set them in places where it would also be permissible to set a read-only
    property.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 这是您可以使用只读属性初始化的另一个额外位置—除此之外，您只能在可以设置只读属性的地方设置它们。
- en: Warning
  id: totrans-491
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: The restrictions on init-only properties are enforced only by the compiler.
    From the CLR’s perspective, they are read-write properties, meaning that if you
    were to use this sort of property from some language that did not recognize this
    init-only feature (which was new in C# 9.0), or using indirect means such as reflection
    (see [Chapter 13](ch13.xhtml#ch_reflection)), it would be able to set the property
    at any time, not just during initialization.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 仅编译器强制执行对只读属性的限制。从CLR的角度来看，它们是可读写的属性，这意味着如果你从某些不识别这个 init-only 特性（这在 C# 9.0
    中是新功能）的语言中使用此类属性，或者使用间接手段如反射（见[第13章](ch13.xhtml#ch_reflection)），它可以在任何时候设置属性，而不仅仅是在初始化期间。
- en: Init-only properties provide a way to enable immutable `struct` types to use
    the same `with` syntax that is available to record types. [Example 3-87](#a_readonly_struct_with_init_only_props)
    shows another variation on the `Point` type used in various earlier examples,
    this time featuring init-only properties.
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: Init-only 属性提供了一种方法，使得不可变的 `struct` 类型可以使用与记录类型相同的 `with` 语法。[示例 3-87](#a_readonly_struct_with_init_only_props)展示了在之前各种示例中使用的
    `Point` 类型的另一种变体，这次特色是 init-only 属性。
- en: Example 3-87\. A `readonly struct` with init-only properties
  id: totrans-494
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-87\. 带有 init-only 属性的 `readonly struct`
- en: '[PRE95]'
  id: totrans-495
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: This defines setters for the properties, which would normally not be allowed
    with a `readonly struct`, but because they can be set only during initialization,
    they don’t cause a problem here. And they enable code such as [Example 3-88](#with_syntax_on_non_record_struct).
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 这定义了属性的设置器，通常不允许在 `readonly struct` 中使用，但因为它们只能在初始化期间设置，所以在这里不会引起问题。它们使得像[示例 3-88](#with_syntax_on_non_record_struct)这样的代码得以实现。
- en: Example 3-88\. Using the `with` syntax on a nonrecord `readonly struct`
  id: totrans-497
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-88\. 在非记录 `readonly struct` 上使用 `with` 语法
- en: '[PRE96]'
  id: totrans-498
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: Note
  id: totrans-499
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Since you can use the `with` syntax with a nonrecord `struct`, you might be
    wondering whether it also works for a nonrecord `class`. It doesn’t. The `with`
    keyword depends on the ability to create a copy of an existing instance. This
    is not a problem with `struct` types—their defining feature is that they can be
    copied. But there is no reliable general-purpose way to clone an instance of a
    `class`, so with reference types, `with` only works on records, because record
    types *are* reliably cloneable.
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 因为你可以在非记录 `struct` 上使用 `with` 语法，你可能想知道它是否也适用于非记录 `class`。不适用。`with` 关键字依赖于能够创建现有实例的副本。这对于
    `struct` 类型并不是问题——它们的定义特性是可以被复制的。但是对于 `class` 类型的实例，没有一种可靠的通用方法来克隆实例，因此对于引用类型，`with`
    只在记录类型上起作用，因为记录类型是可靠可克隆的。
- en: Sometimes it is useful to write a read-only property with a value calculated
    entirely in terms of other properties. For example, if you have written a type
    representing a vector with properties called `X` and `Y`, you could add a property
    that returns the magnitude of the vector, calculated from those other two properties,
    as shown in [Example 3-89](#calculated_property).
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，编写一个只读属性，其值完全是基于其他属性计算而得，是很有用的。例如，如果你已经编写了一个代表向量的类型，拥有名为`X`和`Y`的属性，你可以添加一个属性，返回这个向量的大小，从这两个属性计算而得，就像在[示例 3-89](#calculated_property)中展示的那样。
- en: Example 3-89\. A calculated property
  id: totrans-502
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-89\. 一个计算属性
- en: '[PRE97]'
  id: totrans-503
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'There is a more compact way of writing this. We could use the expression-bodied
    syntax shown in [Example 3-78](#expression_bodied_accessors), but for a read-only
    property, we can go one step further: you can put the `=>` and expression directly
    after the property name. (This enables us to leave out the braces and the `get`
    keyword.) [Example 3-90](#expression_bodied_readonly_property) is exactly equivalent
    to [Example 3-89](#calculated_property).'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 有一种更简洁的写法。我们可以使用在[示例 3-78](#expression_bodied_accessors)中展示的表达式主体语法，但对于只读属性，我们可以再进一步：你可以直接在属性名后面放置
    `=>` 和表达式。（这使我们可以省略大括号和 `get` 关键字。）[示例 3-90](#expression_bodied_readonly_property)与[示例 3-89](#calculated_property)完全等效。
- en: Example 3-90\. An expression-bodied read-only property
  id: totrans-505
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-90\. 表达式主体只读属性
- en: '[PRE98]'
  id: totrans-506
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: Speaking of read-only properties, there’s an important issue to be aware of
    involving properties, value types, and immutability.
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 谈到只读属性，有一个需要注意的重要问题，涉及属性、值类型和不可变性。
- en: Properties and mutable value types
  id: totrans-508
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 属性和可变值类型
- en: As I mentioned earlier, value types tend to be more straightforward if they’re
    immutable, but it’s not a requirement. One reason to avoid modifiable value types
    is that you can end up accidentally modifying a copy of the value rather than
    the one you meant, and this issue becomes apparent if you define a property that
    uses a mutable value type. The `Point` struct in the `System.Windows` namespace
    is modifiable, so we can use it to illustrate the problem. [Example 3-91](#property_using_a_mutable_value_type)
    defines a `Location` property of this type.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，如果值类型是不可变的，它们通常会更加简单直接，但这不是必需的。避免修改可修改的值类型的一个原因是，你可能会意外修改值的副本，而不是你打算修改的那个，如果你定义一个使用可修改值类型的属性，这个问题就会显现出来。位于`System.Windows`命名空间中的`Point`结构体是可修改的，因此我们可以用它来说明这个问题。[示例 3-91](#property_using_a_mutable_value_type)定义了这种类型的`Location`属性。
- en: Example 3-91\. A property using a mutable value type
  id: totrans-510
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-91\. 使用可修改值类型的属性
- en: '[PRE99]'
  id: totrans-511
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: The `Point` type defines read/write properties called `X` and `Y`, so given
    a variable of type `Point`, you can set these properties. However, if you try
    to set either of these properties via another property, the code will not compile.
    [Example 3-92](#error_cannot_modify_a_property_of_a_valu) tries this—it attempts
    to modify the `X` property of a `Point` retrieved from an `Item` object’s `Location`
    property.
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: '`Point`类型定义了名为`X`和`Y`的读/写属性，因此，给定类型为`Point`的变量，可以设置这些属性。但是，如果你试图通过另一个属性设置这些属性中的任何一个，代码将无法编译通过。[示例 3-92](#error_cannot_modify_a_property_of_a_valu)尝试了这一点——它试图修改从`Item`对象的`Location`属性检索到的`Point`的`X`属性。'
- en: 'Example 3-92\. Error: cannot modify a property of a value type property'
  id: totrans-513
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-92\. 错误：不能修改值类型属性的属性
- en: '[PRE100]'
  id: totrans-514
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'This example produces the following error:'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例会产生以下错误：
- en: '[PRE101]'
  id: totrans-516
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: C# considers fields to be variables as well as local variables and method arguments,
    so if we were to modify [Example 3-91](#property_using_a_mutable_value_type) so
    that `Location` was a public field rather than a property, [Example 3-92](#error_cannot_modify_a_property_of_a_valu)
    would then compile and would work as expected. But why doesn’t it work with a
    property? Remember that properties are just methods, so [Example 3-91](#property_using_a_mutable_value_type)
    is more or less equivalent to [Example 3-93](#replacing_a_property_with_methods).
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: C#将字段视为变量，以及局部变量和方法参数，因此，如果我们修改[示例 3-91](#property_using_a_mutable_value_type)，使`Location`成为一个公共字段而不是属性，[示例 3-92](#error_cannot_modify_a_property_of_a_valu)将会编译通过，并按预期工作。但为什么它不适用于属性呢？请记住，属性只是方法，因此[示例 3-91](#property_using_a_mutable_value_type)与[示例 3-93](#replacing_a_property_with_methods)基本等效。
- en: Example 3-93\. Replacing a property with methods
  id: totrans-518
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-93\. 用方法替换属性
- en: '[PRE102]'
  id: totrans-519
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: Since `Point` is a value type, `get_Location` returns a copy. You might be wondering
    if we could use the `ref` return feature described earlier. We certainly could
    with plain methods, but there are a couple of constraints to doing this with properties.
    First, you cannot define an auto-property with a `ref` type. Second, you cannot
    define a writable property with a `ref` type. However, you can define a read-only
    `ref` property, as [Example 3-94](#ref_type_property) shows.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`Point`是一个值类型，`get_Location`返回一个副本。你可能会想知道我们是否可以使用前面描述的`ref`返回特性。对于普通方法，我们当然可以，但是在属性中做这些有一些限制。首先，你不能使用`ref`类型定义自动属性。其次，你不能使用`ref`类型定义可写属性。但是，正如[示例 3-94](#ref_type_property)所示，你可以定义一个只读的`ref`属性。
- en: Example 3-94\. A property returning a reference
  id: totrans-521
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-94\. 返回引用的属性
- en: '[PRE103]'
  id: totrans-522
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: With this implementation of `Item`, the code in [Example 3-92](#error_cannot_modify_a_property_of_a_valu)
    now works fine. (Ironically, to make the property modifiable, we had to turn it
    into a read-only property.)
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 有了`Item`的这种实现，[示例 3-92](#error_cannot_modify_a_property_of_a_valu)中的代码现在可以正常工作了。（具有讽刺意味的是，为了使属性可修改，我们不得不将其变成只读属性。）
- en: Before `ref` returns were added in C# 7.0, there was no way to make this work.
    All possible implementations of the property would end up returning a copy of
    the property value, so if the compiler did allow [Example 3-92](#error_cannot_modify_a_property_of_a_valu)
    to compile, we would be setting the `X` property on the copy returned by the property,
    and not the actual value in the `Item` object that the property represents. [Example 3-95](#making_the_copy_explicit)
    makes this explicit, and it will in fact compile—the compiler will let us shoot
    ourselves in the foot if we make it sufficiently clear that we really want to.
    And with this version of the code, it’s quite obvious that this will not modify
    the value in the `Item` object.
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C# 7.0 中添加 `ref` 返回之前，没有办法使其工作。 所有属性的所有可能实现最终都会返回属性值的副本，因此如果编译器确实允许 [示例 3-92](#error_cannot_modify_a_property_of_a_valu)
    编译，我们将设置由属性返回的副本上的 `X` 属性，而不是属性代表的 `Item` 对象中的实际值。 [示例 3-95](#making_the_copy_explicit)
    显式地进行了此操作，并且实际上会编译—如果我们非常清楚地表明我们确实想要这样做，编译器将允许我们自食其果。 并且通过这个代码版本，很明显这不会修改 `Item`
    对象中的值。
- en: Example 3-95\. Making the copy explicit
  id: totrans-525
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-95\. 明确复制
- en: '[PRE104]'
  id: totrans-526
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: However, with the property implementation in [Example 3-94](#ref_type_property),
    the code in [Example 3-92](#error_cannot_modify_a_property_of_a_valu) does compile
    and ends up behaving like the code shown in [Example 3-96](#making_the_ref_explicit).
    Here we can see that we’ve retrieved a reference to a `Point`, so when we set
    its `X` property, we’re acting on whatever that refers to (the `_location` field
    in the `Item` in this case), rather than a local copy.
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，在 [示例 3-94](#ref_type_property) 中的属性实现中， [示例 3-92](#error_cannot_modify_a_property_of_a_valu)
    中的代码确实编译，并且行为类似于 [示例 3-96](#making_the_ref_explicit) 中显示的代码。 在这里，我们可以看到我们获取了对
    `Point` 的引用，因此当我们设置其 `X` 属性时，我们实际上是在操作其引用的内容（在这种情况下是 `Item` 中的 `_location` 字段），而不是本地副本。
- en: Example 3-96\. Making the reference explicit
  id: totrans-528
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-96\. 明确引用
- en: '[PRE105]'
  id: totrans-529
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'Thanks to fairly recent additions to the language, it’s possible to make it
    work, although there is arguably a loss of encapsulation here: the behavior is
    now more or less equivalent to defining a public field. It’s also easy to get
    it wrong. Fortunately, most value types are immutable, and this problem arises
    only with mutable value types.'
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了语言的相对较新的增强功能，现在可以使其工作，尽管在这里可以说封装性有所减少：行为现在更或多或少等同于定义一个公共字段。 并且很容易搞错。 幸运的是，大多数值类型是不可变的，这个问题只会在可变值类型中出现。
- en: Note
  id: totrans-531
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Immutability doesn’t exactly solve the problem—you still can’t write the code
    you might want to, such as `item.Location.X = 123`. But at least immutable structs
    don’t mislead you by making it look like you should be able to do that.
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 不可变性并不能完全解决问题——您仍然无法编写可能想要的代码，例如 `item.Location.X = 123`。 但至少不可变结构不会让您误以为您应该能够这样做。
- en: 'Since all properties are really just methods (typically in pairs), in theory
    they could accept more arguments in addition to the implicit `value` argument
    used by `set` methods. The CLR allows this, but C# does not support it except
    for one special kind of property: an indexer.'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 由于所有属性实际上只是方法（通常成对出现），理论上除了 `set` 方法使用的隐式 `value` 参数之外，它们可以接受更多参数。 CLR 允许这样做，但是
    C# 除了一种特殊类型的属性——索引器之外不支持。
- en: Indexers
  id: totrans-534
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 索引器
- en: An *indexer* is a property that takes one or more arguments and is accessed
    with the same syntax as is used for arrays. This is useful when you’re writing
    a class that contains a collection of objects. [Example 3-97](#using_an_indexer)
    uses one of the collection classes provided by the runtime libraries, `List<T>`.
    It is essentially a variable-length array, and it feels like a native array thanks
    to its indexer, used on the second and third lines. (I’ll describe arrays and
    collection types in detail in [Chapter 5](ch05.xhtml#ch_collections). And I’ll
    describe generic types, of which `List<T>` is an example, in [Chapter 4](ch04.xhtml#ch_generics).)
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: '*索引器* 是一个接受一个或多个参数的属性，并且使用与数组相同的语法进行访问。 当您编写包含对象集合的类时，这非常有用。 运行库提供的一个集合类示例
    [示例 3-97](#using_an_indexer) 使用 `List<T>`。 它本质上是一个可变长度的数组，并且由于其索引器，在第二和第三行使用。
    （我将在 [第五章](ch05.xhtml#ch_collections) 中详细描述数组和集合类型。 以及我将在 [第四章](ch04.xhtml#ch_generics)
    中描述泛型类型，其中 `List<T>` 是一个示例。）'
- en: Example 3-97\. Using an indexer
  id: totrans-536
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-97\. 使用索引器
- en: '[PRE106]'
  id: totrans-537
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: From the CLR’s point of view, an indexer is a property much like any other,
    except that it has been designated as the *default property*. This concept is
    a holdover from the old COM-based versions of Visual Basic that got carried over
    into .NET, and that C# mostly ignores. Indexers are the only C# feature that treats
    default properties as being special. If a class designates a property as being
    the default one, and if the property accepts at least one argument, C# will let
    you use that property through the indexer syntax.
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 从CLR的角度来看，索引器是与任何其他属性一样的属性，只是它被指定为*默认属性*。这个概念是从旧版基于COM的Visual Basic中保留下来，并且被带入到.NET中，尽管C#大部分情况下忽略了它。索引器是唯一一种将默认属性视为特殊的C#特性。如果一个类指定某个属性为默认属性，并且该属性至少接受一个参数，C#将允许您通过索引器语法使用该属性。
- en: The syntax for declaring indexers is somewhat idiosyncratic. [Example 3-98](#class_with_indexer)
    shows a read-only indexer. You could add a `set` accessor to make it read/write,
    just like with any other property.^([7](ch03.xhtml#idm45884827660912))
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 声明索引器的语法有些特殊。[示例 3-98](#class_with_indexer)展示了一个只读索引器。您可以添加一个`set`访问器使其变为读/写，就像处理任何其他属性一样。^([7](ch03.xhtml#idm45884827660912))
- en: Example 3-98\. Class with indexer
  id: totrans-540
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-98\. 带有索引器的类
- en: '[PRE107]'
  id: totrans-541
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: C# supports multidimensional indexers. These are indexers with more than one
    parameter—since properties are really just methods, you can define indexers with
    any number of parameters. You are free to use any mixture of types for the parameters.
    Indexers also support overloading, so you can define any number of indexers, as
    long as each takes a distinct set of parameter types.
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: C#支持多维索引器。这些是具有多个参数的索引器—因为属性实际上只是方法，您可以为参数定义任意数量的索引器。索引器还支持重载，因此您可以定义任意数量的索引器，只要每个索引器使用一组不同的参数类型。
- en: As you may recall from [Chapter 2](ch02.xhtml#ch_basic_coding), C# offers *null-conditional*
    operators. In that chapter, we saw this used to access properties and fields—e.g.,
    `myString?.Length` will be of type `int?`—and its value will be `null` if `myString`
    is `null`, and the value of the `Length` property otherwise. There is one other
    form of null-conditional operator, which can be used with an indexer, shown in
    [Example 3-99](#null_conditional_index_access).
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您可能从[第二章](ch02.xhtml#ch_basic_coding)中记得的那样，C#提供了*空值条件*运算符。在那一章中，我们看到它被用于访问属性和字段，例如，`myString?.Length`的类型将是`int?`—如果`myString`为`null`，其值将为`null`，否则为`Length`属性的值。还有一种空值条件运算符的形式，可以用于索引器，如[示例 3-99](#null_conditional_index_access)所示。
- en: Example 3-99\. Null-conditional index access
  id: totrans-544
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-99\. 空值条件索引访问
- en: '[PRE108]'
  id: totrans-545
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: As with the null-conditional field or property access, this generates code that
    checks whether the lefthand part (`objectWithIndexer` in this case) is null. If
    it is, the whole expression evaluates to null; it only invokes the indexer if
    the lefthand part of the expression is not null. It is effectively equivalent
    to the code shown in [Example 3-100](#code_equivalent_to_null_conditional_inde).
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 与空值条件字段或属性访问类似，这会生成代码来检查左侧部分（在本例中是`objectWithIndexer`）是否为null。如果是，整个表达式将评估为null；只有在表达式的左侧部分不为null时才会调用索引器。这实际上相当于在[示例 3-100](#code_equivalent_to_null_conditional_inde)中展示的代码。
- en: Example 3-100\. Code equivalent to null-conditional index access
  id: totrans-547
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-100\. 等效于空值条件索引访问的代码
- en: '[PRE109]'
  id: totrans-548
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: This null-conditional index syntax also works with arrays.
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 这种空值条件索引语法也适用于数组。
- en: Initializer syntax
  id: totrans-550
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 初始化器语法
- en: You will often want to set certain properties when you create an object, because
    it might not be possible to supply all relevant information through constructor
    arguments. This is particularly common with objects that represent settings for
    controlling some operation. For example, the `ProcessStartInfo` type enables you
    to configure many different aspects of a newly created OS process. It has 16 properties,
    but you would typically only need to set a few of these in any particular scenario.
    Even if you assume that the name of the file to run should always be present,
    there are still 32,768 possible combinations of properties. You wouldn’t want
    to have a constructor for every one of those.
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 您通常希望在创建对象时设置某些属性，因为可能无法通过构造函数参数提供所有相关信息。这在表示控制某些操作的设置的对象中特别常见。例如，`ProcessStartInfo`类型使您能够配置新创建的操作系统进程的许多不同方面。它有16个属性，但在任何特定场景中，您通常只需设置其中的几个。即使假设运行的文件名应始终存在，仍然存在32768种可能的属性组合。您不希望为其中每一个组合编写构造函数。
- en: In practice, a class might offer constructors for a handful of particularly
    common combinations, but for everything else, you just set the properties after
    construction. C# offers a succinct way to create an object and set some of its
    properties in a single expression. [Example 3-101](#using_an_object_initializer)
    uses this *object initializer* syntax. This also works with fields, although it’s
    relatively unusual to have writable public fields.
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，一个类可能为一些特别常见的组合提供构造函数，但对于其他一切，您只需在构造之后设置属性。C# 提供了一种简洁的方式来创建对象并在单个表达式中设置其一些属性。[示例 3-101](#using_an_object_initializer)
    使用了这种 *对象初始化器* 语法。这也适用于字段，尽管具有可写公共字段相对较不常见。
- en: Example 3-101\. Using an object initializer
  id: totrans-553
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-101\. 使用对象初始化器
- en: '[PRE110]'
  id: totrans-554
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: You can supply constructor arguments too. [Example 3-102](#using_an_object_initializer_with_ctor)
    has the same effect as [Example 3-101](#using_an_object_initializer) but chooses
    to supply the filename as a constructor argument. (This is one of the few properties
    `ProcessStartInfo` lets you supply that way.)
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以提供构造函数参数。[示例 3-102](#using_an_object_initializer_with_ctor) 与 [示例 3-101](#using_an_object_initializer)
    具有相同的效果，但选择将文件名作为构造函数参数提供。（这是 `ProcessStartInfo` 允许以这种方式提供的少数属性之一。）
- en: Example 3-102\. Using a constructor and an object initializer
  id: totrans-556
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-102\. 使用构造函数和对象初始化器
- en: '[PRE111]'
  id: totrans-557
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: The object initializer syntax can remove the need for a separate variable to
    refer to the object while you set the properties you need. As Examples [3-101](#using_an_object_initializer)
    and [3-102](#using_an_object_initializer_with_ctor) show, you can pass an object
    initialized in this way directly as an argument to a method. More generally, this
    style of initialization can be contained entirely within a single expression.
    This is important in scenarios that use expression trees, which we’ll be looking
    at in [Chapter 9](ch09.xhtml#ch_delegates_lambdas_events). Another important benefit
    of initializers is that they can use an `init` accessor—when a property defines
    an `init` accessor and if there are no constructor overloads available that can
    set that property, the object initializer syntax is the only mechanism available
    for setting that property.
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 对象初始化器语法可以消除在设置所需属性时引用对象的单独变量的需要。正如示例 [3-101](#using_an_object_initializer)
    和 [3-102](#using_an_object_initializer_with_ctor) 所示，您可以直接将以这种方式初始化的对象作为参数传递给方法。更一般地说，这种初始化样式可以完全包含在单个表达式中。在使用表达式树的场景中尤为重要，我们将在
    [第9章](ch09.xhtml#ch_delegates_lambdas_events) 中探讨这一点。初始化器的另一个重要优点是，它们可以使用 `init`
    访问器——当属性定义了 `init` 访问器，并且没有可用于设置该属性的构造函数重载时，对象初始化器语法是设置该属性的唯一机制。
- en: There’s a variation on the object initializer syntax that enables you to supply
    values to an indexer in an object initializer. [Example 3-103](#using_an_indexer_in_an_object_initialize)
    uses this to initialize a dictionary. ([Chapter 5](ch05.xhtml#ch_collections)
    describes dictionaries and other collection types in detail.)
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 有一种变体的对象初始化器语法，可以在对象初始化器中为索引器提供值。[示例 3-103](#using_an_indexer_in_an_object_initialize)
    使用此语法来初始化字典。([第5章](ch05.xhtml#ch_collections) 详细描述了字典和其他集合类型。)
- en: Example 3-103\. Using an indexer in an object initializer
  id: totrans-560
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-103\. 在对象初始化器中使用索引器
- en: '[PRE112]'
  id: totrans-561
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: Operators
  id: totrans-562
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运算符
- en: 'Classes and structs can define customized meanings for operators. I showed
    some custom operators earlier: [Example 3-29](#support_custom_comparison) supplied
    definitions for `==` and `!=`. A class or struct can support almost all of the
    arithmetic, logical, and relational operators introduced in [Chapter 2](ch02.xhtml#ch_basic_coding).
    Of the operators shown in Tables [2-3](ch02.xhtml#basic_arithmetic_operators),
    [2-4](ch02.xhtml#binary_integer_operators), [2-5](ch02.xhtml#operators_for_bool),
    and [2-6](ch02.xhtml#relational_operators), you can define custom meanings for
    all except the conditional AND (`&&`) and conditional OR (`||`) operators. Those
    operators are evaluated in terms of other operators, however, so by defining logical
    AND (`&`), logical OR (`|`), and also the logical `true` and `false` operators
    (described shortly), you can control the way that `&&` and `||` work for your
    type, even though you cannot implement them directly.'
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 类和结构体可以为运算符定义自定义含义。我之前展示了一些自定义运算符：[示例 3-29](#support_custom_comparison)提供了`==`和`!=`的定义。类或结构体可以支持在[第2章](ch02.xhtml#ch_basic_coding)中引入的几乎所有算术、逻辑和关系运算符。在表[2-3](ch02.xhtml#basic_arithmetic_operators)、[2-4](ch02.xhtml#binary_integer_operators)、[2-5](ch02.xhtml#operators_for_bool)和[2-6](ch02.xhtml#relational_operators)中展示的运算符中，除了条件AND
    (`&&`) 和条件OR (`||`) 运算符外，你可以为其他所有运算符定义自定义含义。但是这些运算符是基于其他运算符进行评估的，因此通过定义逻辑AND (`&`)、逻辑OR
    (`|`)以及逻辑`true`和`false`运算符（稍后描述），你可以控制`&&`和`||`对于你的类型的工作方式，尽管你不能直接实现它们。
- en: All custom operator implementations follow a certain pattern. They look like
    static methods, but in the place where you’d normally expect the method name,
    you instead have the `operator` keyword followed by the operator for which you
    want to define a custom meaning. After that comes a parameter list, where the
    number of parameters is determined by the number of operands the operator requires.
    [Example 3-104](#implementing_the_plus_operator) shows how the binary `+` operator
    would look for the `Counter` class defined earlier in this chapter.
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 所有自定义运算符实现都遵循一定的模式。它们看起来像静态方法，但在通常期望方法名的位置上，你会看到`operator`关键字，后跟你想要为其定义自定义含义的运算符。之后是一个参数列表，其中参数的数量由运算符所需的操作数数量决定。[示例 3-104](#implementing_the_plus_operator)展示了如何为本章前面定义的`Counter`类实现二元`+`运算符。
- en: Example 3-104\. Implementing the `+` operator
  id: totrans-565
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-104\. 实现`+`运算符
- en: '[PRE113]'
  id: totrans-566
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: Although the argument count must match the number of operands the operator requires,
    only one of the arguments has to be the same as the defining type. [Example 3-105](#supporting_other_operand_types)
    exploits this to allow the `Counter` class to be added to an `int`.
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然参数数量必须与运算符所需的操作数数量匹配，但只有一个参数必须与定义类型相同。[示例 3-105](#supporting_other_operand_types)利用这一点允许将`Counter`类添加到`int`中。
- en: Example 3-105\. Supporting other operand types
  id: totrans-568
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-105\. 支持其他操作数类型
- en: '[PRE114]'
  id: totrans-569
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: C# requires certain operators to be defined in pairs. We already saw this with
    the `==` and `!=` operators—it is illegal to define one and not the other. Likewise,
    if you define the `>` operator for your type, you must also define the `<` operator,
    and vice versa. The same is true for `>=` and `<=`. (There’s one more pair, the
    `true` and `false` operators, but they’re slightly different; I’ll get to those
    shortly.)
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 在C#中，某些运算符必须成对定义。我们已经看到了`==`和`!=`运算符的情况——定义一个而不定义另一个是不合法的。同样，如果你为你的类型定义了`>`运算符，那么你必须同时定义`<`运算符，反之亦然。对于`>=`和`<=`也是如此。（还有一对运算符是`true`和`false`，但它们稍有不同；我稍后会详细说明。）
- en: When you overload an operator for which a compound assignment operator exists,
    you are in effect defining behavior for both. For example, if you define custom
    behavior for the `+` operator, the `+=` operator will automatically work too.
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: 当你为存在复合赋值运算符的运算符重载时，实际上你定义了两者的行为。例如，如果你为`+`运算符定义了自定义行为，那么`+=`运算符也会自动工作。
- en: The `operator` keyword can also define custom conversions—methods that convert
    your type to or from some other type. For example, if we wanted to be able to
    convert `Counter` objects to and from `int`, we could add the two methods in [Example 3-106](#conversion_operators)
    to the class.
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: '`operator`关键字还可以定义自定义转换——将你的类型转换为其他类型或从其他类型转换。例如，如果我们希望能够将`Counter`对象转换为`int`并且反之亦然，我们可以将[示例 3-106](#conversion_operators)中的两个方法添加到该类中。'
- en: Example 3-106\. Conversion operators
  id: totrans-573
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-106\. 转换运算符
- en: '[PRE115]'
  id: totrans-574
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: I’ve used the `explicit` keyword here, which means that these conversions are
    accessed with the cast syntax, as [Example 3-107](#using_explicit_conversion_operators)
    shows.
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我使用了`explicit`关键字，这意味着这些转换可以使用强制类型转换的语法，正如[示例3-107](#using_explicit_conversion_operators)所示。
- en: Example 3-107\. Using explicit conversion operators
  id: totrans-576
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-107\. 使用显式转换运算符
- en: '[PRE116]'
  id: totrans-577
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'If you use the `implicit` keyword instead of `explicit`, your conversion will
    be able to happen without needing a cast. In [Chapter 2](ch02.xhtml#ch_basic_coding)
    we saw that some conversions happen implicitly: in certain situations, C# will
    automatically promote numeric types. For example, you can use an `int` where a
    `long` is expected, perhaps as an argument for a method or in an assignment. Conversion
    from `int` to `long` will always succeed and can never lose information, so the
    compiler will automatically generate code to perform the conversion without requiring
    an explicit cast. If you write `implicit` conversion operators, the C# compiler
    will silently use them in exactly the same way, enabling your custom type to be
    used in places where some other type was expected. (In fact, the C# specification
    defines numeric promotions such as conversion from `int` to `long` as built-in
    implicit conversions.)'
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用`implicit`关键字而不是`explicit`，你的转换可以在不需要转换的情况下进行。在[第2章](ch02.xhtml#ch_basic_coding)中我们看到，某些转换是隐式进行的：在特定情况下，C#会自动提升数值类型。例如，你可以在期望`long`的地方使用`int`，比如作为方法的参数或赋值。从`int`到`long`的转换总是成功的，不会丢失信息，所以编译器会自动生成代码来执行转换，而不需要显式的类型转换。如果你编写`implicit`转换运算符，C#编译器将会静默地以完全相同的方式使用它们，使得你的自定义类型可以在期望其他类型的地方使用。（事实上，C#规范定义了如从`int`到`long`的数值提升作为内置的隐式转换。）
- en: 'Implicit conversion operators are something you shouldn’t need to write very
    often. You should do so only when you can meet the same standards as built-in
    promotions: the conversion must always be possible and should never throw an exception.
    Moreover, the conversion should be unsurprising—`implicit` conversions are a little
    sneaky in that they allow you to cause methods to be invoked in code that doesn’t
    look like it’s calling a method. So unless you’re intending to confuse other developers,
    you should write implicit conversions only where they seem to make unequivocal
    sense.'
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 隐式转换运算符并不是你经常需要编写的东西。只有当你可以达到与内置提升相同的标准时才应该这样做：转换必须始终可能，并且不应抛出异常。此外，转换应该是不令人意外的——`implicit`转换有点狡猾，因为它们允许你在看起来不像是调用方法的代码中调用方法。因此，除非你打算混淆其他开发人员，否则你应该只在似乎毫无疑问的地方编写隐式转换。
- en: 'C# recognizes two more operators: `true` and `false`. If you define either
    of these, you are required to define both. These are a bit of an oddball pair,
    because although the C# specification defines them as unary operator overloads,
    they don’t correspond directly to any operator you can write in an expression.
    They come into play in two scenarios.'
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: C#还识别出两个运算符：`true`和`false`。如果你定义了其中一个，你必须同时定义另一个。这两个运算符有点奇怪，因为虽然C#规范将它们定义为一元运算符重载，但它们并不直接对应于你可以在表达式中编写的任何运算符。它们在两种情况下起作用。
- en: If you have not defined an implicit conversion to `bool`, but you have defined
    the `true` and `false` operators, C# will use the `true` operator if you use your
    type as the expression for an `if` statement or a `do` or `while` loop, or as
    the condition expression in a `for` loop. However, the compiler prefers the implicit
    `bool` operator, so this is not the main reason the `true` and `false` operators
    exist.
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有定义一个隐式转换到`bool`的方法，但是你定义了`true`和`false`运算符，那么当你把你的类型作为`if`语句、`do`或`while`循环的表达式，或者作为`for`循环的条件表达式时，C#将使用`true`运算符。然而，编译器更倾向于隐式的`bool`运算符，所以这并不是`true`和`false`运算符存在的主要原因。
- en: The main scenario for the `true` and `false` operators is to enable your custom
    type to be used as an operand of a conditional Boolean operator (either `&&` or
    `||`). Remember that these operators will evaluate their second operand only if
    the first outcome does not fully determine the result. If you want to customize
    the behavior of these operators, you cannot implement them directly. Instead,
    you must define the nonconditional versions of the operators (`&` and `|`), and
    you must also define the `true` and `false` operators. When evaluating `&&`, C#
    will use your `false` operator on the first operand, and if that indicates that
    the first operand is false, then it will not bother to evaluate the second operand.
    If the first operand is not false, it will evaluate the second operand and then
    pass both into your custom `&` operator. The `||` operator works in much the same
    way but with the `true` and `|` operators, respectively.
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: '`true` 和 `false` 操作符的主要场景是允许你的自定义类型作为条件布尔运算符（`&&` 或 `||`）的操作数之一。请记住，这些操作符仅在第一个结果不能完全确定结果时才会评估其第二个操作数。如果您想定制这些操作符的行为，则不能直接实现它们。相反，您必须定义操作符的非条件版本（`&`
    和 `|`），并且还必须定义 `true` 和 `false` 操作符。在评估 `&&` 时，C# 将在第一个操作数上使用您的 `false` 操作符，如果这表明第一个操作数是假的，则不会评估第二个操作数。如果第一个操作数不是假的，则将评估第二个操作数，然后将两者传递到您的自定义
    `&` 操作符中。`||` 操作符的工作方式类似，但使用 `true` 和 `|` 操作符分别。'
- en: You may be wondering why we need special `true` and `false` operators—couldn’t
    we just define an implicit conversion to the `bool` type? In fact we can, and
    if we do that instead of providing `&`, `|`, `true`, and `false`, C# will use
    that to implement `&&` and `||` for our type. However, some types may want to
    represent values that are neither true nor false—there may be a third value representing
    an unknown state. The `true` operator allows C# to ask the question “Is this definitely
    true?” and for the object to be able to answer “no” without implying that it’s
    definitely false. A conversion to `bool` does not support that.
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 或许你会想为什么我们需要特别的 `true` 和 `false` 操作符 —— 难道我们不能简单地定义到 `bool` 类型的隐式转换吗？事实上我们可以，如果我们这样做而不是提供
    `&`、`|`、`true` 和 `false`，C# 将使用它来实现我们类型的 `&&` 和 `||`。然而，有些类型可能希望表示既非真也非假的值 ——
    可能存在一个第三个值，表示未知状态。`true` 操作符允许 C# 提出问题：“这绝对是真吗？” 并且对象可以回答 “不是” 而不意味着它绝对是假的。转换到
    `bool` 不支持这一点。
- en: Note
  id: totrans-584
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The `true` and `false` operators have been present since the first version of
    C#, and their main application was to enable the implementation of types that
    support nullable Boolean values with similar semantics to those offered by many
    databases. The nullable type support added in C# 2.0 provides a better solution,
    so these operators are no longer particularly useful, but there are still some
    old parts of the runtime libraries that depend on them.
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: '`true` 和 `false` 操作符自 C# 的第一个版本以来就存在，并且它们的主要应用是使得支持可空布尔值的类型可以具有与许多数据库提供的语义类似的实现。C#
    2.0 中添加的可空类型支持提供了更好的解决方案，因此这些操作符不再特别有用，但仍然有一些旧的运行库部分依赖于它们。'
- en: No other operators can be overloaded. For example, you cannot define custom
    meanings for the `.` operator used to access members of a method, or the conditional
    (`? :`) or null coalescing (`??`) operators.
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: 不能重载任何其他操作符。例如，不能为用于访问方法成员的 `.` 操作符或条件运算符 (`? :`) 或空值合并运算符 (`??`) 定义自定义含义。
- en: Events
  id: totrans-587
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 事件
- en: Structs and classes can declare *events*. This kind of member enables a type
    to provide notifications when interesting things happen, using a subscription-based
    model. For example, a UI object representing a button might define a `Click` event,
    and you can write code that subscribes to that event.
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: 结构体和类可以声明*事件*。这种成员类型使得类型在发生有趣的事情时能够提供通知，采用订阅模型。例如，表示按钮的 UI 对象可能定义一个 `Click`
    事件，您可以编写代码订阅该事件。
- en: Events depend on delegates, and since [Chapter 9](ch09.xhtml#ch_delegates_lambdas_events)
    is dedicated to these topics, I won’t go into any detail here. I’m mentioning
    them only because this section on type members would otherwise be incomplete.
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: 事件依赖于委托，而由于[第9章](ch09.xhtml#ch_delegates_lambdas_events)专门讨论了这些主题，我在这里不会详细介绍。我仅提到它们是因为否则这一类型成员部分会显得不完整。
- en: Nested Types
  id: totrans-590
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 嵌套类型
- en: The final kind of member we can define in a class, a struct, or a record is
    a nested type. You can define nested classes, structs, or any of the other types
    described later in this chapter. A nested type can do anything its normal counterpart
    would do, but it gets a couple of additional features.
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: 在类、结构体或记录中可以定义的最终成员类型是嵌套类型。你可以在本章后面描述的任何类型中定义嵌套类、结构体或任何其他类型。嵌套类型可以做任何其正常对应部分可以做的事情，但它还有几个额外的功能。
- en: When a type is nested, you have more choices for accessibility. A type defined
    at global scope can be only `public` or `internal`—`private` would make no sense,
    because that makes something accessible only from within its containing type,
    and there is no containing type when you define something at global scope. But
    a nested type does have a containing type, so if you define a nested type and
    make it `private`, that type can be used only from inside the type within which
    it is nested. [Example 3-108](#private_nested_class) shows a private class.
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个类型被嵌套时，你对于可访问性有更多的选择。在全局范围定义的类型只能是`public`或者`internal`，因为`private`没有意义，因为私有仅使得某些东西仅从其包含的类型内部访问，而在定义在全局范围内的东西时没有包含的类型。但是嵌套类型确实有一个包含类型，因此如果你定义一个嵌套类型并将其设为`private`，那么该类型只能在它被嵌套的类型内部使用。[示例
    3-108](#private_nested_class) 展示了一个私有的类。
- en: Example 3-108\. A private nested class
  id: totrans-593
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-108\. 一个私有的嵌套类
- en: '[PRE117]'
  id: totrans-594
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: Private classes can be useful in scenarios like this where you are using an
    API that requires an implementation of a particular interface, and either you
    don’t want to make that interface part of your type or, as in this case, you couldn’t
    even if you wanted to. (My `FileSorter` type is `static`, so I can’t create an
    instance of it to pass to `Array.Sort`.) In this case, I’m calling `Array.Sort`
    to sort a list of files by the lengths of their names. (This is not useful, but
    it looks nice.) I’m providing the custom sort order in the form of an object that
    implements the `IComparer<string>` interface. I’ll describe interfaces in detail
    in the next section, but this interface is just a description of what the `Array.Sort`
    method needs us to provide. I’ve written a custom class to implement this interface.
    This class is just an implementation detail of the rest of my code, so I don’t
    want to make it public. A nested private class is just what I need.
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: 私有类在这种情况下可能很有用，例如当你使用一个需要实现特定接口的API，而你不想把该接口作为你的类型的一部分，或者像在这种情况下一样，即使你想也不能。（我的`FileSorter`类型是`static`的，所以我不能创建它的实例来传递给`Array.Sort`。）在这种情况下，我调用`Array.Sort`来按文件名长度排序文件列表。（虽然这没什么用，但看起来不错。）我提供自定义排序顺序，形式是实现了`IComparer<string>`接口的对象。接口的详细信息我将在下一节详细描述，但这个接口仅仅是描述了`Array.Sort`方法需要我们提供的内容。我编写了一个自定义类来实现这个接口。这个类仅仅是我代码的一个实现细节，所以我不想把它设为公共的。一个嵌套的私有类正是我需要的。
- en: Code in a nested type is allowed to use nonpublic members of its containing
    type. However, an instance of a nested type does not automatically get a reference
    to an instance of its containing type. If you need nested instances to have a
    reference to their container, then you will need to declare a field to hold that
    and arrange for it to be initialized; this would work in exactly the same way
    as any object that wants to hold a reference to another object. Obviously, it’s
    an option only if the outer type is a reference type.
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌套类型中的代码可以使用其包含类型的非公共成员。然而，嵌套类型的实例并不会自动获取对其包含类型实例的引用。如果您需要嵌套实例引用它们的容器，则需要声明一个字段来保存它，并安排进行初始化；这将与希望保留对另一个对象引用的任何对象完全相同。显然，这只适用于外部类型是引用类型的情况。
- en: So far, we’ve looked only at classes, records, and structs, but there are some
    other ways to define custom types in C#. One of these is complicated enough to
    warrant getting its own chapter, but there are a couple of simpler ones that I’ll
    discuss here.
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只看过类、记录和结构体，但在C#中定义自定义类型还有其他几种方法。其中一种足够复杂，值得单独章节讨论，但还有几种较简单的方法我会在这里讨论。
- en: Interfaces
  id: totrans-598
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接口
- en: C#’s `interface` keyword defines a programming interface. Interfaces are very
    often entirely devoid of implementation, although you can define default implementations
    for some or all methods. You can also define nested types and static fields. (Interfaces
    cannot define nonstatic fields, though.) Classes can choose to implement interfaces.
    If you write code that works in terms of an interface, it will be able to work
    with anything that implements that interface, instead of being limited to working
    with one particular type.
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: C#的`interface`关键字定义了一个编程接口。接口往往完全没有实现，尽管您可以为某些或所有方法定义默认实现。您还可以定义嵌套类型和静态字段。（但接口不能定义非静态字段。）类可以选择实现接口。如果您编写的代码是基于一个接口，它将能够与实现该接口的任何内容一起工作，而不限于与一个特定类型一起工作。
- en: For example, the .NET runtime libraries include an interface called `IEnumerable<T>`,
    which defines a minimal set of members for representing sequences of values. (It’s
    a generic interface, so it can represent sequences of anything. For example, an
    `IE⁠num⁠era⁠ble​<st⁠rin⁠g>` is a sequence of strings. Generic types are discussed
    in [Chapter 4](ch04.xhtml#ch_generics).) If a method has a parameter of type `IEnumerable<string>`,
    you can pass it a reference to an instance of any type that implements the interface,
    which means that a single method can work with arrays, various collection classes
    provided by the .NET runtime libraries, certain LINQ features, and many other
    things.
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，.NET运行库包括一个名为`IEnumerable<T>`的接口，它定义了一个表示值序列的最小成员集。（它是一个泛型接口，因此可以表示任何类型的序列。例如，`IE⁠num⁠era⁠ble​<st⁠rin⁠g>`是一个字符串序列。泛型类型在[第4章](ch04.xhtml#ch_generics)中讨论。）如果一个方法具有类型为`IEnumerable<string>`的参数，您可以将其传递给任何实现该接口的类型的实例的引用，这意味着单个方法可以与数组、.NET运行库提供的各种集合类、某些LINQ特性和许多其他内容一起工作。
- en: An interface declares methods, properties, and events, but it doesn’t have to
    define their bodies, as [Example 3-109](#interface) shows. Properties indicate
    whether getters and/or setters should be present, but we have semicolons in place
    of the bodies. An interface is effectively a list of the members that a type will
    need to provide if it wants to implement the interface. Be aware that on .NET
    Framework, these method-like members are the only kinds of members interfaces
    can have. I’ll discuss the additional member types available on .NET Core and
    .NET shortly, but the majority of interfaces you are likely to come across today
    only contain these kinds of members.
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: 接口声明方法、属性和事件，但不必定义它们的实现，就像[示例 3-109](#interface)展示的那样。属性指示是否应存在getter和/或setter，但我们用分号代替实现体。接口实际上是一个列表，列出了一个类型在想要实现接口时需要提供的成员。请注意，在.NET
    Framework上，这些方法类成员是接口可以拥有的唯一类型的成员。稍后我将讨论在.NET Core和.NET上可用的其他成员类型，但今天你可能会遇到的大多数接口只包含这些成员类型。
- en: Example 3-109\. An interface
  id: totrans-602
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-109\. 一个接口
- en: '[PRE118]'
  id: totrans-603
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: Individual method-like members are not allowed accessibility modifiers—their
    accessibility is controlled at the level of the interface itself. (Like classes,
    interfaces are either `public` or `internal`, unless they are nested, in which
    case they can have any accessibility.) Interfaces cannot declare constructors—an
    interface only gets to say what services an object should supply once it has been
    constructed.
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: 单独的方法成员不允许使用访问修饰符——它们的访问权限由接口本身控制。（与类一样，接口要么是`public`，要么是`internal`，除非它们是嵌套的，在这种情况下，它们可以有任何访问权限。）接口不能声明构造函数——接口只能在对象构造后说对象应该提供哪些服务。
- en: By the way, most interfaces in .NET follow the convention that their name starts
    with an uppercase `I` followed by one or more words in PascalCasing.
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，在.NET中，大多数接口遵循以下约定：它们的名称以大写字母`I`开头，后面跟着一个或多个PascalCasing风格的单词。
- en: A class declares the interfaces that it implements in a list after a colon following
    the class name, as [Example 3-110](#implementing_an_interface) shows. It must
    provide implementations of all the members listed in the interface. You’ll get
    a compiler error if you leave any out. Record types can also implement interfaces,
    using a similar syntax. If the record type uses the positional syntax, the colon
    and interface list come after the positional parameter list.
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: 类在类名后面的冒号后面的列表中声明它实现的接口，就像[示例 3-110](#implementing_an_interface)所示的那样。它必须提供接口中列出的所有成员的实现。如果您遗漏了任何一个成员，编译器将会报错。记录类型也可以实现接口，使用类似的语法。如果记录类型使用位置语法，冒号和接口列表将在位置参数列表后出现。
- en: Example 3-110\. Implementing an interface
  id: totrans-607
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-110\. 实现一个接口
- en: '[PRE119]'
  id: totrans-608
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: When we implement an interface in C#, we typically define each of that interface’s
    methods as a public member of our class. However, sometimes you may want to avoid
    this. Occasionally, some API may require you to implement an interface that you
    feel pollutes the purity of your class’s API. Or, more prosaically, you may already
    have defined a member with the same name and signature as a member required by
    the interface, but that does something different from what the interface requires.
    Or worse, you may need to implement two different interfaces, both of which define
    members that have the same name and signature but require different behavior.
    You can solve any of these problems with a technique called *explicit implementation*
    to define members that implement a member of a specific interface without being
    public. [Example 3-111](#explicit_implementation_of_an_interface) shows the syntax
    for this, with an implementation of one of the methods from the interface in [Example 3-109](#interface).
    With explicit implementations, you do not specify the accessibility, and you prefix
    the member name with the interface name.
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: 在C#中实现接口时，通常将该接口的每个方法定义为类的公共成员。然而，有时你可能希望避免这样做。偶尔，某些API可能要求你实现一个污染了类API纯度的接口。或者更平淡地说，你可能已经定义了与接口要求的同名同签名成员执行不同操作的成员。或者更糟的是，你可能需要实现两个不同的接口，这两个接口都定义了具有相同名称和签名但需要不同行为的成员。你可以通过称为*显式实现*的技术解决这些问题，来定义实现特定接口成员的成员，而无需公开。[示例3-111](#explicit_implementation_of_an_interface)展示了此语法，包括从[示例3-109](#interface)中接口方法的实现。使用显式实现时，你不需要指定可访问性，并且需要用接口名称作为成员名称的前缀。
- en: Example 3-111\. Explicit implementation of an interface member
  id: totrans-610
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例3-111\. 显式实现接口成员
- en: '[PRE120]'
  id: totrans-611
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: When a type uses explicit interface implementation, those members cannot be
    used through a reference of the type itself. They become visible only when referring
    to an object through an expression of the interface’s type.
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: 当类型使用显式接口实现时，这些成员不能通过类型本身的引用使用。它们只有在通过接口类型的表达式引用对象时才可见。
- en: When a class implements an interface, it becomes implicitly convertible to that
    interface type. So you can pass any expression of type `DoStuff` from [Example 3-110](#implementing_an_interface)
    as a method argument of type `IDoStuff`, for example.
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: 当类实现接口时，它变成了隐式可转换为该接口类型。因此，你可以将来自[示例3-110](#implementing_an_interface)的`DoStuff`类型的任何表达式作为`IDoStuff`类型的方法参数传递，例如。
- en: Interfaces are reference types. Despite this, you can implement interfaces on
    both classes and structs. However, you need to be careful when doing so with a
    struct, because when you get hold of an interface-typed reference to a struct,
    it will be a reference to a *box*, which is effectively an object that holds a
    copy of a struct in a way that can be referred to via a reference. We’ll look
    at boxing in [Chapter 7](ch07.xhtml#ch_object_lifetime).
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: 接口是引用类型。尽管如此，你可以在类和结构上实现接口。但是，在对结构进行此类操作时需要小心，因为当你获取一个结构的接口类型引用时，它实际上是对*箱*的引用，这是一种以可以通过引用引用的方式保存结构的对象。我们将在[第7章](ch07.xhtml#ch_object_lifetime)中讨论装箱。
- en: Default Interface Implementation
  id: totrans-615
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 默认接口实现
- en: An interface definition can include some implementation details. This relatively
    new feature (added in C# 8.0) relies on runtime support, so it is only available
    in code that targets .NET Core 3.1 or later, or .NET Standard 2.1 or later, so
    you can’t use this on .NET Framework. But as long as you’re using a suitable runtime,
    your interface definition can supply static fields, nested types, and bodies for
    methods, property accessors, and the `add` and `remove` methods for events (which
    I will describe in [Chapter 9](ch09.xhtml#ch_delegates_lambdas_events)). [Example 3-112](#interface_with_default_implementation)
    shows this in use to define a default implementation of a property.
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: 接口定义可以包含一些实现细节。这个相对较新的特性（在C# 8.0中添加）依赖于运行时支持，因此仅适用于目标为.NET Core 3.1或更高版本，或者.NET
    Standard 2.1或更高版本的代码，因此无法在.NET Framework上使用。但只要你使用合适的运行时，你的接口定义可以提供静态字段、嵌套类型，以及方法、属性访问器的主体，以及事件的`add`和`remove`方法（我将在[第9章](ch09.xhtml#ch_delegates_lambdas_events)中描述）。[示例3-112](#interface_with_default_implementation)展示了如何使用它来定义属性的默认实现。
- en: Example 3-112\. An interface with a default property implementation
  id: totrans-617
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例3-112\. 带有默认属性实现的接口
- en: '[PRE121]'
  id: totrans-618
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: If a class chooses to implement `INamed`, it will only be required to provide
    an implementation for this interface’s `Id` property. It can also supply a `Name`
    property if it wants to, but this is optional. If the class does not define its
    own `Name`, the definition from the interface will be used instead.
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个类选择实现 `INamed` 接口，它只需要为这个接口的 `Id` 属性提供实现。它也可以提供一个 `Name` 属性，但这是可选的。如果类没有定义自己的
    `Name`，则会使用接口中的定义。
- en: 'Default interface implementations provide a partial solution to a long-standing
    limitation of interfaces: if you define an interface that you then make available
    for other code to use (e.g., via a class library), adding new members to that
    interface could cause problems for existing code that uses it. Code that invokes
    methods on the interface won’t have a problem because it will be blissfully unaware
    that new members were added, but any class that implements your interface would,
    prior to C# 8.0, be broken if you were to add new members. A concrete class is
    required to supply all the members of an interface it implements, so if the interface
    gets new members, formerly complete implementations will now be incomplete. Unless
    you have some way of reaching out to everyone who has written types that implement
    your interface and getting them to add the missing members, you will cause them
    problems if they upgrade to the new version.'
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: 默认接口实现为接口长期存在的一个局限性提供了部分解决方案：如果你定义了一个接口，然后让其他代码使用它（例如通过类库），那么向该接口添加新成员可能会对已存在使用它的代码造成问题。调用接口方法的代码不会有问题，因为它并不知道新成员的存在，但是任何实现你接口的类，在
    C# 8.0 之前，如果你添加了新成员，就会出现问题。具体类需要提供其实现的接口所有成员，因此如果接口添加了新成员，原本完整的实现现在将变得不完整。除非你有办法联系到所有实现你接口的类型的作者，并让他们添加缺失的成员，否则如果他们升级到新版本，将会给他们带来问题。
- en: 'You might think that this would only be a problem if the authors of code that
    works with an interface deliberately upgraded to the library containing the updated
    interface, at which point they’d have an opportunity to fix the problem. However,
    library upgrades can sometimes be forced on code. If you write an application
    that uses multiple libraries, each of which was built against different versions
    of some common library, then at least one of those is going to end up getting
    a different version of that common library at runtime than the version it was
    compiled against. (The poster child for this is the Json.NET library for parsing
    JSON. It’s extremely widely used and has had many versions released, so it’s common
    for a single application to use multiple libraries, each with a dependency on
    a different version of Json.NET. Only one version is used at runtime, so they
    can’t all have their expectations met.) This means that even if you use schemes
    such as semantic versioning, in which breaking changes are always accompanied
    by a change to the component’s major version number, that might not be enough
    to avoid trouble: you might find yourself needing to use two components where
    one wants the v1.0 flavor of some interface, while another wants the v2.0 edition.'
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会认为这只有当使用接口的代码作者有意升级到包含更新接口的库时才会成为问题，这时他们会有机会修复问题。然而，有时候库的升级可能会被强制进行。如果你编写一个应用程序，使用了多个库，每个库都是针对某些共同库的不同版本构建的，那么其中至少一个在运行时将会获取到与其编译版本不同的共同库的版本。（这种情况的典型例子是
    Json.NET 库用于解析 JSON。它被广泛使用，并且有许多版本发布，因此一个应用程序通常会使用多个库，每个库依赖于 Json.NET 的不同版本。在运行时只能使用一个版本，因此它们无法满足所有的期望。）这意味着，即使你使用了语义版本控制这样的方案，在这种方案中，破坏性变更总是伴随着组件主版本号的更改，这可能并不足以避免麻烦：你可能会发现自己需要同时使用两个组件，其中一个需要某个接口的
    v1.0 版本，而另一个则需要 v2.0 版本。
- en: 'The upshot of this was that interfaces were essentially frozen: you couldn’t
    add new members over time, even across major version changes. But default interface
    implementations loosen this restriction: you can add a new member to an existing
    interface if you also provide a default implementation for it. That way, existing
    types that implemented the older version were able to supply a complete implementation
    of the updated definition, because they automatically pick up the default implementation
    of the newly added member without needing to be modified in any way. (There is
    a small fly in the ointment, making it still sometimes preferable to use the older
    solution to this problem, abstract base classes. [Chapter 6](ch06.xhtml#ch_inheritance)
    describes these issues. So although default interface implementation can provide
    a useful escape hatch, you should still avoid modifying published interfaces if
    at all possible.)'
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是接口基本上被冻结了：即使跨大版本更改，你也不能随时间添加新成员。但是默认接口实现放宽了这一限制：如果为新添加的成员提供了默认实现，你可以向现有接口添加新成员。这样，已实现旧版本的类型可以提供更新定义的完整实现，因为它们自动获取新添加成员的默认实现，无需任何修改。（然而，这个方法仍有一些小缺陷，使得在某些情况下仍然更倾向于使用旧的解决方案，即抽象基类。[Chapter 6](ch06.xhtml#ch_inheritance)
    描述了这些问题。因此，尽量避免修改已发布的接口，尽管默认接口实现可以提供有用的逃生口。）
- en: 'In addition to providing extra flexibility for backward compatibility, the
    default interface implementation feature adds three more capabilities: interfaces
    can now define constants, static fields, and types. [Example 3-113](#interface_with_const_and_nested_type)
    shows an interface that contains a nested constant and type.'
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: 除了为向后兼容性提供额外的灵活性外，默认接口实现功能还增加了三个功能：接口现在可以定义常量、静态字段和类型。 [Example 3-113](#interface_with_const_and_nested_type)
    显示了一个包含嵌套常量和类型的接口。
- en: Example 3-113\. An interface with a `const` and a nested type
  id: totrans-624
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 3-113\. 包含 `const` 和嵌套类型的接口
- en: '[PRE122]'
  id: totrans-625
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: With non-method-like members such as these, we need to specify the accessibility,
    because in some cases you may want to introduce these nested members purely for
    the benefit of default method implementations, in which case you’d want them to
    be `private`. In this case, I want the relevant members to be accessible to all,
    since they form part of the API defined by this interface, so I have marked them
    as `public`. You might be looking at that nested `Outcome` type and wondering
    what’s going on. Wonder no more.
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: 对于诸如这些非方法样式成员，我们需要指定其可访问性，因为在某些情况下，你可能只想为了默认方法实现而引入这些嵌套成员，在这种情况下，你希望它们是 `private`
    的。在这种情况下，我希望相关成员对所有人都可访问，因为它们是该接口定义的一部分 API，所以我将它们标记为 `public`。你可能正在看这个嵌套的 `Outcome`
    类型并想知道发生了什么。不用再纳闷了。
- en: Enums
  id: totrans-627
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 枚举
- en: The `enum` keyword declares a very simple type that defines a set of named values.
    [Example 3-114](#enum_with_mutually_exclusive_options) shows an `enum` that defines
    a set of mutually exclusive choices. You could say that this *enumerates* the
    options, which is where the `enum` keyword gets its name.
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: '`enum` 关键字声明了一种非常简单的类型，用于定义一组命名值。 [Example 3-114](#enum_with_mutually_exclusive_options)
    显示了一个定义了一组互斥选择的 `enum`。你可以说这个 *列举* 了选项，这就是 `enum` 关键字得名的由来。'
- en: Example 3-114\. An `enum` with mutually exclusive options
  id: totrans-629
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 3-114\. 具有互斥选项的 `enum`
- en: '[PRE123]'
  id: totrans-630
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: An `enum` can be used in most places you might use any other type—it could be
    the type of a local variable, a field, or a method parameter, for example. But
    one of the most common ways to use an `enum` is in a `switch` statement, as [Example 3-115](#switching_with_an_enum)
    shows.
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: '`enum` 可以在大多数情况下使用，就像你可能使用其他任何类型一样——它可以是局部变量、字段或方法参数的类型，例如。但是使用 `enum` 最常见的一种方式是在
    `switch` 语句中，正如 [Example 3-115](#switching_with_an_enum) 所示。'
- en: Example 3-115\. Switching with an `enum`
  id: totrans-632
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 3-115\. 使用 `enum` 进行切换
- en: '[PRE124]'
  id: totrans-633
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: As this illustrates, to refer to enumeration members, you must qualify them
    with the type name. In fact, an `enum` is really just a fancy way of defining
    a load of `const` fields. The members are all just `int` values under the covers.
    You can even specify the values explicitly, as [Example 3-116](#explicit_enum_values)
    shows.
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: 正如这个例子所示，要引用枚举成员，必须使用类型名称限定它们。事实上，`enum` 只是定义一堆 `const` 字段的一种花哨方式。这些成员在底层都是
    `int` 值。你甚至可以像 [Example 3-116](#explicit_enum_values) 所示一样显式指定这些值。
- en: Example 3-116\. Explicit `enum` values
  id: totrans-635
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 3-116\. 显式 `enum` 值
- en: '[PRE125]'
  id: totrans-636
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: This example also shows an alternative way to use an `enum`. The options in
    [Example 3-116](#explicit_enum_values) are not mutually exclusive. I’ve used binary
    constants here, so you can see that each value corresponds to a particular bit
    position being set to 1\. This makes it easy to combine them—`Eggs` and `Bacon`
    would be 3 (11 in binary), while `Eggs`, `Bacon`, `Sausages`, `BlackPudding`,
    and `BakedBeans` (my preferred combination) would be 103 (1100111 in binary, or
    0x67 in hex).
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例还展示了使用`enum`的另一种方法。[示例3-116](#explicit_enum_values) 中的选项不是互斥的。我在这里使用了二进制常量，这样你可以看到每个值对应于特定的位位置被设置为1。这使得它们易于组合——`Eggs`和`Bacon`将是3（二进制中的11），而`Eggs`、`Bacon`、`Sausages`、`BlackPudding`和`BakedBeans`（我偏爱的组合）将是103（二进制中的1100111，或者16进制中的0x67）。
- en: Note
  id: totrans-638
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: When combining flag-based enumeration values, we normally use the bitwise OR
    operator. For example, you could write `Ing⁠red⁠ien⁠ts.​Eg⁠gs|⁠Ing⁠red⁠ien⁠ts.⁠Ba⁠con`.
    Not only is this significantly easier to read than using the numeric values, but
    it also works well with the search tools in IDEs—you can find all the places a
    particular symbol is used by right-clicking its definition and choosing Find All
    References or Go to References, respectively, from the context menu. You might
    come across code that uses `+` instead of `|`. This works for some combinations;
    however, `Ingredients.TheFullEnglish + Ingredients.Eggs` would be a value of 128,
    which does not correspond to anything, so it is safer to stick with `|`.
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: 在组合基于标志的枚举值时，通常使用按位OR运算符。例如，你可以写`Ing⁠red⁠ien⁠ts.​Eg⁠gs|⁠Ing⁠red⁠ien⁠ts.⁠Ba⁠con`。这不仅比使用数值更容易阅读，而且在IDE中的搜索工具中也很有效——你可以通过右键单击其定义并选择“查找所有引用”或“转到引用”来查找使用特定符号的所有位置。你可能会遇到使用`+`而不是`|`的代码。这对某些组合有效；然而，`Ingredients.TheFullEnglish
    + Ingredients.Eggs`将是一个值为128的值，这不对应于任何东西，因此最好还是坚持使用`|`。
- en: When you declare an `enum` that’s designed to be combined in this way, you’re
    supposed to annotate it with the `Flags` attribute, which is defined in the `System`
    namespace. ([Chapter 14](ch14.xhtml#ch_attributes) will describe attributes in
    detail.) [Example 3-116](#explicit_enum_values) does this, although in practice,
    it doesn’t matter greatly if you forget, because the C# compiler doesn’t care,
    and in fact, there are very few tools that pay any attention to it. The main benefit
    is that if you call `ToString` on an `enum` value, it will notice when the `Flags`
    attribute is present. For this `Ingredients` type, `ToString` would convert the
    value of 3 to the string `Eggs, Bacon`, which is also how the debugger would show
    the value, whereas without the `Flags` attribute, it would be treated as an unrecognized
    value, and you would just get a string containing the digit `3`.
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: 当你声明一个设计为可以这样组合的`enum`时，应该使用`Flags`属性进行注释，该属性定义在`System`命名空间中。([第14章](ch14.xhtml#ch_attributes)将详细描述属性。)
    [示例3-116](#explicit_enum_values) 就是这样做的，尽管在实际应用中，如果你忘记了也不会有太大问题，因为C#编译器并不在乎，实际上很少有工具会注意到这一点。主要的好处是，如果在`enum`值上调用`ToString`时存在`Flags`属性，它会注意到。对于`Ingredients`类型，`ToString`会将值3转换为字符串`Eggs,
    Bacon`，这也是调试器显示值的方式，而没有`Flags`属性，则会被视为未识别的值，你只会得到一个包含数字`3`的字符串。
- en: With this sort of flags-style enumeration, you can run out of bits fairly quickly.
    By default, `enum` uses `int` to represent the value, and with a sequence of mutually
    exclusive values, that’s usually sufficient. It would be a fairly complicated
    scenario that needed billions of different values in a single enumeration type.
    However, with 1 bit per flag, an `int` provides space for just 32 flags. Fortunately,
    you can get a little more breathing room, because you can specify a different
    underlying type—you can use any built-in integer type, meaning that you can go
    up to 64 bits. As [Example 3-117](#six4-bit_enum) shows, you can specify the underlying
    type after a colon following the `enum` type name.
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种标志样式的枚举，你很快就会用完位。默认情况下，`enum`使用`int`表示值，对于一系列互斥的值，这通常是足够的。只有在单个枚举类型中需要数十亿不同值的情况下，才会变得相当复杂。然而，每个标志位1位，`int`提供的空间只能容纳32个标志。幸运的是，你可以获得更多的空间，因为你可以指定不同的底层类型——你可以使用任何内置整数类型，这意味着你可以使用最多64位。正如[示例3-117](#six4-bit_enum)所示，你可以在`enum`类型名称后面的冒号后指定底层类型。
- en: Example 3-117\. 64-bit `enum`
  id: totrans-642
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-117\. 64位`enum`
- en: '[PRE126]'
  id: totrans-643
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: All `enum` types are value types, incidentally, like the built-in numeric types
    or any struct. But they are very limited. You cannot define any members other
    than the constant values—no methods or properties, for example.
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的`enum`类型都是值类型，顺便说一句，就像内置的数值类型或任何结构体一样。但它们的功能非常有限。你不能定义除了常量值以外的任何成员—例如，没有方法或属性。
- en: Enumeration types can sometimes enhance the readability of code. A lot of APIs
    accept a `bool` to control some aspect of their behavior but might often have
    done better to use an `enum`. Consider the code in [Example 3-118](#unhelpful_use_of_bool).
    It constructs a `StreamReader`, a class for working with data streams that contain
    text. The second constructor argument is a `bool`.
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: 枚举类型有时可以提升代码的可读性。许多 API 接受一个`bool`来控制其行为的某些方面，但可能更好地使用`enum`。考虑[示例3-118](#unhelpful_use_of_bool)中的代码。它构造了一个`StreamReader`，这是一个用于处理包含文本数据流的类。第二个构造函数参数是一个`bool`。
- en: Example 3-118\. Unhelpful use of the `bool` type
  id: totrans-646
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-118\. 不合理使用`bool`类型
- en: '[PRE127]'
  id: totrans-647
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: It’s not remotely obvious what that second argument does. If you happen to be
    familiar with `StreamReader`, you may know that this argument determines whether
    byte ordering in a multibyte text encoding should be set explicitly from the code
    or determined from a preamble at the start of the stream. (Using the named argument
    syntax would help here.) And if you’ve got a really good memory, you might even
    know which of those choices `true` happens to select. But most mere mortal developers
    will probably have to reach for IntelliSense or even the documentation to work
    out what that argument does. Compare that experience with [Example 3-119](#clarity_with_an_enum),
    which shows a different type.
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: 很难看出第二个参数的作用。如果你熟悉`StreamReader`，你可能知道这个参数确定是否应该从代码中显式设置多字节文本编码的字节顺序，或者应该从流的开头的前导部分确定。
    （在这里使用命名参数语法会有所帮助。）如果你有非常好的记忆力，你甚至可能知道`true`选择了哪个选项。但是大多数普通开发者可能需要借助 IntelliSense
    或者文档来弄清楚这个参数的作用。将这种经验与[示例3-119](#clarity_with_an_enum)进行比较，它展示了不同的类型。
- en: Example 3-119\. Clarity with an `enum`
  id: totrans-649
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-119\. 通过`enum`来提高清晰度
- en: '[PRE128]'
  id: totrans-650
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: This constructor’s second argument uses an enumeration type, which makes for
    rather less opaque code. It doesn’t take an eidetic memory to work out that this
    code intends to append data to an existing file.
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: 此构造函数的第二个参数使用了枚举类型，这样可以使代码更加清晰易懂。不需要超强记忆力就能理解，这段代码的意图是将数据追加到现有文件中。
- en: As it happens, because this particular API has more than two options, it couldn’t
    use a `bool`. So `FileMode` really had to be an `enum`. But these examples illustrate
    that even in cases where you’re selecting between just two choices, it’s well
    worth considering defining an `enum` for the job so that it’s completely obvious
    which choice is being made when you look at the code.
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个特定的 API 有超过两个选项，所以它不能使用`bool`。因此，`FileMode`确实必须是一个`enum`。但这些示例说明，即使在只有两个选择时，考虑定义一个`enum`来进行选择也是非常值得的，这样当你查看代码时就完全明了了。
- en: Other Types
  id: totrans-653
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他类型
- en: 'We’re almost done with our survey of types and what goes in them. There’s one
    kind of type that I’ll not discuss until [Chapter 9](ch09.xhtml#ch_delegates_lambdas_events):
    delegates. We use delegates when we need a reference to a function, but the details
    are somewhat involved.'
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: 我们几乎完成了对类型及其内容的调查。直到[第9章](ch09.xhtml#ch_delegates_lambdas_events)之前，我将不讨论一种类型：委托。当我们需要引用函数时，我们使用委托，但细节有些复杂。
- en: I’ve also not mentioned pointers. C# supports pointers that work in a pretty
    similar way to C-style pointers, complete with pointer arithmetic. (If you’re
    not familiar with these, they provide a reference to a particular location in
    memory.) These are a little weird, because they are slightly outside of the rest
    of the type system. For example, in [Chapter 2](ch02.xhtml#ch_basic_coding), I
    mentioned that a variable of type `object` can refer to “almost anything.” The
    reason I had to qualify that is that pointers are one of the two exceptions—`object`
    can work with any C# data type except a pointer or a `ref struct`. ([Chapter 18](ch18.xhtml#ch_memory_efficiency)
    discusses the latter.)
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: 我也没有提到指针。C#支持指针，其工作方式与 C 风格指针非常相似，包括指针算术。 （如果你对这些不熟悉，它们提供了对内存中特定位置的引用。）这些有点奇怪，因为它们略微超出了其余类型系统的范围。例如，在[第2章](ch02.xhtml#ch_basic_coding)中，我提到类型为`object`的变量可以引用“几乎任何东西”。我必须说明的原因是指针是两个例外之一—`object`可以与除了指针或`ref
    struct`之外的任何 C# 数据类型一起使用。（[第18章](ch18.xhtml#ch_memory_efficiency)讨论了后者。）
- en: But now we really are done. Some types in C# are special, including the fundamental
    types discussed in [Chapter 2](ch02.xhtml#ch_basic_coding) and the records, structs,
    interfaces, enums, delegates, and pointers just described, but everything else
    looks like a class. There are a few classes that get special handling in certain
    circumstances—notably attribute classes ([Chapter 14](ch14.xhtml#ch_attributes))
    and exception classes ([Chapter 8](ch08.xhtml#ch_exceptions))—but except for certain
    special scenarios, even those are otherwise completely normal classes. Even though
    we’ve seen all the kinds of types that C# supports, there’s one way to define
    a class that I’ve not shown yet.
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: 但现在我们真的完成了。C#中的某些类型是特殊的，包括第二章中讨论的基本类型以及刚刚描述的记录、结构、接口、枚举、委托和指针，但其他所有内容看起来都像一个类。在某些情况下，有几个类会有特殊处理，特别是属性类（[第14章](ch14.xhtml#ch_attributes)）和异常类（[第8章](ch08.xhtml#ch_exceptions)），但除了某些特殊情况外，它们都是完全普通的类。尽管我们已经看过C#支持的所有类型，但还有一种定义类的方式我还没有展示过。
- en: Anonymous Types
  id: totrans-657
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 匿名类型
- en: 'C# offers two mechanisms for grouping a handful of values together. You’ve
    already seen tuples, which were described in [Chapter 2](ch02.xhtml#ch_basic_coding).
    These were introduced in C# 7.0, but there is an alternative that has been available
    since C# 3.0: [Example 3-120](#anonymous_type) shows how to create an instance
    of an *anonymous type* and how to use it.'
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: C#提供了两种将少数值组合在一起的机制。你已经看过元组，这些在[第二章](ch02.xhtml#ch_basic_coding)中描述过。它们在C# 7.0中引入，但自C#
    3.0以来就有另一种可用的替代方案：[示例 3-120](#anonymous_type)展示了如何创建*匿名类型*的实例以及如何使用它。
- en: Example 3-120\. An anonymous type
  id: totrans-659
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-120\. 匿名类型
- en: '[PRE129]'
  id: totrans-660
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: As you can see, we use the `new` keyword without specifying a type name. Instead,
    we just use the object initializer syntax. The C# compiler will provide a type
    that has one read-only property for each entry inside the initializer. So in [Example 3-120](#anonymous_type),
    the variable `x` will refer to an object that has two properties, `Title` and
    `Surname`, both of type `string`. (You do not state the property types explicitly
    in an anonymous type. The compiler infers each property’s type from the initialization
    expression in the same way it does for the `var` keyword.) Since these are just
    normal properties, we can access them with the usual syntax, as the final line
    of the example shows.
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，我们在不指定类型名称的情况下使用`new`关键字。相反，我们只使用对象初始化器语法。C#编译器将为每个初始化器中的条目提供一个只读属性的类型。因此，在[示例 3-120](#anonymous_type)中，变量`x`将引用一个具有两个属性的对象，`Title`和`Surname`，均为`string`类型。（在匿名类型中，你不需要显式声明属性类型。编译器会根据初始化表达式推断每个属性的类型，就像对`var`关键字一样。）由于这些只是普通的属性，我们可以使用通常的语法访问它们，正如示例的最后一行所示。
- en: Tip
  id: totrans-662
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 小贴士
- en: The `with` syntax available for record types and `struct` types also works with
    anonymous types. The reason `with` is not available for all reference types is
    the lack of a general, universal cloning mechanism, but that’s not a problem with
    anonymous types. They are always generated by the compiler, so the compiler knows
    exactly how to copy them.
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: 对于记录类型和`struct`类型，也可以使用`with`语法，这也适用于匿名类型。`with`不适用于所有引用类型的原因是缺乏通用的克隆机制，但这对于匿名类型来说不是问题。它们总是由编译器生成，因此编译器清楚地知道如何复制它们。
- en: The compiler generates a fairly ordinary class definition for each anonymous
    type. It is immutable, because all the properties are read-only. Much like a record,
    it overrides `Equals` so that you can compare instances by value, and it also
    provides a matching `GetHashCode` implementation. The only unusual thing about
    the generated class is that it’s not possible to refer to the type by name in
    C#. Running [Example 3-120](#anonymous_type) in the debugger, I find that the
    compiler has chosen the name `<>f__AnonymousType0'2`. This is not a legal identifier
    in C# because of those angle brackets (`<>`) at the start. C# uses names like
    this whenever it wants to create something that is guaranteed not to collide with
    any identifiers you might use in your own code, or that it wants to prevent you
    from using directly. This sort of identifier is called, rather magnificently,
    an *unspeakable name*.
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器为每个匿名类型生成一个相当普通的类定义。它是不可变的，因为所有属性都是只读的。就像记录一样，它重写了`Equals`以便您可以按值比较实例，并且还提供了相应的`GetHashCode`实现。生成类的唯一不寻常之处在于，在C#中无法通过名称引用该类型。在调试器中运行[示例3-120](#anonymous_type)，我发现编译器选择了名称`<>f__AnonymousType0'2`。由于这些尖括号（`<>`）的存在，这不是C#中的合法标识符。当C#希望创建不会与您自己代码中的任何标识符冲突的东西，或者想要防止您直接使用时，会使用这种类型的名称。这种标识符被称为*不可言之名*，相当壮观。
- en: 'Because you cannot write the name of an anonymous type, a method cannot declare
    that it returns one, or that it requires one to be passed as an argument (unless
    you use an anonymous type as an inferred generic type argument, something we’ll
    see in [Chapter 4](ch04.xhtml#ch_generics)). Of course, an expression of type
    `object` can refer to an instance of an anonymous type, but only the method that
    defines the type can use its properties (unless you use the `dynamic` type described
    in [Chapter 2](ch02.xhtml#ch_basic_coding)). So anonymous types are of somewhat
    limited value. They were added to the language for LINQ’s benefit: they enable
    a query to select specific columns or properties from some source collection and
    also to define custom grouping criteria, as you’ll see in [Chapter 10](ch10.xhtml#ch_linq).'
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: 由于无法写出匿名类型的名称，方法不能声明其返回一个匿名类型，也不能要求将其作为参数传递（除非您将匿名类型用作推断的泛型类型参数，我们将在[第4章](ch04.xhtml#ch_generics)中看到）。当然，类型为`object`的表达式可以引用匿名类型的实例，但只有定义类型的方法才能使用其属性（除非您使用了[第2章](ch02.xhtml#ch_basic_coding)中描述的`dynamic`类型）。因此，匿名类型的价值有所限制。它们被添加到语言中以用于LINQ的好处：它们使查询能够从某些源集合中选择特定列或属性，并定义自定义分组条件，正如您将在[第10章](ch10.xhtml#ch_linq)中看到的那样。
- en: These limitations provide a clue as to why Microsoft felt the need to add tuples
    in C# 7.0 when the language already had a pretty similar-looking feature. However,
    if the inability to use anonymous types as parameters or return types was the
    only problem, an obvious solution might have been to introduce a syntax enabling
    them to be identified. The syntax for referring to tuples could arguably have
    worked—we can now write `(string Name, double Age)` to refer to a tuple type,
    but why introduce a whole new concept? Why not just use that syntax to name anonymous
    types? (Obviously we’d no longer be able to call them anonymous types, but at
    least we wouldn’t have ended up with two confusingly similar language features.)
    However, the lack of names isn’t the only problem with anonymous types.
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: 这些限制提供了一个线索，说明为什么Microsoft觉得在C# 7.0中需要添加元组，尽管语言已经有了一个看起来非常相似的特性。然而，如果无法将匿名类型用作参数或返回类型是唯一的问题，显而易见的解决方案可能是引入一种语法来使它们能够被识别。引用元组的语法可能起作用——我们现在可以写`(string
    Name, double Age)`来引用元组类型，但为什么要引入一个全新的概念呢？为什么不只是使用那个语法来命名匿名类型呢？（显然，我们将不能再称它们为匿名类型，但至少我们不会最终得到两个令人困惑的相似语言特性。）然而，没有名称并不是匿名类型的唯一问题。
- en: 'As C# has been used in increasingly diverse applications, and across a broader
    range of hardware, efficiency has become more of a concern. In the database access
    scenarios for which anonymous types were originally introduced, the cost of object
    allocations would have been a relatively small part of the picture, but the basic
    concept—a small bundle of values—is potentially useful in a much wider range of
    scenarios, some of which are more performance sensitive. However, anonymous types
    are all reference types, and while in many cases that’s not a problem, it can
    rule them out in some hyper-performance-sensitive scenarios. Tuples, on the other
    hand, are all value types, making them viable even in code where you are attempting
    to minimize the number of allocations. (See [Chapter 7](ch07.xhtml#ch_object_lifetime)
    for more detail on memory management and garbage collection, and [Chapter 18](ch18.xhtml#ch_memory_efficiency)
    for information about some of the newer language features aimed at enabling more
    efficient memory usage.) Also, since tuples are all based on a set of generic
    types under the covers, they may end up reducing the runtime overhead required
    to keep track of loaded types: with anonymous types, you can end up with a lot
    more distinct types loaded. For related reasons, anonymous types would have problems
    with compatibility across component boundaries.'
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: 随着C#在越来越多的应用程序中被使用，并跨越更广泛的硬件范围，效率变得更加重要。在匿名类型最初引入的数据库访问场景中，对象分配的成本可能只是一个相对较小的部分，但其基本概念——一小组值——在更广泛的场景中可能非常有用，其中一些场景更加注重性能。然而，匿名类型都是引用类型，虽然在许多情况下这并不是问题，但在某些超高性能敏感的场景中可能会排除它们。另一方面，元组都是值类型，使得它们在试图最小化分配数量的代码中也是可行的。
    (详见[第7章](ch07.xhtml#ch_object_lifetime)了解有关内存管理和垃圾回收的更多细节，以及[第18章](ch18.xhtml#ch_memory_efficiency)了解有关一些旨在实现更高效内存使用的新语言特性的信息。)
    另外，由于元组都是基于一组通用类型底层实现的，它们可能会减少在跟踪加载的类型所需的运行时开销：使用匿名类型时，可能会加载更多不同的类型。出于相关原因，匿名类型在组件边界之间的兼容性可能会存在问题。
- en: Does this mean that anonymous types are no longer of any use? In fact, they
    still offer some advantages. The most significant one is that you cannot use a
    tuple in a lambda expression that will be converted into an expression tree. This
    issue is described in detail in [Chapter 9](ch09.xhtml#ch_delegates_lambdas_events),
    but the practical upshot is that you cannot use tuples in the kinds of LINQ queries
    mentioned earlier that anonymous types were added to support.
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: 这是否意味着匿名类型不再有任何用处呢？事实上，它们仍然提供了一些优势。最重要的优势是你无法在将转换为表达式树的lambda表达式中使用元组。这个问题在[第9章](ch09.xhtml#ch_delegates_lambdas_events)中有详细描述，但实际上的结果是，你不能在之前提到的支持匿名类型的LINQ查询中使用元组。
- en: 'More subtle is the fact that with tuples, property names are a convenient fiction,
    whereas with anonymous types, they are real. This has two upshots. One regards
    equivalence: the tuples `(X: 10, Y:20)` and `(W:10, H:20)` are considered interchangeable,
    where any variable capable of holding one is capable of holding the other. That
    is not true for anonymous types: `new { X = 10, Y = 20 }` has a different type
    than `new { W = 10, H = 20 }`, and attempting to pass one to code that expects
    the other will cause a compiler error. This difference can make tuples more convenient,
    but it can also make them more error prone, because the compiler looks only at
    the shape of the data when asking whether you’re using the right type. Anonymous
    types can still enable errors: if you have two types with exactly the same property
    names and types but that are semantically different, there’s no way to express
    that with anonymous types. (In practice you’d probably just define two record
    types to deal with this.) The second upshot of anonymous types offering genuine
    properties is that you can pass them to code that inspects an object’s properties.
    Many reflection-driven features such as certain serialization frameworks, or UI
    framework databinding, depend on being able to discover properties at runtime
    through reflection (see [Chapter 13](ch13.xhtml#ch_reflection)). Anonymous types
    may work better with these frameworks than tuples, in which the properties’ real
    names are all things like `Item1`, `Item2`, etc.'
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: '更微妙的是，对于元组而言，属性名称是一个方便的虚构，而对于匿名类型来说，它们是真实存在的。这有两个结果。一个关于等价性：元组`(X: 10, Y:20)`和`(W:10,
    H:20)`被视为可互换，任何能够容纳一个的变量也能容纳另一个。但对于匿名类型并非如此：`new { X = 10, Y = 20 }`与`new { W
    = 10, H = 20 }`有不同的类型，尝试将其中一个传递给期望另一个的代码将导致编译器错误。这种差异使得元组可能更加方便，但也可能更容易出错，因为编译器只关注数据的形状来判断是否使用了正确的类型。匿名类型仍然可能导致错误：如果有两个类型具有完全相同的属性名称和类型但在语义上不同，那么用匿名类型无法表达这一点。（实际上，您可能只需定义两种记录类型来处理这种情况。）匿名类型提供真正的属性的第二个结果是，您可以将它们传递给检查对象属性的代码。许多反射驱动的功能，如某些序列化框架或
    UI 框架数据绑定，依赖于能够通过反射在运行时发现属性（参见 [第 13 章](ch13.xhtml#ch_reflection)）。与元组相比，匿名类型可能在这些框架中表现更好，因为它们的属性真实名称类似于`Item1`、`Item2`等。'
- en: Partial Types and Methods
  id: totrans-670
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部分类型和方法
- en: 'There’s one last topic I want to discuss relating to types. C# supports what
    it calls a *partial type declaration*. This is a very simple concept: it means
    that the type declaration might span multiple files. If you add the `partial`
    keyword to a type declaration, C# will not complain if another file defines the
    same type—it will simply act as though all the members defined by the two files
    had appeared in a single declaration in one file.'
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
  zh: 关于类型，我想讨论的最后一个话题是部分类型声明。C# 支持所谓的*部分类型声明*。这是一个非常简单的概念：它意味着类型声明可能跨多个文件。如果在类型声明中添加`partial`关键字，C#
    将不会在另一个文件定义相同的类型时报错——它会简单地假定这两个文件定义的所有成员都像在一个文件中单独声明的一样。
- en: This feature exists to make it easier to write code-generation tools. Various
    features in Visual Studio can generate bits of your class for you. This is particularly
    common with UIs. UI applications typically have markup that defines the layout
    and content of each part of the UI, and you can choose for certain UI elements
    to be accessible in your code. You usually achieve this by adding a field to a
    class associated with the markup file. To keep things simple, all the parts of
    the class that Visual Studio generates go in a separate file from the parts that
    you write. This means that the generated parts can be remade from scratch whenever
    needed without any risk of overwriting the code that you’ve written. Before partial
    types were introduced to C#, all the code for a class had to go in one file, and
    from time to time, code generation tools would get confused, leading to loss of
    code.
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: 此功能存在是为了更轻松地编写代码生成工具。Visual Studio 中的各种功能可以为您生成类的各个部分。这在 UI 中特别常见。UI 应用程序通常有标记，定义
    UI 各部分的布局和内容，您可以选择让某些 UI 元素在代码中可访问。通常通过向与标记文件关联的类添加字段来实现这一点。为了保持简单，所有 Visual Studio
    生成的类部分都放在与您编写的部分分开的文件中。这意味着生成的部分可以在需要时从头开始重新制作，而不会有任何覆盖您编写的代码的风险。在引入部分类型到 C# 之前，所有类的代码都必须在一个文件中，有时，代码生成工具会混淆，导致代码丢失。
- en: Note
  id: totrans-673
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'Partial classes are not limited to code-generation scenarios, so you can of
    course use this to split your own class definitions across multiple files. However,
    if you’ve written a class so large and complex that you feel the need to split
    it into multiple source files just to keep it manageable, that’s probably a sign
    that the class is too complex. A better response to this problem might be to change
    your design. However, it can be useful if you need to maintain code that is built
    in different ways for different target platforms: you can use partial classes
    to put target-specific parts in separate files.'
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
  zh: 部分类不仅限于代码生成场景，因此您当然可以使用它来将自己的类定义分割到多个文件中。然而，如果您编写了一个如此庞大和复杂的类，以至于您感觉需要将其分割成多个源文件来保持可管理性，那可能是该类过于复杂的迹象。对这个问题的更好响应可能是改变您的设计。然而，如果您需要维护针对不同目标平台以不同方式构建的代码，使用部分类将非常有用：您可以使用部分类将特定于目标的部分放入单独的文件中。
- en: Partial methods are also designed for code-generation scenarios, but they are
    slightly more complex. They allow one file, typically a generated file, to declare
    a method, and for another file to implement the method. (Strictly speaking, the
    declaration and implementation are allowed to be in the same file, but they usually
    won’t be.) This may sound like the relationship between an interface and a class
    that implements that interface, but it’s not quite the same. With partial methods,
    the declaration and implementation are in the same class—they’re in different
    files only because the class has been split across multiple files.
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
  zh: 部分方法也是为代码生成场景设计的，但它们稍微复杂一些。它们允许一个文件（通常是生成的文件）声明一个方法，另一个文件实现该方法。（严格来说，声明和实现可以在同一个文件中，但通常不会。）这听起来像是接口和实现该接口的类之间的关系，但并不完全相同。使用部分方法，声明和实现在同一个类中，它们之所以在不同文件中仅因为类已分割成多个文件。
- en: If you do not provide an implementation of a partial method, then as long as
    the method definition does not specify any accessibility, has a `void` return
    type, and no `out` arguments, the compiler acts as though the method isn’t there
    at all, and any code that invokes the method is ignored at compile time. The main
    reason for this is to support code-generation mechanisms that are able to offer
    many kinds of notifications but where you want zero runtime overhead for notifications
    that you don’t need. Partial methods enable this by letting the code generator
    declare a partial method for each kind of notification it provides and to generate
    code that invokes all of these partial methods where necessary. All code relating
    to notifications for which you do not write a handler method will be stripped
    out at compile time.
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您没有提供部分方法的实现，则只要方法定义不指定任何可访问性，具有`void`返回类型，并且没有`out`参数，编译器会表现得好像方法根本不存在，任何调用该方法的代码在编译时都将被忽略。这样做的主要原因是支持能够提供多种通知的代码生成机制，但您不需要的通知在运行时不产生任何开销。部分方法通过允许代码生成器为其提供的每种通知声明一个部分方法，并生成在必要时调用所有这些部分方法的代码来实现这一点。对于您未编写处理程序方法的通知相关的所有代码将在编译时被剥离。
- en: It’s an idiosyncratic mechanism, but it was driven by frameworks that provide
    extremely fine-grained notifications and extension points. There are some more
    obvious runtime techniques you could use instead, such as interfaces, or features
    that I’ll cover in later chapters, such as callbacks or virtual methods. However,
    any of these would impose a relatively high cost for unused features. Unused partial
    methods get stripped out at compile time, reducing the cost of the bits you don’t
    use to nothing, which is a considerable improvement.
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个特殊的机制，但它是由提供极其细粒度通知和扩展点的框架驱动的。还有一些更明显的运行时技术您可以使用，比如接口，或者我稍后将介绍的特性，比如回调或虚方法。然而，这些方法中的任何一个都将对未使用的特性施加相对较高的成本。未使用的部分方法在编译时被剥离，将不需要使用的位的成本降至零，这是一个相当大的改进。
- en: Up until recently, partial methods were required not to specify their accessibility
    and not return any data. C# 9.0 relaxed this to support additional code-generation
    scenarios, in which a developer writes a partial method in the expectation that
    a code-generation tool will supply the implementation. When a partial method specifies
    the accessibility (even if it is `private` and returns no data), it is an error
    for the method not to be implemented.
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: 直到最近，局部方法要求不指定它们的可访问性并且不返回任何数据。C# 9.0放宽了这一点，以支持额外的代码生成场景，在这些场景中，开发人员编写局部方法，期望代码生成工具提供实现。当局部方法指定了可访问性（即使是`private`并且不返回数据），如果未实现该方法，则会产生错误。
- en: Summary
  id: totrans-679
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Summary
- en: You’ve now seen most of the kinds of types you can write in C# and the sorts
    of members they support. Classes are the most widely used, but structs are useful
    if you need value-like semantics for assignment and arguments; both support the
    same member types—namely, fields, constructors, methods, properties, indexers,
    events, custom operators, and nested types. Records provide a more convenient
    syntax for defining types that consist mostly of properties, especially if you
    want to be able to compare the values of such types. And while they do not have
    to be immutable, record types make it easier to define and work with immutable
    data. Interfaces are abstract, so at the instance level they support only methods,
    properties, indexers, and events. They can also provide static fields, nested
    types, and default implementations for other members. And enums are very limited,
    providing just a set of known values.
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经看到了你可以在C#中编写的大多数类型以及它们支持的成员类型。类是最广泛使用的，但如果需要赋值和参数的值类型语义，结构体也是有用的；两者都支持相同的成员类型，包括字段、构造函数、方法、属性、索引器、事件、自定义运算符和嵌套类型。记录提供了更方便的语法来定义主要由属性组成的类型，特别是如果你希望能够比较这些类型的值。虽然它们不必是不可变的，但记录类型使得定义和处理不可变数据变得更容易。接口是抽象的，因此在实例级别上只支持方法、属性、索引器和事件。它们还可以提供静态字段、嵌套类型和其他成员的默认实现。而枚举非常有限，只提供一组已知的值。
- en: There’s another feature of the C# type system that makes it possible to write
    very flexible types, called generic types. We’ll look at these in the next chapter.
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
  zh: C#类型系统的另一个特性使得编写非常灵活的类型成为可能，称为泛型类型。我们将在下一章节中介绍这些内容。
- en: ^([1](ch03.xhtml#idm45884853473568-marker)) Specifically, it generates a method
    with a special name, `<Clone>$`. That name is an illegal identifier in C#, so
    this method is in effect hidden from your code, but you will be using it indirectly
    if you use the `with` syntax to build a modified copy of a record.
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch03.xhtml#idm45884853473568-marker)) 具体来说，它生成一个带有特殊名称`<Clone>$`的方法。这个名称在C#中是非法标识符，因此这个方法实际上被隐藏在你的代码中，但如果你使用`with`语法来构建记录的修改副本，则间接使用它。
- en: ^([2](ch03.xhtml#idm45884832593360-marker)) There are certain exceptions, described
    in [Chapter 18](ch18.xhtml#ch_memory_efficiency).
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch03.xhtml#idm45884832593360-marker)) 有一些例外情况，在[第18章](ch18.xhtml#ch_memory_efficiency)中有描述。
- en: ^([3](ch03.xhtml#fn19-marker)) You wouldn’t want it to be a value type, because
    strings can be large, so passing them by value would be expensive. In any case,
    it cannot be a struct, because strings vary in length. However, that’s not a factor
    you need to consider, because you can’t write your own variable-length data types
    in C#. Only strings and array types have variable size.
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
  zh: ^([3](ch03.xhtml#fn19-marker)) 你不希望它成为值类型，因为字符串可能很大，因此按值传递它们将是昂贵的。无论如何，它不能是结构体，因为字符串的长度不同。然而，在C#中你无法自己编写可变长度的数据类型，只有字符串和数组类型具有可变大小。
- en: ^([4](ch03.xhtml#idm45884832211984-marker)) If you omit the initializer for
    a `readonly` field, you should set it in the constructor or a property’s `init`
    accessor instead; otherwise it’s not very useful.
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
  zh: ^([4](ch03.xhtml#idm45884832211984-marker)) 如果省略了`readonly`字段的初始化程序，则应在构造函数或属性的`init`访问器中设置它；否则它没有什么用处。
- en: ^([5](ch03.xhtml#fn20-marker)) There are two exceptions. If a class supports
    a CLR feature called *serialization*, objects of that type can be deserialized
    directly from a data stream, bypassing constructors. But even here, you can dictate
    what data is required. And there’s the `MemberwiseClone` method described in [Chapter 6](ch06.xhtml#ch_inheritance).
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: ^([5](ch03.xhtml#fn20-marker)) 有两个例外情况。如果一个类支持CLR特性称为*serialization*，那么该类型的对象可以直接从数据流反序列化，而不经过构造函数。但即便如此，你也可以规定所需的数据。并且在[第6章](ch06.xhtml#ch_inheritance)中描述了`MemberwiseClone`方法。
- en: '^([6](ch03.xhtml#idm45884830549600-marker)) The CLR calls this kind of reference
    a *Managed Pointer*, to distinguish it from the kind of reference that refers
    to an object on the heap. Unfortunately, C#’s terminology is less clear: it calls
    both of these things *references*.'
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
  zh: ^([6](ch03.xhtml#idm45884830549600-marker)) CLR 将这种引用称为*托管指针*，以区别于指向堆上对象的引用。不幸的是，C#
    的术语并不那么清晰：它都称这些为*引用*。
- en: ^([7](ch03.xhtml#idm45884827660912-marker)) Incidentally, the default property
    has a name, because all properties are required to. C# calls the indexer property
    `Item` and automatically adds the annotation indicating that it’s the default
    property. You won’t normally refer to an indexer by name, but the name is visible
    in some tools. The .NET documentation lists indexers under `Item`, even though
    it’s rare to use that name in code.
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
  zh: ^([7](ch03.xhtml#idm45884827660912-marker)) 顺便提一下，默认属性有一个名称，因为所有属性都必须有。C# 将索引器属性称为`Item`，并自动添加注释以指示它是默认属性。通常情况下不会通过名称来引用索引器，但在某些工具中可以看到这个名称。.NET
    文档将索引器列在`Item`下，尽管在代码中很少使用这个名称。
