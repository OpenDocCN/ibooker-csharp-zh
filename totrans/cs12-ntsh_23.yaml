- en: Chapter 23\. Span<T> and Memory<T>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Span<T>` and `Memory<T>` structs act as low-level façades over an array,
    string, or any contiguous block of managed or unmanaged memory. Their main purpose
    is to help with certain kinds of micro-optimization—in particular, writing *low-allocation*
    code that minimizes managed memory allocations (thereby reducing the load on the
    garbage collector), without having to duplicate your code for different kinds
    of input. They also enable *slicing*—working with a portion of an array, string,
    or memory block without creating a copy.
  prefs: []
  type: TYPE_NORMAL
- en: '`Span<T>` and `Memory<T>` are particularly useful in performance hotspots,
    such as the ASP.NET Core processing pipeline, or a JSON parser that serves an
    object database.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Should you come across these types in an API and not need or care for their
    potential performance advantages, you can deal with them easily as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: When calling a method that expects a `Span<T>`, `ReadOnlySpan<T>`, `Memory<T>`,
    or `ReadOnlyMemory<T>`, pass in an array instead; that is, `T[]`. (This works
    thanks to implicit conversion operators.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To convert from a span/memory *to* an array, call the `ToArray` method. And
    if `T` is `char`, `ToString` will convert the span/memory into a string.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: From C# 12, you can also use collection initializers to create spans.
  prefs: []
  type: TYPE_NORMAL
- en: 'Specifically, `Span<T>` does two things:'
  prefs: []
  type: TYPE_NORMAL
- en: It provides a common array-like interface over managed arrays, strings, and
    pointer-backed memory. This gives you the freedom to employ stack-allocated and
    unmanaged memory to avoid garbage collection, without having to duplicate code
    or mess with pointers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It allows “slicing”: exposing reusable subsections of the span without making
    copies.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '`Span<T>` comprises just two fields, a pointer and a length. For this reason,
    it can represent only contiguous blocks of memory. (Should you need to work with
    noncontiguous memory, the `ReadOnlySequence<T>` class is available to serve as
    a linked list.)'
  prefs: []
  type: TYPE_NORMAL
- en: Because `Span<T>` can wrap stack-allocated memory, there are restrictions on
    how you can store or pass around instances (imposed, in part, by `Span<T>` being
    a *ref struct*). `Memory<T>` acts as a span without those restrictions, but it
    cannot wrap stack-allocated memory. `Memory<T>` still provides the benefit of
    slicing.
  prefs: []
  type: TYPE_NORMAL
- en: Each struct comes with a read-only counterpart (`ReadOnlySpan<T>` and `ReadOnly​Me⁠mory<T>`).
    As well as preventing unintentional change, the read-only counterparts further
    improve performance by allowing the compiler and runtime additional freedom for
    optimization.
  prefs: []
  type: TYPE_NORMAL
- en: .NET itself (and ASP.NET Core) use these types to improve efficiency with I/O,
    networking, string handling, and JSON parsing.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '`Span<T>` and `Memory<T>`’s ability to perform array slicing make the old `ArraySegment<T>`
    class redundant. To help with any transition, there are implicit conversion operators
    from `ArraySegment<T>` to all of the span/memory structs, and from `Memory<T>`
    and `ReadOnlyMemory<T>` to `ArraySegment<T>`.'
  prefs: []
  type: TYPE_NORMAL
- en: Spans and Slicing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unlike an array, a span can easily be *sliced* to represent different subsections
    of the same underlying data, as illustrated in [Figure 23-1](#slicing).
  prefs: []
  type: TYPE_NORMAL
- en: 'To give a practical example, suppose that you’re writing a method to sum an
    array of integers. A micro-optimized implementation would avoid LINQ in favor
    of a `foreach` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '![Slicing](assets/cn10_2301.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 23-1\. Slicing
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Now imagine that you want to sum just a *portion* of the array. You have two
    options:'
  prefs: []
  type: TYPE_NORMAL
- en: First copy the portion of the array that you want to sum into another array
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add additional parameters to the method (`offset` and `count`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first option is inefficient; the second option adds clutter and complexity
    (which worsens with methods that need to accept more than one array).
  prefs: []
  type: TYPE_NORMAL
- en: 'Spans solve this nicely. All you need to do is to change the parameter type
    from `int[]` to `ReadOnlySpan<int>` (everything else stays the same):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: We used `ReadOnlySpan<T>` rather than `Span<T>` because we don’t need to modify
    the array. There’s an implicit conversion from `Span<T>` to `ReadOnlySpan<T>`,
    so you can pass a `Span<T>` into a method that expects a `ReadOnlySpan<T>`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can test this method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We can call `Sum` with an array because there’s an implicit conversion from
    `T[]` to `Span<T>` and `ReadOnlySpan<T>`. Another option is to use the `AsSpan`
    extension method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The indexer for `ReadOnlySpan<T>` uses C#’s `ref readonly` feature to reach
    directly into the underlying data: this allows our method to perform almost as
    well as the original example that used an array. But what we’ve gained is that
    we can now “slice” the array and sum just a portion of the elements as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'If you already have a `Span<T>` or `ReadOnlySpan<T>`, you can slice it by calling
    the `Slice` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also use C#’s *indices* and *ranges* (from C# 8):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Although `Span<T>` doesn’t implement `IEnumerable<T>` (it can’t implement interfaces
    by virtue of being a ref struct), it does implement the pattern that allows C#’s
    `foreach` statement to work (see [“Enumeration”](ch04.html#enumeration-id00012)).
  prefs: []
  type: TYPE_NORMAL
- en: CopyTo and TryCopyTo
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `CopyTo` method copies elements from one span (or `Memory<T>`) to another.
    In the following example, we copy all of the elements from span `x` into span
    `y`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Notice that we initialized `x` with a *collection expression*. Collection expressions
    (from C# 12) are not only a useful shortcut, but in the case of spans, they allow
    the compiler the freedom to choose the underlying type. When the element count
    is small, the compiler may allocate memory on the stack (rather than creating
    an array) to avoid the overhead of a heap allocation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Slicing makes this method much more useful. In the next example, we copy the
    first half of span `x` into the second half of span `y`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: If there’s not enough space in the destination to complete the copy, `CopyTo`
    throws an exception, whereas `TryCopyTo` returns `false` (without copying any
    elements).
  prefs: []
  type: TYPE_NORMAL
- en: The span structs also expose methods to `Clear` and `Fill` the span as well
    as an `IndexOf` method to search for an element in the span.
  prefs: []
  type: TYPE_NORMAL
- en: Searching in Spans
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `MemoryExtensions` class defines numerous extension methods to help with
    searching for values within spans such as `Contains`, `IndexOf`, `LastIndexOf`,
    and `BinarySearch` (as well as methods that mutate spans, such as `Fill`, `Replace`,
    and `Reverse`).
  prefs: []
  type: TYPE_NORMAL
- en: 'From .NET 8, there are also methods to search for any one of a number of values,
    such as `ContainsAny`, `ContainsAnyExcept`, `IndexOfAny`, and `IndexOfAnyExcept`.
    With these methods, you can specify the values to search either as a span or as
    a `SearchValues<T>` instance (in `System.Buffers`), which you instantiate by calling
    `SearchValues.Create`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '`SearchValues<T>` improves performance when the instance is reused across multiple
    searches.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You can also utilize these methods when working with arrays or strings, simply
    by calling `AsSpan()` on the array or string.
  prefs: []
  type: TYPE_NORMAL
- en: Working with Text
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Spans are designed to work well with strings, which are treated as `ReadOnlySpan<char>`.
    The following method counts whitespace characters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'You can call such a method with a string (thanks to an implicit conversion
    operator):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'or with a substring:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The `ToString()` method converts a `ReadOnlySpan<char>` back to a string.
  prefs: []
  type: TYPE_NORMAL
- en: 'Extension methods ensure that some of the commonly used methods on the string
    class are also available to `ReadOnlySpan<char>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: (Note that methods such as `StartsWith` use *ordinal* comparison, whereas the
    corresponding methods on the `string` class use culture-sensitive comparison by
    default.)
  prefs: []
  type: TYPE_NORMAL
- en: Methods such as `ToUpper` and `ToLower` are available, but you must pass in
    a destination span with the correct length (this allows you to decide how and
    where to allocate the memory).
  prefs: []
  type: TYPE_NORMAL
- en: Some of `string`’s methods are unavailable, such as `Split` (which splits a
    string into an array of words). It’s actually impossible to write the direct equivalent
    of `string`’s `Split` method because you cannot create an array of spans.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: This is because spans are defined as *ref structs*, which can exist only on
    the stack.
  prefs: []
  type: TYPE_NORMAL
- en: (By “exist only on the stack,” we mean that the struct itself can exist only
    on the stack. The content that the span *wraps* can—and does, in this case—exist
    on the heap.)
  prefs: []
  type: TYPE_NORMAL
- en: 'The `System.Buffers.Text` namespace contains additional types to help you work
    with span-based text, including the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Utf8Formatter.TryFormat` does the equivalent of calling `ToString` on built-in
    and simple types such as `decimal`, `DateTime`, and so on but writes to a span
    instead of a string.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Utf8Parser.TryParse` does the reverse and parses data from a span into a simple
    type.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Base64` type provides methods for reading/writing base-64 data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: From .NET 8, the .NET numeric and date/time types (as well as other simple types)
    allow direct formatting and parsing of UTF-8, via new `TryFormat` and `Parse`/`TryParse`
    methods that operate on a `Span<byte>`. The new methods are defined in the `IUtf8SpanFormattable`
    and `IUtf8SpanParsable<TSelf>` interfaces (the latter leverages C# 12’s ability
    to define static abstract interface members).
  prefs: []
  type: TYPE_NORMAL
- en: Fundamental CLR methods such as `int.Parse` have also been overloaded to accept
    `ReadOnlySpan<char>`.
  prefs: []
  type: TYPE_NORMAL
- en: Memory<T>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Span<T>` and `ReadOnlySpan<T>` are defined as *ref structs* to maximize their
    optimization potential as well as allowing them to work safely with stack-allocated
    memory (as you’ll see in the next section). However, it also imposes limitations.
    In addition to being array-unfriendly, you cannot use them as fields in a class
    (this would put them on the heap). This, in turn, prevents them from appearing
    in lambda expressions—and as parameters in asynchronous methods, iterators, and
    asynchronous streams:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '(Remember that the compiler processes asynchronous methods and iterators by
    writing a private *state machine*, which means that any parameters and local variables
    end up as fields. The same applies to lambda expressions that close over variables:
    these also end up as fields in a *closure*.)'
  prefs: []
  type: TYPE_NORMAL
- en: The `Memory<T>` and `ReadOnlyMemory<T>` structs work around this, acting as
    spans that cannot wrap stack-allocated memory, allowing their use in fields, lambda
    expressions, asynchronous methods, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can obtain a `Memory<T>` or `ReadOnlyMemory<T>` from an array via an implicit
    conversion or the `AsMemory()` extension method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'You can easily “convert” a `Memory<T>` or `ReadOnlyMemory<T>` into a `Span<T>`
    or `ReadOnlySpan<T>` via its `Span` property so that you can interact with it
    as though it were a span. The conversion is efficient in that it doesn’t perform
    any copying:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: (You can also directly slice a `Memory<T>` or `ReadOnlyMemory<T>` via its `Slice`
    method or a C# range, and access its length via its `Length` property.)
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Another way to obtain a `Memory<T>` is to rent it from a *pool*, using the `System.Buffers.MemoryPool<T>`
    class. This works just like array pooling (see [“Array Pooling”](ch12.html#array_pooling))
    and offers another strategy for reducing the load on the garbage collector.
  prefs: []
  type: TYPE_NORMAL
- en: 'We said in the previous section that you cannot write the direct equivalent
    of `string`.`Split` for spans, because you cannot create an array of spans. This
    limitation does not apply to `ReadOnlyMemory<char>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'This is more efficient than string’s `Split` method: instead of creating new
    strings for each word, it returns *slices* of the original string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You can easily convert a `Memory<T>` into a `Span<T>` (via the `Span` property),
    but not vice versa. For this reason, it’s better to write methods that accept
    `Span<T>` than `Memory<T>` when you have a choice.
  prefs: []
  type: TYPE_NORMAL
- en: For the same reason, it’s better to write methods that accept `ReadOnlySpan<T>`
    rather than `Span<T>`.
  prefs: []
  type: TYPE_NORMAL
- en: Forward-Only Enumerators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the preceding section, we employed `ReadOnlyMemory<char>` as a solution to
    implementing a string-style `Split` method. But by giving up on `ReadOnlySpan<char>`,
    we lost the ability to slice spans backed by unmanaged memory. Let’s revisit `ReadOnlySpan<char>`
    to see whether we can find another solution.
  prefs: []
  type: TYPE_NORMAL
- en: 'One possible option would be to write our `Split` method so that it returns
    *ranges*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The caller could then use those ranges to slice the original span:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This is an improvement, but it’s still imperfect. One of the reasons for using
    spans in the first place is to avoid memory allocations. But notice that our `Split`
    method creates a `List<Range>`, adds items to it, and then converts the list into
    an array. This incurs *at least* two memory allocations as well a memory-copy
    operation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The solution to this is to eschew the list and array in favor of a forward-only
    enumerator. An enumerator is clumsier to work with, but it can be made allocation-free
    with the use of structs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s how you would call it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: By defining a `Current` property and a `MoveNext` method, our enumerator can
    work with C#’s `foreach` statement (see [“Enumeration”](ch04.html#enumeration-id00012)).
    We don’t have to implement the `IEnumerable<T>`/`IEnumerator<T>` interfaces (in
    fact, we can’t; ref structs can’t implement interfaces). We’re sacrificing abstraction
    for micro-optimization.
  prefs: []
  type: TYPE_NORMAL
- en: Working with Stack-Allocated and Unmanaged Memory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another effective micro-optimization technique is to reduce the load on the
    garbage collector by minimizing heap-based allocations. This means making greater
    use of stack-based memory—or even unmanaged memory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unfortunately, this normally requires that you rewrite code to use pointers.
    In the case of our previous example that summed elements in an array, we would
    need to write another version as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'so that we could do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Spans solve this problem: you can construct a `Span<T>` or `ReadOnlySpan<T>`
    directly from a pointer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Or in one step:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '(Note that this doesn’t require the use of `unsafe`). Recall the `Sum` method
    that we wrote previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'This method works equally well for a stack-allocated span. We have gained on
    three counts:'
  prefs: []
  type: TYPE_NORMAL
- en: The same method works with both arrays and stack-allocated memory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can use stack-allocated memory with minimal use of pointers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The span can be sliced
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The compiler is smart enough to prevent you from writing a method that allocates
    memory on the stack and returns it to the caller via a `Span<T>` or `ReadOnlySpan<T>`.
  prefs: []
  type: TYPE_NORMAL
- en: (In other scenarios, however, you can legally return a `Span<T>` or `ReadOnlySpan<T>`.)
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also use spans to wrap memory that you allocate from the unmanaged
    heap. In the following example, we allocate unmanaged memory using the `Marshal.AllocHGlobal`
    function, wrap it in a `Span<char>`, and then copy a string into the unmanaged
    memory. Finally, we employ the `CharSpanSplitter` struct that we wrote in the
    preceding section to split the unmanaged string into words:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'A nice bonus is that `Span<T>`’s indexer performs bounds-checking, preventing
    a buffer overrun. This protection applies if you correctly instantiate `Span<T>`:
    in our example, you would lose this protection if you wrongly obtained the span:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: There’s also no protection from the equivalent of a dangling pointer, so you
    must take care not to access the span after releasing its unmanaged memory with
    `Marshal.FreeHGlobal`.
  prefs: []
  type: TYPE_NORMAL
