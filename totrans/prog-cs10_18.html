<html><head></head><body>
<div id="sbo-rt-content"><section data-pdf-bookmark="Chapter 18. Memory Efficiency" data-type="chapter" epub:type="chapter"><div class="chapter" id="ch_memory_efficiency">
<h1><span class="label">Chapter 18. </span>Memory Efficiency</h1>
<p><a data-primary="memory efficiency" data-type="indexterm" id="ix_ch18-asciidoc0"/>As <a data-type="xref" href="ch07.xhtml#ch_object_lifetime">Chapter 7</a> described, the <a data-primary="CLR (Common Language Runtime)" data-secondary="GC and" data-type="indexterm" id="idm45884782650768"/><a data-primary="garbage collector/garbage collection (GC)" data-secondary="memory efficiency and" data-type="indexterm" id="idm45884782649824"/>CLR is able to perform automatic memory management thanks
to its garbage collector (GC). This comes at a price: when a CPU spends time on garbage collection,
that stops it from getting on with more productive work. On laptops and phones, GC work drains
power from the battery. In a cloud computing environment where you may be paying for CPU time based on consumption, extra work for the CPU corresponds directly to increased costs. More subtly, on a computer with many cores, spending too
much time in the GC can dramatically reduce throughput, because many of the cores may end up
blocked, waiting for the GC to complete before they can proceed.</p>
<p>In many cases, these effects will be small enough not to cause visible problems. However, when
certain kinds of programs experience heavy load, GC costs can come to dominate the overall
execution time. In particular, if you write code that performs relatively simple but highly
repetitive processing, GC overhead can have a substantial impact on throughput.</p>
<p>To give you an example of the kinds of improvements that can sometimes be possible, early versions of Microsoft’s ASP.NET Core web server framework frequently ran into hard limits due to GC overhead. <a data-primary="garbage collector/garbage collection (GC)" data-type="indexterm" id="idm45884782647952"/>To enable .NET applications to break through these barriers, C# introduced various features that can enable dramatic reductions in the number of allocations. Fewer allocations means fewer blocks of memory for the GC to recover, so this translates directly to lower GC overhead. When ASP.NET Core first started making extensive use of these features, performance improved across the board, but for the simplest performance benchmark, known as <em>plaintext</em> (part of the TechEmpower suite of web performance tests), this release improved the request handling rate by over 25%.</p>
<p>In some specialized scenarios, the differences can be more dramatic. In 2019, I worked on a project that processed diagnostic information from a broadband 
<span class="keep-together">provider’s</span> networking equipment (in the form of RADIUS packets). Adopting the techniques described in this chapter boosted the
rate at which a single CPU core in our system could process the messages from around 300,000/s to
about 7 million/s.</p>
<p>There is a price to pay, of course: these GC-efficient techniques add significant complication to
your code. And the payoff won’t always be so large—although the first ASP.NET Core release to be able to use these features improved over the previous version on all benchmarks, only the simplest shows a 25% boost, and most improved more modestly. The practical
improvement will really depend on the nature of your workload, and for some applications you
might find that applying these techniques delivers no measurable improvement. So before you
even consider using them, you should use performance monitoring tools to find out how much
time your code spends in the GC. If it’s only a few percent, then you might not be able to
realize order-of-magnitude improvements. But if testing suggests that there’s room for significant
improvement, the next step is to ask whether the techniques in this chapter are likely to
help. So let’s start by exploring exactly how these new techniques can help you reduce GC overhead.</p>
<section data-pdf-bookmark="(Don’t) Copy That" data-type="sect1"><div class="sect1" id="idm45884782644672">
<h1>(Don’t) Copy That</h1>
<p><a data-primary="copying" data-secondary="don't" data-type="indexterm" id="ix_ch18-asciidoc1a"/><a data-primary="memory efficiency" data-secondary="avoiding making copies of data" data-type="indexterm" id="ix_ch18-asciidoc1"/>The way to reduce GC overhead is to allocate less memory on the heap. And the most important
technique for minimizing allocations is to avoid making copies of data. For example, consider the
URL <i>http://example.com/books/1323?edition=6&amp;format=pdf</i>. There are several elements of interest
in here, such as the protocol (<code>http</code>), the hostname (<code>example.com</code>), or the query string. The
latter has its own structure: it is a sequence of name/value pairs. The obvious way to work with a
URL in .NET is to use the <code>System.Uri</code> type, as <a data-type="xref" href="#ex_basic_url_parsing">Example 18-1</a> shows.</p>
<div data-type="example" id="ex_basic_url_parsing">
<h5><span class="label">Example 18-1. </span>Deconstructing a URL</h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="kt">var</code> <code class="n">uri</code> <code class="p">=</code> <code class="k">new</code> <code class="n">Uri</code><code class="p">(</code><code class="s">"http://example.com/books/1323?edition=6&amp;format=pdf"</code><code class="p">);</code>
<code class="n">Console</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code><code class="n">uri</code><code class="p">.</code><code class="n">Scheme</code><code class="p">);</code>
<code class="n">Console</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code><code class="n">uri</code><code class="p">.</code><code class="n">Host</code><code class="p">);</code>
<code class="n">Console</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code><code class="n">uri</code><code class="p">.</code><code class="n">AbsolutePath</code><code class="p">);</code>
<code class="n">Console</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code><code class="n">uri</code><code class="p">.</code><code class="n">Query</code><code class="p">);</code></pre></div>
<p>It produces the following output:</p>
<pre data-type="programlisting">http
example.com
/books/1323
?edition=6&amp;format=pdf</pre>
<p>This is convenient, but by getting the values of these four properties, we have forced the <code>Uri</code>
to provide four <code>string</code> objects in addition to the original one. You could imagine a smart
implementation of <code>Uri</code> that recognized certain standard values for <code>Scheme</code>, such as <code>http</code>, and
that always returned the same string instance for these instead of allocating new ones, but for
all the other parts, it’s likely to have to allocate new strings on the heap.</p>
<p>There is another way. Instead of creating new <code>string</code> objects for each section, we could take
advantage of the fact that all of the information we want was already in the string containing the
whole URL. There’s no need to copy each section into a new string, when instead we can just keep
track of the position and lengths of the relevant sections within the string. Instead of creating
a string for each section, we would need just two numbers. And since we can represent numbers
using value types (e.g., <code>int</code> or, for very long strings, <code>long</code>), we don’t need any additional
objects on the heap beyond the single string with the full URL. For example, the scheme (<code>http</code>)
is at position 0 and has length 4. <a data-type="xref" href="#fig_UrlByOffsetAndSize">Figure 18-1</a> shows each of the elements by their
offset and position within the string.</p>
<figure><div class="figure" id="fig_UrlByOffsetAndSize">
<img alt="URL elements by their offset and size in a string" height="98" src="assets/pc10_1801.png" width="600"/>
<h6><span class="label">Figure 18-1. </span>URL substrings</h6>
</div></figure>
<p>This works, but already we can see the first problem with working this way: it is somewhat awkward. Instead of representing, say, the <code>Host</code> with a convenient <code>string</code> object, which is easily understood and readily inspected in the debugger, we now have a pair of numbers, and as developers, we now have to remember which string they point into. It’s not rocket science, but it makes it slightly harder to understand our code, and easier to introduce bugs. But there’s a payoff: instead of five strings (the original URL and the four properties), we just have one. And if you’re trying to process millions of events each second, that could easily be worth the effort.</p>
<p>Obviously this technique would work for a more fine-grained structure too. The offset and position
<code>(25, 4)</code> locates the text <code>1323</code> in this URL. We might want to parse that as an <code>int</code>. But at this
point we run into the second problem with this style of working: it is not widely supported
in .NET libraries. <a data-primary="TryParse method" data-type="indexterm" id="idm45884782553328"/>The usual way to parse text into an <code>int</code> is to use the <code>int</code> type’s static
<code>Parse</code> or <code>TryParse</code> methods. Unfortunately, these do not provide overloads that accept a
position or offset within a <code>string</code>. They require a string containing only the number to be
parsed. This means you end up writing code such as <a data-type="xref" href="#ex_substring_defeating_the_purpose">Example 18-2</a>.</p>
<div class="less_space pagebreak-before" data-type="example" id="ex_substring_defeating_the_purpose">
<h5><span class="label">Example 18-2. </span>Defeating the point of the exercise by using <code>Substring</code></h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="kt">string</code> <code class="n">uriString</code> <code class="p">=</code> <code class="s">"http://example.com/books/1323?edition=6&amp;format=pdf"</code><code class="p">;</code>
<code class="kt">int</code> <code class="n">id</code> <code class="p">=</code> <code class="kt">int</code><code class="p">.</code><code class="n">Parse</code><code class="p">(</code><code class="n">uriString</code><code class="p">.</code><code class="n">Substring</code><code class="p">(</code><code class="m">25</code><code class="p">,</code> <code class="m">4</code><code class="p">));</code></pre></div>
<p>This works, but by using <code>Substring</code> to go from our (offset, length) representation back to the
plain <code>string</code> that <code>int.Parse</code> wants, we’ve allocated a new <code>string</code>. The whole point of this exercise was to reduce allocations, so this doesn’t seem like progress. One solution might be for Microsoft to go through the entire .NET API surface area, adding overloads that accept offset and
length parameters in any situation where we might want to work with something in the middle of
something else (either a substring, as in this example, or perhaps a subrange of an array). In
fact, there are examples of this already: the <code>Stream</code> API for working with byte streams has
various methods that accept a <code>byte[]</code> array, and also offset and length arguments to
indicate exactly which part of the array you want to work with.</p>
<p>However, there’s one more problem with this technique: it is inflexible about the type of container that the data lives in. Microsoft could add an overload to <code>int.Parse</code> that takes a <code>string</code>, an offset, and a length, but it would only be able to parse data inside a <code>string</code>. What if the data happens to be in a <code>char[]</code>? In that case, you’d have to convert it to a <code>string</code> first, at which point we’re back to additional allocations. Alternatively, every API that wants to support this approach would need multiple overloads to support all the containers that anyone might want to use, each potentially requiring a different implementation of the same basic method.</p>
<p>More subtly, what if the data you have is currently in memory that’s not on the CLR’s heap? This is
a particularly important question when it comes to the performance of servers that accept requests
over the network (e.g., a web server). Sometimes it is not possible to arrange for data received by
a network card to be delivered directly into memory on .NET’s heap. Also, some forms of
interprocess communication involve arranging for the OS to map a particular region of memory into
two different processes’ address spaces. The .NET heap is local to the process and cannot use such memory.</p>
<p><a data-primary="unsafe code" data-type="indexterm" id="idm45884782524048"/>C# has always supported use of external memory through <em>unsafe code</em>, which supports
raw unmanaged pointers that work in a similar way to pointers in the C and <span class="keep-together">C++</span> languages.
However, there are a couple of problems with these. First, they would add yet another entry to the
list of overloads that everything would need to support in a world where we can parse data in place. Second, code using pointers cannot
pass .NET’s type safety verification rules. This means it becomes possible to make certain kinds
of programming errors that are normally impossible in C#. It may also mean that the code will not
be allowed to run in certain scenarios, since the loss of type safety would enable unsafe code to
bypass certain security constraints.</p>
<p>To summarize, it has always been possible to reduce allocations and copying in .NET by working with
offsets and lengths and either a reference to a containing string or array or an unmanaged
pointer to memory, but there was considerable room for improvement on these fronts:</p>
<ul>
<li>
<p>Convenience</p>
</li>
<li>
<p>Wide support across .NET APIs</p>
</li>
<li>
<p>Unified, safe handling of the following:</p>
<ul>
<li>
<p>Strings</p>
</li>
<li>
<p>Arrays</p>
</li>
<li>
<p>Unmanaged memory</p>
</li>
</ul>
</li>
</ul>
<p>.NET offers a type that addresses all three points: <code>Span&lt;T&gt;</code>. (See the next sidebar,
<a href="#span_runtime_and_langauge_versions_sidebar">“Support Across Language and Runtime Versions”</a>, for more information on how the features
described in this chapter relate to C# language and .NET runtime versions.)</p>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="span_runtime_and_langauge_versions_sidebar">
<h5>Support Across Language and Runtime Versions</h5>
<p><code>Span&lt;T&gt;</code> is built into .NET and .NET Core and is available to any library that targets .NET Standard 2.1. You can also use it on .NET Framework via a NuGet package, <code>System.Memory</code>, but be aware that this package has some limitations.</p>
<p>First, although this NuGet package adds <code>Span&lt;T&gt;</code> and related types, it cannot modify existing libraries. To fulfill the “wide support across .NET APIs” requirement, Microsoft added numerous methods to the .NET Core and .NET runtime libraries. For example, new overloads of <code>int.TryParse</code> accept <code>ReadOnlySpan&lt;char&gt;</code> as an alternative to <code>string</code>. The <code>System.Memory</code> NuGet package can’t add new static methods to <code>int</code>, so these new methods are not available in .NET Framework.</p>
<p>Second, this package provides a slightly different implementation than the one you will get when running the exact same code on .NET Core or .NET. These newer runtimes recognize <code>Span&lt;T&gt;</code> and related types and provide special optimizations. This is critical to the high performance offered by the features discussed in this chapter. The latest version of the .NET Framework at the time of writing (version 4.8) lacks the <code>Span&lt;T&gt;</code> optimizations, and Microsoft has no plans to add them in future versions because the .NET Framework is superseded by .NET. Code using these techniques works correctly on .NET Framework, but if you want to reap the full performance benefits of these techniques, you’ll need to run on .NET.
<a data-startref="ix_ch18-asciidoc1" data-type="indexterm" id="idm45884782477040"/><a data-startref="ix_ch18-asciidoc1a" data-type="indexterm" id="idm45884782476336"/></p>
</div></aside>
</div></section>
<section data-pdf-bookmark="Representing Sequential Elements with Span&lt;T&gt;" data-type="sect1"><div class="sect1" id="idm45884782644048">
<h1>Representing Sequential Elements with Span&lt;T&gt;</h1>
<p><a data-primary="memory efficiency" data-secondary="representing sequential elements with Span&lt;T&gt;" data-type="indexterm" id="ix_ch18-asciidoc2"/><a data-primary="Span&lt;T&gt; type" data-type="indexterm" id="ix_ch18-asciidoc3"/>The <code>System.Span&lt;T&gt;</code> value type represents a sequence of elements of type <code>T</code> stored contiguously
in memory. Those elements can live inside an array, a string, a managed block of memory allocated
in a stack frame, or unmanaged memory. Let’s look at how <code>Span&lt;T&gt;</code> addresses each of the
requirements enumerated in the preceding <span class="keep-together">section.</span></p>
<p>A <code>Span&lt;T&gt;</code> encapsulates three things: a pointer or reference to the containing memory (e.g.,
the <code>string</code> or array), the position of the data within that memory, and its
length.<sup><a data-type="noteref" href="ch18.xhtml#idm45884782468272" id="idm45884782468272-marker">1</a></sup> To access the contents of a span, you use it much as you would an array, as
<a data-type="xref" href="#ex_sum_span_contents">Example 18-3</a> shows. This makes it much more convenient to use than
ad hoc techniques in which you define a couple of <code>int</code> variables and have to remember what they
refer to.</p>
<div data-type="example" id="ex_sum_span_contents">
<h5><span class="label">Example 18-3. </span>Iterating over a <code>Span&lt;int&gt;</code></h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="k">static</code> <code class="kt">int</code> <code class="nf">SumSpan</code><code class="p">(</code><code class="n">ReadOnlySpan</code><code class="p">&lt;</code><code class="kt">int</code><code class="p">&gt;</code> <code class="n">span</code><code class="p">)</code>
<code class="p">{</code>
    <code class="kt">int</code> <code class="n">sum</code> <code class="p">=</code> <code class="m">0</code><code class="p">;</code>
    <code class="k">for</code> <code class="p">(</code><code class="kt">int</code> <code class="n">i</code> <code class="p">=</code> <code class="m">0</code><code class="p">;</code> <code class="n">i</code> <code class="p">&lt;</code> <code class="n">span</code><code class="p">.</code><code class="n">Length</code><code class="p">;</code> <code class="p">++</code><code class="n">i</code><code class="p">)</code>
    <code class="p">{</code>
        <code class="n">sum</code> <code class="p">+=</code> <code class="n">span</code><code class="p">[</code><code class="n">i</code><code class="p">];</code>
    <code class="p">}</code>
    <code class="k">return</code> <code class="n">sum</code><code class="p">;</code>
<code class="p">}</code></pre></div>
<p>Since a <code>Span&lt;T&gt;</code>  knows its own length, its indexer checks that the index is in range, just as
the built-in array type does. And if you are running on .NET Core or .NET, the performance is very similar
to using a built-in array. This includes the optimizations that detect certain loop patterns—for example, the CLR will recognize the preceding code as a loop that iterates over the entire contents, enabling it to generate code that doesn’t need to check that the index is in range each time around the loop. In some cases it is even able to generate code that uses the vector-oriented instructions available in some CPUs to accelerate the loop. (On .NET Framework, <code>Span&lt;T&gt;</code> is a little slower than an array, because
its CLR does not include the optimizations that were added in .NET Core to support <code>Span&lt;T&gt;</code>.)</p>
<p>You may have noticed that the method in <a data-type="xref" href="#ex_sum_span_contents">Example 18-3</a> takes a <code>ReadOnlySpan&lt;T&gt;</code>. This
is a close relative of <code>Span&lt;T&gt;</code>, and <a data-primary="conversions" data-secondary="implicit" data-type="indexterm" id="idm45884782425648"/><a data-primary="implicit conversions" data-type="indexterm" id="idm45884782424640"/>there is an implicit conversion enabling
you to pass any <code>Span&lt;T&gt;</code> to a method that takes a <code>ReadOnlySpan&lt;T&gt;</code>. The read-only form
enables a method to declare clearly that it will only read from the span, and not write to it.
(This is enforced by the fact that the read-only form’s indexer offers just a <code>get</code> accessor, and
no <code>set</code>.)</p>
<div data-type="tip"><h6>Tip</h6>
<p>Whenever you write a method that works with a span and that does not mean to modify it,
you should use <code>ReadOnlySpan&lt;T&gt;</code>.</p>
</div>
<p>There are implicit conversions from the various supported containers to <code>Span&lt;T&gt;</code> (and also to
<code>ReadOnlySpan&lt;T&gt;</code>). This enables <a data-type="xref" href="#ex_pass_int_array_as_span">Example 18-4</a> to pass an array to the <code>SumSpan</code>
method.</p>
<div data-type="example" id="ex_pass_int_array_as_span">
<h5><span class="label">Example 18-4. </span>Passing an <code>int[]</code> as a <code>ReadOnlySpan&lt;int&gt;</code></h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="n">Console</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code><code class="n">SumSpan</code><code class="p">(</code><code class="k">new</code> <code class="kt">int</code><code class="p">[]</code> <code class="p">{</code> <code class="m">1</code><code class="p">,</code> <code class="m">2</code><code class="p">,</code> <code class="m">3</code> <code class="p">}));</code></pre></div>
<p>Of course, we’ve gone and allocated an array on the heap there, so this particular example
defeats the whole point of using spans, but if you already have an array on hand, this is a
useful technique. <code>Span&lt;T&gt;</code> also works with stack-allocated arrays,
as <a data-type="xref" href="#ex_pass_stack_int_array_as_span">Example 18-5</a> shows. <a data-primary="stackalloc keyword" data-type="indexterm" id="idm45884782354176"/>(The <code>stackalloc</code> keyword enables you to create an array in memory allocated on the current stack frame.)</p>
<div data-type="example" id="ex_pass_stack_int_array_as_span">
<h5><span class="label">Example 18-5. </span>Passing a stack-allocated array as a <code>ReadOnlySpan&lt;int&gt;</code></h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="n">Span</code><code class="p">&lt;</code><code class="kt">int</code><code class="p">&gt;</code> <code class="n">numbers</code> <code class="p">=</code> <code class="k">stackalloc</code> <code class="kt">int</code><code class="p">[]</code> <code class="p">{</code> <code class="m">1</code><code class="p">,</code> <code class="m">2</code><code class="p">,</code> <code class="m">3</code> <code class="p">};</code>
<code class="n">Console</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code><code class="n">SumSpan</code><code class="p">(</code><code class="n">numbers</code><code class="p">));</code></pre></div>
<p>Normally, C# won’t allow you to use <code>stackalloc</code> outside of code marked as <code>unsafe</code>. The keyword
allocates memory on the current method’s stack frame, and it does not create a real array
object. Arrays are reference types, so they must live on the GC heap. A <code>stackalloc</code>
expression produces a pointer type, because it produces plain memory without the usual .NET
object headers. In this case, it would be an <code>int*</code>. You can only use pointer types directly
in unsafe code blocks. However, the compiler makes an exception to this rule if you assign the
pointer produced by a <code>stackalloc</code> expression directly into a span. This is permitted because
spans impose bounds checking, preventing undetected out-of-range access errors of the kind that
normally make pointers unsafe. Also, <code>Span&lt;T&gt;</code> and <code>ReadOnlySpan&lt;T&gt;</code> are both defined as
<code>ref struct</code> types, and as <a data-type="xref" href="#stack_only">“Stack Only”</a> describes, this means they cannot outlive their containing stack frame. This guarantees
that the stack frame on which the stack-allocated memory lives will not vanish while there are
still outstanding references to it. (.NET’s type safety verification rules include special handling

<span class="keep-together">for spans.</span>)</p>
<p>Earlier I mentioned that spans can refer to strings as well as arrays. However, we can’t pass a
<code>string</code> to this <code>SumSpan</code> for the simple reason that it requires a span with an element type of
<code>int</code>, whereas a <code>string</code> is a sequence of <code>char</code> values. <code>int</code> and <code>char</code> have different
sizes—they take 4 and 2 bytes each, respectively. Although an implicit conversion exists between the two
(meaning you can assign a <code>char</code> value into an <code>int</code> variable, giving you the Unicode value of
the <code>char</code>), that does not make a <code>ReadOnlySpan&lt;char&gt;</code> implicitly compatible with a
<code>ReadOnlySpan&lt;int&gt;</code>.<sup><a data-type="noteref" href="ch18.xhtml#idm45884782266080" id="idm45884782266080-marker">2</a></sup> Remember, the entire point of spans is that they provide a view into a block
of data without needing to copy or modify that data; since <code>int</code> and <code>char</code> have different sizes,
converting a <code>char[]</code> to an <code>int[]</code> array would double its size. However, if we were to write a
method accepting a <code>ReadOnlySpan&lt;char&gt;</code>, we would be able to pass it a <code>string</code>, a <code>char[]</code> array, a
<code>stackalloc char[]</code>, or an unmanaged pointer of type <code>char*</code> (because the in-memory representation
of a particular span of characters within each of these is the same).</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Since strings are immutable in .NET, you cannot convert a <code>string</code> to a <code>Span&lt;char&gt;</code>. You can
only convert it to a <code>ReadOnlySpan&lt;char&gt;</code>.</p>
</div>
<p>We’ve examined two of our requirements from the preceding section: <code>Span&lt;T&gt;</code> is easier to use than
ad hoc storing of an offset and length, and it makes it possible to write a single method that can
work with data in arrays, strings, the stack, or unmanaged memory. This leaves our final
requirement: widespread support throughout .NET’s runtime libraries. As <a data-type="xref" href="#ex_parse_string_in_situ">Example 18-6</a> shows, it is now supported in <code>int.Parse</code>, enabling us to fix the problem shown in <a data-type="xref" href="#ex_substring_defeating_the_purpose">Example 18-2</a>.</p>
<div data-type="example" id="ex_parse_string_in_situ">
<h5><span class="label">Example 18-6. </span>Parsing integers in a string using <code>Span&lt;char&gt;</code></h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="kt">string</code> <code class="n">uriString</code> <code class="p">=</code> <code class="s">"http://example.com/books/1323?edition=6&amp;format=pdf"</code><code class="p">;</code>
<code class="kt">int</code> <code class="n">id</code> <code class="p">=</code> <code class="kt">int</code><code class="p">.</code><code class="n">Parse</code><code class="p">(</code><code class="n">uriString</code><code class="p">.</code><code class="n">AsSpan</code><code class="p">(</code><code class="m">25</code><code class="p">,</code> <code class="m">4</code><code class="p">));</code></pre></div>
<p><code>Span&lt;T&gt;</code> is a relatively new type (it was introduced in 2018; .NET has been around since 2002), so
although the .NET runtime libraries now support it widely, many third-party libraries do not yet support it, and perhaps never will. However, it has become increasingly well supported since being introduced, and the situation will only improve.</p>
<section data-pdf-bookmark="Utility Methods" data-type="sect2"><div class="sect2" id="idm45884782245904">
<h2>Utility Methods</h2>
<p>In addition to the array-like indexer and <code>Length</code> properties, <code>Span&lt;T&gt;</code> offers a few useful
methods. The <code>Clear</code> and <code>Fill</code> methods provide convenient ways to initialize all the elements
in a span either to the default value for the element type or a specific value. Obviously,
these are not available on <code>ReadOnlySpan&lt;T&gt;</code>.</p>
<p>You may sometimes encounter situations in which you have a span and you need to pass its contents
to a method that requires an array. Obviously there’s no avoiding an allocation in this case, but
if you need to do it, you can use the <code>ToArray</code> method.</p>
<p>Spans (both normal and read-only) also offer a <code>TryCopyTo</code> method, which takes as its argument a
(non-read-only) span of the same element type. This allows you to copy data between spans. This
method handles scenarios where the source and target spans refer to overlapping ranges within the
same container. As the <code>Try</code> suggests, it’s possible for this method to fail: if the target span is too small, this method returns <code>false</code>.</p>
</div></section>
<section data-pdf-bookmark="Stack Only" data-type="sect2"><div class="sect2" id="stack_only">
<h2>Stack Only</h2>
<p>The <code>Span&lt;T&gt;</code> and <code>ReadOnlySpan&lt;T&gt;</code> types are both declared as <code>ref struct</code>. This means that not
only are they value types, they are value types that can live only on the stack. So you cannot
have fields with span types in a <code>class</code>, or in any <code>struct</code> that is not also a <code>ref struct</code>.
This also imposes some potentially more surprising restrictions. For example, it means you cannot use a span in a variable in an <code>async</code> method. (These store all their variables as fields in
a hidden type, enabling them to live on the heap, because asynchronous methods often need to outlive their original stack frame.
In fact, these methods can even switch to a completely different stack altogether, because asynchronous methods
can end up running on different threads as their execution progresses.) For similar reasons,
there are restrictions on using spans in anonymous functions and in iterator methods. You
can use them in local methods, and you can even declare a <code>ref struct</code> variable in the outer method
and use it from the nested one, but with one restriction: you must not create a delegate that refers to
that local method, because this would cause the compiler to move shared variables into an object
that lives on the heap. (See <a data-type="xref" href="ch09.xhtml#ch_delegates_lambdas_events">Chapter 9</a> for details.)</p>
<p>This restriction is necessary for .NET to be able to offer the combination of array-like
performance, type safety, and the flexibility to work with multiple different 
<span class="keep-together">containers.</span> For situations in which this stack-only limitation is problematic, we have the <code>Memory&lt;T&gt;</code> type.<a data-startref="ix_ch18-asciidoc3" data-type="indexterm" id="idm45884782218384"/><a data-startref="ix_ch18-asciidoc2" data-type="indexterm" id="idm45884782217648"/></p>
</div></section>
</div></section>
<section data-pdf-bookmark="Representing Sequential Elements with Memory&lt;T&gt;" data-type="sect1"><div class="sect1" id="memory_of_T">
<h1>Representing Sequential Elements with Memory&lt;T&gt;</h1>
<p><a data-primary="memory efficiency" data-secondary="representing sequential elements with Memory&lt;T&gt;" data-type="indexterm" id="idm45884782215440"/><a data-primary="Memory&lt;T&gt; type" data-type="indexterm" id="idm45884782214096"/><a data-primary="ReadOnlyMemory&lt;T&gt; type" data-type="indexterm" id="idm45884782213424"/>The <code>Memory&lt;T&gt;</code> type and its counterpart, <code>ReadOnlyMemory&lt;T&gt;</code>, represent the same basic concept as
<code>Span&lt;T&gt;</code> and <code>ReadOnlySpan&lt;T&gt;</code>: these types provide a uniform view over a contiguous sequence
of elements of type <code>T</code> that could reside in an array, unmanaged memory, or,
if the element type is <code>char</code>, a <code>string</code>. But unlike spans, these are <em>not</em> <code>ref struct</code> types,
so they can be used anywhere. The downside is that this means they cannot offer the same high
performance as spans. (It also means you cannot create a <code>Memory&lt;T&gt;</code> that refers to <code>stackalloc</code> memory.)</p>
<p>You can convert a <code>Memory&lt;T&gt;</code> to a <code>Span&lt;T&gt;</code>, and likewise a <code>ReadOnlyMemory&lt;T&gt;</code> to a
<code>ReadOnlySpan&lt;T&gt;</code>, as long as you’re in a context where spans are allowed (e.g., in an ordinary method but not an asynchronous one). The conversion to a span has a cost. It is not massive, but it is significantly higher
than the cost of accessing an individual element in a span. (In particular, many of the optimizations that make spans attractive only become effective with repeated use of the same span.) So if you are going to read or write
elements in a <code>Memory&lt;T&gt;</code> in a loop, you should perform the conversion to <code>Span&lt;T&gt;</code> just once,
outside of the loop, rather than doing it each time around. If you can work entirely with spans,
you should do so since they offer the best performance. (And if you are not concerned with
performance, then this is not the chapter for you!)</p>
</div></section>
<section data-pdf-bookmark="ReadOnlySequence&lt;T&gt;" data-type="sect1"><div class="sect1" id="read_only_sequence_of_T">
<h1>ReadOnlySequence&lt;T&gt;</h1>
<p><a data-primary="memory efficiency" data-secondary="ReadOnlySequence&lt;T&gt;" data-type="indexterm" id="idm45884782174272"/><a data-primary="ReadOnlySequence&lt;T&gt; type" data-type="indexterm" id="idm45884782173296"/>The types we’ve looked at so far in this chapter all represent contiguous blocks of memory.
Unfortunately, data doesn’t always neatly present itself to us in the most convenient possible
form. For example, on a busy server that is handling many concurrent requests, the network messages
for requests in progress often become interleaved—if a particular request is large enough to need
to be split across two network packets, it’s entirely possible that after receiving the first but
before receiving the second of these, one or more packets for other, unrelated requests could
arrive. So by the time we come to process the contents of the request, it might be split across
two different chunks of memory. Since span and memory values can each represent only a contiguous
range of elements, .NET provides another type, <code>ReadOnlySequence</code>, to represent data that is
conceptually a single sequence but that has been split into multiple ranges.</p>
<div class="less_space pagebreak-before" data-type="note" epub:type="note"><h6>Note</h6>
<p><a data-primary="Sequence&lt;T&gt; type" data-type="indexterm" id="idm45884782170896"/><a data-primary="memory efficiency" data-secondary="Sequence&lt;T&gt;" data-type="indexterm" id="idm45884782170192"/>There is no corresponding <code>Sequence&lt;T&gt;</code>. Unlike spans and memory, this particular abstraction
is available only in read-only form. That’s because it’s common to need to deal with fragmented
data as a reader, where you don’t control where the data lives, but if you are producing data, you
are more likely to be in a position to control where it goes.</p>
</div>
<p>Now that we’ve seen the main types for working with data while minimizing the number of
allocations, let’s look at how these can all work together to handle high volumes of data. To
coordinate this kind of processing, we need to look at one more feature: pipelines.</p>
</div></section>
<section data-pdf-bookmark="Processing Data Streams with Pipelines" data-type="sect1"><div class="sect1" id="idm45884782168064">
<h1>Processing Data Streams with Pipelines</h1>
<p><a data-primary="data streams" data-secondary="processing with pipelines" data-type="indexterm" id="ix_ch18-asciidoc6"/><a data-primary="memory efficiency" data-secondary="processing data streams with pipelines" data-type="indexterm" id="ix_ch18-asciidoc8"/><a data-primary="pipelines" data-secondary="processing data streams with" data-type="indexterm" id="ix_ch18-asciidoc9"/>Everything we’re looking at in this chapter is designed to enable safe, efficient processing
of large volumes of data. The types we’ve seen so far all represent information that is already
in memory. We also need to think about how that data is going to get into memory in the first
place. The preceding section hinted at the fact that this can be somewhat messy. The
data will very often be split into chunks, and not in a way designed for the convenience of the
code processing the data, because it will likely be arriving either over a network or from a disk.
If we’re to realize the performance benefits made possible by <code>Span&lt;T&gt;</code> and its related types,
we need to pay close attention to the job of getting data into memory in the first place and
the way in which this data fetching process cooperates with the code that processes the data.
Even if you are only going to be writing code that consumes data—perhaps you are relying on
a framework such as ASP.NET Core to get the data into memory for you—it is important to understand
how this process works.</p>
<p><a data-primary="System.Io.Pipelines package" data-type="indexterm" id="ix_ch18-asciidoc11"/>The <code>System.Io.Pipelines</code> NuGet package defines a set of types in a namespace of the same name that provide a high-performance system for loading data from some source that tends to split data into inconveniently sized chunks, and passing that data over to code that wants to be able to process it in situ using spans. <a data-type="xref" href="#fig_PipelineOverview">Figure 18-2</a> shows the main participants in a pipeline-based process.</p>
<p>At the heart of this is the <code>Pipe</code> class. It offers two properties: <code>Writer</code> and <code>Reader</code>.  The first returns a <code>PipeWriter</code>, which is used by the code that loads the data into memory. (This often doesn’t need to be application-specific. For example, in a web application, you can let ASP.NET Core control the writer on your behalf.) The <code>Reader</code> property’s type is, predictably, <code>PipeReader</code>, and this is most likely to be the part your code interacts with.</p>
<figure><div class="figure" id="fig_PipelineOverview">
<img alt="An overview of the participants in a pipeline" height="310" src="assets/pc10_1802.png" width="600"/>
<h6><span class="label">Figure 18-2. </span>Pipeline overview</h6>
</div></figure>
<p>The basic process for reading data from a pipe is as follows. First, you
call <code>Pipe​Rea⁠der.⁠Rea⁠dAs⁠ync</code>. This returns a task,<sup><a data-type="noteref" href="ch18.xhtml#idm45884782152672" id="idm45884782152672-marker">3</a></sup> because if no data is available yet, you will need to wait until the data source
supplies the writer with some data. Once data is available, the task will provide
a <code>ReadResult</code> object. This supplies a <code>ReadOnlySequence&lt;T&gt;</code>, which presents the available data as
one or more <code>ReadOnlySpan&lt;T&gt;</code> values. The number of spans will depend on how fragmented the data
is. If it’s all conveniently in one place in memory, there will be just one span, but code using a
reader needs to be able to cope with more. Your code should then process as much of the available
data as it can. Once it has done this, it calls the reader’s <code>AdvanceTo</code> to tell it how much of
the data your code has been able to process. Then, if the <code>ReadResult.IsComplete</code> property is
false, we will repeat these steps again from the call to <code>ReadAsync</code>.</p>
<p>An important detail of this is that we are allowed to tell the <code>PipeReader</code> that we couldn’t
process everything it gave us. This would normally be because the information got sliced into
pieces, and we need to see some of the next chunk before we can fully process everything in
the current one. For example, a JSON message large enough to need to be split across
several network packets will probably end up with splits in inconvenient places. So you might find
that the first chunk looks like this:</p>
<pre data-type="programlisting">{"property1":"value1","prope</pre>
<p class="pagebreak-before">And the second like this:</p>
<pre data-type="programlisting">rty2":42}</pre>
<p>In practice the chunks would be bigger, but this illustrates the basic problem: the chunks that a
<code>PipeReader</code> returns are likely to slice across the middle of important features. With most .NET
APIs, you never have to deal with this kind of mess because everything has been cleaned up and
reassembled by the time you see it, but the price you pay for that is the allocation of new
strings to hold the recombined results. If you want to avoid those allocations, you have to handle
these challenges.</p>
<p>There are a couple of ways to deal with this. One is for code reading data to maintain enough
state to be able to stop and later restart at any point in the sequence. So code processing this
JSON might choose to remember that it is partway through an object and that it’s in the middle
of processing a property whose name starts with <code>prope</code>. But <code>PipeReader</code> offers an alternative.
Code processing these examples could report with its call to <code>AdvanceTo</code> that it has consumed everything up to the first
comma. If you do that, the <code>Pipe</code> will remember that we’re not yet finished with this first block,
and when the next call to <code>ReadAsync</code> completes, the <code>ReadOnlySequence&lt;T&gt;</code> in <code>ReadResult.Buffer</code>
will now include at least two spans: the first span will point into the same block of memory as
last time, but now its offset will be set to where we got to last time—that first span will
refer to the <code>"prope</code> text at the end of the first block. And then the second span will refer
to the text in the second chunk.</p>
<p>The advantage of this second approach is that the code processing the data doesn’t need to
remember as much between calls to <code>ReadAsync</code>, because it knows it’ll be able to go back and look
at the previously unprocessed data again once the next chunk arrives, at which point it should
now be able to make sense of it.</p>
<p>In practice, this particular example is fairly easy to cope with because there’s a type in the
runtime libraries called <code>Utf8JsonReader</code> that can handle all the awkward details around chunk
boundaries for us. Let’s look at an example.<a data-startref="ix_ch18-asciidoc11" data-type="indexterm" id="idm45884782136880"/></p>
<section data-pdf-bookmark="Processing JSON in ASP.NET Core" data-type="sect2"><div class="sect2" id="idm45884782136048">
<h2>Processing JSON in ASP.NET Core</h2>
<p><a data-primary="ASP.NET Core, processing JSON in" data-type="indexterm" id="ix_ch18-asciidoc4"/><a data-primary="data streams" data-secondary="processing JSON in ASP.NET Core" data-type="indexterm" id="ix_ch18-asciidoc5"/><a data-primary="JSON" data-secondary="processing in ASP.NET Core" data-type="indexterm" id="ix_ch18-asciidoc7"/><a data-primary="pipelines" data-secondary="processing JSON in ASP.NET Core" data-type="indexterm" id="ix_ch18-asciidoc10"/>Suppose you are developing a web service that needs to handle HTTP requests containing JSON.
This is a pretty common scenario. <a data-type="xref" href="#ex_json_http_handler">Example 18-7</a> shows the typical way to do this
in ASP.NET Core. This is reasonably straightforward, but it does not use any of the low-allocation
mechanisms discussed in this chapter, so this forces ASP.NET Core to allocate multiple objects for
each request.</p>
<div data-type="example" id="ex_json_http_handler">
<h5><span class="label">Example 18-7. </span>Handling JSON in HTTP requests</h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="na">[HttpPost]</code>
<code class="na">[Route("/jobs/create")]</code>
<code class="k">public</code> <code class="k">void</code> <code class="nf">CreateJob</code><code class="p">([</code><code class="n">FromBody</code><code class="p">]</code> <code class="n">JobDescription</code> <code class="n">requestBody</code><code class="p">)</code>
<code class="p">{</code>
    <code class="k">switch</code> <code class="p">(</code><code class="n">requestBody</code><code class="p">.</code><code class="n">JobCategory</code><code class="p">)</code>
    <code class="p">{</code>
        <code class="k">case</code> <code class="s">"arduous"</code><code class="p">:</code>
            <code class="n">CreateArduousJob</code><code class="p">(</code><code class="n">requestBody</code><code class="p">.</code><code class="n">DepartmentId</code><code class="p">);</code>
            <code class="k">break</code><code class="p">;</code>

        <code class="k">case</code> <code class="s">"tedious"</code><code class="p">:</code>
            <code class="n">CreateTediousJob</code><code class="p">(</code><code class="n">requestBody</code><code class="p">.</code><code class="n">DepartmentId</code><code class="p">);</code>
            <code class="k">break</code><code class="p">;</code>
    <code class="p">}</code>
<code class="p">}</code>

<code class="k">public</code> <code class="n">record</code> <code class="nf">JobDescription</code><code class="p">(</code><code class="kt">int</code> <code class="n">DepartmentId</code><code class="p">,</code> <code class="kt">string</code> <code class="n">JobCategory</code><code class="p">);</code></pre></div>
<p>Before we look at how to change it, for readers not familiar with ASP.NET Core, I will quickly
explain what’s happening in this example. The <code>CreateJob</code> method is annotated with attributes
telling ASP.NET Core that this will handle HTTP POST requests where the URL path
is <code>/jobs/create</code>. The <code>[FromBody]</code> attribute on the method’s argument indicates that
we expect the body of the request to contain data in the form described by the
<code>JobDescription</code> type. ASP.NET Core can be configured to handle various data formats, but if you
go with the defaults, it will expect JSON.</p>
<p>This example is therefore telling ASP.NET Core that for each POST request to <span class="keep-together"><code>/jobs/create</code></span>, it should construct a <code>JobDescription</code> object, populating its <code>Dep⁠art⁠ment​Id</code> and <code>JobCategory</code> from properties of the same name in JSON in the incoming request body.</p>
<p>In other words, we’re asking ASP.NET Core to allocate two objects—a <code>Job​Des⁠cri⁠pti⁠on</code> and a
<code>string</code>—for each request, each of which will contain copies of information that was in the
body of the incoming request. (The other property, <code>DepartmentId</code>, is an <code>int</code>, and since that’s a
value type, it lives inside the <code>Job​Des⁠crip⁠tion</code> object.) And for most applications that will be
fine—a couple of allocations is not normally anything to worry about in the course of handling a
single web request. However, in more realistic examples with more complex requests, we might then be
looking at a much larger number of properties, and if you need to handle a very high volume of
requests, the copying of data into a <code>string</code> for each property can start to cause enough extra
work for the GC that it becomes a performance problem.</p>
<p><a data-type="xref" href="#ex_frugal_json_http_handler">Example 18-8</a> shows how we can avoid these allocations using the various
features described in the preceding sections of this chapter. It makes the code a good deal more
complex, demonstrating why you should only apply these kinds of techniques in cases where you have
established that GC overhead is high enough that the extra development effort is justified by the
performance improvements.</p>
<div data-type="example" id="ex_frugal_json_http_handler">
<h5><span class="label">Example 18-8. </span>Handling JSON without allocations</h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="k">private</code> <code class="k">static</code> <code class="k">readonly</code> <code class="kt">byte</code><code class="p">[]</code> <code class="n">Utf8TextJobCategory</code> <code class="p">=</code>
    <code class="n">Encoding</code><code class="p">.</code><code class="n">UTF8</code><code class="p">.</code><code class="n">GetBytes</code><code class="p">(</code><code class="s">"JobCategory"</code><code class="p">);</code>
<code class="k">private</code> <code class="k">static</code> <code class="k">readonly</code> <code class="kt">byte</code><code class="p">[]</code> <code class="n">Utf8TextDepartmentId</code> <code class="p">=</code>
    <code class="n">Encoding</code><code class="p">.</code><code class="n">UTF8</code><code class="p">.</code><code class="n">GetBytes</code><code class="p">(</code><code class="s">"DepartmentId"</code><code class="p">);</code>
<code class="k">private</code> <code class="k">static</code> <code class="k">readonly</code> <code class="kt">byte</code><code class="p">[]</code> <code class="n">Utf8TextArduous</code> <code class="p">=</code> <code class="n">Encoding</code><code class="p">.</code><code class="n">UTF8</code><code class="p">.</code><code class="n">GetBytes</code><code class="p">(</code><code class="s">"arduous"</code><code class="p">);</code>
<code class="k">private</code> <code class="k">static</code> <code class="k">readonly</code> <code class="kt">byte</code><code class="p">[]</code> <code class="n">Utf8TextTedious</code> <code class="p">=</code> <code class="n">Encoding</code><code class="p">.</code><code class="n">UTF8</code><code class="p">.</code><code class="n">GetBytes</code><code class="p">(</code><code class="s">"tedious"</code><code class="p">);</code>

<code class="na">[HttpPost]</code>
<code class="na">[Route("/jobs/create")]</code>
<code class="k">public</code> <code class="k">async</code> <code class="n">ValueTask</code> <code class="nf">CreateJobFrugalAsync</code><code class="p">()</code>
<code class="p">{</code>
    <code class="kt">bool</code> <code class="n">inDepartmentIdProperty</code> <code class="p">=</code> <code class="k">false</code><code class="p">;</code>
    <code class="kt">bool</code> <code class="n">inJobCategoryProperty</code> <code class="p">=</code> <code class="k">false</code><code class="p">;</code>
    <code class="kt">int?</code> <code class="n">departmentId</code> <code class="p">=</code> <code class="k">null</code><code class="p">;</code>
    <code class="kt">bool?</code> <code class="n">isArduous</code> <code class="p">=</code> <code class="k">null</code><code class="p">;</code>

    <code class="n">PipeReader</code> <code class="n">reader</code> <code class="p">=</code> <code class="k">this</code><code class="p">.</code><code class="n">Request</code><code class="p">.</code><code class="n">BodyReader</code><code class="p">;</code>
    <code class="n">JsonReaderState</code> <code class="n">jsonState</code> <code class="p">=</code> <code class="k">default</code><code class="p">;</code>
    <code class="k">while</code> <code class="p">(</code><code class="k">true</code><code class="p">)</code>
    <code class="p">{</code>
        <code class="n">ReadResult</code> <code class="n">result</code> <code class="p">=</code> <code class="k">await</code> <code class="n">reader</code><code class="p">.</code><code class="n">ReadAsync</code><code class="p">().</code><code class="n">ConfigureAwait</code><code class="p">(</code><code class="k">false</code><code class="p">);</code>
        <code class="n">jsonState</code> <code class="p">=</code> <code class="n">ProcessBuffer</code><code class="p">(</code>
            <code class="n">result</code><code class="p">,</code>
            <code class="n">jsonState</code><code class="p">,</code>
            <code class="k">out</code> <code class="n">SequencePosition</code> <code class="n">position</code><code class="p">);</code>

        <code class="k">if</code> <code class="p">(</code><code class="n">departmentId</code><code class="p">.</code><code class="n">HasValue</code> <code class="p">&amp;&amp;</code> <code class="n">isArduous</code><code class="p">.</code><code class="n">HasValue</code><code class="p">)</code>
        <code class="p">{</code>
            <code class="k">if</code> <code class="p">(</code><code class="n">isArduous</code><code class="p">.</code><code class="n">Value</code><code class="p">)</code>
            <code class="p">{</code>
                <code class="n">CreateArduousJob</code><code class="p">(</code><code class="n">departmentId</code><code class="p">.</code><code class="n">Value</code><code class="p">);</code>
            <code class="p">}</code>
            <code class="k">else</code>
            <code class="p">{</code>
                <code class="n">CreateTediousJob</code><code class="p">(</code><code class="n">departmentId</code><code class="p">.</code><code class="n">Value</code><code class="p">);</code>
            <code class="p">}</code>

            <code class="k">return</code><code class="p">;</code>
        <code class="p">}</code>

        <code class="n">reader</code><code class="p">.</code><code class="n">AdvanceTo</code><code class="p">(</code><code class="n">position</code><code class="p">);</code>

        <code class="k">if</code> <code class="p">(</code><code class="n">result</code><code class="p">.</code><code class="n">IsCompleted</code><code class="p">)</code>
        <code class="p">{</code>
            <code class="k">break</code><code class="p">;</code>
        <code class="p">}</code>
    <code class="p">}</code>

    <code class="n">JsonReaderState</code> <code class="nf">ProcessBuffer</code><code class="p">(</code>
        <code class="k">in</code> <code class="n">ReadResult</code> <code class="n">result</code><code class="p">,</code>
        <code class="k">in</code> <code class="n">JsonReaderState</code> <code class="n">jsonState</code><code class="p">,</code>
        <code class="k">out</code> <code class="n">SequencePosition</code> <code class="n">position</code><code class="p">)</code>
    <code class="p">{</code>
        <code class="c1">// This is a ref struct, so this has no GC overhead</code>
        <code class="kt">var</code> <code class="n">r</code> <code class="p">=</code> <code class="k">new</code> <code class="n">Utf8JsonReader</code><code class="p">(</code><code class="n">result</code><code class="p">.</code><code class="n">Buffer</code><code class="p">,</code> <code class="n">result</code><code class="p">.</code><code class="n">IsCompleted</code><code class="p">,</code> <code class="n">jsonState</code><code class="p">);</code>

        <code class="k">while</code> <code class="p">(</code><code class="n">r</code><code class="p">.</code><code class="n">Read</code><code class="p">())</code>
        <code class="p">{</code>
            <code class="k">if</code> <code class="p">(</code><code class="n">inDepartmentIdProperty</code><code class="p">)</code>
            <code class="p">{</code>
                <code class="k">if</code> <code class="p">(</code><code class="n">r</code><code class="p">.</code><code class="n">TokenType</code> <code class="p">==</code> <code class="n">JsonTokenType</code><code class="p">.</code><code class="n">Number</code><code class="p">)</code>
                <code class="p">{</code>
                    <code class="k">if</code> <code class="p">(</code><code class="n">r</code><code class="p">.</code><code class="n">TryGetInt32</code><code class="p">(</code><code class="k">out</code> <code class="kt">int</code> <code class="n">v</code><code class="p">))</code>
                    <code class="p">{</code>
                        <code class="n">departmentId</code> <code class="p">=</code> <code class="n">v</code><code class="p">;</code>
                    <code class="p">}</code>
                <code class="p">}</code>
            <code class="p">}</code>
            <code class="k">else</code> <code class="k">if</code> <code class="p">(</code><code class="n">inJobCategoryProperty</code><code class="p">)</code>
            <code class="p">{</code>
                <code class="k">if</code> <code class="p">(</code><code class="n">r</code><code class="p">.</code><code class="n">TokenType</code> <code class="p">==</code> <code class="n">JsonTokenType</code><code class="p">.</code><code class="n">String</code><code class="p">)</code>
                <code class="p">{</code>
                    <code class="k">if</code> <code class="p">(</code><code class="n">r</code><code class="p">.</code><code class="n">ValueSpan</code><code class="p">.</code><code class="n">SequenceEqual</code><code class="p">(</code><code class="n">Utf8TextArduous</code><code class="p">))</code>
                    <code class="p">{</code>
                        <code class="n">isArduous</code> <code class="p">=</code> <code class="k">true</code><code class="p">;</code>
                    <code class="p">}</code>
                    <code class="k">else</code> <code class="k">if</code> <code class="p">(</code><code class="n">r</code><code class="p">.</code><code class="n">ValueSpan</code><code class="p">.</code><code class="n">SequenceEqual</code><code class="p">(</code><code class="n">Utf8TextTedious</code><code class="p">))</code>
                    <code class="p">{</code>
                        <code class="n">isArduous</code> <code class="p">=</code> <code class="k">false</code><code class="p">;</code>
                    <code class="p">}</code>
                <code class="p">}</code>
            <code class="p">}</code>

            <code class="n">inDepartmentIdProperty</code> <code class="p">=</code> <code class="k">false</code><code class="p">;</code>
            <code class="n">inJobCategoryProperty</code> <code class="p">=</code> <code class="k">false</code><code class="p">;</code>

            <code class="k">if</code> <code class="p">(</code><code class="n">r</code><code class="p">.</code><code class="n">TokenType</code> <code class="p">==</code> <code class="n">JsonTokenType</code><code class="p">.</code><code class="n">PropertyName</code><code class="p">)</code>
            <code class="p">{</code>
                <code class="k">if</code> <code class="p">(</code><code class="n">r</code><code class="p">.</code><code class="n">ValueSpan</code><code class="p">.</code><code class="n">SequenceEqual</code><code class="p">(</code><code class="n">Utf8TextJobCategory</code><code class="p">))</code>
                <code class="p">{</code>
                    <code class="n">inJobCategoryProperty</code> <code class="p">=</code> <code class="k">true</code><code class="p">;</code>
                <code class="p">}</code>
                <code class="k">else</code> <code class="k">if</code> <code class="p">(</code><code class="n">r</code><code class="p">.</code><code class="n">ValueSpan</code><code class="p">.</code><code class="n">SequenceEqual</code><code class="p">(</code><code class="n">Utf8TextDepartmentId</code><code class="p">))</code>
                <code class="p">{</code>
                    <code class="n">inDepartmentIdProperty</code> <code class="p">=</code> <code class="k">true</code><code class="p">;</code>
                <code class="p">}</code>
            <code class="p">}</code>
        <code class="p">}</code>

        <code class="n">position</code> <code class="p">=</code> <code class="n">r</code><code class="p">.</code><code class="n">Position</code><code class="p">;</code>
        <code class="k">return</code> <code class="n">r</code><code class="p">.</code><code class="n">CurrentState</code><code class="p">;</code>
    <code class="p">}</code>
<code class="p">}</code></pre></div>
<p>Instead of defining an argument with a <code>[FromBody]</code> attribute, this method works directly with
the <code>this.Request.BodyReader</code> property. (Inside an ASP.NET Core MVC controller class,
<code>this.Request</code> returns an object representing the request being handled.) This property’s type is
<code>PipeReader</code>, the consumer side of a <code>Pipe</code>. ASP.NET Core creates the pipe, and it manages the
data production side, feeding data from incoming requests into the associated <code>PipeWriter</code>.</p>
<p>As the property name suggests, this particular <code>PipeReader</code> enables us to read the contents of the
HTTP request’s body. By reading the data this way, we make it possible for ASP.NET Core to
present the request body to us in situ: our code will be able to read the data directly from
wherever it happened to end up in memory once the computer’s network card received it. (In other
words, no copies, and no additional GC overhead.)</p>
<p>The <code>while</code> loop in <code>CreateJobFrugalAsync</code> performs the same process you’ll see with any code
that reads data from a <code>PipeReader</code>: it calls <code>ReadAsync</code>, processes the data that returns,
and calls <code>AdvanceTo</code> to let the <code>PipeReader</code> know how much of that data it was able to process.
We then check the <code>IsComplete</code> property of the <code>ReadResult</code> returned by <code>ReadAsync</code>, and if that
is <code>false</code>, then we go round one more time.</p>
<p><a data-primary="serialization" data-secondary="Utf8JsonReader" data-type="indexterm" id="ix_ch18-asciidoc12a"/><a data-primary="Utf8JsonReader type" data-type="indexterm" id="ix_ch18-asciidoc12"/><a data-type="xref" href="#ex_frugal_json_http_handler">Example 18-8</a> uses the <code>Utf8JsonReader</code> type to read the data. As the name
suggests, this works directly with text in UTF-8 encoding. This alone can provide a significant
performance improvement: JSON messages are commonly sent with this encoding, but .NET strings
use UTF-16. So one of the jobs that the simpler <a data-type="xref" href="#ex_json_http_handler">Example 18-7</a> forced ASP.NET to do
was convert any strings from UTF-8 to UTF-16. On the other hand, we’ve lost some flexibility.
The simpler, slower approach has the benefit of being able to adapt to incoming requests in more formats: if a client chose to send its request in something other than UTF-8—perhaps
UTF-16 or UCS-32, or even a non-Unicode encoding such as ISO-8859-1—our handler could cope
with any of them, because ASP.NET Core can do the string conversions for us. But since
<a data-type="xref" href="#ex_frugal_json_http_handler">Example 18-8</a> works directly with the data in the form the client transmitted,
using a type that only understands UTF-8, we have traded off that flexibility in exchange for
higher performance.</p>
<p><code>Utf8JsonReader</code> is able to handle the tricky chunking issues for us—if an incoming request ends up being
split across multiple buffers in memory because it was too large to fit in a single network
packet, <code>Utf8JsonReader</code> is able to cope. In the event of an unhelpfully placed split, it will
process what it can, and then the <code>JsonReaderState</code> value it returns through its <code>CurrentState</code>
will report a <code>Position</code> indicating the first unprocessed character. We pass this to
<code>PipeReader.AdvanceTo</code>. The next call to <code>PipeReader.ReadAsync</code> will return only when there is
more data, but its <code>ReadResult.Buffer</code> will also include the previously unconsumed data.</p>
<p>Like the <code>ReadOnlySpan&lt;T&gt;</code> type it uses internally when reading data, <code>Utf8JsonReader</code>
is a <code>ref struct</code> type, meaning that it cannot live on the heap. This means it cannot be used in
an <code>async</code> method, because <code>async</code> methods store all of their local variables on the heap. That is
why this example has a separate method, <code>ProcessBuffer</code>. The outer <code>CreateJobFrugalAsync</code> method
has to be <code>async</code> because the streaming nature of the <code>PipeReader</code> type means that its <code>ReadAsync</code>
method requires us to use <code>await</code>. But the <code>Utf8JsonReader</code> cannot be used in an <code>async</code> method,
so we end up having to split our logic across two methods.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>When splitting your pipeline processing into an outer <code>async</code> reader loop and an inner method
that avoids async in order to use <code>ref struct</code> types, it can be convenient to make the inner
method a local method, as <a data-type="xref" href="#ex_frugal_json_http_handler">Example 18-8</a> does. This
enables it to access variables declared in the outer method. You might be wondering whether this
causes a hidden extra allocation—to enable sharing of variables in this way, the compiler generates
a type, storing shared variables in fields in that type and not as conventional stack-based
variables. With lambdas and other anonymous methods, this type will indeed cause an additional
allocation, because it needs to be a heap-based type so that it can outlive the parent method.
However, with local methods, the compiler uses a <code>struct</code> to hold the shared variables, which
it passes by reference to the inner method, thus avoiding any extra allocation. This is possible
because the compiler can determine that all calls to the local method will return before the
outer method returns.</p>
</div>
<p>When using <code>Utf8JsonReader</code>, our code has to be prepared to receive the content in whatever order it
happens to arrive. We can’t write code that tries to read the properties in an order that is
convenient for us, because that would rely on something holding those properties and their values
in memory. (If you tried to rely on going back to the underlying data to retrieve particular
properties on demand, you might find that the property you wanted was in an earlier chunk that’s
no longer available.) This defeats the whole goal of minimizing allocations. If you want to avoid
allocations, your code needs to be flexible enough to handle the properties in whatever order
they appear.</p>
<p>So the <code>ProcessBuffer</code> code in <a data-type="xref" href="#ex_frugal_json_http_handler">Example 18-8</a> just looks at each JSON element as
it comes and works out whether it’s of interest. This means that when looking for particular
property values, we have to notice the <code>PropertyName</code> element, and then remember that this was the
last thing we saw, so that we know how to handle the <code>Number</code> or <code>String</code> element that follows,
containing the value.</p>
<p>One strikingly odd feature of this code is the way it checks for particular strings. It needs to
recognize properties of interest (<code>JobCategory</code> and <code>DepartmentId</code> in this example). But we can’t
just use normal string comparison. While it’s possible to retrieve property names and string
values  as .NET strings, doing so defeats the main purpose of using <code>Utf8JsonReader</code>: if you
obtain a <code>string</code>, the CLR has to allocate space for that string on the heap and will eventually have
to garbage collect the memory. (In this example, every acceptable incoming string is known in
advance. In some scenarios there will be user-supplied strings whose values you will need to
perform further processing on, and in those cases, you may just need to accept the
costs of allocating an actual <code>string</code>.) So instead we end up performing binary comparisons.
Notice that we’re working entirely in UTF-8 encoding, and not the UTF-16 encoding used by .NET’s
<code>string</code> type. (The various static fields, such as <code>Utf8TextJobCategory</code> and <code>Utf8TextDepartmentId</code>, are all byte arrays created through <code>Encoding.UTF8</code> from the <code>System.Text</code> namespace.) That’s
because all of this code works directly against the request’s payload in the form in which it
arrived over the network, in order to avoid unnecessary copying<a data-startref="ix_ch18-asciidoc12a" data-type="indexterm" id="idm45884781467632"/><a data-startref="ix_ch18-asciidoc12" data-type="indexterm" id="idm45884781466928"/>.<a data-startref="ix_ch18-asciidoc10" data-type="indexterm" id="idm45884781466128"/><a data-startref="ix_ch18-asciidoc9" data-type="indexterm" id="idm45884781465424"/><a data-startref="ix_ch18-asciidoc8" data-type="indexterm" id="idm45884781464752"/><a data-startref="ix_ch18-asciidoc7" data-type="indexterm" id="idm45884781464080"/><a data-startref="ix_ch18-asciidoc6" data-type="indexterm" id="idm45884781463408"/><a data-startref="ix_ch18-asciidoc5" data-type="indexterm" id="idm45884781462736"/><a data-startref="ix_ch18-asciidoc4" data-type="indexterm" id="idm45884781462064"/></p>
</div></section>
</div></section>
<section data-pdf-bookmark="Summary" data-type="sect1"><div class="sect1" id="idm45884782135456">
<h1>Summary</h1>
<p>APIs that break data down into the constituent components can be very convenient to use, but this
convenience comes at a price. Each time we want some subelement represented either as a string or
a child object, we cause another object to be allocated on the GC heap. The cumulative cost of
these allocations (and the corresponding work to recover the memory once they are no longer in use)
can be damaging in some very performance-sensitive applications. They can also be significant in cloud applications or high-volume data processing, where you might be paying for the amount of processing work you do—reducing CPU or memory usage can have a nontrivial effect on cost.</p>
<p>The <code>Span&lt;T&gt;</code> type and the related types discussed in this chapter make it possible to work with
data wherever it already resides in memory. This typically requires rather more complex code, but
in cases where the payoff justifies the work, these features make it possible for C# to tackle
whole classes of problems for which it would previously have been too slow.</p>
<p>Thank you for reading this book, and congratulations for making it to the end. I hope you enjoy using C#, and I wish you every success with your future projects.<a data-startref="ix_ch18-asciidoc0" data-type="indexterm" id="idm45884781459344"/></p>
</div></section>
<div data-type="footnotes"><p data-type="footnote" id="idm45884782468272"><sup><a href="ch18.xhtml#idm45884782468272-marker">1</a></sup> .NET Core and .NET do not store the pointer and offset separately: instead, a span just points directly to the data of interest. The version of <code>Span&lt;T&gt;</code> available for .NET Framework needs to maintain the pointer separately to ensure GC handles spans correctly, because its CLR does not have the same modifications for supporting spans that .NET Core has.</p><p data-type="footnote" id="idm45884782266080"><sup><a href="ch18.xhtml#idm45884782266080-marker">2</a></sup> That said, it is possible to perform this kind of conversion explicitly—the <code>MemoryMarshal</code> class offers methods that can take a span of one type and return another span that provides a view over the same underlying memory, interpreted as containing a different element type. But it is unlikely to be useful in this case: converting a <code>ReadOnlySpan&lt;char&gt;</code> to a <code>ReadOnlySpan&lt;int&gt;</code> would produce a span with half the number of elements, where each <code>int</code> contained pairs of adjacent <code>char</code> values.</p><p data-type="footnote" id="idm45884782152672"><sup><a href="ch18.xhtml#idm45884782152672-marker">3</a></sup> It is a <code>ValueTask&lt;ReadResult&gt;</code> because the purpose of this exercise is to minimize allocations. <code>ValueTask&lt;T&gt;</code> was described in <a data-type="xref" href="ch16.xhtml#ch_multithreading">Chapter 16</a>.</p></div></div></section></div></body></html>