- en: Chapter 16\. Networking
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 16 章\. 网络
- en: '.NET offers a variety of classes in the `System.Net.*` namespaces for communicating
    via standard network protocols, such as HTTP and TCP/IP. Here’s a summary of the
    key components:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 提供了一系列类用于通过标准网络协议（如 HTTP 和 TCP/IP）进行通信，这些类位于 `System.Net.*` 命名空间中。以下是关键组件的摘要：
- en: '`HttpClient` for consuming HTTP web APIs and RESTful services'
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HttpClient` 用于消费 HTTP Web API 和 RESTful 服务'
- en: '`HttpListener` for writing an HTTP server'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HttpListener` 用于编写 HTTP 服务器'
- en: '`SmtpClient` for constructing and sending mail messages via SMTP'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SmtpClient` 用于通过 SMTP 构建和发送邮件消息'
- en: '`Dns` for converting between domain names and addresses'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Dns` 用于在域名和地址之间进行转换'
- en: '`TcpClient`, `UdpClient`, `TcpListener`, and `Socket` classes for direct access
    to the transport and network layers'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TcpClient`、`UdpClient`、`TcpListener` 和 `Socket` 类用于直接访问传输和网络层'
- en: The .NET types in this chapter are in the `System.Net.*` and `System.IO` namespaces.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的 .NET 类型位于 `System.Net.*` 和 `System.IO` 命名空间中。
- en: Note
  id: totrans-8
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: .NET also provides client-side support for FTP, but only through classes that
    have been marked as obsolete from .NET 6\. If you need to use FTP, your best option
    is to reach for a NuGet library such as FluentFTP.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 还为 FTP 提供了客户端支持，但仅限于自 .NET 6 起已标记为过时的类。如果需要使用 FTP，您最好选择 NuGet 库，例如 FluentFTP。
- en: Network Architecture
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络架构
- en: '[Figure 16-1](#network_architecture) illustrates the .NET networking types
    and the communication layers in which they reside. Most types reside in the *transport
    layer* or *application layer*. The transport layer defines basic protocols for
    sending and receiving bytes (TCP and UDP); the application layer defines higher-level
    protocols designed for specific applications such as retrieving web pages (HTTP),
    sending mail (SMTP), and converting between domain names and IP addresses (DNS).'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 16-1](#network_architecture)展示了 .NET 网络类型及其所属的通信层。大多数类型位于传输层或应用层。传输层定义了发送和接收字节的基本协议（TCP
    和 UDP）；应用层定义了针对特定应用程序设计的高级协议，例如检索网页（HTTP）、发送邮件（SMTP）和在域名和 IP 地址之间转换（DNS）。'
- en: '![](assets/cn10_1601.png)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/cn10_1601.png)'
- en: Figure 16-1\. Network architecture
  id: totrans-13
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 16-1\. 网络架构
- en: It’s usually most convenient to program at the application layer; however, there
    are a couple of reasons why you might want to work directly at the transport layer.
    One is if you need an application protocol not provided in .NET, such as POP3
    for retrieving mail. Another is if you want to invent a custom protocol for a
    special application such as a peer-to-peer client.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 通常最方便的是在应用层编程；但是，直接在传输层工作可能有几个理由。其中一个是如果您需要 .NET 中没有提供的应用层协议，比如用于检索邮件的 POP3。另一个是如果您想为特殊应用程序（如对等客户端）发明自定义协议。
- en: Of the application protocols, HTTP is special in its applicability to general-purpose
    communication. Its basic mode of operation—“give me the web page with this URL”—adapts
    nicely to “get me the result of calling this endpoint with these arguments.” (In
    addition to the “get” verb, there is “put,” “post,” and “delete,” allowing for
    REST-based services.)
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 应用层协议中，HTTP 在其通用通信适用性上非常特殊。其基本操作模式——“给我这个 URL 的网页”——很好地适应于“使用这些参数调用此端点后得到的结果”。（除了“get”动词外，还有“put”、“post”和“delete”，允许基于
    REST 的服务。）
- en: HTTP also has a rich set of features that are useful in multitier business applications
    and service-oriented architectures, such as protocols for authentication and encryption,
    message chunking, extensible headers and cookies, and the ability to have many
    server applications share a single port and IP address. For these reasons, HTTP
    is well supported in .NET—both directly, as described in this chapter, and at
    a higher level, through such technologies as Web API and ASP.NET Core.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP 还具有丰富的功能集，对于多层业务应用程序和面向服务的架构非常有用，如身份验证和加密协议、消息分块、可扩展的头部和 Cookie、以及许多服务器应用程序共享单一端口和
    IP 地址的能力。因此，HTTP 在 .NET 中得到了很好的支持——既通过本章描述的直接支持，也通过 Web API 和 ASP.NET Core 等技术在更高层次上支持。
- en: As the preceding discussion makes clear, networking is a field that is awash
    in acronyms. We list the most common in [Table 16-1](#network_acronyms).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，网络是一个充斥着缩略词的领域。我们在[表 16-1](#network_acronyms)中列出了最常见的缩略词。
- en: Table 16-1\. Network acronyms
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 表 16-1\. 网络缩略词
- en: '| Acronym | Expansion | Notes |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| 缩略词 | 扩展 | 备注 |'
- en: '| --- | --- | --- |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| DNS | Domain Name Service | Converts between domain names (e.g., *ebay.com*)
    and IP addresses (e.g., 199.54.213.2) |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| DNS | 域名服务 | 在域名（例如 *ebay.com*）和 IP 地址（例如 199.54.213.2）之间进行转换 |'
- en: '| FTP | File Transfer Protocol | Internet-based protocol for sending and receiving
    files |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| FTP | 文件传输协议 | 用于发送和接收文件的互联网协议 |'
- en: '| HTTP | Hypertext Transfer Protocol | Retrieves web pages and runs web services
    |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| HTTP | 超文本传输协议 | 检索网页和运行网络服务 |'
- en: '| IIS | Internet Information Services | Microsoft’s web server software |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| IIS | 互联网信息服务 | 微软的网络服务器软件 |'
- en: '| IP | Internet Protocol | Network-layer protocol below TCP and UDP |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| IP | 互联网协议 | 位于TCP和UDP之下的网络层协议 |'
- en: '| LAN | Local Area Network | Most LANs use internet-based protocols such as
    TCP/IP |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| LAN | 局域网 | 大多数LAN使用基于互联网的协议，如TCP/IP |'
- en: '| POP | Post Office Protocol | Retrieves internet mail |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| POP | 邮局协议 | 检索互联网邮件 |'
- en: '| REST | REpresentational State Transfer | A popular web service architecture
    that uses machine-followable links in responses and that can operate over basic
    HTTP |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| REST | 表述性状态转移 | 使用响应中的可机器跟随链接的流行Web服务架构，可以在基本的HTTP上运行 |'
- en: '| SMTP | Simple Mail Transfer Protocol | Sends internet mail |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| SMTP | 简单邮件传输协议 | 发送互联网邮件 |'
- en: '| TCP | Transmission and Control Protocol | Transport-layer internet protocol
    on top of which most higher-layer services are built |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| TCP | 传输和控制协议 | 大多数高层服务建立在其上的传输层互联网协议 |'
- en: '| UDP | Universal Datagram Protocol | Transport-layer internet protocol used
    for low-overhead services such as VoIP |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| UDP | 通用数据报协议 | 用于低开销服务（如VoIP）的传输层互联网协议 |'
- en: '| UNC | Universal Naming Convention | *\\computer\sharename\filename* |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| UNC | 通用命名约定 | *\\computer\sharename\filename* |'
- en: '| URI | Uniform Resource Identifier | Ubiquitous resource naming system (e.g.,
    *http://www.amazon.com* or *mailto:joe@bloggs.org*) |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| URI | 统一资源标识符 | 普遍的资源命名系统（例如，*http://www.amazon.com* 或 *mailto:joe@bloggs.org*）
    |'
- en: '| URL | Uniform Resource Locator | Technical meaning (fading from use): subset
    of URI; popular meaning: synonym of URI |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| URL | 统一资源定位符 | 技术含义（逐渐不再使用）：URI的子集；普通含义：URI的同义词 |'
- en: Addresses and Ports
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 地址和端口
- en: 'For communication to work, a computer or device requires an address. The internet
    uses two addressing systems:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使通信正常工作，计算机或设备需要一个地址。互联网使用两个寻址系统：
- en: IPv4
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: IPv4
- en: Currently the dominant addressing system; IPv4 addresses are 32 bits wide. When
    string-formatted, IPv4 addresses are written as four dot-separated decimals (e.g.,
    101.102.103.104). An address can be unique in the world—or unique within a particular
    *subnet* (such as on a corporate network).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 目前主导的寻址系统；IPv4地址为32位。以字符串格式化时，IPv4地址写成四个点分隔的十进制数（例如，101.102.103.104）。一个地址可以是全球唯一的，或者在特定*子网*内是唯一的（例如在企业网络上）。
- en: IPv6
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: IPv6
- en: The newer 128-bit addressing system. Addresses are string-formatted in hexadecimal
    with a colon separator (e.g., [3EA0:FFFF:198A:E4A3:​4FF2:54fA:41BC:8D31]). .NET
    requires that you add square brackets around the address.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 较新的128位寻址系统。地址以十六进制格式化，并用冒号分隔（例如，[3EA0:FFFF:198A:E4A3:​4FF2:54fA:41BC:8D31]）。在.NET中，需要在地址周围加上方括号。
- en: 'The `IPAddress` class in the `System.Net` namespace represents an address in
    either protocol. It has a constructor accepting a byte array, and a static `Parse`
    method accepting a correctly formatted string:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`System.Net`命名空间中的`IPAddress`类表示任一协议中的地址。它有一个接受字节数组的构造函数，并且一个静态的`Parse`方法接受正确格式的字符串：'
- en: '[PRE0]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The TCP and UDP protocols break out each IP address into 65,535 ports, allowing
    a computer on a single address to run multiple applications, each on its own port.
    Many applications have standard default port assignments; for instance, HTTP uses
    port 80; SMTP uses port 25.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: TCP和UDP协议将每个IP地址分解为65535个端口，允许单个地址上的计算机运行多个应用程序，每个应用程序位于自己的端口上。许多应用程序具有标准的默认端口分配；例如，HTTP使用端口80；SMTP使用端口25。
- en: Note
  id: totrans-44
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The TCP and UDP ports from 49152 to 65535 are officially unassigned, so they
    are good for testing and small-scale deployments.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: TCP和UDP端口从49152到65535是官方未分配的，因此它们非常适合测试和小规模部署。
- en: 'An IP address and port combination is represented in .NET by the `IPEndPoint`
    class:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在.NET中，IP地址和端口组合由`IPEndPoint`类表示：
- en: '[PRE1]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note
  id: totrans-48
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Firewalls block ports. In many corporate environments, only a few ports are
    open—typically, port 80 (for unencrypted HTTP) and port 443 (for secure HTTP).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 防火墙阻止端口。在许多企业环境中，只有少数端口是开放的，通常是端口80（用于非加密的HTTP）和端口443（用于安全HTTP）。
- en: URIs
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: URI
- en: A URI is a specially formatted string that describes a resource on the internet
    or a LAN, such as a web page, file, or email address. Examples include *http://www.ietf.org*,
    *ftp://myisp/doc.txt*, and *mailto:joe@bloggs.com*. The exact formatting is defined
    by the [*Internet Engineering Task Force*](http://www.ietf.org) (IETF).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: URI是一个特殊格式的字符串，描述了互联网或LAN上的资源，例如网页、文件或电子邮件地址。示例包括*http://www.ietf.org*、*ftp://myisp/doc.txt*和*mailto:joe@bloggs.com*。确切的格式由[*Internet
    Engineering Task Force*](http://www.ietf.org)（IETF）定义。
- en: A URI can be broken up into a series of elements—typically, *scheme*, *authority*,
    and *path*. The `Uri` class in the `System` namespace performs just this division,
    exposing a property for each element, as illustrated in [Figure 16-2](#uri_properties).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: URI可以分解为一系列元素—通常是*scheme*、*authority*和*path*。`System`命名空间中的`Uri`类正是执行此分割，为每个元素公开一个属性，如在[图16-2](#uri_properties)中所示。
- en: '![](assets/cn10_1602.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/cn10_1602.png)'
- en: Figure 16-2\. URI properties
  id: totrans-54
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图16-2\. URI属性
- en: Note
  id: totrans-55
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The `Uri` class is useful when you need to validate the format of a URI string
    or to split a URI into its component parts. Otherwise, you can treat a URI simply
    as a string—most networking methods are overloaded to accept either a `Uri` object
    or a string.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 当您需要验证URI字符串的格式或将URI拆分为其组成部分时，`Uri`类非常有用。否则，您可以简单地将URI视为字符串—大多数网络方法都重载以接受`Uri`对象或字符串。
- en: 'You can construct a `Uri` object by passing any of the following strings into
    its constructor:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过将以下任何字符串传递到其构造函数来构造`Uri`对象：
- en: A URI string, such as *http://www.ebay.com* or *file://janespc/sharedpics/dolphin.jpg*
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: URI字符串，例如*http://www.ebay.com*或*file://janespc/sharedpics/dolphin.jpg*
- en: An absolute path to a file on your hard disk, such as *c:\myfiles\data.xlsx*
    or, on Unix, */tmp/myfiles/data.xlsx*
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 硬盘上文件的绝对路径，例如*c:\myfiles\data.xlsx*或在Unix上，*/tmp/myfiles/data.xlsx*
- en: A UNC path to a file on the LAN, such as *\\janespc\sharedpics\dolphin.jpg*
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: LAN上文件的UNC路径，例如*\\janespc\sharedpics\dolphin.jpg*
- en: 'File and UNC paths are automatically converted to URIs: the “file:” protocol
    is added, and backslashes are converted to forward slashes. The `Uri` constructors
    also perform some basic cleanup on your string before creating the `Uri`, including
    converting the scheme and hostname to lowercase and removing default and blank
    port numbers. If you supply a URI string without the scheme, such as *www.test.com*,
    a `UriFormatException` is thrown.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 文件和UNC路径会自动转换为URI：添加了“file:”协议，并将反斜杠转换为正斜杠。`Uri`构造函数还在创建`Uri`之前对您的字符串执行一些基本清理，包括将方案和主机名转换为小写，并删除默认和空白端口号。如果提供没有方案的URI字符串，例如*www.test.com*，则会引发`UriFormatException`。
- en: '`Uri` has an `IsLoopback` property, which indicates whether the `Uri` references
    the local host (IP address 127.0.0.1), and an `IsFile` property, which indicates
    whether the `Uri` references a local or UNC (`IsUnc`) path (`IsUnc` reports `false`
    for a *Samba* share mounted in a *Linux* filesystem). If `IsFile` returns `true`,
    the `LocalPath` property returns a version of `AbsolutePath` that is friendly
    to the local OS (with slashes or backslashes as appropriate to the OS), on which
    you can call `File.Open`.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`Uri`有一个`IsLoopback`属性，指示`Uri`是否引用本地主机（IP地址127.0.0.1），以及一个`IsFile`属性，指示`Uri`是否引用本地或UNC（`IsUnc`）路径（`IsUnc`对于在Linux文件系统中挂载的*Samba*共享返回`false`）。如果`IsFile`返回`true`，则`LocalPath`属性返回一个针对本地操作系统友好的`AbsolutePath`版本（适当地使用斜杠或反斜杠），您可以在其上调用`File.Open`。'
- en: Instances of `Uri` have read-only properties. To modify an existing `Uri`, instantiate
    a `UriBuilder` object—this has writable properties and can be converted back via
    its `Uri` property.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`Uri`的实例具有只读属性。要修改现有的`Uri`，请实例化一个`UriBuilder`对象—它具有可写属性，并可以通过其`Uri`属性转换回来。'
- en: '`Uri` also provides methods for comparing and subtracting paths:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`Uri`还提供了比较和减去路径的方法：'
- en: '[PRE2]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'A relative `Uri`, such as *page.html* in this example, will throw an exception
    if you call almost any property or method other than `IsAbsoluteUri` and `ToString()`.
    You can directly instantiate a relative `Uri`, as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 相对`Uri`，例如本示例中的*page.html*，如果调用除`IsAbsoluteUri`和`ToString()`之外的任何属性或方法，将抛出异常。您可以直接实例化相对`Uri`，如下所示：
- en: '[PRE3]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Warning
  id: totrans-68
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: A trailing slash is significant in a URI and makes a difference as to how a
    server processes a request if a path component is present.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: URI中的尾部斜杠对于服务器如何处理请求（如果存在路径组件）具有重要意义。
- en: In a traditional web server, for instance, given the URI *http://www.albahari.com/nutshell/*,
    you can expect an HTTP web server to look in the *nutshell* subdirectory in the
    site’s web folder and return the default document (usually *index.html*).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在传统的Web服务器中，例如给定URI *http://www.albahari.com/nutshell/*，您可以期望HTTP Web服务器查找站点Web文件夹中的*nutshell*子目录，并返回默认文档（通常是*index.html*）。
- en: Without the trailing slash, the web server will instead look for a file called
    *nutshell* (without an extension) directly in the site’s root folder—which is
    usually not what you want. If no such file exists, most web servers will assume
    the user mistyped and will return a 301 *Permanent Redirect* error, suggesting
    the client retry with the trailing slash. A .NET HTTP client, by default, will
    respond transparently to a 301 in the same way as a web browser—by retrying with
    the suggested URI. This means that if you omit a trailing slash when it should
    have been included, your request will still work—but will suffer an unnecessary
    extra round trip.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有尾部斜杠，Web服务器将会查找站点根目录中名为*nutshell*（没有扩展名）的文件——这通常不是您想要的。如果不存在这样的文件，大多数Web服务器会假定用户输入错误，并返回301
    *永久重定向*错误，建议客户端使用带有尾部斜杠的URI重试。默认情况下，.NET HTTP客户端将以与Web浏览器相同的方式透明地响应301，重新尝试建议的URI。这意味着如果您在应包含尾部斜杠的地方省略了它，您的请求仍将起作用，但会增加不必要的额外往返。
- en: The `Uri` class also provides static helper methods such as `EscapeUriString()`,
    which converts a string to a valid URL by converting all characters with an ASCII
    value greater than 127 to hexadecimal representation. The `CheckHostName()` and
    `CheckSchemeName()` methods accept a string and check whether it is syntactically
    valid for the given property (although they do not attempt to determine whether
    a host or URI exists).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`Uri`类还提供了静态帮助方法，例如`EscapeUriString()`，它将字符串转换为有效的URL，将所有ASCII值大于127的字符转换为十六进制表示。`CheckHostName()`和`CheckSchemeName()`方法接受一个字符串，并检查其在给定属性上是否语法有效（尽管它们不试图确定主机或URI是否存在）。'
- en: HttpClient
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`HttpClient`'
- en: The `HttpClient` class exposes a modern API for HTTP client operations, replacing
    the old `WebClient` and `WebRequest`/`WebResponse` types (which have since been
    marked as obsolete).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`HttpClient`类提供了现代API，用于HTTP客户端操作，替代了旧的`WebClient`和`WebRequest`/`WebResponse`类型（这些类型已被标记为过时）。'
- en: '`HttpClient` was written in response to the growth of HTTP-based web APIs and
    REST services, and provides a good experience when dealing with protocols more
    elaborate than simply fetching a web page. In particular:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`HttpClient`是为应对基于HTTP的Web API和REST服务的增长而编写的，并且在处理比简单获取Web页面更复杂的协议时提供了良好的体验。特别是：'
- en: A single `HttpClient` instance can handle concurrent requests and plays well
    with features such as custom headers, cookies, and authentication schemes.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单个`HttpClient`实例可以处理并发请求，并与自定义头部、cookie和认证方案等功能良好配合。
- en: '`HttpClient` lets you write and plug in custom message handlers. This enables
    mocking in unit tests, and the creation of custom pipelines (for logging, compression,
    encryption, and so on).'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HttpClient`允许您编写和插入自定义消息处理程序。这使得在单元测试中进行模拟成为可能，并创建自定义管道（用于日志记录、压缩、加密等）。'
- en: '`HttpClient` has a rich and extensible type system for headers and content.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HttpClient`具有丰富且可扩展的类型系统，用于处理头部和内容。'
- en: Note
  id: totrans-79
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: '`HttpClient` does not support progress reporting. For a solution, see “HttpClient
    with Progress.linq” at [*http://www.albahari.com/nutshell/code.aspx*](http://www.albahari.com/nutshell/code.aspx)
    or via LINQPad’s interactive samples gallery.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`HttpClient`不支持进度报告。要解决此问题，请参阅[*http://www.albahari.com/nutshell/code.aspx*](http://www.albahari.com/nutshell/code.aspx)上的“使用Progress.linq的HttpClient”或通过LINQPad的交互式样本库。'
- en: 'The simplest way to use `HttpClient` is to instantiate it and then call one
    of its `Get*` methods, passing in a URI:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`HttpClient`的最简单方法是实例化它，然后调用其`Get*`方法之一，传入一个URI：
- en: '[PRE4]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: (There’s also `GetByteArrayAsync` and `GetStreamAsync`.) All I/O-bound methods
    in `HttpClient` are asynchronous.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: （还有`GetByteArrayAsync`和`GetStreamAsync`。）`HttpClient`中所有的I/O绑定方法都是异步的。
- en: 'Unlike its `WebRequest`/`WebResponse` predecessors, to get the best performance
    with `HttpClient`, you *must* reuse the same instance (otherwise things such as
    DNS resolution can be unnecessarily repeated and sockets are held open longer
    than necessary). `HttpClient` permits concurrent operations, so the following
    is legal and downloads two web pages at once:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 与其`WebRequest`/`WebResponse`前身不同，为了获得最佳性能，您*必须*重用同一个`HttpClient`实例（否则诸如DNS解析可能会被不必要地重复，并且套接字会比必要时更长时间保持打开状态）。`HttpClient`允许并发操作，因此以下操作是合法的，并同时下载两个网页：
- en: '[PRE5]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '`HttpClient` has a `Timeout` property and a `BaseAddress` property, which prefixes
    a URI to every request. `HttpClient` is somewhat of a thin shell: most of the
    other properties that you might expect to find here are defined in another class
    called `HttpClientHandler`. To access this class, you instantiate it and then
    pass the instance into `HttpClient`’s constructor:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`HttpClient` 有一个 `Timeout` 属性和一个 `BaseAddress` 属性，该属性会将 URI 前缀添加到每个请求中。`HttpClient`
    在某种程度上是一个薄壳：您可能希望在此处找到的大多数其他属性都在另一个名为 `HttpClientHandler` 的类中定义。要访问此类，您首先实例化它，然后将实例传递给
    `HttpClient` 的构造函数：'
- en: '[PRE6]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In this example, we told the handler to disable proxy support, which can sometimes
    improve performance by avoiding the cost of automatic proxy detection. There are
    also properties to control cookies, automatic redirection, authentication, and
    so on (we describe these in the following sections).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，我们告诉处理程序禁用代理支持，有时可以通过避免自动代理检测的成本来提高性能。还有控制 cookie、自动重定向、身份验证等属性（我们将在下面的部分描述这些属性）。
- en: GetAsync and Response Messages
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`GetAsync` 和 响应消息'
- en: 'The `GetStringAsync`, `GetByteArrayAsync`, and `GetStreamAsync` methods are
    convenient shortcuts for calling the more general `GetAsync` method, which returns
    a *response message*:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetStringAsync`、`GetByteArrayAsync` 和 `GetStreamAsync` 方法是调用更通用的 `GetAsync`
    方法的便捷快捷方式，后者返回一个 *响应消息*：'
- en: '[PRE7]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '`HttpResponseMessage` exposes properties for accessing the headers (see [“Headers”](#headers))
    and the HTTP `StatusCode`. An unsuccessful status code such as 404 (not found)
    doesn’t cause an exception to be thrown unless you explicitly call `EnsureSuccessStatusCode`.
    Communication or DNS errors, however, do throw exceptions.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`HttpResponseMessage` 公开了用于访问标头（请参见 [“标头”](#headers)）和 HTTP `StatusCode` 的属性。不成功的状态代码（如
    404（未找到））不会引发异常，除非您显式调用 `EnsureSuccessStatusCode`。然而，通信或 DNS 错误确实会引发异常。'
- en: '`HttpContent` has a `CopyToAsync` method for writing to another stream, which
    is useful in writing the output to a file:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`HttpContent` 有一个 `CopyToAsync` 方法，用于将内容写入另一个流中，这在将输出写入文件时非常有用：'
- en: '[PRE8]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '`GetAsync` is one of four methods corresponding to HTTP’s four verbs (the others
    are `PostAsync`, `PutAsync`, and `DeleteAsync`). We demonstrate `PostAsync` later
    in [“Uploading Form Data”](#uploading_form_data).'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetAsync` 是对应 HTTP 的四个动词之一（其余分别是 `PostAsync`、`PutAsync` 和 `DeleteAsync`）。我们稍后在
    [“上传表单数据”](#uploading_form_data) 中演示 `PostAsync`。'
- en: SendAsync and Request Messages
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`SendAsync` 和 请求消息'
- en: '`GetAsync`, `PostAsync`, `PutAsync`, and `DeleteAsync` are all shortcuts for
    calling `Send​A⁠sync`, the single low-level method into which everything else
    feeds. To use this, you first construct an `HttpRequestMessage`:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetAsync`、`PostAsync`、`PutAsync` 和 `DeleteAsync` 都是调用 `Send​A⁠sync` 的快捷方式，这是单个低级方法，所有其他方法都依赖于此。要使用此方法，首先构造一个
    `HttpRequestMessage`：'
- en: '[PRE9]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Instantiating a `HttpRequestMessage` object means that you can customize properties
    of the request, such as the headers (see [“Headers”](#headers)) and the content
    itself, allowing you to upload data.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 实例化 `HttpRequestMessage` 对象意味着可以自定义请求的属性，如标头（请参见 [“标头”](#headers)）和内容本身，允许您上传数据。
- en: Uploading Data and HttpContent
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 上传数据和`HttpContent`
- en: 'After instantiating a `HttpRequestMessage` object, you can upload content by
    assigning its `Content` property. The type for this property is an abstract class
    called `HttpContent`. .NET includes the following concrete subclasses for different
    kinds of content (you can also write your own):'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在实例化 `HttpRequestMessage` 对象之后，可以通过分配其 `Content` 属性来上传内容。该属性的类型是名为 `HttpContent`
    的抽象类。.NET 包括以下用于不同内容类型的具体子类（您也可以编写自己的）：
- en: '`ByteArrayContent`'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ByteArrayContent`'
- en: '`StringContent`'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`StringContent`'
- en: '`FormUrlEncodedContent` (see [“Uploading Form Data”](#uploading_form_data))'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FormUrlEncodedContent`（参见 [“上传表单数据”](#uploading_form_data)）'
- en: '`StreamContent`'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`StreamContent`'
- en: 'For example:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE10]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: HttpMessageHandler
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`HttpMessageHandler`'
- en: 'We said previously that most of the properties for customizing requests are
    defined not in `HttpClient` but in `HttpClientHandler`. The latter is actually
    a subclass of the abstract `HttpMessageHandler` class, defined as follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们先前说过，大多数用于自定义请求的属性实际上不是在 `HttpClient` 中定义的，而是在 `HttpClientHandler` 中定义的。后者实际上是抽象类
    `HttpMessageHandler` 的子类，定义如下：
- en: '[PRE11]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `SendAsync` method is called from `HttpClient`’s `SendAsync` method.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`SendAsync` 方法是从 `HttpClient` 的 `SendAsync` 方法中调用的。'
- en: '`HttpMessageHandler` is simple enough to subclass easily and offers an extensibility
    point into `HttpClient`.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`HttpMessageHandler` 足够简单，易于子类化，并提供了对 `HttpClient` 的可扩展性入口。'
- en: Unit testing and mocking
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 单元测试和模拟
- en: 'We can subclass `HttpMessageHandler` to create a *mocking* handler to assist
    with unit testing:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过子类化`HttpMessageHandler`创建一个*模拟*处理程序来辅助单元测试：
- en: '[PRE12]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Its constructor accepts a function that tells the mocker how to generate a response
    from a request. This is the most versatile approach because the same handler can
    test multiple requests.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 其构造函数接受一个函数，告诉模拟器如何从请求生成响应。这是最灵活的方法，因为同一个处理程序可以测试多个请求。
- en: '`SendAsync` is synchronous by virtue of `Task.FromResult`. We could have maintained
    asynchrony by having our response generator return a `Task<HttpResponseMessage>`,
    but this is pointless given that we can expect a mocking function to be short
    running. Here’s how to use our mocking handler:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`Task.FromResult`，`SendAsync`是同步的。我们本可以通过使我们的响应生成器返回`Task<HttpResponseMessage>`来保持异步，但考虑到我们可以预期模拟函数的执行时间很短，这是毫无意义的。以下是如何使用我们的模拟处理器：
- en: '[PRE13]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: (`Assert.AreEqual` is a method you’d expect to find in a unit-testing framework
    such as NUnit.)
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: （`Assert.AreEqual`是你会在诸如NUnit之类的单元测试框架中找到的方法。）
- en: Chaining handlers with DelegatingHandler
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用DelegatingHandler链接处理程序
- en: 'You can create a message handler that calls another (resulting in a chain of
    handlers) by subclassing `DelegatingHandler`. You can use this to implement custom
    authentication, compression, and encryption protocols. The following demonstrates
    a simple logging handler:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过子类化`DelegatingHandler`创建调用另一个处理程序的消息处理程序（从而形成处理程序链）。您可以使用此方法来实现自定义认证、压缩和加密协议。以下是一个简单日志处理程序的示例：
- en: '[PRE14]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Notice that we’ve maintained asynchrony in overriding `SendAsync`. Introducing
    the `async` modifier when overriding a task-returning method is perfectly legal—and
    desirable in this case.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们在覆盖`SendAsync`时保持了异步性。在覆盖返回任务的方法时引入`async`修饰符是完全合法的，而且在这种情况下是可取的。
- en: A better solution than writing to the `Console` would be to have the constructor
    accept some kind of logging object. Better still would be to accept a couple of
    `Action<T>` delegates that tell it how to log the request and response objects.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 比直接写入`Console`更好的解决方案是让构造函数接受某种日志对象。更好的做法是接受一对`Action<T>`委托，告诉它如何记录请求和响应对象。
- en: Proxies
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代理
- en: A *proxy server* is an intermediary through which HTTP requests can be routed.
    Organizations sometimes set up a proxy server as the only means by which employees
    can access the internet—primarily because it simplifies security. A proxy has
    an address of its own and can demand authentication so that only selected users
    on the LAN can access the internet.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '*代理服务器*是一个中介，通过它可以路由HTTP请求。有时组织会设置代理服务器作为员工访问互联网的唯一途径，主要是因为它简化了安全性。代理有自己的地址，并且可以要求身份验证，以便只有局域网上的选定用户可以访问互联网。'
- en: 'To use a proxy with `HttpClient`, first create an `HttpClientHandler` and assign
    its `Proxy` property and then feed that into `HttpClient`’s constructor:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用`HttpClient`与代理，首先创建一个`HttpClientHandler`并分配其`Proxy`属性，然后将其传递给`HttpClient`的构造函数：
- en: '[PRE15]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '`HttpClientHandler` also has a `UseProxy` property that you can assign to false
    instead of nulling out the `Proxy` property to defeat autodetection.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`HttpClientHandler`还有一个`UseProxy`属性，您可以将其赋值为false，而不是将`Proxy`属性置空以避免自动检测。'
- en: If you supply a domain when constructing the `NetworkCredential`, Windows-based
    authentication protocols are used. To use the currently authenticated Windows
    user, assign the static `CredentialCache.DefaultNetworkCredentials` value to the
    proxy’s `Credentials` property.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 当构建`NetworkCredential`时，如果提供了一个域名，将使用基于Windows的认证协议。要使用当前认证的Windows用户，请将静态值`CredentialCache.DefaultNetworkCredentials`分配给代理的`Credentials`属性。
- en: 'As an alternative to repeatedly setting the `Proxy`, you can set the global
    default as follows:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 作为重复设置`Proxy`的替代方案，您可以如下设置全局默认值：
- en: '[PRE16]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Authentication
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 认证
- en: 'You can supply a username and password to an `HttpClient` as follows:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过以下方式向`HttpClient`提供用户名和密码：
- en: '[PRE17]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This works with dialog-based authentication protocols, such as Basic and Digest,
    and is extensible through the `AuthenticationManager` class. It also supports
    Windows NTLM and Kerberos (if you include a domain name when constructing the
    `NetworkCredential` object). If you want to use the currently authenticated Windows
    user, you can leave the `Credentials` property `null` and instead set `Use​De⁠faultCredentials`
    to `true`.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这适用于基于对话框的认证协议，如基本和摘要，并且可以通过`AuthenticationManager`类进行扩展。它还支持Windows NTLM和Kerberos（如果在构建`NetworkCredential`对象时包括域名）。如果要使用当前认证的Windows用户，可以将`Credentials`属性留空，而是将`Use​De⁠faultCredentials`设置为`true`。
- en: 'When you provide credentials, `HttpClient` automatically negotiates a compatible
    protocol. In some cases, there can be a choice: if you examine the initial response
    from a Microsoft Exchange server web mail page, for instance, it might contain
    the following headers:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 当您提供凭据时，`HttpClient`会自动协商兼容的协议。在某些情况下，可能会有选择：例如，如果您检查来自Microsoft Exchange服务器Web邮件页面的初始响应，则可能包含以下标头：
- en: '[PRE18]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The 401 code signals that authorization is required; the “WWW-Authenticate”
    headers indicate what authentication protocols are understood. If you configure
    the `HttpClientHandler` with the correct username and password, however, this
    message will be hidden from you because the runtime responds automatically by
    choosing a compatible authentication protocol, and then resubmitting the original
    request with an extra header. Here’s an example:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 401代码表示需要授权；“WWW-Authenticate”标头指示理解的身份验证协议。然而，如果您配置了`HttpClientHandler`正确的用户名和密码，此消息将对您隐藏，因为运行时会自动选择兼容的身份验证协议，然后重新提交带有额外标头的原始请求。以下是一个示例：
- en: '[PRE19]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This mechanism provides transparency, but generates an extra round trip with
    each request. You can avoid the extra round trips on subsequent requests to the
    same URI by setting the `PreAuthenticate` property on the `HttpClientHandler`
    to `true`.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 此机制提供透明性，但每个请求都会生成一个额外的往返。您可以通过将`HttpClientHandler`的`PreAuthenticate`属性设置为`true`，来避免对同一URI的后续请求中产生额外的往返。
- en: CredentialCache
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: CredentialCache
- en: 'You can force a particular authentication protocol with a `CredentialCache`
    object. A credential cache contains one or more `NetworkCredential` objects, each
    keyed to a particular protocol and URI prefix. For example, you might want to
    avoid the Basic protocol when logging into an Exchange Server because it transmits
    passwords in plain text:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`CredentialCache`对象强制指定特定的身份验证协议。凭据缓存包含一个或多个`NetworkCredential`对象，每个对象都与特定的协议和URI前缀相关联。例如，当登录到Exchange
    Server时，您可能希望避免基本协议，因为它会以明文传输密码：
- en: '[PRE20]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'An authentication protocol is specified as a string. The valid values include:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 身份验证协议被指定为一个字符串。有效的值包括：
- en: '[PRE21]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In this particular situation it will choose `Negotiate`, because the server
    didn’t indicate that it supported `Digest` in its authentication headers. `Negotiate`
    is a Windows protocol that currently boils down to either Kerberos or NTLM, depending
    on the capabilities of the server, but ensures forward compatibility of your application
    when future security standards are deployed.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种特定情况下，它将选择`Negotiate`，因为服务器未指示其在身份验证标头中支持`Digest`。`Negotiate`是一种Windows协议，目前归结为Kerberos或NTLM，取决于服务器的能力，但确保在部署未来安全标准时应用程序具备前向兼容性。
- en: 'The static `CredentialCache.DefaultNetworkCredentials` property allows you
    to add the currently authenticated Windows user to the credential cache without
    having to specify a password:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 静态的`CredentialCache.DefaultNetworkCredentials`属性允许您将当前经过身份验证的Windows用户添加到凭据缓存，而无需指定密码：
- en: '[PRE22]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Authenticating via headers
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过标头进行身份验证
- en: 'Another way to authenticate is to set the authentication header directly:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种身份验证方式是直接设置身份验证标头：
- en: '[PRE23]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This strategy also works with custom authentication systems such as OAuth.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这种策略也适用于OAuth等自定义身份验证系统。
- en: Headers
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 标头
- en: '`HttpClient` lets you add custom HTTP headers to a request, as well as enumerate
    the headers in a response. A header is simply a key/value pair containing metadata,
    such as the message content type or server software. `HttpClient` exposes strongly
    typed collections with properties for standard HTTP headers. The `DefaultReques⁠t​Headers`
    property is for headers that apply to every request:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`HttpClient`允许您向请求添加自定义的HTTP标头，并枚举响应中的标头。标头简单地是包含元数据的键/值对，例如消息内容类型或服务器软件。`HttpClient`暴露了具有标准HTTP标头属性的强类型集合。`DefaultReques⁠t​Headers`属性适用于每个请求的标头：'
- en: '[PRE24]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The `Headers` property on the `HttpRequestMessage` class, however, is for headers
    specific to a request.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，`HttpRequestMessage`类上的`Headers`属性是特定于请求的标头。
- en: Query Strings
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查询字符串
- en: 'A query string is simply a string appended to a URI with a question mark, used
    to send simple data to the server. You can specify multiple key/value pairs in
    a query string with the following syntax:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 查询字符串只是附加到URI的字符串，带有问号，用于将简单数据发送到服务器。您可以使用以下语法在查询字符串中指定多个键/值对：
- en: '[PRE25]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Here’s a URI with a query string:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个带有查询字符串的URI：
- en: '[PRE26]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'If there’s a possibility of your query including symbols or spaces, you can
    use `Uri`’s `EscapeDataString` method to create a legal URI:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的查询可能包含符号或空格，请使用`Uri`的`EscapeDataString`方法创建合法的URI：
- en: '[PRE27]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This resultant URI is:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 此生成的URI为：
- en: '[PRE28]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: (`EscapeDataString` is similar to `EscapeUriString` except that it also encodes
    characters such as `&` and `=`, which would otherwise mess up the query string.)
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: (`EscapeDataString`类似于`EscapeUriString`，但还会对`&`和`=`等字符进行编码，否则会破坏查询字符串。)
- en: Uploading Form Data
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 上传表单数据
- en: 'To upload HTML form data, create and populate the `FormUrlEncodedContent` object.
    You can then either pass it into the `PostAsync` method or assign it to a request’s
    `Content` property:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 要上传HTML表单数据，请创建并填充`FormUrlEncodedContent`对象。然后，可以将其传递给`PostAsync`方法或分配给请求的`Content`属性：
- en: '[PRE29]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Cookies
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Cookie
- en: A cookie is a name/value string pair that an HTTP server sends to a client in
    a response header. A web browser client typically remembers cookies and replays
    them to the server in each subsequent request (to the same address) until their
    expiry. A cookie allows a server to know whether it’s talking to the same client
    it was a minute ago—or yesterday—without needing a messy query string in the URI.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: Cookie是HTTP服务器在响应标头中发送给客户端的名称/值字符串对。Web浏览器客户端通常会记住cookie，并在每个后续请求（到同一地址）中向服务器重放它们，直到它们过期。Cookie允许服务器知道它是否在与一分钟前或昨天的同一客户端交谈，而无需在URI中使用混乱的查询字符串。
- en: 'By default, `HttpClient` ignores any cookies received from the server. To accept
    cookies, create a `CookieContainer` object and assign it an `HttpClientHandler`:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`HttpClient`会忽略从服务器收到的任何cookie。要接受cookie，请创建一个`CookieContainer`对象，并将其分配给`HttpClientHandler`：
- en: '[PRE30]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'To replay the received cookies in future requests, simply use the same `CookieContainer`
    object again. Alternatively, you can start with a fresh `CookieContainer` and
    then add cookies manually, as follows:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 要在将来的请求中重放接收到的cookie，只需再次使用相同的`CookieContainer`对象。或者，您可以从头开始使用新的`CookieContainer`，然后手动添加cookie，如下所示：
- en: '[PRE31]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The third and fourth arguments indicate the path and domain of the originator.
    A `CookieContainer` on the client can house cookies from many different places;
    `HttpClient` sends only those cookies whose path and domain match those of the
    server.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 第三和第四个参数表示发起者的路径和域。客户端上的`CookieContainer`可以存储来自许多不同位置的cookie；`HttpClient`仅发送路径和域与服务器匹配的cookie。
- en: Writing an HTTP Server
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写HTTP服务器
- en: Note
  id: totrans-179
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'If you need to write an HTTP server, an alternative higher-level approach (from
    .NET 6) is to use the ASP.NET minimal API. Here’s all it takes to get started:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要编写一个HTTP服务器，从.NET 6开始，使用ASP.NET最小API是一种替代的更高级方法。以下是入门所需的全部步骤：
- en: '[PRE32]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'You can write your own .NET HTTP server with the `HttpListener` class. The
    following is a simple server that listens on port 51111, waits for a single client
    request, and then returns a one-line reply:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`HttpListener`类编写自己的.NET HTTP服务器。以下是一个简单的服务器示例，监听端口51111，等待单个客户端请求，然后返回一行回复：
- en: '[PRE33]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: On Windows, `HttpListener` does not internally use .NET `Socket` objects; it
    instead calls the Windows HTTP Server API. This allows many applications on a
    computer to listen on the same IP address and port—as long as each registers different
    address prefixes. In our example, we registered the prefix *http://localhost/myapp*,
    so another application would be free to listen on the same IP and port on another
    prefix such as *http://localhost/anotherapp*. This is of value because opening
    new ports on corporate firewalls can be politically arduous.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows上，`HttpListener`不会内部使用.NET `Socket`对象；它会调用Windows HTTP服务器API。这允许计算机上的许多应用程序监听相同的IP地址和端口，只要每个应用程序注册不同的地址前缀即可。在我们的示例中，我们注册了前缀*http://localhost/myapp*，因此另一个应用程序可以在另一个前缀*http://localhost/anotherapp*上自由监听相同的IP和端口。这很重要，因为在企业防火墙上打开新端口可能会很复杂。
- en: '`HttpListener` waits for the next client request when you call `GetContext`,
    returning an object with `Request` and `Response` properties. Each is analogous
    to client request or response, but from the server’s perspective. You can read
    and write headers and cookies, for instance, to the request and response objects,
    much as you would at the client end.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 当您调用`GetContext`时，`HttpListener`会等待下一个客户端请求，并返回一个具有`Request`和`Response`属性的对象。每个属性从服务器的角度看类似于客户端请求或响应。例如，您可以读取和写入请求和响应对象的头和cookie，就像在客户端端一样。
- en: You can choose how fully to support features of the HTTP protocol, based on
    your anticipated client audience. At a bare minimum, you should set the content
    length and status code on each request.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以根据预期的客户端受众选择如何完全支持HTTP协议的功能。至少，你应该在每个请求上设置内容长度和状态码。
- en: 'Here’s a very simple web page server, written *asynchronously*:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常简单的异步编写的网页服务器：
- en: '[PRE34]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The following code sets things in motion:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码启动了一切：
- en: '[PRE35]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: You can test this at the client end with any web browser; the URI in this case
    will be *http://localhost:51111/* plus the name of the web page.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用任何Web浏览器在客户端端测试此功能；在这种情况下，URI将是*http://localhost:51111/*加上网页的名称。
- en: Warning
  id: totrans-192
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: '`HttpListener` will not start if other software is competing for the same port
    (unless that software also uses the Windows HTTP Server API). Examples of applications
    that might listen on the default port 80 include a web server or a peer-to-peer
    program such as Skype.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 如果其他软件竞争使用相同的端口，`HttpListener`将无法启动（除非该软件也使用Windows HTTP服务器API）。可能监听默认端口80的应用程序包括Web服务器或对等程序（如Skype）。
- en: 'Our use of asynchronous functions makes this server scalable and efficient.
    Starting this from a user interface (UI) thread, however, would hinder scalability
    because for each *request*, execution would bounce back to the UI thread after
    each `await`. Incurring such overhead is particularly pointless given that we
    don’t have shared state, so in a UI scenario we’d get off the UI thread, either
    like this:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用异步函数使得该服务器具有可伸缩性和效率。然而，从用户界面（UI）线程启动会阻碍可伸缩性，因为每个*请求*在每个`await`后会回到UI线程。考虑到我们没有共享状态，产生这样的开销特别是没有意义的，在UI场景下我们应该离开UI线程，像这样：
- en: '[PRE36]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: or by calling `ConfigureAwait(false)` after calling `GetContextAsync`.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 或在调用`GetContextAsync`之后调用`ConfigureAwait(false)`。
- en: Note that we used `Task.Run` to call `ProcessRequestAsync` even though the method
    was already asynchronous. This allows the caller to process another request *immediately*
    rather than having to first wait out the synchronous phase of the method (up until
    the first `await`).
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们使用`Task.Run`调用`ProcessRequestAsync`，即使该方法已经是异步的。这允许调用者*立即*处理另一个请求，而不必首先等待方法的同步阶段（直到第一个`await`）。
- en: Using DNS
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用DNS
- en: The static `Dns` class encapsulates the DNS, which converts between a raw IP
    address, such as 66.135.192.87, and a human-friendly domain name, such as *ebay.com*.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 静态的`Dns`类封装了DNS，它在原始IP地址（例如66.135.192.87）与人类友好的域名（例如*ebay.com*）之间进行转换。
- en: 'The `GetHostAddresses` method converts from domain name to IP address (or addresses):'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetHostAddresses`方法从域名转换为IP地址（或多个地址）：'
- en: '[PRE37]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The `GetHostEntry` method goes the other way around, converting from address
    to domain name:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetHostEntry`方法反向操作，从地址转换为域名：'
- en: '[PRE38]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '`GetHostEntry` also accepts an `IPAddress` object, so you can specify an IP
    address as a byte array:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetHostEntry`还接受`IPAddress`对象，因此可以指定IP地址为字节数组：'
- en: '[PRE39]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Domain names are automatically resolved to IP addresses when you use a class
    such as `WebRequest` or `TcpClient`. However, if you plan to make many network
    requests to the same address over the life of an application, you can sometimes
    improve performance by first using `Dns` to explicitly convert the domain name
    into an IP address, and then communicating directly with the IP address from that
    point on. This avoids repeated round-tripping to resolve the same domain name,
    and it can be of benefit when dealing at the transport layer (via `TcpClient`,
    `UdpClient`, or `Socket`).
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用类似`WebRequest`或`TcpClient`的类时，域名会自动解析为IP地址。但是，如果您计划在应用程序的生命周期内对同一地址进行多次网络请求，有时通过首先使用`Dns`显式将域名转换为IP地址，然后直接与该IP地址通信，可以提高性能。这避免了重复的往返来解析相同的域名，并且在处理传输层（通过`TcpClient`，`UdpClient`或`Socket`）时可能会有所好处。
- en: 'The DNS class also provides awaitable task-based asynchronous methods:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: DNS类还提供了可等待的基于任务的异步方法：
- en: '[PRE40]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Sending Mail with SmtpClient
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用SmtpClient发送邮件
- en: 'The `SmtpClient` class in the `System.Net.Mail` namespace allows you to send
    mail messages through the ubiquitous Simple Mail Transfer Protocol, or SMTP. To
    send a simple text message, instantiate `SmtpClient`, set its `Host` property
    to your SMTP server address, and then call `Send`:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '`System.Net.Mail`命名空间中的`SmtpClient`类允许您通过普遍存在的简单邮件传输协议（SMTP）发送邮件消息。要发送简单文本消息，请实例化`SmtpClient`，将其`Host`属性设置为您的SMTP服务器地址，然后调用`Send`：'
- en: '[PRE41]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Constructing a `MailMessage` object exposes further options, including the
    ability to add attachments:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 构造`MailMessage`对象还提供了进一步的选项，包括添加附件的能力：
- en: '[PRE42]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'To frustrate spammers, most SMTP servers on the internet will accept connections
    only from authenticated connections and require communication over SSL:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 为了阻止垃圾邮件发送者，大多数互联网上的SMTP服务器只接受来自经过身份验证的连接，并要求通过SSL进行通信：
- en: '[PRE43]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'By changing the `DeliveryMethod` property, you can instruct the `SmtpClient`
    to instead use IIS to send mail messages or simply to write each message to an
    *.eml* file in a specified directory. This can be useful during development:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 通过更改`DeliveryMethod`属性，您可以指示`SmtpClient`改用IIS发送邮件消息，或者仅将每条消息写入指定目录中的*.eml*文件。这在开发过程中可能会很有用：
- en: '[PRE44]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Using TCP
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用TCP
- en: TCP and UDP constitute the transport layer protocols on top of which most internet—and
    LAN—services are built. HTTP (version 2 and below), FTP, and SMTP use TCP; DNS
    and HTTP version 3 use UDP. TCP is connection-oriented and includes reliability
    mechanisms; UDP is connectionless, has a lower overhead, and supports broadcasting.
    *BitTorrent* uses UDP, as does Voice over IP (VoIP).
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: TCP和UDP构成了大多数互联网和局域网服务构建在其上的传输层协议。HTTP（版本2及以下）、FTP和SMTP使用TCP；DNS和HTTP版本3使用UDP。TCP是面向连接的，并包含可靠性机制；UDP是无连接的，具有较低的开销，并支持广播。*BitTorrent*使用UDP，VoIP（语音IP）也是如此。
- en: The transport layer offers greater flexibility—and potentially improved performance—over
    the higher layers, but it requires that you handle such tasks as authentication
    and encryption yourself.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 传输层提供了比较高层更大的灵活性和潜在的性能提升，但要求您自己处理诸如认证和加密等任务。
- en: With TCP in .NET, you have a choice of either the easier-to-use `TcpClient`
    and `TcpListener` façade classes, or the feature-rich `Socket` class. (In fact,
    you can mix and match, because `TcpClient` exposes the underlying `Socket` object
    through the `Client` property.) The `Socket` class exposes more configuration
    options and allows direct access to the network layer (IP) and non-internet-based
    protocols such as Novell’s SPX/IPX.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在.NET中使用TCP时，您可以选择更易于使用的`TcpClient`和`TcpListener`外观类，或者功能丰富的`Socket`类。（事实上，您可以混合使用，因为`TcpClient`通过`Client`属性公开了底层的`Socket`对象。）`Socket`类公开了更多的配置选项，并允许直接访问网络层（IP）和非互联网协议，如Novell的SPX/IPX。
- en: 'As with other protocols, TCP differentiates a client and server: the client
    initiates a request, while the server waits for a request. Here’s the basic structure
    for a synchronous TCP client request:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他协议一样，TCP区分客户端和服务器：客户端发起请求，而服务器等待请求。这是同步TCP客户端请求的基本结构：
- en: '[PRE45]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '`TcpClient`’s `Connect` method blocks until a connection is established (`Connect​A⁠sync`
    is the asynchronous equivalent). The `NetworkStream` then provides a means of
    two-way communication, for both transmitting and receiving bytes of data from
    a server.'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '`TcpClient`的`Connect`方法会阻塞，直到建立连接（`Connect​A⁠sync`是异步等价方法）。然后，`NetworkStream`提供了一种方式进行双向通信，用于从服务器传输和接收字节数据。'
- en: 'A simple TCP server looks like this:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 简单的TCP服务器看起来像这样：
- en: '[PRE46]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '`TcpListener` requires the local IP address on which to listen (a computer
    with two network cards, for instance, can have two addresses). You can use `IPAddress.Any`
    to instruct it to listen on all (or the only) local IP addresses. `AcceptTcpClient`
    blocks until a client request is received (again, there’s also an asynchronous
    version), at which point we call `GetStream`, just as on the client side.'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '`TcpListener`需要本地IP地址来监听（例如，一台计算机有两张网络卡，可能有两个地址）。您可以使用`IPAddress.Any`指示它监听所有（或唯一的）本地IP地址。`AcceptTcpClient`会阻塞，直到收到客户端的请求（也有一个异步版本），此时我们调用`GetStream`，就像在客户端一样。'
- en: When working at the transport layer, you need to decide on a protocol for who
    talks when and for how long—rather like with a walkie-talkie. If both parties
    talk or listen at the same time, communication breaks down!
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在传输层工作时，您需要决定谁何时说话以及持续多长时间，有点像使用对讲机。如果双方同时说话或同时听取，通信就会中断！
- en: 'Let’s invent a protocol in which the client speaks first, saying “Hello,” and
    then the server responds by saying “Hello right back!” Here’s the code:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们发明一个协议，在这个协议中客户端首先说“Hello”，然后服务器回复“Hello right back!” 这是代码：
- en: '[PRE47]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: In this example, we’re using the `localhost` loopback to run the client and
    server on the same machine. We’ve arbitrarily chosen a port in the unallocated
    range (above 49152) and used a `BinaryWriter` and `BinaryReader` to encode the
    text messages. We’ve avoided closing or disposing the readers and writers in order
    to keep the underlying `NetworkStream` open until our conversation completes.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，我们使用 `localhost` 回环来在同一台机器上运行客户端和服务器。我们任意选择了一个未分配范围内的端口（大于49152），并使用 `BinaryWriter`
    和 `BinaryReader` 来编码文本消息。为了保持底层的 `NetworkStream` 在对话完成之前保持打开状态，我们避免关闭或释放读写器。
- en: '`BinaryReader` and `BinaryWriter` might seem like odd choices for reading and
    writing strings. However, they have a major advantage over `StreamReader` and
    `StreamWriter`: they prefix strings with an integer indicating the length, so
    a `BinaryReader` always knows exactly how many bytes to read. If you call `StreamReader.ReadToEnd`,
    you might block indefinitely—because a `NetworkStream` doesn’t have an end! As
    long as the connection is open, the network stream can never be sure that the
    client isn’t going to send more data.'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '`BinaryReader` 和 `BinaryWriter` 可能看起来是读写字符串的奇怪选择。然而，它们比 `StreamReader` 和 `StreamWriter`
    有一个重要优势：它们在字符串前面加上一个指示长度的整数，因此 `BinaryReader` 总是确切地知道要读取多少字节。如果调用 `StreamReader.ReadToEnd`，可能会无限期地阻塞，因为
    `NetworkStream` 没有结束！只要连接保持打开状态，网络流就无法确定客户端是否会发送更多数据。'
- en: Note
  id: totrans-233
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: '`StreamReader` is in fact completely out of bounds with `NetworkStream`, even
    if you plan only to call `ReadLine`. This is because `StreamReader` has a read-ahead
    buffer, which can result in it reading more bytes than are currently available,
    blocking indefinitely (or until the socket times out). Other streams such as `FileStream`
    don’t suffer this incompatibility with `StreamReader` because they have a definite
    *end*—at which point `Read` returns immediately with a value of `0`.'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '`StreamReader` 实际上与 `NetworkStream` 完全不兼容，即使你只计划调用 `ReadLine`。这是因为 `StreamReader`
    有一个预读缓冲区，可能会读取比当前可用的字节更多的字节，导致阻塞（或直到套接字超时）。其他流如 `FileStream` 与 `StreamReader`
    不会有这种不兼容性，因为它们有一个明确的*结束*—当 `Read` 到达结束时，立即返回值 `0`。'
- en: Concurrency with TCP
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: TCP 并发处理
- en: '`TcpClient` and `TcpListener` offer task-based asynchronous methods for scalable
    concurrency. Using these is simply a question of replacing blocking method calls
    with their `*Async` versions and awaiting the task that’s returned.'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '`TcpClient` 和 `TcpListener` 提供了基于任务的异步方法，用于可扩展的并发处理。使用它们只需将阻塞方法调用替换为它们的 `*Async`
    版本，并等待返回的任务。'
- en: 'In the following example, we write an asynchronous TCP server that accepts
    requests of 5,000 bytes in length, reverses the bytes, and then sends them back
    to the client:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们编写了一个异步 TCP 服务器，接受长度为 5,000 字节的请求，颠倒字节顺序，然后将其发送回客户端：
- en: '[PRE48]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Such a program is scalable in that it does not block a thread for the duration
    of a request. So, if 1,000 clients were to connect at once over a slow network
    connection (so that each request took several seconds from start to finish, for
    example), this program would not require 1,000 threads for that time (unlike with
    a synchronous solution). Instead, it leases threads only for the small periods
    of time required to execute code before and after the `await` expressions.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的程序具有可伸缩性，因为它不会在请求的整个持续时间内阻塞线程。因此，如果有 1,000 个客户端同时通过慢速网络连接连接（例如，每个请求从开始到结束需要几秒钟），这个程序不会在此期间需要
    1,000 个线程（不像同步解决方案）。相反，它只会在 `await` 表达式之前和之后短暂租用线程的时间。
- en: Receiving POP3 Mail with TCP
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 TCP 接收 POP3 邮件
- en: '.NET provides no application-layer support for POP3, so you need to write at
    the TCP layer in order to receive mail from a POP3 server. Fortunately, this is
    a simple protocol; a POP3 conversation goes like this:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 在应用层上不提供 POP3 的支持，因此你需要在 TCP 层编写代码来接收来自 POP3 服务器的邮件。幸运的是，这是一个简单的协议；POP3
    会话的过程如下：
- en: '| Client | Mail server | Notes |'
  id: totrans-242
  prefs: []
  type: TYPE_TB
  zh: '| 客户端 | 邮件服务器 | 备注 |'
- en: '| --- | --- | --- |'
  id: totrans-243
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| *Client connects...* | `+OK Hello there.` | Welcome message |'
  id: totrans-244
  prefs: []
  type: TYPE_TB
  zh: '| *客户端连接中...* | `+OK 你好。` | 欢迎消息 |'
- en: '| `USER joe` | `+OK Password required.` |  |'
  id: totrans-245
  prefs: []
  type: TYPE_TB
  zh: '| `USER joe` | `+OK 需要密码。` |  |'
- en: '| `PASS password` | `+OK Logged in.` |  |'
  id: totrans-246
  prefs: []
  type: TYPE_TB
  zh: '| `PASS 密码` | `+OK 登录成功。` |  |'
- en: '| `LIST` | `+OK` `1 1876`'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '| `LIST` | `+OK` `1 1876`'
- en: '`2 5412`'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '`2 5412`'
- en: '`3 845`'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '`3 845`'
- en: '`.` | Lists the ID and file size of each message on the server |'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '`.` | 列出服务器上每个消息的 ID 和文件大小 |'
- en: '| `RETR 1` | `+OK 1876 octets` *Content of message #1...*'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '| `RETR 1` | `+OK 1876 字节` *消息 #1 的内容...*'
- en: '`.` | Retrieves the message with the specified ID |'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '`.` | 检索指定 ID 的消息 |'
- en: '| `DELE 1` | `+OK Deleted.` | Deletes a message from the server |'
  id: totrans-253
  prefs: []
  type: TYPE_TB
  zh: '| `DELE 1` | `+OK 已删除。` | 从服务器上删除一封消息 |'
- en: '| `QUIT` | `+OK Bye-bye.` |  |'
  id: totrans-254
  prefs: []
  type: TYPE_TB
  zh: '| `QUIT` | `+OK 再见。` |  |'
- en: 'Each command and response is terminated by a new line (CR + LF) except for
    the multiline `LIST` and `RETR` commands, which are terminated by a single dot
    on a separate line. Because we can’t use `StreamReader` with `NetworkStream`,
    we can start by writing a helper method to read a line of text in a nonbuffered
    fashion:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 每个命令和响应都以新行（CR + LF）终止，除了多行的 `LIST` 和 `RETR` 命令，它们以单独一行上的一个点终止。因为我们不能在 `NetworkStream`
    中使用 `StreamReader`，所以我们可以先编写一个帮助方法以非缓冲的方式读取一行文本：
- en: '[PRE49]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'We also need a helper method to send a command. Because we always expect to
    receive a response starting with `+OK`, we can read and validate the response
    at the same time:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要一个帮助方法来发送命令。因为我们总是期望收到以 `+OK` 开头的响应，所以我们可以同时读取和验证响应：
- en: '[PRE50]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'With these methods written, the job of retrieving mail is easy. We establish
    a TCP connection on port 110 (the default POP3 port) and then start talking to
    the server. In this example, we write each mail message to a randomly named file
    with an *.eml* extension, before deleting the message off the server:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些编写的方法，检索邮件的工作变得简单。我们在端口 110 上（默认的 POP3 端口）建立一个 TCP 连接，然后开始与服务器通信。在这个例子中，我们将每封邮件写入一个随机命名的带有
    *.eml* 扩展名的文件中，然后从服务器上删除该消息：
- en: '[PRE51]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Note
  id: totrans-261
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: You can find open source POP3 libraries on NuGet that provide support for protocol
    aspects such as authentication TLS/SSL connections, MIME parsing, and more.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 NuGet 上找到开源的 POP3 库，提供支持协议方面的功能，如身份验证 TLS/SSL 连接，MIME 解析等。
