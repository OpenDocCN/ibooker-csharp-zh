<html><head></head><body>
<div id="sbo-rt-content"><section data-pdf-bookmark="Chapter 14. Attributes" data-type="chapter" epub:type="chapter"><div class="chapter" id="ch_attributes">
<h1><span class="label">Chapter 14. </span>Attributes</h1>
<p><a data-primary="attributes" data-type="indexterm" id="ix_ch14-asciidoc0"/><a data-primary="attributes" data-secondary="defined" data-type="indexterm" id="idm45884793847920"/>In .NET, you can annotate components, types, and their members with <em>attributes</em>. <a data-primary="frameworks, attributes and" data-type="indexterm" id="idm45884793846496"/>An attribute’s purpose is to control or modify the behavior of a framework, a tool, the compiler, or the CLR. For example, in <a data-type="xref" href="ch01.xhtml#ch_introducing_csharp">Chapter 1</a>, I showed a class annotated with the <code>[TestClass]</code> attribute. This told a unit testing framework that the annotated class contains some tests to be run as part of a test suite.</p>
<p>Attributes are passive containers of information that do nothing on their own. To draw an analogy with the physical world, if you print out a shipping label containing an address and tracking information and attach it to a package, that label will not in itself cause the package to make its way to a destination. Such a label is useful only once the package is in the hands of a shipping company. When the company picks up your parcel, it’ll expect to find the label and will use it to work out how to route your package. So the label is important, but ultimately, its only job is to provide information that some system requires. .NET attributes work the same way—they have an effect only if something goes looking for them. Some attributes are handled by the CLR or the compiler, but these are in the minority. The majority of attributes are consumed by frameworks, libraries, tools (such as a unit test runner), or your own code.</p>
<section data-pdf-bookmark="Applying Attributes" data-type="sect1"><div class="sect1" id="applying_attributes">
<h1>Applying Attributes</h1>
<p><a data-primary="attributes" data-secondary="applying attributes" data-type="indexterm" id="ix_ch14-asciidoc1"/>To avoid having to introduce an extra set of concepts into the type system, .NET models attributes as instances of .NET types. To be used as an attribute, a type must derive from the <code>System.Attribute</code> class, but it can otherwise be entirely ordinary. To apply an attribute, you put the type’s name in square brackets, and this usually goes directly before the attribute’s target. (Since C# mostly ignores whitespace, attributes don’t have to be on a separate line, but that is the convention when the target is a type or a member.) <a data-type="xref" href="#attributes_in_a_unit_test_class">Example 14-1</a> shows some attributes from Microsoft’s test framework. I’ve applied one to the class to indicate that this contains tests I’d like to run, and I’ve also applied attributes to individual methods, telling the test framework which ones represent tests and which contain initialization code to be run before each test.</p>
<div data-type="example" id="attributes_in_a_unit_test_class">
<h5><span class="label">Example 14-1. </span>Attributes in a unit test class</h5>
<pre data-code-language="csharp" data-type="programlisting">
<code class="k">using</code> <code class="nn">Microsoft.VisualStudio.TestTools.UnitTesting</code><code class="p">;</code>

<code class="k">namespace</code> <code class="nn">ImageManagement.Tests</code><code class="p">;</code>

<strong><code class="na">[TestClass]</code></strong>
<code class="k">public</code> <code class="k">class</code> <code class="nc">WhenPropertiesRetrieved</code>
<code class="p">{</code>
    <code class="k">private</code> <code class="n">ImageMetadataReader</code><code class="p">?</code> <code class="n">_reader</code><code class="p">;</code>

    <strong><code class="na">[TestInitialize]</code></strong>
    <code class="k">public</code> <code class="k">void</code> <code class="nf">Initialize</code><code class="p">(</code><code class="p">)</code>
    <code class="p">{</code>
        <code class="n">_reader</code> <code class="p">=</code> <code class="k">new</code> <code class="n">ImageMetadataReader</code><code class="p">(</code><code class="n">TestFiles</code><code class="p">.</code><code class="n">GetImage</code><code class="p">(</code><code class="p">)</code><code class="p">)</code><code class="p">;</code>
    <code class="p">}</code>

    <strong><code class="na">[TestMethod]</code></strong>
    <code class="k">public</code> <code class="k">void</code> <code class="nf">ReportsCameraMaker</code><code class="p">(</code><code class="p">)</code>
    <code class="p">{</code>
        <code class="n">Assert</code><code class="p">.</code><code class="n">AreEqual</code><code class="p">(</code><code class="n">_reader</code><code class="p">!</code><code class="p">.</code><code class="n">CameraManufacturer</code><code class="p">,</code> <code class="s">"Fabrikam"</code><code class="p">)</code><code class="p">;</code>
    <code class="p">}</code>

    <strong><code class="na">[TestMethod]</code></strong>
    <code class="k">public</code> <code class="k">void</code> <code class="nf">ReportsCameraModel</code><code class="p">(</code><code class="p">)</code>
    <code class="p">{</code>
        <code class="n">Assert</code><code class="p">.</code><code class="n">AreEqual</code><code class="p">(</code><code class="n">_reader</code><code class="p">!</code><code class="p">.</code><code class="n">CameraModel</code><code class="p">,</code> <code class="s">"Fabrikam F450D"</code><code class="p">)</code><code class="p">;</code>
    <code class="p">}</code>
<code class="p">}</code></pre></div>
<p>If you look at the documentation for most attributes, you’ll find that their real name ends with <code>Attribute</code>. If there’s no class with the name you specify in the brackets, the C# compiler tries appending <code>Attribute</code>, so the <code>[TestClass]</code> attribute in <a data-type="xref" href="#attributes_in_a_unit_test_class">Example 14-1</a> refers to the <code>TestClassAttribute</code> class. If you really want to, you can spell the class name out in full—for example, <code>[TestClassAttribute]</code>—but it’s more common to use the shorter version.</p>
<p>If you want to apply multiple attributes, you have two options. You can either provide multiple sets of brackets or put multiple attributes inside a single pair of brackets, separated by commas.</p>
<p>Some attribute types can take constructor arguments. For example, Microsoft’s test framework includes a <code>TestCategoryAttribute</code>. When running tests, you can choose to execute only those in a certain category. This attribute requires you to pass the 
<span class="keep-together">category</span> name as a constructor argument, because there would be no point in applying this attribute without specifying the name. As <a data-type="xref" href="#attribute_with_constructor_argument">Example 14-2</a> shows, the syntax for specifying an attribute’s constructor arguments is unsurprising.</p>
<div data-type="example" id="attribute_with_constructor_argument">
<h5><span class="label">Example 14-2. </span>Attribute with constructor argument</h5>
<pre data-code-language="csharp" data-type="programlisting">
<strong><code class="na">[TestCategory("Property Handling")]</code></strong>
<code class="na">[TestMethod]</code>
<code class="k">public</code> <code class="k">void</code> <code class="nf">ReportsCameraMaker</code><code class="p">(</code><code class="p">)</code>
<code class="p">{</code>
    <code class="p">.</code><code class="p">.</code><code class="p">.</code></pre></div>
<p>You can also specify property or field values. Some attributes have features that can be controlled only through properties or fields, and not constructor arguments. (If an attribute has lots of optional settings, it’s usually easier to present these as properties or fields, instead of defining a constructor overload for every conceivable combination of settings.) The syntax for this is to write one or more <code><em>PropertyOrFieldName</em>=<em>Value</em></code> entries after the constructor arguments (or instead of them, if there are no constructor arguments). <a data-type="xref" href="#optional_attribute_settings_with_props">Example 14-3</a> shows another attribute used in unit testing, <code>ExpectedExceptionAttribute</code>, which allows you to specify that when your test runs, you expect it to throw a particular exception. The exception type is mandatory, so we pass that as a constructor argument, but this attribute also allows you to state whether the test runner should accept exceptions of a type derived from the one specified. (By default, it will accept only an exact match.) This is controlled with the <code>AllowDerivedTypes</code> property.</p>
<div data-type="example" id="optional_attribute_settings_with_props">
<h5><span class="label">Example 14-3. </span>Specifying optional attribute settings with properties</h5>
<pre data-code-language="csharp" data-type="programlisting">
<strong><code class="na">[ExpectedException(typeof(ArgumentException), AllowDerivedTypes = true)]</code></strong>
<code class="na">[TestMethod]</code>
<code class="k">public</code> <code class="k">void</code> <code class="nf">ThrowsWhenNameMalformed</code><code class="p">(</code><code class="p">)</code>
<code class="p">{</code>
    <code class="p">.</code><code class="p">.</code><code class="p">.</code></pre></div>
<p>Applying an attribute will not cause it to be constructed. All you are doing when you apply an attribute is providing instructions on how the attribute should be created and initialized if something should ask to see it. (There is a common misconception that method attributes are instantiated when the method runs. Not so.) When the compiler builds the metadata for an assembly, it includes information about which attributes have been applied to which items, including a list of constructor arguments and property values, and the CLR will dig that information out and use it only if something asks for it. For example, when you tell Visual Studio to run your unit tests, it will load your test assembly, and then for each public type, it asks the CLR for any test-related attributes. That’s the point at which the attributes get constructed. If you were simply to load the assembly by, say, adding a reference to it from another project and then using some of the types it contains, the attributes would never come into existence—they would remain as nothing more than a set of building instructions frozen into your assembly’s metadata.</p>
<section data-pdf-bookmark="Attribute Targets" data-type="sect2"><div class="sect2" id="attribute_targets">
<h2>Attribute Targets</h2>
<p><a data-primary="attributes" data-secondary="attribute targets" data-type="indexterm" id="idm45884793637840"/>Attributes can be applied to numerous different kinds of targets. You can put attributes on any of the features of the type system represented in the reflection API that I showed in <a data-type="xref" href="ch13.xhtml#ch_reflection">Chapter 13</a>. Specifically, you can apply attributes to assemblies, modules, types, methods, method parameters, constructors, fields, properties, events, and generic type parameters. In addition, you can supply attributes that target a method’s return value.</p>
<p>For most of these, you denote the target simply by putting the attribute in front of it. But that’s not an option for assemblies or modules, because there is no single feature that represents those in your source code—everything in your project goes into the assembly it produces, and modules are likewise an aggregate (typically constituting the whole assembly, as I described in <a data-type="xref" href="ch12.xhtml#ch_assemblies">Chapter 12</a>). So for these, we have to state the target explicitly at the start of the attribute. You will often see assembly-level attributes like the one shown in <a data-type="xref" href="#assembly-level_attributes">Example 14-4</a> in a <em>GlobalSuppressions.cs</em> file. Visual Studio sometimes makes suggestions for modifying your code, and if you choose to suppress these, it can do so with assembly-level attributes.</p>
<div data-type="example" id="assembly-level_attributes">
<h5><span class="label">Example 14-4. </span>Assembly-level attributes</h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="na">[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage(</code>
<code class="na">    "Style",</code>
<code class="na">    "IDE0060:Remove unused parameter",</code>
<code class="na">    Justification = "This is just some example code from a book",</code>
<code class="na">    Scope = "member",</code>
<code class="na">    Target = "~M:Idg.Examples.SomeMethod")]</code></pre></div>
<p>You can put assembly-level attributes in any file. The sole restriction is that they must appear before any namespace or type definitions. The only things that should come before assembly-level attributes are whichever <code>using</code> directives you need, comments, and whitespace (all of which are optional).</p>
<p>Module-level attributes follow the same pattern, although they are much less common, not least because multimodule assemblies are pretty rare and are not supported in the latest versions of .NET—they only work on .NET Framework. <a data-type="xref" href="#module-level_attribute">Example 14-5</a> shows how to configure the debuggability of a particular module, should you want one module in a multimodule assembly to be easily debuggable but the rest to be JIT-compiled with full optimizations. (This is a contrived scenario so that I can show the syntax. In practice, you’re unlikely ever to want to do this.) I’ll talk about the <code>DebuggableAttribute</code> later, in <a data-type="xref" href="#jit_compilation">“JIT compilation”</a>.</p>
<div data-type="example" id="module-level_attribute">
<h5><span class="label">Example 14-5. </span>Module-level attribute</h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="k">using</code> <code class="nn">System.Diagnostics</code><code class="p">;</code>

<code class="na">[module: Debuggable(DebuggableAttribute.DebuggingModes.DisableOptimizations)]</code></pre></div>
<p>Another kind of target that needs qualification is a compiler-generated field. You get these with  properties in which you do not supply code for the getter or setter, and also in <code>event</code> members without explicit <code>add</code> and <code>remove</code> implementations. The attributes in <a data-type="xref" href="#attributes_for_generated_field">Example 14-6</a> apply to the fields that hold the property’s value and the delegate for the event; without the <code>field:</code> qualifiers, attributes in those positions would apply to the property or event itself.</p>
<div data-type="example" id="attributes_for_generated_field">
<h5><span class="label">Example 14-6. </span>Attribute for compiler-generated property and event fields</h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="na">[field: NonSerialized]</code>
<code class="k">public</code> <code class="kt">int</code> <code class="n">DynamicId</code> <code class="p">{</code> <code class="k">get</code><code class="p">;</code> <code class="k">set</code><code class="p">;</code> <code class="p">}</code>

<code class="na">[field: NonSerialized]</code>
<code class="k">public</code> <code class="k">event</code> <code class="n">EventHandler</code><code class="p">?</code> <code class="n">Frazzled</code><code class="p">;</code></pre></div>
<p>Methods’ return values can be annotated, and this also requires qualification, because return value attributes go in front of the method, the same place as attributes that apply to the method itself. (Attributes for parameters do not need qualification, because these appear inside the parentheses with the arguments.) <a data-type="xref" href="#method_and_return_value_attributes">Example 14-7</a> shows a method with attributes applied to both the method and the return type. (The attributes in this example are part of the interop services that enable .NET code to call external code, such as OS APIs. This example imports a function from a Win32 DLL, enabling you to use it from C#. There are several different representations for Boolean values in unmanaged code, so I’ve annotated the return type here with a <code>MarshalAsAttribute</code> to say which particular one the CLR should expect.)</p>
<div data-type="example" id="method_and_return_value_attributes">
<h5><span class="label">Example 14-7. </span>Method and return value attributes</h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="na">[DllImport("User32.dll")]</code>
<code class="na">[return: MarshalAs(UnmanagedType.Bool)]</code>
<code class="k">static</code> <code class="k">extern</code> <code class="kt">bool</code> <code class="nf">IsWindowVisible</code><code class="p">(</code><code class="n">HandleRef</code> <code class="n">hWnd</code><code class="p">);</code></pre></div>
<p>What about cases where we don’t write the method declaration explicitly? As you saw in <a data-type="xref" href="ch09.xhtml#ch_delegates_lambdas_events">Chapter 9</a>, the lambda syntax lets us write an expression whose value is a delegate. The compiler generates a normal method to hold the code (typically in a hidden class), and we might want to pass that method to a framework that uses attributes to control its functionality, such as the ASP.NET Core web framework. <a data-type="xref" href="#lambda_attributes">Example 14-8</a> shows how we can specify these attributes when using a lambda.</p>
<div data-type="example" id="lambda_attributes">
<h5><span class="label">Example 14-8. </span>Lambda with attributes</h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="n">app</code><code class="p">.</code><code class="n">MapGet</code><code class="p">(</code>
    <code class="s">"/items/{id}"</code><code class="p">,</code>
<code class="na">    [Authorize]</code> <code class="p">([</code><code class="n">FromRoute</code><code class="p">]</code> <code class="kt">int</code> <code class="n">id</code><code class="p">)</code> <code class="p">=&gt;</code> <code class="err">$</code><code class="s">"Item {id} requested"</code><code class="p">);</code></pre></div>
<p>The <code>MapGet</code> method here tells the ASP.NET Core framework how our application should behave when it receives <code>GET</code> requests on URLs matching a particular pattern. The first argument specifies the pattern, and the second is a delegate that defines the behavior. I’ve used the lambda syntax here, and I’ve applied a couple of attributes.</p>
<p>The first attribute is <code>[Authorize]</code>. This appears before the parameter list, so its target is the whole method. (You can also use a <code>return:</code> attribute in this position.) This causes ASP.NET Core to block unauthenticated requests that match this URL pattern. The <code>[FromRoute]</code> attribute is inside the parameter list’s parentheses, so it applies to the <code>id</code> parameter, and it tells ASP.NET Core that we want that particular parameter’s value to be taken from the expression of the same name in the URL pattern. So if a request came in for <em>https://myserver/items/42</em>, ASP.NET Core would first check that the request meets the application’s configured requirements for authentication and authorization, and if so, it would then invoke my lambda passing <code>42</code> as the <code>id</code> argument.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p><a data-type="xref" href="ch09.xhtml#lambda_variations">Example 9-22</a> in <a data-type="xref" href="ch09.xhtml#ch_delegates_lambdas_events">Chapter 9</a> showed that you can omit details in certain cases. The parentheses around the parameter list are normally optional for 1-argument lambdas. However, the parentheses <em>must</em> be present if you apply attributes to a lambda. To see why, imagine <a data-type="xref" href="#lambda_attributes">Example 14-8</a> without parentheses around the parameter list: it would be unclear whether the attributes were meant to apply to the method or the parameter.</p>
</div>
</div></section>
<section data-pdf-bookmark="Compiler-Handled Attributes" data-type="sect2"><div class="sect2" id="compiler-handled_attributes">
<h2>Compiler-Handled Attributes</h2>
<p><a data-primary="attributes" data-secondary="compiler-handled attributes" data-type="indexterm" id="ix_ch14-asciidoc2"/>The C# compiler recognizes certain attribute types and handles them in special ways. For example, assembly names and versions are set via attributes and also some related information about your assembly. As <a data-type="xref" href="ch12.xhtml#ch_assemblies">Chapter 12</a> described, in modern .NET projects, the build process generates a hidden source file containing these for you. If you’re curious, it usually ends up in the <em>obj\Debug</em> or <em>obj\Release</em> folder of your project, and it will be named something like <em>YourProject.AssemblyInfo.cs</em>. <a data-type="xref" href="#auto_generated_assembly_info">Example 14-9</a> shows a typical example.</p>
<div data-type="example" id="auto_generated_assembly_info">
<h5><span class="label">Example 14-9. </span>A typical generated file with assembly-level attributes</h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="c1">//------------------------------------------------------------------------------</code>
<code class="c1">// &lt;auto-generated&gt;</code>
<code class="c1">//     This code was generated by a tool.</code>
<code class="c1">//     Runtime Version:4.0.30319.42000</code>
<code class="c1">//</code>
<code class="c1">//     Changes to this file may cause incorrect behavior and will be lost if</code>
<code class="c1">//     the code is regenerated.</code>
<code class="c1">// &lt;/auto-generated&gt;</code>
<code class="c1">//------------------------------------------------------------------------------</code>

<code class="k">using</code> <code class="nn">System</code><code class="p">;</code>
<code class="k">using</code> <code class="nn">System.Reflection</code><code class="p">;</code>

<code class="na">[assembly: System.Reflection.AssemblyCompanyAttribute("MyCompany")]</code>
<code class="na">[assembly: System.Reflection.AssemblyConfigurationAttribute("Debug")]</code>
<code class="na">[assembly: System.Reflection.AssemblyFileVersionAttribute("1.0.0.0")]</code>
<code class="na">[assembly: System.Reflection.AssemblyInformationalVersionAttribute("1.0.0")]</code>
<code class="na">[assembly: System.Reflection.AssemblyProductAttribute("MyApp")]</code>
<code class="na">[assembly: System.Reflection.AssemblyTitleAttribute("MyApp")]</code>
<code class="na">[assembly: System.Reflection.AssemblyVersionAttribute("1.0.0.0")]</code>

<code class="c1">// Generated by the MSBuild WriteCodeFragment class.</code></pre></div>
<p>Old versions of the .NET Framework SDK did not generate this file at build time, so if you work on older projects, you will often find these attributes in a file called <em>AssemblyInfo.cs</em>. (By default Visual Studio hid this inside the project’s Properties node in Solution Explorer, but it was still just an ordinary source file.) The advantage of the file generation used in modern projects is that names are less likely to drift out of sync. For example, by default the assembly Product and Title will be the same as the project filename. If you rename the project file, the generated <span class="keep-together"><em>YourRenamedProject.AssemblyInfo.cs</em></span> will change to match (unless you added 
<span class="keep-together"><code>&lt;Product&gt;</code></span> and <code>&lt;AssemblyTitle&gt;</code> properties to your project file, in which case it will use those), whereas with the old <em>AssemblyInfo.cs</em> approach you could accidentally end up with mismatched names. Similarly, if you build a NuGet package from your project, certain properties end up in both the NuGet package and the compiled assembly. When these are all generated from information in the project file, it’s easier to keep things consistent.</p>
<p>Even though you only control these attributes indirectly, it’s useful to understand them since they affect the compiler output.</p>
<section data-pdf-bookmark="Names and versions" data-type="sect3"><div class="sect3" id="names_and_versions">
<h3>Names and versions</h3>
<p><a data-primary="attributes" data-secondary="names and versions" data-type="indexterm" id="idm45884793377280"/>As you saw in <a data-type="xref" href="ch12.xhtml#ch_assemblies">Chapter 12</a>, assemblies have a compound name. The simple name, which is typically the same as the filename but without the <em>.exe</em> or <em>.dll</em> extension, is configured as part of the project settings. The name also includes a version number, and this is controlled with an attribute, as <a data-type="xref" href="#version_attributes">Example 14-10</a> shows.</p>
<div data-type="example" id="version_attributes">
<h5><span class="label">Example 14-10. </span>Version attributes</h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="na">[assembly: AssemblyVersion("1.0.0.0")]</code>
<code class="na">[assembly: AssemblyFileVersion("1.0.0.0")]</code></pre></div>
<p>As you may recall from <a data-type="xref" href="ch12.xhtml#ch_assemblies">Chapter 12</a>, the first of these sets the version part of the assembly’s name. The second has nothing to do with .NET—the compiler uses this to generate a Win32-style version resource. This is the version number end users will see if they select your assembly in Windows Explorer and open the Properties <span class="keep-together">window.</span></p>
<p>The culture is also part of the assembly name. This will often be set automatically if you’re using the satellite resource assembly mechanisms described in <a data-type="xref" href="ch12.xhtml#ch_assemblies">Chapter 12</a>. You can set it explicitly with the <code>AssemblyCulture</code> attribute, but for nonresource assemblies, the culture should usually not be set. (The only culture-related assembly-level attribute you will normally specify explicitly is the <code>Neu⁠tral⁠Res⁠our⁠ces⁠Lan⁠gua⁠ge​Att⁠rib⁠ute</code>, which I showed in <a data-type="xref" href="ch12.xhtml#ch_assemblies">Chapter 12</a>.)</p>
<p><a data-primary="strongly named assemblies" data-type="indexterm" id="idm45884793304064"/>Strongly named assemblies have an additional component in their name: the public key token. The easiest way to set up a strong name in Visual Studio is with the “Strong naming” section of your project’s properties page  (which is inside the Build section). If you’re using VS Code or some other editor, you can just add two properties to your <em>.csproj</em> file: <code>SignAssembly</code> set to <code>True</code>, and <code>AssemblyOriginatorKeyFile</code> with the path to your key file.  However, you can also manage strong naming from the source code, because the compiler recognizes some special attributes for this. <code>AssemblyKeyFileAttribute</code> takes the name of a file that contains a key. Alternatively, you can install a key in the computer’s key store (which is part of the Windows cryptography system). If you want to do that, you can use the <code>AssemblyKeyNameAttribute</code> instead. The presence of either of these attributes causes the compiler to embed the public key in the assembly and include a hash of that key as the public key token of the strong name. If the key file includes the private key, the compiler will sign your assembly too. If it does not, it will fail to compile, unless you also enable either delay signing or public signing. You can enable delay signing by applying the <code>Ass⁠emb⁠ly​Del⁠ayS⁠ign⁠Att⁠rib⁠ute</code> with a constructor argument of <code>true</code>. Alternatively, you can add either <code>&lt;DelaySign&gt;true&lt;/DelaySign&gt;</code> or <code>&lt;PublicSign&gt;true&lt;/PublicSign&gt;</code> to your <em>.csproj</em> file.</p>
<div data-type="warning" epub:type="warning"><h6>Warning</h6>
<p>Although the key-related attributes trigger special handling from the compiler, it still embeds them in the metadata as normal attributes. So, if you use the <code>AssemblyKeyFileAttribute</code>, the path to your key file will be visible in the final compiled output. This is not necessarily a problem, but you might prefer not to advertise these sorts of details, so it may be better to use the project-level configuration for strong names than the attribute-based approach.</p>
</div>
</div></section>
<section data-pdf-bookmark="Description and related resources" data-type="sect3"><div class="sect3" id="description_and_related_resources">
<h3>Description and related resources</h3>
<p><a data-primary="attributes" data-secondary="description and related resources" data-type="indexterm" id="idm45884800917456"/>The version resource produced by the <code>AssemblyFileVersion</code> attribute is not the only information that the C# compiler can embed in Win32-style resources. There are several other attributes providing copyright information and other descriptive text. <a data-type="xref" href="#typical_assembly_description_attributes">Example 14-11</a> shows a typical selection.</p>
<div data-type="example" id="typical_assembly_description_attributes">
<h5><span class="label">Example 14-11. </span>Typical assembly description attributes</h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="na">[assembly: AssemblyTitle("ExamplePlugin")]</code>
<code class="na">[assembly: AssemblyDescription("An example plug-in DLL")]</code>
<code class="na">[assembly: AssemblyConfiguration("Retail")]</code>
<code class="na">[assembly: AssemblyCompany("Endjin Ltd.")]</code>
<code class="na">[assembly: AssemblyProduct("ExamplePlugin")]</code>
<code class="na">[assembly: AssemblyCopyright("Copyright © 2022 Endjin Ltd.")]</code>
<code class="na">[assembly: AssemblyTrademark("")]</code></pre></div>
<p>As with the file version, these are all visible in the Details tab of the Properties window that Windows Explorer can show for the file. And with all of these attributes, you can cause them to be generated by editing the project file.</p>
</div></section>
<section data-pdf-bookmark="Caller information attributes" data-type="sect3"><div class="sect3" id="caller_information_attributes">
<h3>Caller information attributes</h3>
<p><a data-primary="attributes" data-secondary="caller information attributes" data-type="indexterm" id="ix_ch14-asciidoc3"/>There are some compiler-handled attributes designed for scenarios where your methods need information about the context from which they were invoked. This is useful for certain diagnostic logging or error handling scenarios, and it is also helpful when implementing a particular interface commonly used in UI code.</p>
<p><a data-type="xref" href="#applying_caller_info_attributes">Example 14-12</a> illustrates how you can use these attributes in logging code. If you annotate method parameters with any of these three attributes, the compiler provides some special handling when callers omit the arguments. We can ask for the name of the member (method or property) that called the attributed method, the filename containing the code that called the method, or the line number from which the call was made. <a data-type="xref" href="#applying_caller_info_attributes">Example 14-12</a> asks for all three, but you can be more selective.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>These attributes are allowed only for optional parameters. Optional arguments are required to specify a default value, but C# will always substitute a different value when these attributes are present, so the default you specify will not be used if you invoke the method from C# (or Visual Basic, which also supports these attributes). Nonetheless, you must provide a default because without one, the parameter is not optional, so we normally use empty strings, <code>null</code>, or the number <code>0</code>.</p>
</div>
<div data-type="example" id="applying_caller_info_attributes">
<h5><span class="label">Example 14-12. </span>Applying caller info attributes to method parameters</h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="k">public</code> <code class="k">static</code> <code class="k">void</code> <code class="nf">Log</code><code class="p">(</code>
    <code class="kt">string</code> <code class="n">message</code><code class="p">,</code>
<code class="na">    [CallerMemberName]</code> <code class="kt">string</code> <code class="n">callingMethod</code> <code class="p">=</code> <code class="s">""</code><code class="p">,</code>
<code class="na">    [CallerFilePath]</code> <code class="kt">string</code> <code class="n">callingFile</code> <code class="p">=</code> <code class="s">""</code><code class="p">,</code>
<code class="na">    [CallerLineNumber]</code> <code class="kt">int</code> <code class="n">callingLineNumber</code> <code class="p">=</code> <code class="m">0</code><code class="p">)</code>
<code class="p">{</code>
    <code class="n">Console</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code><code class="s">"Message {0}, called from {1} in file '{2}', line {3}"</code><code class="p">,</code>
        <code class="n">message</code><code class="p">,</code> <code class="n">callingMethod</code><code class="p">,</code> <code class="n">callingFile</code><code class="p">,</code> <code class="n">callingLineNumber</code><code class="p">);</code>
<code class="p">}</code></pre></div>
<p>If you supply all arguments when invoking this method, nothing unusual happens. But if you omit any of the optional arguments, C# will generate code that provides information about the site from which the method was invoked. The default values for the three optional arguments in <a data-type="xref" href="#applying_caller_info_attributes">Example 14-12</a> will be the name of the method or property that called this <code>Log</code> method, the full path of the source code containing the code that made the call, and the line number from which <code>Log</code> was called.</p>
<p>The <code>CallerMemberName</code> attribute has a superficial resemblance to the <code>nameof</code> operator, which we saw in <a data-type="xref" href="ch08.xhtml#ch_exceptions">Chapter 8</a>. Both cause the compiler to create a string containing the name of some feature of the code, but they work quite differently. With <code>nameof</code>, you always know exactly what string you’ll get, because it’s determined by the expression you supply. (E.g., if we were to write <code>nameof(message)</code> inside <code>Log</code> in <a data-type="xref" href="#applying_caller_info_attributes">Example 14-12</a>, it would always evaluate to <code>"message"</code>.) But <code>CallerMemberName</code> changes the way the compiler invokes the method to which they apply—<code>cal⁠lin⁠g​Met⁠hod</code> has that attribute, and its value is not fixed. It will depend on where this method is called from.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>You can discover the calling method another way: the <code>StackTrace</code> and <code>StackFrame</code> classes in the <code>System.Diagnostics</code> namespace can report information about methods above you in the call stack. However, these have a considerably higher runtime expense—the caller information attributes calculate the values at compile time, making the runtime overhead very low. (Likewise with <code>nameof</code>.) Also, <code>StackFrame</code> can determine the filename and line number only if debug symbols are available.</p>
</div>
<p><a data-primary="INotifyPropertyChanged interface" data-type="indexterm" id="idm45884793169392"/>Although diagnostic logging is the obvious application for this, I also mentioned a certain scenario that most .NET UI developers will be familiar with. The runtime libraries define an interface called <code>INotifyPropertyChanged</code>. As <a data-type="xref" href="#inotifypropertychanged">Example 14-13</a> shows, this is a very simple interface with just one member, an event called <code>PropertyChanged</code>.</p>
<div data-type="example" id="inotifypropertychanged">
<h5><span class="label">Example 14-13. </span><code>INotifyPropertyChanged</code></h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="k">public</code> <code class="k">interface</code> <code class="n">INotifyPropertyChanged</code>
<code class="p">{</code>
    <code class="k">event</code> <code class="n">PropertyChangedEventHandler</code><code class="p">?</code> <code class="n">PropertyChanged</code><code class="p">;</code>
<code class="p">}</code></pre></div>
<p>Types that implement this interface raise the <code>PropertyChanged</code> event every time one of their properties changes. The <code>PropertyChangedEventArgument</code> provides a string containing the name of the property that just changed. These change notifications are useful in UIs, because they enable an object to be used with databinding technologies (such as those provided by .NET’s WPF UI framework) that can automatically update the UI any time a property changes. Databinding can help you to achieve a clean separation between the code that deals directly with UI types and code that contains the logic that decides how the application should respond to user input.</p>
<p>Implementing <code>INotifyPropertyChanged</code> can be both tedious and error-prone. Because the <code>PropertyChanged</code> event indicates which property changed as a string, it is very easy to mistype the property name, or to accidentally use the wrong name if you copy and paste the implementation from one property to another. Also, if you rename a property, it’s easy to forget to change the text used for the event, meaning that code that was previously correct will now provide the wrong name when raising the <code>PropertyChanged</code> event. The <code>nameof</code> operator helps avoid mistyping, and helps with renames, but can’t always detect cut-and-paste errors. (It won’t notice if you fail to update the name when pasting code between properties of the same class, for example.)</p>
<p>Caller information attributes can help make implementing this interface much less error-prone. You can refer to <a data-type="xref" href="#reusable_inotifypropertychanged_impl">Example 14-14</a>, which shows a base class that 
<span class="keep-together">implements</span> <code>INotifyPropertyChanged</code>, supplying a helper for raising change notifications in a way that exploits one of these attributes. (It also uses the null-conditional <code>?.</code> operator to ensure that it only invokes the event’s delegate if it is non-null. By the way, when you use the operator this way, C# generates code that only evaluates the delegate’s <code>Invoke</code> method’s arguments if it is non-null. So not only does it skip the call to <code>Invoke</code> when the delegate is null, it will also avoid constructing the <code>Pro⁠per⁠ty​Cha⁠nge⁠dEv⁠ent⁠Args</code> that would have been passed as an argument.) This code also detects whether the value really has changed, only raising the event when that’s the case, and its return value indicates whether it changed, in case callers might find that useful.</p>
<div data-type="example" id="reusable_inotifypropertychanged_impl">
<h5><span class="label">Example 14-14. </span>A reusable <code>INotifyPropertyChanged</code> implementation</h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="k">public</code> <code class="k">class</code> <code class="nc">NotifyPropertyChanged</code> <code class="p">:</code> <code class="n">INotifyPropertyChanged</code>
<code class="p">{</code>
    <code class="k">public</code> <code class="k">event</code> <code class="n">PropertyChangedEventHandler</code><code class="p">?</code> <code class="n">PropertyChanged</code><code class="p">;</code>

    <code class="k">protected</code> <code class="kt">bool</code> <code class="n">SetProperty</code><code class="p">&lt;</code><code class="n">T</code><code class="p">&gt;(</code>
        <code class="k">ref</code> <code class="n">T</code> <code class="n">field</code><code class="p">,</code>
        <code class="n">T</code> <code class="k">value</code><code class="p">,</code>
<code class="na">        [CallerMemberName]</code> <code class="kt">string</code> <code class="n">propertyName</code> <code class="p">=</code> <code class="s">""</code><code class="p">)</code>
    <code class="p">{</code>
        <code class="k">if</code> <code class="p">(</code><code class="n">Equals</code><code class="p">(</code><code class="n">field</code><code class="p">,</code> <code class="k">value</code><code class="p">))</code>
        <code class="p">{</code>
            <code class="k">return</code> <code class="k">false</code><code class="p">;</code>
        <code class="p">}</code>

        <code class="n">field</code> <code class="p">=</code> <code class="k">value</code><code class="p">;</code>

        <code class="n">PropertyChanged</code><code class="p">?.</code><code class="n">Invoke</code><code class="p">(</code><code class="k">this</code><code class="p">,</code> <code class="k">new</code> <code class="n">PropertyChangedEventArgs</code><code class="p">(</code><code class="n">propertyName</code><code class="p">));</code>
        <code class="k">return</code> <code class="k">true</code><code class="p">;</code>
    <code class="p">}</code>
<code class="p">}</code></pre></div>
<p>The presence of the <code>[CallerMemberName]</code> attribute means that a class deriving from this type does not need to specify the property name if it calls <code>SetProperty</code> from inside a property setter, as <a data-type="xref" href="#raising_a_property_changed_event">Example 14-15</a> shows.</p>
<div data-type="example" id="raising_a_property_changed_event">
<h5><span class="label">Example 14-15. </span>Raising a property changed event</h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="k">public</code> <code class="k">class</code> <code class="nc">MyViewModel</code> <code class="p">:</code> <code class="n">NotifyPropertyChanged</code>
<code class="p">{</code>
    <code class="k">private</code> <code class="kt">string?</code> <code class="n">_name</code><code class="p">;</code>

    <code class="k">public</code> <code class="kt">string?</code> <code class="n">Name</code>
    <code class="p">{</code>
        <code class="k">get</code> <code class="p">=&gt;</code> <code class="n">_name</code><code class="p">;</code>
        <code class="k">set</code> <code class="p">=&gt;</code> <code class="n">SetProperty</code><code class="p">(</code><code class="k">ref</code> <code class="n">_name</code><code class="p">,</code> <code class="k">value</code><code class="p">);</code>
    <code class="p">}</code>
<code class="p">}</code></pre></div>
<p>Even with the new attribute, implementing <code>INotifyPropertyChanged</code> is clearly more effort than an automatic property, where you just write <code>{ get; set; }</code> and let the compiler do the work for you. But it’s only a little more complex than an explicit <span class="keep-together">implementation</span> of a trivial field-backed property, and it’s simpler than would be possible without <code>[CallerMemberName]</code>, because I’ve been able to omit the property name when asking the base class to raise the event. More importantly, it’s less error prone: I can now be confident that the right name will be used every time, even if I rename the property at some point in the future<a data-startref="ix_ch14-asciidoc3" data-type="indexterm" id="idm45884792979728"/>.<a data-startref="ix_ch14-asciidoc2" data-type="indexterm" id="idm45884792978928"/></p>
<p>.NET 6.0 <a data-primary="CallerArgumentExpression" data-type="indexterm" id="idm45884792945456"/><a data-primary=".NET 6.0" data-primary-sortas="NET 6.0" data-secondary="caller information attributes" data-type="indexterm" id="idm45884792944848"/><a data-primary="ArgumentNullException class" data-type="indexterm" id="idm45884792943664"/>adds a new caller information attribute: <code>CallerArgumentExpression</code>. <a data-type="xref" href="#caller_argument_expression_attr">Example 14-16</a> shows an excerpt from the runtime libraries’ <code>ArgumentNullException</code> class. It declares a <code>ThrowIfNull</code> method that uses this attribute.</p>
<div data-type="example" id="caller_argument_expression_attr">
<h5><span class="label">Example 14-16. </span>The <code>CallerArgumentExpressionAttribute</code> in 
<span class="keep-together"><code>ArgumentNullException.ThrowIfNull</code></span></h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="k">public</code> <code class="k">class</code> <code class="nc">ArgumentNullException</code>
<code class="p">{</code>
    <code class="k">public</code> <code class="k">static</code> <code class="k">void</code> <code class="nf">ThrowIfNull</code><code class="p">(</code>
<code class="na">        [NotNull]</code> <code class="kt">object?</code> <code class="n">argument</code><code class="p">,</code>
<code class="na">        [CallerArgumentExpression("argument")]</code> <code class="kt">string?</code> <code class="n">paramName</code> <code class="p">=</code>  <code class="k">null</code><code class="p">)</code>
    <code class="p">{</code>
<code class="p">...</code></pre></div>
<p>As you can see, the <code>CallerArgumentExpression</code> attribute takes a single string argument. This must be the name of another parameter in the same method—in this case there is only one other parameter, called <code>argument</code>, so it has to refer to that. The effect is that if you call this method without providing a value for the annotated <code>paramName</code> argument, the C# compiler will pass a string containing the exact expression you used for the argument that the attribute identified. <a data-type="xref" href="#caller_argument_expression_in_use">Example 14-17</a> shows how this <code>ThrowIfNull</code> method is typically called.</p>
<div data-type="example" id="caller_argument_expression_in_use">
<h5><span class="label">Example 14-17. </span>Calling a method that uses <code>CallerArgumentExpressionAttribute</code></h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="k">static</code> <code class="k">void</code> <code class="nf">Greet</code><code class="p">(</code><code class="kt">string</code> <code class="n">greetingRecipient</code><code class="p">)</code>
<code class="p">{</code>
    <code class="n">ArgumentNullException</code><code class="p">.</code><code class="n">ThrowIfNull</code><code class="p">(</code><code class="n">greetingRecipient</code><code class="p">);</code>
    <code class="n">Console</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code><code class="err">$</code><code class="s">"Hello, {greetingRecipient}"</code><code class="p">);</code>
<code class="p">}</code>

<code class="n">Greet</code><code class="p">(</code><code class="s">"world"</code><code class="p">);</code>
<code class="n">Greet</code><code class="p">(</code><code class="k">null</code><code class="p">!);</code></pre></div>
<p>The <code>Greet</code> method needs <code>greetingRecipient</code> not to be null, so it calls <code>Arg⁠ume⁠nt​Nul⁠lEx⁠cep⁠tio⁠n.T⁠hro⁠wIf⁠Null</code>, passing in <code>greetingRecipient</code>. Because this code does not provide a second argument to <code>ThrowIfNull</code>, the compiler will provide the full text of the expression we used for the first argument. In this case, that’s <code>"gre⁠eti⁠ng​Rec⁠ipi⁠ent"</code>. So the effect is that when I run this program, it throws an <code>Arg⁠ume⁠nt​Nul⁠lEx⁠cep⁠tion</code> with this message:</p>
<pre data-type="programlisting">Value cannot be null. (Parameter 'greetingRecipient')</pre>
<p><a data-primary="C# 10.0" data-secondary="CallerArgumentExpression" data-type="indexterm" id="idm45884792852768"/>Before C# 10.0, we would typically have used <code>nameof(greetingRecipient)</code> to tell <code>ArgumentNullException</code> the name of the offending argument. This new technique prevents a certain mistake: it used to be all too easy to pass the name of the wrong argument when throwing an exception. (This was particularly common if you needed to check multiple arguments for null—copying and pasting the relevant checks provided ample opportunities to make this mistake.)</p>
<p>One of the scenarios this attribute supports is to improve assertion messages. For example, unit test libraries typically provide mechanisms for asserting that certain conditions are true after exercising the code under test. The idea is that if your test contains code such as <code>Assert.IsTrue(answer == 42);</code> the test library could use <code>[CallerArgumentExpression]</code> to be able to report the exact expression (<code>answer == 42</code>) on failure.</p>
<p>You might expect the <code>Debug.Assert</code> method in the runtime libraries to use this for similar reasons. However, to use <code>CallerArgumentExpressionAttribute</code>, you have to add a parameter to the method to receive the expression text (in addition to the existing parameter that receives the value of the expression), so it’s not a binary-compatible change. The new <code>ThrowIfNull</code> method is the only place the .NET 6.0 runtime libraries use this attribute, and at the time of writing this, the NuGet packages for Microsoft’s testing framework do not yet use this. But it seems likely that test frameworks will adopt this in time.</p>
</div></section>
</div></section>
<section data-pdf-bookmark="CLR-Handled Attributes" data-type="sect2"><div class="sect2" id="clr-handled_attributes">
<h2>CLR-Handled Attributes</h2>
<p><a data-primary="attributes" data-secondary="CLR-handled attributes" data-type="indexterm" id="ix_ch14-asciidoc4"/>Some attributes get special treatment at runtime from the CLR. There is no official comprehensive list of such attributes, so in the next few sections, I will just describe some of the most widely used examples.</p>
<section data-pdf-bookmark="InternalsVisibleToAttribute" data-type="sect3"><div class="sect3" id="internalsvisibletoattribute">
<h3>InternalsVisibleToAttribute</h3>
<p><a data-primary="InternalsVisibleToAttribute" data-type="indexterm" id="ix_ch14-asciidoc5"/><a data-primary="internal members" data-type="indexterm" id="idm45884792841408"/><a data-primary="internal types" data-type="indexterm" id="idm45884792840736"/>You can apply the <code>InternalsVisibleToAttribute</code> to an assembly to declare that any <code>internal</code> types or members it defines should be visible to one or more other assemblies. A popular use for this is to enable unit testing of internal types. As <a data-type="xref" href="#internalsvisibleto-attributes">Example 14-18</a> shows, you pass the name of the assembly as a constructor <span class="keep-together">argument</span>.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Strong naming complicates matters. Strongly named assemblies cannot make their internals visible to assemblies that are not strongly named, and vice versa. When a strongly named assembly makes its internals visible to another strongly named assembly, it must specify not just the simple name but also the public key of the assembly to which it is granting access. And this is not just the public key token I described in <a data-type="xref" href="ch12.xhtml#ch_assemblies">Chapter 12</a>—it is the hexadecimal for the entire public key, which will be several hundred digits. You can discover an assembly’s full public key with the .NET SDK’s <em>sn.exe</em> utility, using the <span class="keep-together"><code class="keep-together">-Tp</code></span> switch followed by the assembly’s path.</p>
</div>
<div data-type="example" id="internalsvisibleto-attributes">
<h5><span class="label">Example 14-18. </span><code>InternalsVisibleToAttribute</code></h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="na">[assembly:InternalsVisibleTo("ImageManagement.Tests")]</code>
<code class="na">[assembly:InternalsVisibleTo("ImageServices.Tests")]</code></pre></div>
<p>This shows that you can make the types visible to multiple assemblies by applying the attribute multiple times, with a different assembly name each time.</p>
<p>The CLR is responsible for enforcing accessibility rules. Normally, if you try to use an internal class from another assembly, you’ll get an error at runtime. (C# won’t even let you compile such code, but it’s possible to trick the compiler. Or you could write directly in IL. The IL assembler, <em>ILASM</em>, does what you tell it and imposes far fewer restrictions than C#. Once you get past the compile-time restrictions, then you’ll hit the runtime ones.) But when this attribute is present, the CLR relaxes its rules for the assemblies you list. The compiler also understands this attribute and lets code that tries to use externally defined internal types compile as long as the external library names your assembly in an <code>InternalsVisibleToAttribute</code>.</p>
<p>Besides being useful in unit test scenarios, this attribute can also be helpful if you want to split code across multiple assemblies. If you have written a large class library, you might not want to put it into one massive DLL. If it has several areas that your customers might want to use in isolation, it could make sense to split it up so that they can deploy just the parts that they need. However, although you may be able to partition your library’s public-facing API, the implementation might not be as easy to divide, particularly if your codebase performs a lot of reuse. You might have many classes that are not designed for public consumption but that you use throughout your code.</p>
<p>If it weren’t for the <code>InternalsVisibleToAttribute</code>, it would be awkward to reuse shared implementation details across assemblies. <a data-primary="public types" data-type="indexterm" id="idm45884792789408"/>Either each assembly would need to contain its own copy of the relevant classes, or you’d need to make them public types in some common assembly. The problem with that second technique is that making types public effectively invites people to use them. Your documentation might state that the types are for the internal use of your framework and should not be used, but that won’t stop some people.</p>
<p>Fortunately, you don’t have to make them <code>public</code>. Any types that are just implementation details can remain <code>internal</code>, and you can make them available to all of your assemblies with the <code>InternalsVisibleToAttribute</code> while keeping them inaccessible to everyone else.<a data-startref="ix_ch14-asciidoc5" data-type="indexterm" id="idm45884792799504"/></p>
</div></section>
<section data-pdf-bookmark="JIT compilation" data-type="sect3"><div class="sect3" id="jit_compilation">
<h3>JIT compilation</h3>
<p><a data-primary="JIT (just-in-time) compilation" data-type="indexterm" id="idm45884792797344"/><a data-primary="just-in-time (JIT) compilation" data-type="indexterm" id="idm45884792796672"/>There are a few attributes that influence how the JIT compiler generates code. You can apply the <code>MethodImplAttribute</code> to a method, passing values from the <code>Met⁠hod​Imp⁠lOp⁠tions</code> enumeration. Its <code>NoInlining</code> value ensures that whenever your method is called by another method, it will be a full method call. Without this, the JIT compiler will sometimes just copy a method’s code directly into the calling code.</p>
<p>In general, you’ll want to leave inlining enabled. The JIT compiler inlines only small methods, and it’s particularly important for tiny methods, such as property accessors. For simple field-based properties, invoking accessors with a normal function call often requires more code than inlining, so this optimization can produce code that’s smaller, as well as faster. (Even if the code is not smaller, it may still be faster, because function calls can be surprisingly expensive. Modern CPUs tend to handle long sequential streams of instructions more efficiently than code that leaps around from one location to another.) However, inlining is an optimization with observable side effects—an inlined method does not get its own stack frame. Earlier, I mentioned some diagnostic APIs you can use to inspect the stack, and inlining will change the number of reported stack frames. If you just want to ask the question “Which method is calling me?” the caller info attributes described earlier provide a more efficient way to discover this and will not be defeated by inlining, but if you have code that inspects the stack for any reason, it can sometimes be confused by inlining. So, just occasionally, it’s useful to disable it.</p>
<p>Conversely, you can specify <code>AggressiveInlining</code>, which encourages the JIT compiler to inline things it might otherwise leave as normal method calls. If you have identified a particular method as being highly performance sensitive, it might be worth trying this setting to see if it makes any difference, although be aware that it could make code either slower or faster—it will depend on the circumstances. Conversely, you can disable all optimizations with the <code>NoOptimization</code> option (although the documentation implies that this is more for the benefit of the CLR team at Microsoft than for consumers, because it is for “debugging possible code generation <span class="keep-together">problems”).</span></p>
<p>Another attribute that has an impact on optimization is the <code>DebuggableAttribute</code>. The C# compiler automatically applies this to your assembly in Debug builds. The attribute tells the CLR to be less aggressive about certain optimizations, particularly ones that affect variable lifetime and ones that change the order in which code 
<span class="keep-together">executes.</span> Normally, the compiler is free to change such things as long as the final result of the code is the same, but this can cause confusion if you break into the middle of an optimized method with the debugger. This attribute ensures that variable values and the flow of execution are easy to follow in that scenario.</p>
</div></section>
<section data-pdf-bookmark="STAThread and MTAThread" data-type="sect3"><div class="sect3" id="stathread_and_mtathread">
<h3>STAThread and MTAThread</h3>
<p><a data-primary="COM (Component Object Model)" data-type="indexterm" id="idm45884792762304"/><a data-primary="Component Object Model (COM)" data-type="indexterm" id="idm45884792761472"/><a data-primary="MTAThread attribute" data-type="indexterm" id="idm45884792760864"/><a data-primary="STAThread attribute" data-type="indexterm" id="idm45884792760256"/>Applications that run only on Windows and that present a UI (e.g., anything using .NET’s WPF or Windows Forms frameworks) typically have the <code>[STAThread]</code> attribute on their <code>Main</code> method (although you won’t always see it, because the entry point is often generated by the build system for these kinds of applications). This is an instruction to the CLR’s interop services for the Component Object Model (COM), but it has broader implications: you need this attribute on <code>Main</code> if you want your main thread to host UI elements.</p>
<p>Various Windows UI features rely on COM under the covers. The clipboard uses it, for example, as do certain kinds of controls. COM has several threading models, and only one of them is compatible with UI threads. One of the main reasons for this is that UI elements have thread affinity, so COM needs to ensure that it does certain work on the right thread. Also, if a UI thread doesn’t regularly check for messages and handle them, deadlock can ensue. If you don’t tell COM that a particular thread is a UI thread, it will omit these checks, and you will encounter problems.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Even if you’re not writing UI code, some interop scenarios need the <code>[STAThread]</code> attribute, because certain COM components are incapable of working without it. However, UI work is the most common reason for seeing it.</p>
</div>
<p>Since COM is managed for you by the CLR, the CLR needs to know that it should tell COM that a particular thread needs to be handled as a UI thread. When you create a new thread explicitly using the techniques shown in <a data-type="xref" href="ch16.xhtml#ch_multithreading">Chapter 16</a>, you can configure its COM threading mode, but the main thread is a special case—the CLR creates it for you when your application starts, and by the time your code runs, it’s too late to configure the thread. Placing the <code>[STAThread]</code> attribute on the <code>Main</code> method tells the CLR that your main thread should be initialized for UI-compatible COM behavior.</p>
<p><a data-primary="single-threaded apartment (STA)" data-type="indexterm" id="idm45884792753136"/><a data-primary="STA (single-threaded apartment)" data-type="indexterm" id="idm45884792752240"/>STA is short for <em>single-threaded apartment</em>. <a data-primary="multi-threaded apartment (MTA)" data-type="indexterm" id="idm45884792751056"/>Threads that participate in COM always belong to either an STA or a <em>multithreaded apartment</em> (MTA). There are other kinds of apartments, but threads have only temporary membership in those; when a thread starts using COM, it must pick either STA or MTA mode. So there is, unsurprisingly, also an <code>[MTAThread]</code> attribute.</p>
</div></section>
<section data-pdf-bookmark="Interop" data-type="sect3"><div class="sect3" id="interop">
<h3>Interop</h3>
<p><a data-primary="interop services" data-type="indexterm" id="idm45884792747760"/>The CLR’s interop services define numerous attributes. Most of them are handled directly by the CLR, because interop is an intrinsic feature of the runtime. Since the attributes make sense only in the context of the mechanisms they support, and because there are so many, I will not describe them in full here, but <a data-type="xref" href="#interop_attributes_example">Example 14-19</a> illustrates the kinds of things they can do.</p>
<div data-type="example" id="interop_attributes_example">
<h5><span class="label">Example 14-19. </span>Interop attributes</h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="na">[DllImport("advapi32.dll", CharSet = CharSet.Unicode, SetLastError = true,</code>
<code class="na">           EntryPoint = "LookupPrivilegeValueW")]</code>
<code class="k">internal</code> <code class="k">static</code> <code class="k">extern</code> <code class="kt">bool</code> <code class="nf">LookupPrivilegeValue</code><code class="p">(</code>
<code class="na">    [MarshalAs(UnmanagedType.LPWStr)]</code> <code class="kt">string</code> <code class="n">lpSystemName</code><code class="p">,</code>
<code class="na">    [MarshalAs(UnmanagedType.LPWStr)]</code> <code class="kt">string</code> <code class="n">lpName</code><code class="p">,</code>
    <code class="k">out</code> <code class="n">LUID</code> <code class="n">lpLuid</code><code class="p">);</code></pre></div>
<p>This uses two interop attributes that we saw earlier in <a data-type="xref" href="#method_and_return_value_attributes">Example 14-7</a> but in a somewhat more complex way. This calls into a function exposed by <em>advapi32.dll</em>, part of the Win32 API. The first argument to the <code>DllImport</code> attribute tells us that, but unlike the earlier example, this goes on to provide the interop layer with additional information. This API deals with strings, so interop needs to know which character representation is in use. This particular API uses a common Win32 idiom: it returns a Boolean value to indicate success or failure, but it also uses the Windows <code>SetLastError</code> API to provide more information in the failure case. The attribute’s <code>SetLastError</code> property tells the interop layer to retrieve that immediately after calling this API so that .NET code can inspect it if necessary. The <code>EntryPoint</code> property deals with the fact that Win32 APIs taking strings sometimes come in two forms, working with either 8-bit or 16-bit characters (Windows 95 only supported 8-bit text, to conserve memory) and that we want to call the <em>Wide</em> form (hence the <code>W</code> suffix). It then uses <code>MarshalAs</code> on the two string arguments to tell the interop layer which of the many different string representations available in unmanaged code this particular API expects<a data-startref="ix_ch14-asciidoc4" data-type="indexterm" id="idm45884792719792"/>.<a data-startref="ix_ch14-asciidoc1" data-type="indexterm" id="idm45884792719072"/></p>
</div></section>
</div></section>
</div></section>
<section data-pdf-bookmark="Defining and Consuming Attributes" data-type="sect1"><div class="sect1" id="defining_and_consuming_custom_attributes">
<h1>Defining and Consuming Attributes</h1>
<p><a data-primary="attributes" data-secondary="defining and consuming attributes" data-type="indexterm" id="ix_ch14-asciidoc7"/>The vast majority of attributes you will come across are not intrinsic to the runtime or compiler. They are defined by class libraries and have an effect only if you are using the relevant libraries or frameworks. You are free to do exactly the same in your own code—you can define your own attribute types. Because attributes don’t do anything on their own—they don’t even get instantiated unless something asks to see them—it is normally useful to define an attribute type only if you’re writing some sort of framework, particularly one that is driven by reflection.</p>
<p>For example, unit test frameworks often discover the test classes you write via reflection and enable you to control the test runner’s behavior with attributes. Another example is how Visual Studio uses reflection to discover the properties of editable objects on design surfaces (such as UI controls), and it will look for certain attributes that enable you to customize the editing behavior. Another application of attributes is to opt out of rules applied by the static code analysis tools. (The .NET SDK has built-in tools for detecting potential problems in your code. This is an extensible system, and NuGet packages can add analyzers that expand on this, potentially detecting common mistakes specific to a particular library.) Sometimes these tools get it wrong, and you can suppress their warnings by annotating your code with attributes.</p>
<p>The common theme here is that some tool or framework examines your code and decides what to do based on what it finds. This is the kind of scenario in which attributes are a good fit. For example, attributes could be useful if you write an application that end users could extend. You might support loading of external assemblies that augment your application’s behavior—this is often known as a <em>plug-in</em> model. It might be useful to define an attribute that allows a plug-in to provide descriptive information about itself. It’s not strictly necessary to use attributes—you would probably define at least one interface that all plug-ins are required to implement, and you could have members in that interface for retrieving the necessary information. However, one advantage of using attributes is that you would not need to create an instance of the plug-in just to retrieve the description information. That would enable you to show the plug-in’s details to the user before loading it, which might be important if constructing the plug-in could have side effects that the user might 
<span class="keep-together">not want.</span></p>
<section data-pdf-bookmark="Attribute Types" data-type="sect2"><div class="sect2" id="attribute_type">
<h2>Attribute Types</h2>
<p><a data-primary="attributes" data-secondary="attribute types" data-type="indexterm" id="idm45884792711344"/><a data-type="xref" href="#an_attribute_type">Example 14-20</a> shows how an attribute containing information about a plug-in might look.</p>
<div data-type="example" id="an_attribute_type">
<h5><span class="label">Example 14-20. </span>An attribute type</h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="na">[AttributeUsage(AttributeTargets.Class)]</code>
<code class="k">public</code> <code class="k">class</code> <code class="nc">PluginInformationAttribute</code> <code class="p">:</code> <code class="n">Attribute</code>
<code class="p">{</code>
    <code class="k">public</code> <code class="nf">PluginInformationAttribute</code><code class="p">(</code><code class="kt">string</code> <code class="n">name</code><code class="p">,</code> <code class="kt">string</code> <code class="n">author</code><code class="p">)</code>
    <code class="p">{</code>
        <code class="n">Name</code> <code class="p">=</code> <code class="n">name</code><code class="p">;</code>
        <code class="n">Author</code> <code class="p">=</code> <code class="n">author</code><code class="p">;</code>
    <code class="p">}</code>

    <code class="k">public</code> <code class="kt">string</code> <code class="n">Name</code> <code class="p">{</code> <code class="k">get</code><code class="p">;</code> <code class="p">}</code>

    <code class="k">public</code> <code class="kt">string</code> <code class="n">Author</code> <code class="p">{</code> <code class="k">get</code><code class="p">;</code> <code class="p">}</code>

    <code class="k">public</code> <code class="kt">string?</code> <code class="n">Description</code> <code class="p">{</code> <code class="k">get</code><code class="p">;</code> <code class="k">set</code><code class="p">;</code> <code class="p">}</code>
<code class="p">}</code></pre></div>
<p><a data-primary="Attribute base class" data-type="indexterm" id="idm45884792655792"/>To act as an attribute, a type must derive from the <code>Attribute</code> base class. Although <code>Attribute</code> defines various static methods for discovering and retrieving attributes, it does not provide very much of interest for instances. We do not derive from it to get any particular functionality; we do so because the compiler will not let you use a type as an attribute unless it derives from <code>Attribute</code>.</p>
<p>Notice that my type’s name ends in the word <code>Attribute</code>. This is not an absolute requirement, but it is an extremely widely used convention. As you saw earlier, it’s even built into the compiler, which automatically adds the <code>Attribute</code> suffix if you leave it out when applying an attribute. So there’s usually no reason not to follow this convention.</p>
<p>I’ve annotated my attribute type with an attribute. Most attribute types are annotated with the <code>AttributeUsageAttribute</code>, indicating the targets to which the attribute can usefully be applied. The C# compiler will enforce this. Since my attribute in <a data-type="xref" href="#an_attribute_type">Example 14-20</a> states that it may be applied only to classes, the compiler will generate an error if anyone attempts to apply it to anything else.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>As you’ve seen, sometimes when we apply an attribute, we need to state its target. For example, when an attribute appears before a method, its target is the method, unless you qualify it with the <code>return:</code> prefix. You might have hoped that you’d be able to leave out these prefixes when using attributes that can target only certain members. For example, if an attribute can be applied only to an assembly, do you really need the <code>assembly:</code> qualifier? However, C# doesn’t let you leave it off. It uses the <span class="keep-together"><code>AttributeUsageAttribute</code></span> only to verify that an attribute has not been misapplied.</p>
</div>
<p>My attribute defines only one constructor, so any code that uses it will have to pass the arguments that the constructor requires, as <a data-type="xref" href="#applying_a_custom_attribute">Example 14-21</a> does.</p>
<div data-type="example" id="applying_a_custom_attribute">
<h5><span class="label">Example 14-21. </span>Applying an attribute</h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="na">[PluginInformation("Reporting", "Endjin Ltd.")]</code>
<code class="k">public</code> <code class="k">class</code> <code class="nc">ReportingPlugin</code>
<code class="p">{</code>
    <code class="p">...</code>
<code class="p">}</code></pre></div>
<p>Attribute classes are free to define multiple constructor overloads to support different sets of information. They can also define properties as a way to support optional pieces of information. My attribute defines a <code>Description</code> property, which is not required because the constructor does not demand a value for it, but which I can set using the syntax I described earlier in this chapter. <a data-type="xref" href="#providing_an_optional_property_value_for">Example 14-22</a> shows how that looks for my attribute.</p>
<div data-type="example" id="providing_an_optional_property_value_for">
<h5><span class="label">Example 14-22. </span>Providing an optional property value for an attribute</h5>
<pre data-code-language="csharp" data-type="programlisting">
<code class="na">[PluginInformation("Reporting", "Endjin Ltd.",
    </code><strong><code class="na">Description = "Automated report generation")]</code></strong>
<code class="k">public</code> <code class="k">class</code> <code class="nc">ReportingPlugin</code>
<code class="p">{</code>
    <code class="p">.</code><code class="p">.</code><code class="p">.</code>
<code class="p">}</code></pre></div>
<p>So far, nothing I’ve shown will cause an instance of my <code>Plu⁠gin⁠Inf⁠orm⁠ation​Att⁠rib⁠ute</code> type to be created. These annotations are simply instructions for how the attribute should be initialized if anything asks to see it. So, if this attribute is to be useful, I need to write some code that will look for it.</p>
</div></section>
<section data-pdf-bookmark="Retrieving Attributes" data-type="sect2"><div class="sect2" id="retrieving_attributes">
<h2>Retrieving Attributes</h2>
<p><a data-primary="attributes" data-secondary="retrieving attributes" data-type="indexterm" id="ix_ch14-asciidoc8"/>You can discover whether a particular kind of attribute has been applied using the reflection API, which can also instantiate the attribute for you. In <a data-type="xref" href="ch13.xhtml#ch_reflection">Chapter 13</a>, I showed all of the reflection types representing the various targets to which attributes can be applied—types such as <code>MethodInfo</code>, <code>Type</code>, and <code>PropertyInfo</code>. These all implement an interface called <code>ICustomAttributeProvider</code>, as shown in <a data-type="xref" href="#icustomattributeprovider">Example 14-23</a>.</p>
<div data-type="example" id="icustomattributeprovider">
<h5><span class="label">Example 14-23. </span><code>ICustomAttributeProvider</code></h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="k">public</code> <code class="k">interface</code> <code class="n">ICustomAttributeProvider</code>
<code class="p">{</code>
    <code class="kt">object</code><code class="p">[]</code> <code class="nf">GetCustomAttributes</code><code class="p">(</code><code class="kt">bool</code> <code class="n">inherit</code><code class="p">);</code>
    <code class="kt">object</code><code class="p">[]</code> <code class="nf">GetCustomAttributes</code><code class="p">(</code><code class="n">Type</code> <code class="n">attributeType</code><code class="p">,</code> <code class="kt">bool</code> <code class="n">inherit</code><code class="p">);</code>
    <code class="kt">bool</code> <code class="nf">IsDefined</code><code class="p">(</code><code class="n">Type</code> <code class="n">attributeType</code><code class="p">,</code> <code class="kt">bool</code> <code class="n">inherit</code><code class="p">);</code>
<code class="p">}</code></pre></div>
<p>The <code>IsDefined</code> method simply tells you whether or not a particular attribute type is present—it does not instantiate it. The two <code>GetCustomAttributes</code> overloads create attributes and return them. (This is the point at which attributes are constructed and also when any properties the annotations specify are set.) The first overload returns all attributes applied to the target, while the second lets you request only those attributes of a particular type.</p>
<p>All of these methods take a <code>bool</code> argument that lets you specify whether you want only attributes that were applied directly to the target you’re inspecting or also attributes applied to the base type or types.</p>
<p>This interface was introduced in .NET 1.0, so it does not use generics, meaning you need to cast the objects that come back. Fortunately, the <code>Cus⁠tom⁠Att⁠rib⁠ute​Ext⁠ens⁠ions</code> static class defines several extension methods. Instead of defining them for the <code>ICustomAttributeProvider</code> interface, it extends the reflection classes that offer attributes. For example, if you have a variable of type <code>Type</code>, you could call <code>GetCustomAttribute&lt;PluginInformationAttribute&gt;()</code> on it, which would construct and return the plug-in information attribute or <code>null</code> if the attribute is not present. <a data-type="xref" href="#showing_plug-in_information">Example 14-24</a> uses this to show all of the plug-in information from all the DLLs in a particular folder.</p>
<div data-type="example" id="showing_plug-in_information">
<h5><span class="label">Example 14-24. </span>Showing plug-in information</h5>
<pre data-code-language="csharp" data-type="programlisting"><code class="k">static</code> <code class="k">void</code> <code class="nf">ShowPluginInformation</code><code class="p">(</code><code class="kt">string</code> <code class="n">pluginFolder</code><code class="p">)</code>
<code class="p">{</code>
    <code class="kt">var</code> <code class="n">dir</code> <code class="p">=</code> <code class="k">new</code> <code class="n">DirectoryInfo</code><code class="p">(</code><code class="n">pluginFolder</code><code class="p">)</code><code class="p">;</code>
    <code class="k">foreach</code> <code class="p">(</code><code class="n">FileInfo</code> <code class="n">file</code> <code class="k">in</code> <code class="n">dir</code><code class="p">.</code><code class="n">GetFiles</code><code class="p">(</code><code class="s">"*.dll"</code><code class="p">)</code><code class="p">)</code>
    <code class="p">{</code>
        <code class="n">Assembly</code> <code class="n">pluginAssembly</code> <code class="p">=</code> <code class="n">Assembly</code><code class="p">.</code><code class="n">LoadFrom</code><code class="p">(</code><code class="n">file</code><code class="p">.</code><code class="n">FullName</code><code class="p">)</code><code class="p">;</code>
        <code class="kt">var</code> <code class="n">plugins</code> <code class="p">=</code>
             <code class="k">from</code> <code class="n">type</code> <code class="k">in</code> <code class="n">pluginAssembly</code><code class="p">.</code><code class="n">ExportedTypes</code>
             <strong><code class="k">let</code> <code class="n">info</code> <code class="p">=</code> <code class="n">type</code><code class="p">.</code><code class="n">GetCustomAttribute</code><code class="p">&lt;</code><code class="n">PluginInformationAttribute</code><code class="p">&gt;</code><code class="p">(</code><code class="p">)</code></strong>
             <code class="k">where</code> <code class="n">info</code> <code class="p">!</code><code class="p">=</code> <code class="k">null</code>
             <code class="k">select</code> <code class="k">new</code> <code class="p">{</code> <code class="n">type</code><code class="p">,</code> <code class="n">info</code> <code class="p">}</code><code class="p">;</code>

        <code class="k">foreach</code> <code class="p">(</code><code class="kt">var</code> <code class="n">plugin</code> <code class="k">in</code> <code class="n">plugins</code><code class="p">)</code>
        <code class="p">{</code>
            <code class="n">Console</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code><code class="err">$</code><code class="s">"Plugin type: {plugin.type.Name}"</code><code class="p">)</code><code class="p">;</code>
            <code class="n">Console</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code>
                <code class="err">$</code><code class="s">"Name: {plugin.info.Name}, written by {plugin.info.Author}"</code><code class="p">)</code><code class="p">;</code>
            <code class="n">Console</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code><code class="err">$</code><code class="s">"Description: {plugin.info.Description}"</code><code class="p">)</code><code class="p">;</code>
        <code class="p">}</code>
    <code class="p">}</code>
<code class="p">}</code>
</pre></div>
<p>There’s one potential problem with this. I said that one benefit of attributes is that they can be retrieved without instantiating their target types. That’s true here—I’m not constructing any of the plug-ins in <a data-type="xref" href="#showing_plug-in_information">Example 14-24</a>. However, I am loading the plug-in assemblies, and a possible side effect of enumerating the plug-ins would be to run static constructors in the plug-in DLLs. So, although I’m not deliberately running any code in those DLLs, I can’t guarantee that no code from those DLLs will run. If my goal is to present a list of plug-ins to the user, and to load and run only the ones explicitly selected, I’ve failed, because I’ve given plug-in code a chance to run. However, we can fix this.</p>
</div></section>
<section data-pdf-bookmark="Metadata-Only Load" data-type="sect2"><div class="sect2" id="metadata-only_load">
<h2>Metadata-Only Load</h2>
<p><a data-primary="assemblies" data-secondary="reflection-only load" data-type="indexterm" id="idm45884792279840"/><a data-primary="attributes" data-secondary="reflection-only load" data-type="indexterm" id="idm45884792278464"/><a data-primary="reflection-only load" data-type="indexterm" id="idm45884792300240"/><a data-primary="assemblies" data-secondary="metadata-only load" data-type="indexterm" id="idm45884792299568"/><a data-primary="attributes" data-secondary="metadata-only load" data-type="indexterm" id="idm45884792298624"/><a data-primary="metadata-only load" data-type="indexterm" id="idm45884792297680"/><a data-primary="MetadataLoadContext class" data-type="indexterm" id="idm45884792297008"/>You do not need to load an assembly fully in order to retrieve attribute information. As I discussed in <a data-type="xref" href="ch13.xhtml#ch_reflection">Chapter 13</a>, you can load an assembly for reflection purposes only with the <code>MetadataLoadContext</code> class. This prevents any of the code in the assembly from running but enables you to inspect the types it contains. However, this presents a challenge for attributes. The usual way to inspect an attribute’s properties is to instantiate it by calling <code>GetCustomAttributes</code> or a related extension method. Since that involves constructing the attribute—which means running some code—it is not supported for assemblies loaded by <code>MetadataLoadContext</code> (not even if the attribute type in question were defined in a different assembly that had been fully loaded in the normal way). If I modified <a data-type="xref" href="#showing_plug-in_information">Example 14-24</a> to load the assembly with <code>Met⁠ada⁠ta​Loa⁠dCo⁠ntext</code>, the call to <code>Get⁠Cus⁠tom⁠Att⁠rib⁠ute⁠&lt;Pl⁠ugi⁠nIn⁠for⁠mat⁠ion​Att⁠rib⁠ute&gt;</code> would throw an exception.</p>
<p>When loading for metadata only, you have to use the <code>GetCustomAttributesData</code> method. Instead of instantiating the attribute for you, this returns the information stored in the metadata—the instructions for creating the attribute. <a data-type="xref" href="#retrieving_attributes_metadata_load">Example 14-25</a> shows a version of the relevant code from <a data-type="xref" href="#showing_plug-in_information">Example 14-24</a> modified to work this way. (It also includes the code required to initialize the <code>MetadataLoadContext</code>.)</p>
<div data-type="example" id="retrieving_attributes_metadata_load">
<h5><span class="label">Example 14-25. </span>Retrieving attributes with the <code>MetadataLoadContext</code></h5>
<pre data-code-language="csharp" data-type="programlisting">
<code class="kt">string</code><code class="p">[</code><code class="p">]</code> <code class="n">runtimeAssemblies</code> <code class="p">=</code> <code class="n">Directory</code><code class="p">.</code><code class="n">GetFiles</code><code class="p">(</code>
    <code class="n">RuntimeEnvironment</code><code class="p">.</code><code class="n">GetRuntimeDirectory</code><code class="p">(</code><code class="p">)</code><code class="p">,</code> <code class="s">"*.dll"</code><code class="p">)</code><code class="p">;</code>
<code class="kt">var</code> <code class="n">paths</code> <code class="p">=</code> <code class="k">new</code> <code class="n">List</code><code class="p">&lt;</code><code class="kt">string</code><code class="p">&gt;</code><code class="p">(</code><code class="n">runtimeAssemblies</code><code class="p">)</code><code class="p">;</code>
<code class="n">paths</code><code class="p">.</code><code class="n">Add</code><code class="p">(</code><code class="n">file</code><code class="p">.</code><code class="n">FullName</code><code class="p">)</code><code class="p">;</code>

<code class="kt">var</code> <code class="n">resolver</code> <code class="p">=</code> <code class="k">new</code> <code class="n">PathAssemblyResolver</code><code class="p">(</code><code class="n">paths</code><code class="p">)</code><code class="p">;</code>
<code class="kt">var</code> <code class="n">mlc</code> <code class="p">=</code> <code class="k">new</code> <code class="n">MetadataLoadContext</code><code class="p">(</code><code class="n">resolver</code><code class="p">)</code><code class="p">;</code>

<code class="n">Assembly</code> <code class="n">pluginAssembly</code> <code class="p">=</code> <code class="n">mlc</code><code class="p">.</code><code class="n">LoadFromAssemblyPath</code><code class="p">(</code><code class="n">file</code><code class="p">.</code><code class="n">FullName</code><code class="p">)</code><code class="p">;</code>
<code class="kt">var</code> <code class="n">plugins</code> <code class="p">=</code>
     <code class="k">from</code> <code class="n">type</code> <code class="k">in</code> <code class="n">pluginAssembly</code><code class="p">.</code><code class="n">ExportedTypes</code>
     <strong><code class="k">let</code> <code class="n">info</code> <code class="p">=</code> <code class="n">type</code><code class="p">.</code><code class="n">GetCustomAttributesData</code><code class="p">(</code><code class="p">)</code><code class="p">.</code><code class="n">SingleOrDefault</code><code class="p">(</code><code class="n">attrData</code> <code class="p">=</code><code class="p">&gt;</code></strong>
            <strong><code class="n">attrData</code><code class="p">.</code><code class="n">AttributeType</code><code class="p">.</code><code class="n">FullName</code> <code class="p">=</code><code class="p">=</code> <code class="n">pluginAttributeType</code><code class="p">.</code><code class="n">FullName</code><code class="p">)</code></strong>
     <code class="k">where</code> <code class="n">info</code> <code class="p">!</code><code class="p">=</code> <code class="k">null</code>
     <code class="k">let</code> <code class="n">description</code> <code class="p">=</code> <code class="n">info</code><code class="p">.</code><code class="n">NamedArguments</code>
                           <code class="p">.</code><code class="n">SingleOrDefault</code><code class="p">(</code><code class="n">a</code> <code class="p">=</code><code class="p">&gt;</code> <code class="n">a</code><code class="p">.</code><code class="n">MemberName</code> <code class="p">=</code><code class="p">=</code> <code class="s">"Description"</code><code class="p">)</code>
     <code class="k">select</code> <code class="k">new</code>
     <code class="p">{</code>
         <code class="n">type</code><code class="p">,</code>
         <code class="n">Name</code> <code class="p">=</code> <code class="p">(</code><code class="kt">string</code><code class="p">)</code> <code class="n">info</code><code class="p">.</code><code class="n">ConstructorArguments</code><code class="p">[</code><code class="m">0</code><code class="p">]</code><code class="p">.</code><code class="n">Value</code><code class="p">,</code>
         <code class="n">Author</code> <code class="p">=</code> <code class="p">(</code><code class="kt">string</code><code class="p">)</code> <code class="n">info</code><code class="p">.</code><code class="n">ConstructorArguments</code><code class="p">[</code><code class="m">1</code><code class="p">]</code><code class="p">.</code><code class="n">Value</code><code class="p">,</code>
         <code class="n">Description</code> <code class="p">=</code>
             <code class="n">description</code> <code class="p">=</code><code class="p">=</code> <code class="k">null</code> <code class="p">?</code> <code class="k">null</code> <code class="p">:</code> <code class="n">description</code><code class="p">.</code><code class="n">TypedValue</code><code class="p">.</code><code class="n">Value</code>
     <code class="p">}</code><code class="p">;</code>

<code class="k">foreach</code> <code class="p">(</code><code class="kt">var</code> <code class="n">plugin</code> <code class="k">in</code> <code class="n">plugins</code><code class="p">)</code>
<code class="p">{</code>
    <code class="n">Console</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code><code class="err">$</code><code class="s">"Plugin type: {plugin.type.Name}"</code><code class="p">)</code><code class="p">;</code>
    <code class="n">Console</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code><code class="err">$</code><code class="s">"Name: {plugin.Name}, written by {plugin.Author}"</code><code class="p">)</code><code class="p">;</code>
    <code class="n">Console</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code><code class="err">$</code><code class="s">"Description: {plugin.Description}"</code><code class="p">)</code><code class="p">;</code>
<code class="p">}</code></pre></div>
<p>The code is rather more cumbersome because we don’t get back an instance of the attribute. <code>GetCustomAttributesData</code> returns a collection of <code>CustomAttributeData</code> objects. <a data-type="xref" href="#retrieving_attributes_metadata_load">Example 14-25</a> uses LINQ’s <code>SingleOrDefault</code> operator to find the entry for the <code>PluginInformationAttribute</code>, and if that’s present, the <code>info</code> variable in the query will end up holding a reference to the relevant <code>CustomAttributeData</code> object. The code then picks through the constructor arguments and property values using the <code>ConstructorArguments</code> and <code>NamedArguments</code> properties, enabling it to retrieve the three descriptive text values embedded in the attribute.</p>
<p>As this demonstrates, the <code>MetadataLoadContext</code> adds complexity, so you should use it only if you need the benefits it offers. One benefit is the fact that it won’t run any of the assemblies you load. It can also load assemblies that might be rejected if they were loaded normally (e.g., because they target a specific processor architecture that doesn’t match your process). But if you don’t need the metadata-only option, accessing the attributes directly, as <a data-type="xref" href="#showing_plug-in_information">Example 14-24</a> does, is more convenient<a data-startref="ix_ch14-asciidoc8" data-type="indexterm" id="idm45884792225392"/>.<a data-startref="ix_ch14-asciidoc7" data-type="indexterm" id="idm45884792224592"/></p>
</div></section>
</div></section>
<section data-pdf-bookmark="Summary" data-type="sect1"><div class="sect1" id="summary-id14">
<h1>Summary</h1>
<p>Attributes provide a way to embed custom data into an assembly’s metadata. You can apply attributes to a type, any member of a type, a parameter, a return value, or even a whole assembly or one of its modules. A handful of attributes get special handling from the CLR, and a few control compiler features, but most have no intrinsic behavior, acting merely as passive information containers. Attributes do not even get instantiated unless something asks to see them. All of this makes attributes most useful in systems with reflection-driven behavior—if you already have one of the reflection API objects such as <code>ParameterInfo</code> or <code>Type</code>, you can ask it directly for attributes. You therefore most often see attributes used in frameworks that inspect your code with reflection, such as unit test frameworks, serialization frameworks, data-driven UI elements like Visual Studio’s Properties panel, or plug-in frameworks. If you are using a framework of this kind, you will typically be able to configure its behavior by annotating your code with the attributes the framework recognizes. If you are writing this sort of framework, then it may make sense to define your own attribute types.<a data-startref="ix_ch14-asciidoc0" data-type="indexterm" id="idm45884792193616"/></p>
</div></section>
</div></section></div></body></html>