["```cs\npublic static Task<string> DownloadStringTaskAsync(this WebClient client,\n    Uri address)\n{\n  var tcs = new TaskCompletionSource<string>();\n\n  // The event handler will complete the task and unregister itself.\n  DownloadStringCompletedEventHandler handler = null;\n  handler = (_, e) =>\n  {\n    client.DownloadStringCompleted -= handler;\n    if (e.Cancelled)\n      tcs.TrySetCanceled();\n    else if (e.Error != null)\n      tcs.TrySetException(e.Error);\n    else\n      tcs.TrySetResult(e.Result);\n  };\n\n  // Register for the event and *then* start the operation.\n  client.DownloadStringCompleted += handler;\n  client.DownloadStringAsync(address);\n\n  return tcs.Task;\n}\n```", "```cs\npublic static Task<WebResponse> GetResponseAsync(this WebRequest client)\n{\n  return Task<WebResponse>.Factory.FromAsync(client.BeginGetResponse,\n      client.EndGetResponse, null);\n}\n```", "```cs\npublic interface IMyAsyncHttpService\n{\n  void DownloadString(Uri address, Action<string, Exception> callback);\n}\n```", "```cs\npublic static Task<string> DownloadStringAsync(\n    this IMyAsyncHttpService httpService, Uri address)\n{\n  var tcs = new TaskCompletionSource<string>();\n  httpService.DownloadString(address, (result, exception) =>\n  {\n    if (exception != null)\n      tcs.TrySetException(exception);\n    else\n      tcs.TrySetResult(result);\n  });\n  return tcs.Task;\n}\n```", "```cs\nawait Task.Run(() => Parallel.ForEach(...));\n```", "```cs\nIObservable<int> observable = ...;\nint lastElement = await observable.LastAsync();\n// or:  int lastElement = await observable;\n```", "```cs\nIObservable<int> observable = ...;\nint nextElement = await observable.FirstAsync();\n```", "```cs\nIObservable<int> observable = ...;\nIList<int> allElements = await observable.ToList();\n```", "```cs\nIObservable<HttpResponseMessage> GetPage(HttpClient client)\n{\n  Task<HttpResponseMessage> task =\n      client.GetAsync(\"http://www.example.com/\");\n  return task.ToObservable();\n}\n```", "```cs\nIObservable<HttpResponseMessage> GetPage(HttpClient client)\n{\n  return Observable.StartAsync(\n      token => client.GetAsync(\"http://www.example.com/\", token));\n}\n```", "```cs\nIObservable<HttpResponseMessage> GetPage(HttpClient client)\n{\n  return Observable.FromAsync(\n      token => client.GetAsync(\"http://www.example.com/\", token));\n}\n```", "```cs\nIObservable<HttpResponseMessage> GetPages(\n    IObservable<string> urls, HttpClient client)\n{\n  return urls.SelectMany(\n      (url, token) => client.GetAsync(url, token));\n}\n```", "```cs\npublic static class DataflowExtensions\n{\n  public static bool TryReceiveItem<T>(this ISourceBlock<T> block, out T value)\n  {\n    if (block is IReceivableSourceBlock<T> receivableSourceBlock)\n      return receivableSourceBlock.TryReceive(out value);\n\n    try\n    {\n      value = block.Receive(TimeSpan.Zero);\n      return true;\n    }\n    catch (TimeoutException)\n    {\n      // There is no item available right now.\n      value = default;\n      return false;\n    }\n    catch (InvalidOperationException)\n    {\n      // The block is complete and there are no more items.\n      value = default;\n      return false;\n    }\n  }\n\n  public static async IAsyncEnumerable<T> ReceiveAllAsync<T>(\n      this ISourceBlock<T> block,\n [EnumeratorCancellation] CancellationToken cancellationToken = default)\n  {\n    while (await block\n        .OutputAvailableAsync(cancellationToken).ConfigureAwait(false))\n    {\n      while (block.TryReceiveItem(out var value))\n      {\n        yield return value;\n      }\n    }\n  }\n}\n```", "```cs\nvar multiplyBlock = new TransformBlock<int, int>(value => value * 2);\n\nmultiplyBlock.Post(5);\nmultiplyBlock.Post(2);\nmultiplyBlock.Complete();\n\nawait foreach (int item in multiplyBlock.ReceiveAllAsync())\n{\n  Console.WriteLine(item);\n}\n```", "```cs\npublic static async Task WriteToBlockAsync<T>(\n    this IAsyncEnumerable<T> enumerable,\n    ITargetBlock<T> block, CancellationToken token = default)\n{\n  try\n  {\n    await foreach (var item in enumerable\n        .WithCancellation(token).ConfigureAwait(false))\n    {\n      await block.SendAsync(item, token).ConfigureAwait(false);\n    }\n\n    block.Complete();\n  }\n  catch (Exception ex)\n  {\n    block.Fault(ex);\n  }\n}\n```", "```cs\nvar buffer = new BufferBlock<int>();\nIObservable<int> integers = buffer.AsObservable();\nintegers.Subscribe(data => Trace.WriteLine(data),\n    ex => Trace.WriteLine(ex),\n    () => Trace.WriteLine(\"Done\"));\n\nbuffer.Post(13);\n```", "```cs\nIObservable<DateTimeOffset> ticks =\n    Observable.Interval(TimeSpan.FromSeconds(1))\n        .Timestamp()\n        .Select(x => x.Timestamp)\n        .Take(5);\n\nvar display = new ActionBlock<DateTimeOffset>(x => Trace.WriteLine(x));\nticks.Subscribe(display.AsObserver());\n\ntry\n{\n  display.Completion.Wait();\n  Trace.WriteLine(\"Done.\");\n}\ncatch (Exception ex)\n{\n  Trace.WriteLine(ex);\n}\n```", "```cs\nIObservable<long> observable =\n    Observable.Interval(TimeSpan.FromSeconds(1));\n\n// WARNING: May consume unbounded memory; see discussion!\nIAsyncEnumerable<long> enumerable =\n    observable.ToAsyncEnumerable();\n```", "```cs\n// WARNING: May consume unbounded memory; see discussion!\npublic static async IAsyncEnumerable<T> ToAsyncEnumerable<T>(\n    this IObservable<T> observable)\n{\n  Channel<T> buffer = Channel.CreateUnbounded<T>();\n  using (observable.Subscribe(\n      value => buffer.Writer.TryWrite(value),\n      error => buffer.Writer.Complete(error),\n      () => buffer.Writer.Complete()))\n  {\n    await foreach (T item in buffer.Reader.ReadAllAsync())\n      yield return item;\n  }\n}\n```", "```cs\n// WARNING: May discard items; see discussion!\npublic static async IAsyncEnumerable<T> ToAsyncEnumerable<T>(\n    this IObservable<T> observable, int bufferSize)\n{\n  var bufferOptions = new BoundedChannelOptions(bufferSize)\n  {\n    FullMode = BoundedChannelFullMode.DropOldest,\n  };\n  Channel<T> buffer = Channel.CreateBounded<T>(bufferOptions);\n  using (observable.Subscribe(\n      value => buffer.Writer.TryWrite(value),\n      error => buffer.Writer.Complete(error),\n      () => buffer.Writer.Complete()))\n  {\n    await foreach (T item in buffer.Reader.ReadAllAsync())\n      yield return item;\n  }\n}\n```"]