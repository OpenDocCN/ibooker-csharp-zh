["```cs\npublic interface IObservable<out T>\n{\n    IDisposable Subscribe(IObserver<T> observer);\n}\n\npublic interface IObserver<in T>\n{\n    void OnCompleted();\n    void OnError(Exception error);\n    void OnNext(T value);\n}\n```", "```cs\nclass MySubscriber<T> : IObserver<T>\n{\n    public void OnNext(T value) => Console.WriteLine(\"Received: \" + value);\n    public void OnCompleted() => Console.WriteLine(\"Complete\");\n    public void OnError(Exception ex) => Console.WriteLine(\"Error: \" + ex);\n}\n```", "```cs\npublic class SimpleColdSource : IObservable<string>\n{\n    public IDisposable Subscribe(IObserver<string> observer)\n    {\n        observer.OnNext(\"Hello,\");\n        observer.OnNext(\"World!\");\n        observer.OnCompleted();\n        return NullDisposable.Instance;\n    }\n\n    private class NullDisposable : IDisposable\n    {\n        public readonly static NullDisposable Instance = new();\n        public void Dispose() { }\n    }\n}\n```", "```cs\nvar source = new SimpleColdSource();\nvar sub = new MySubscriber<string>();\nsource.Subscribe(sub);\n```", "```cs\nReceived: Hello,\nReceived: World!\nComplete\n```", "```cs\npublic class FilePusher : IObservable<string>\n{\n    private readonly string _path;\n    public FilePusher(string path)\n    {\n        _path = path;\n    }\n\n    public IDisposable Subscribe(IObserver<string> observer)\n    {\n        using (var sr = new StreamReader(_path))\n        {\n            while (!sr.EndOfStream)\n            {\n                string? line = sr.ReadLine();\n                if (line is not null)\n                {\n                    observer.OnNext(line);\n                }\n            }\n        }\n        observer.OnCompleted();\n        return NullDisposable.Instance;\n    }\n\n    private class NullDisposable : IDisposable\n    {\n        public static NullDisposable Instance = new();\n        public void Dispose() { }\n    }\n}\n```", "```cs\npublic IDisposable Subscribe(IObserver<string> observer)\n{\n    StreamReader? sr = null;\n    string? line = null;\n    bool failed = false;\n\n    try\n    {\n        while (true)\n        {\n            try\n            {\n                if (sr == null)\n                {\n                    sr = new StreamReader(_path);\n                }\n                if (sr.EndOfStream)\n                {\n                    break;\n                }\n                line = sr.ReadLine();\n            }\n            catch (IOException x)\n            {\n                observer.OnError(x);\n                failed = true;\n                break;\n            }\n\n            if (line is not null)\n            {\n                observer.OnNext(line);\n            }\n            else\n            {\n                break;\n            }\n        }\n    }\n    finally\n    {\n        if (sr != null)\n        {\n            sr.Dispose();\n        }\n    }\n    if (!failed)\n    {\n        observer.OnCompleted();\n    }\n    return NullDisposable.Instance;\n}\n```", "```cs\npublic class KeyWatcher : IObservable<char>\n{\n    private readonly List<Subscription> _subscriptions = new();\n\n    public IDisposable Subscribe(IObserver<char> observer)\n    {\n        var sub = new Subscription(this, observer);\n        _subscriptions.Add(sub);\n        return sub;\n    }\n\n    public void Run()\n    {\n        while (true)\n        {\n            // Passing true here stops the console from showing the character\n            char c = Console.ReadKey(true).KeyChar;\n\n            // ToArray duplicates the list, enabling us to iterate over a\n            // snapshot of our subscribers. This handles the case where an\n            // observer unsubscribes from inside its OnNext method.\n            foreach (Subscription sub in _subscriptions.ToArray())\n            {\n                sub.Observer.OnNext(c);\n            }\n        }\n    }\n\n    private void RemoveSubscription(Subscription sub)\n    {\n        _subscriptions.Remove(sub);\n    }\n\n    private class Subscription : IDisposable\n    {\n        private KeyWatcher? _parent;\n        public Subscription(KeyWatcher parent, IObserver<char> observer)\n        {\n            _parent = parent;\n            Observer = observer;\n        }\n\n        public IObserver<char> Observer { get; }\n\n        public void Dispose()\n        {\n            if (_parent is not null)\n            {\n                _parent.RemoveSubscription(this);\n                _parent = null;\n            }\n        }\n    }\n}\n```", "```cs\nvar source = new KeyWatcher();\nvar sub = new MySubscriber<char>();\nsource.Subscribe(sub);\nsource.Run();\n```", "```cs\npublic static IObservable<string> GetFilePusher(string path)\n{\n    return Observable.Create<string>(observer =>\n    {\n        using (var sr = new StreamReader(path))\n        {\n            while (!sr.EndOfStream)\n            {\n                string? line = sr.ReadLine();\n                if (line is not null)\n                {\n                    observer.OnNext(line);\n                }\n                else\n                {\n                    break;\n                }\n            }\n        }\n        observer.OnCompleted();\n        return () => { };\n    });\n}\n```", "```cs\npublic static IObservable<string> GetFilePusher(string path)\n{\n    `return` `Observable``.``Create``<``string``>``(``async` `(``observer``,` `cancel``)` `=``>`\n    {\n        using (var sr = new StreamReader(path))\n        {\n            `while` `(``!``sr``.``EndOfStream` `&``&` `!``cancel``.``IsCancellationRequested``)`\n            {\n                `string?` `line` `=` `await` `sr``.``ReadLineAsync``(``)``;`\n                if (line is not null)\n                {\n                    observer.OnNext(line);\n                }\n                else\n                {\n                    break;\n                }\n            }\n        }\n        observer.OnCompleted();\n    });\n}\n```", "```cs\nIObservable<char> singularHotSource = Observable.Create(\n    (Func<IObserver<char>, IDisposable>) (obs =>\n    {\n        while (true)\n        {\n            obs.OnNext(Console.ReadKey(true).KeyChar);\n        }\n    }));\n\nIConnectableObservable<char> keySource = singularHotSource.Publish();\n\nkeySource.Subscribe(new MySubscriber<char>());\nkeySource.Subscribe(new MySubscriber<char>());\n\nkeySource.Connect();\n```", "```cs\nvar source = new KeyWatcher();\n`source``.``Subscribe``(``value` `=``>` `Console``.``WriteLine``(``\"Received: \"` `+` `value``)``)``;`\nsource.Run();\n```", "```cs\nIObservable<int> src = Observable.Generate(\n    (Current: 0, Total: 0, Random: new Random()),\n    state => state.Total <= 10000,\n    state =>\n    {\n        int value = state.Random.Next(1000);\n        return (value, state.Total + value, state.Random);\n    },\n    state => state.Current);\n```", "```cs\nIObservable<int> src = Observable.Generate(\n    (Current: 0, Total: 0, Random: new Random()),\n    state => state.Total < 10000,\n    state =>\n    {\n        int value = state.Random.Next(1000);\n        return (value, state.Total + value, state.Random);\n    },\n    state => state.Current,\n    state => TimeSpan.FromMilliseconds(state.Random.Next(1000)));\n```", "```cs\nIObservable<EventPattern<MouseEventArgs>> mouseMoves =\n    Observable.FromEventPattern<MouseEventArgs>(\n        background, nameof(background.MouseMove));\n\n`IObservable``<``Point``>` `dragPositions` `=`\n    `from` `move` `in` `mouseMoves`\n    `where` `Mouse``.``Captured` `=``=` `background`\n    `select` `move``.``EventArgs``.``GetPosition``(``background``)``;`\n\ndragPositions.Subscribe(point => { line.Points.Add(point); });\n```", "```cs\nprivate void OnBackgroundMouseDown(object sender, MouseButtonEventArgs e)\n{\n    background.CaptureMouse();\n}\n\nprivate void OnBackgroundMouseUp(object sender, MouseButtonEventArgs e)\n{\n    if (Mouse.Captured == background)\n    {\n        background.ReleaseMouseCapture();\n    }\n}\n```", "```cs\nstring path = Environment.GetFolderPath(Environment.SpecialFolder.MyDocuments);\nvar w = new FileSystemWatcher(path);\nIObservable<EventPattern<FileSystemEventArgs>> changes =\n    Observable.FromEventPattern<FileSystemEventHandler, FileSystemEventArgs>(\n        h => w.Changed += h, h => w.Changed -= h);\nw.IncludeSubdirectories = true;\nw.EnableRaisingEvents = true;\n\nIObservable<IGroupedObservable<string, string>> folders =\n    from change in changes\n    group Path.GetFileName(change.EventArgs.FullPath)\n       by Path.GetDirectoryName(change.EventArgs.FullPath);\n\nfolders.Subscribe(f =>\n{\n    Console.WriteLine(\"New folder ({0})\", f.Key);\n    f.Subscribe(file =>\n        Console.WriteLine(\"File changed in folder {0}, {1}\", f.Key, file));\n});\n```", "```cs\nIObservable<EventPattern<MouseEventArgs>> downs =\n    Observable.FromEventPattern<MouseEventArgs>(\n        background, nameof(background.MouseDown));\nIObservable<EventPattern<MouseEventArgs>> ups =\n    Observable.FromEventPattern<MouseEventArgs>(\n        background, nameof(background.MouseUp));\nIObservable<EventPattern<MouseEventArgs>> allMoves =\n    Observable.FromEventPattern<MouseEventArgs>(\n        background, nameof(background.MouseMove));\n\nIObservable<Point> dragPositions =\n    from down in downs\n    join move in allMoves\n      on ups equals allMoves\n    select move.EventArgs.GetPosition(background);\n```", "```cs\nIObservable<Point> dragPositions = downs.Join(\n    allMoves,\n    down => ups,\n    move => allMoves,\n    (down, move) => move.EventArgs.GetPosition(background));\n```", "```cs\nvar dragPointSets = from mouseDown in downs\n                    join move in allMoves\n                      on ups equals allMoves into m\n                    select m.Select(e => e.EventArgs.GetPosition(background));\n\ndragPointSets.Subscribe(dragPoints =>\n{\n    var currentLine = new Polyline { Stroke = Brushes.Black, StrokeThickness = 2 };\n    background.Children.Add(currentLine);\n\n    dragPoints.Subscribe(point =>\n    {\n        currentLine.Points.Add(point);\n    });\n});\n```", "```cs\nIObservable<EventPattern<MouseEventArgs>> downs =\n    Observable.FromEventPattern<MouseEventArgs>(\n        background, nameof(background.MouseDown));\nIObservable<EventPattern<MouseEventArgs>> ups =\n    Observable.FromEventPattern<MouseEventArgs>(\n        background, nameof(background.MouseUp));\nIObservable<EventPattern<MouseEventArgs>> allMoves =\n    Observable.FromEventPattern<MouseEventArgs>(\n        background, nameof(background.MouseMove));\n\nIObservable<EventPattern<MouseEventArgs>> dragMoves =\n    from move in allMoves\n    where Mouse.Captured == background\n    select move;\n\n`IObservable``<``EventPattern``<``MouseEventArgs``>``>` `allDragPositionEvents` `=`\n    `Observable``.``Merge``(``downs``,` `ups``,` `dragMoves``)``;`\n\nIObservable<Point> dragPositions =\n    from move in allDragPositionEvents\n    select move.EventArgs.GetPosition(background);\n```", "```cs\nIObservable<Point> smoothed = from points in dragPositions.Buffer(5, 2)\n                              let x = points.Average(p => p.X)\n                              let y = points.Average(p => p.Y)\n                              select new Point(x, y);\n```", "```cs\nIObservable<Point> smoothed =\n    from points in dragPositions.Window(5, 2)\n    from totals in points.Aggregate(\n      new { X = 0.0, Y = 0.0, Count = 0 },\n      (acc, point) => new\n          { X = acc.X + point.X, Y = acc.Y + point.Y, Count = acc.Count + 1 })\n    where totals.Count > 0\n    select new Point(totals.X / totals.Count, totals.Y / totals.Count);\n```", "```cs\nIObservable<IObservable<char>> wordWindows = keySource.Window(\n    () => keySource.FirstAsync(char.IsWhiteSpace));\n\nIObservable<string> words = from wordWindow in wordWindows\n                            from chars in wordWindow.ToArray()\n                            select new string(chars).Trim();\n\nwords.Subscribe(word => Console.WriteLine(\"Word: \" + word));\n```", "```cs\nIObservable<IList<char>> wordWindows = keySource.Buffer(\n    () => keySource.FirstAsync(char.IsWhiteSpace));\n\nIObservable<string> words = from wordWindow in wordWindows\n                            select new string(wordWindow.ToArray()).Trim();\n```", "```cs\npublic record Trade(string StockName, decimal UnitPrice, int Number)\n{\n    public static IObservable<Trade> TestStream()\n    {\n        return Observable.Create<Trade>(obs =>\n        {\n            string[] names = { \"MSFT\", \"GOOGL\", \"AAPL\" };\n            var r = new Random(0);\n            for (int i = 0; i < 100; ++i)\n            {\n                var t = new Trade(\n                    StockName: names[r.Next(names.Length)],\n                    UnitPrice: r.Next(1, 100),\n                    Number: r.Next(10, 1000));\n                obs.OnNext(t);\n            }\n            obs.OnCompleted();\n            return Disposable.Empty;\n        });\n    }\n}\n```", "```cs\nIObservable<Trade> trades = Trade.TestStream();\n\nIObservable<long> tradeVolume = trades.Aggregate(\n    0L, (total, trade) => total + trade.Number);\ntradeVolume.Subscribe(Console.WriteLine);\n```", "```cs\nIObservable<Trade> trades = Trade.TestStream();\n\nIObservable<long> tradeVolume = trades.Scan(\n    0L, (total, trade) => total + trade.Number);\ntradeVolume.Subscribe(Console.WriteLine);\n```", "```cs\nIObservable<Trade> trades = GetTradeStream();\nIObservable<Trade> tradesInUiContext =\n    `trades``.``ObserveOn``(``DispatcherScheduler``.``Current``)``;`\ntradesInUiContext.Subscribe(t =>\n{\n    tradeInfoTextBox.AppendText(\n        $\"{t.StockName}: {t.Number} at {t.UnitPrice}\\r\\n\");\n});\n```", "```cs\nIObservable<Trade> tradesInUiContext = trades.ObserveOn(this.Dispatcher);\n```", "```cs\nIObservable<Trade> tradesInUiContext = trades.ObserveOnDispatcher();\n```", "```cs\npublic class KeyWatcher : IObservable<char>\n{\n    private readonly Subject<char> _subject = new();\n\n    public IDisposable Subscribe(IObserver<char> observer)\n    {\n        return _subject.Subscribe(observer);\n    }\n\n    public void Run()\n    {\n        while (true)\n        {\n            _subject.OnNext(Console.ReadKey(true).KeyChar);\n        }\n    }\n}\n```", "```cs\npublic class KeyWatcher\n{\n    private readonly Subject<char> _subject = new();\n\n    public IObservable<char> Keys => _subject;\n\n    public void Run()\n    {\n        while (true)\n        {\n            _subject.OnNext(Console.ReadKey(true).KeyChar);\n        }\n    }\n}\n```", "```cs\npublic static void ShowAll(IEnumerable<string> source)\n{\n    `IObservable``<``string``>` `observableSource` `=` `source``.``ToObservable``(``)``;`\n    observableSource.Subscribe(Console.WriteLine);\n}\n```", "```cs\npublic static IObservable<T> MyToObservable<T>(this IEnumerable<T> input)\n{\n    return Observable.Create((IObserver<T> observer) =>\n        {\n            bool inObserver = false;\n            try\n            {\n                foreach (T item in input)\n                {\n                    inObserver = true;\n                    observer.OnNext(item);\n                    inObserver = false;\n                }\n                inObserver = true;\n                observer.OnCompleted();\n            }\n            catch (Exception x)\n            {\n                if (inObserver)\n                {\n                    throw;\n                }\n                observer.OnError(x);\n            }\n            return () => { };\n        });\n}\n```", "```cs\npublic static void ShowAll(IObservable<string> source)\n{\n    foreach (string s in source.ToEnumerable())\n    {\n        Console.WriteLine(s);\n    }\n}\n```", "```cs\nstring path = Environment.GetFolderPath(Environment.SpecialFolder.MyPictures);\nvar watcher = new FileSystemWatcher(path);\nwatcher.EnableRaisingEvents = true;\n\nIObservable<EventPattern<FileSystemEventArgs>> changes =\n    Observable.FromEventPattern<FileSystemEventArgs>(\n        watcher, nameof(watcher.Created));\nchanges.Subscribe(evt => Console.WriteLine(evt.EventArgs.FullPath));\n```", "```cs\nIObservable<EventPattern<FileSystemEventArgs>> changes =\n    Observable.FromEventPattern<FileSystemEventHandler, FileSystemEventArgs>(\n    h => watcher.Created += h, h => watcher.Created -= h);\n```", "```cs\npublic static IObservable<string> GetWebPageAsObservable(\n    Uri pageUrl, IHttpClientFactory cf)\n{\n    HttpClient web = cf.CreateClient();\n    Task<string> getPageTask = web.GetStringAsync(pageUrl);\n    `return` `getPageTask``.``ToObservable``(``)``;`\n}\n```", "```cs\npublic static IObservable<string> GetWebPageAsObservable(\n    Uri pageUrl, IHttpClientFactory cf)\n{\n    return Observable.FromAsync(() =>\n        {\n            HttpClient web = cf.CreateClient();\n            return web.GetStringAsync(pageUrl);\n        });\n}\n```", "```cs\nIObservable<long> src = Observable.Interval(TimeSpan.FromSeconds(1));\nsrc.Subscribe(i => Console.WriteLine($\"Event {i} at {DateTime.Now:T}\"));\n```", "```cs\nThread.Sleep(2500);\nsrc.Subscribe(i => Console.WriteLine(\n    $\"Event {i} at {DateTime.Now:T} (2nd subscriber)\"));\n```", "```cs\nEvent 0 at 09:46:58\nEvent 1 at 09:46:59\nEvent 2 at 09:47:00\nEvent 0 at 09:47:00 (2nd subscriber)\nEvent 3 at 09:47:01\nEvent 1 at 09:47:01 (2nd subscriber)\nEvent 4 at 09:47:02\nEvent 2 at 09:47:02 (2nd subscriber)\nEvent 5 at 09:47:03\nEvent 3 at 09:47:03 (2nd subscriber)\n```", "```cs\nIObservable<long> ticks = Observable.Interval(TimeSpan.FromSeconds(6));\nIObservable<int> wordGroupCounts = from tick in ticks\n                                   join word in words\n                                     on ticks equals words into wordsInTick\n                                   from count in wordsInTick.Count()\n                                   select count * 10;\n\nwordGroupCounts.Subscribe(c => Console.WriteLine($\"Words per minute: {c}\"));\n```", "```cs\nIObservable<long> src = Observable.Timer(TimeSpan.FromSeconds(1));\nsrc.Subscribe(i => Console.WriteLine($\"Event {i} at {DateTime.Now:T}\"));\n```", "```cs\nIObservable<Timestamped<long>> src =\n    Observable.Interval(TimeSpan.FromSeconds(1)).Timestamp();\nsrc.Subscribe(i => Console.WriteLine(\n    $\"Event {i.Value} at {i.Timestamp.ToLocalTime():T}\"));\n```", "```cs\nIObservable<long> ticks = Observable.Interval(TimeSpan.FromSeconds(0.75));\nIObservable<TimeInterval<long>> timed = ticks.TimeInterval();\ntimed.Subscribe(x => Console.WriteLine(\n    $\"Event {x.Value} took {x.Interval.TotalSeconds:F3}\"));\n```", "```cs\nEvent 0 took 0.760\nEvent 1 took 0.757\nEvent 2 took 0.743\nEvent 3 took 0.751\nEvent 4 took 0.749\nEvent 5 took 0.750\n```", "```cs\nIObservable<int> wordGroupCounts =\n    from wordGroup in words.Buffer(TimeSpan.FromSeconds(6))\n    select wordGroup.Count * 10;\nwordGroupCounts.Subscribe(c => Console.WriteLine(\"Words per minute: \" + c));\n```", "```cs\nIObservable<int> wordGroupCounts =\n    from wordGroup in words.Buffer(TimeSpan.FromSeconds(6),\n                                   TimeSpan.FromSeconds(1))\n    select wordGroup.Count * 10;\n```"]