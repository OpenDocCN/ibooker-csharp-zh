["```cs\npublic interface IDisposable\n{\n  void Dispose();\n}\n```", "```cs\nusing (FileStream fs = new FileStream (\"myFile.txt\", FileMode.Open))\n{\n  // ... Write to the file ...\n}\n```", "```cs\nFileStream fs = new FileStream (\"myFile.txt\", FileMode.Open);\ntry\n{\n  // ... Write to the file ...\n}\nfinally\n{\n  if (fs != null) ((IDisposable)fs).Dispose();\n}\n```", "```cs\nusing FileStream fs = new FileStream (\"myFile.txt\", FileMode.Open);\n\n// ... Write to the file ...\n```", "```cs\nsealed class Demo : IDisposable\n{\n  public void Dispose()\n  {\n    // Perform cleanup / tear-down.\n    ...\n  }\n}\n```", "```cs\npublic bool IsDisposed { get; private set; }\n```", "```cs\nclass Foo\n{\n  int _suspendCount;\n\n  public void SuspendEvents() => _suspendCount++;           \n  public void ResumeEvents() => _suspendCount--;            \n\n  void FireSomeEvent()\n  {\n    if (_suspendCount == 0)\n      ... fire some event ...\n  }\n  ...\n}\n```", "```cs\nvar foo = new Foo();\nfoo.SuspendEvents();\ntry\n{\n  ... do stuff ...      // Because an exception could be thrown here\n}\nfinally\n{\n  foo.ResumeEvents();   // ...we must call this in a finally block\n}\n```", "```cs\nusing (foo.SuspendEvents())\n{\n  ... do stuff ...\n}\n```", "```cs\npublic IDisposable SuspendEvents()\n{\n  _suspendCount++;\n  return new SuspendToken (this);\n}\n\nclass SuspendToken : IDisposable \n{\n  Foo _foo;          \n  public SuspendToken (Foo foo) => _foo = foo;\n  public void Dispose()\n  {\n    if (_foo != null) _foo._suspendCount--;\n    _foo = null;  // Prevent against consumer disposing twice\n  }\n}\n```", "```cs\npublic class Disposable : IDisposable\n{\n  public static Disposable Create (Action onDispose)\n    => new Disposable (onDispose);\n\n  Action _onDispose;\n  Disposable (Action onDispose) => _onDispose = onDispose;\n\n  public void Dispose()\n  {\n    _onDispose?.Invoke();   // Execute disposal action if non-null.\n    _onDispose = null;      // Ensure it can’t execute a second time.\n  }\n}\n```", "```cs\npublic IDisposable SuspendEvents()\n{\n  _suspendCount++;\n  return Disposable.Create (() => _suspendCount--);\n}  \n```", "```cs\npublic void Test()\n{\n  byte[] myArray = new byte[1000];\n  ...\n}\n```", "```cs\nclass Test\n{\n  ˜Test()\n  {\n    // Finalizer logic...\n  }\n}\n```", "```cs\nclass Test : IDisposable\n{\n  public void Dispose()             // NOT virtual\n  {\n    Dispose (true);\n    GC.SuppressFinalize (this);     // Prevent finalizer from running.\n  }\n\n  protected virtual void Dispose (bool disposing)\n  {\n    if (disposing)\n    {\n      // Call Dispose() on other objects owned by this instance.\n      // You can reference other finalizable objects here.\n      // ...\n    }\n\n    // Release unmanaged resources owned by (just) this object.\n    // ...\n  }\n\n  ~Test() => Dispose (false);\n}\n```", "```cs\npublic class TempFileRef\n{\n  public readonly string FilePath;\n  public TempFileRef (string filePath) { FilePath = filePath; }\n\n  ~TempFileRef() { File.Delete (FilePath); }\n}\n```", "```cs\npublic class TempFileRef\n{\n  static internal readonly ConcurrentQueue<TempFileRef> FailedDeletions\n    = new ConcurrentQueue<TempFileRef>();\n\n  public readonly string FilePath;\n  public Exception DeletionError { get; private set; }\n\n  public TempFileRef (string filePath) { FilePath = filePath; }\n\n  ~TempFileRef()\n  {\n    try { File.Delete (FilePath); }\n    catch (Exception ex)\n    {\n      DeletionError = ex;\n      FailedDeletions.Enqueue (this);   // Resurrection\n    }\n  }\n}\n```", "```cs\npublic class TempFileRef\n{\n  public readonly string FilePath;\n  int _deleteAttempt;\n\n  public TempFileRef (string filePath) { FilePath = filePath; }\n\n  ~TempFileRef()\n  {\n    try { File.Delete (FilePath); }\n    catch\n    {\n      if (_deleteAttempt++ < 3) GC.ReRegisterForFinalize (this);\n    }\n  }\n}\n```", "```cs\nstring Foo()\n{\n  var sb1 = new StringBuilder (\"test\");\n  sb1.Append (\"...\");\n  var sb2 = new StringBuilder (\"test\");\n  sb2.Append (sb1.ToString());\n  return sb2.ToString();\n}\n```", "```cs\nGCSettings.LargeObjectHeapCompactionMode =\n  GCLargeObjectHeapCompactionMode.CompactOnce;\n```", "```cs\n<PropertyGroup>\n  <ServerGarbageCollection>true</ServerGarbageCollection>\n</PropertyGroup>\n```", "```cs\n  \"runtimeOptions\": {\n    \"configProperties\": {\n      \"System.GC.Server\": true\n    ...\n```", "```cs\n<PropertyGroup>\n  <ConcurrentGarbageCollection>false</ConcurrentGarbageCollection>\n</PropertyGroup>\n```", "```cs\n  \"runtimeOptions\": {\n    \"configProperties\": {\n      \"System.GC.Concurrent\": false,\n   ...\n```", "```cs\nGC.Collect();\nGC.WaitForPendingFinalizers();\nGC.Collect();\n```", "```cs\nint[] pooledArray = ArrayPool<int>.Shared.Rent (100);  // 100 bytes\n```", "```cs\nArrayPool<int>.Shared.Return (pooledArray);\n```", "```cs\nvar myPool = ArrayPool<int>.Create();\nint[] array = myPool.Rent (100);\n...\n```", "```cs\nclass Host\n{\n  public event EventHandler Click;\n}\n\nclass Client\n{\n  Host _host;\n  public Client (Host host)\n  {\n    _host = host;\n    _host.Click += HostClicked;\n  }\n\n  void HostClicked (object sender, EventArgs e) { ... }\n}\n```", "```cs\nclass Test\n{\n  static Host _host = new Host();\n\n  public static void CreateClients()\n  {\n    Client[] clients = Enumerable.Range (0, 1000)\n     .Select (i => new Client (_host))\n     .ToArray();\n\n    // Do something with clients ... \n  }\n}\n```", "```cs\npublic void Dispose() { _host.Click -= HostClicked; }\n```", "```cs\nArray.ForEach (clients, c => c.Dispose());\n```", "```cs\nusing System.Timers;\n\nclass Foo\n{\n  Timer _timer;\n\n  Foo() \n  {\n    _timer = new System.Timers.Timer { Interval = 1000 };\n    _timer.Elapsed += tmr_Elapsed;\n    _timer.Start();\n  }\n\n  void tmr_Elapsed (object sender, ElapsedEventArgs e) { ... }\n}\n```", "```cs\nclass Foo : IDisposable\n{\n  ...\n  public void Dispose() { _timer.Dispose(); }\n}\n```", "```cs\nstatic void Main()\n{\n  var tmr = new System.Threading.Timer (TimerTick, null, 1000, 1000);\n  GC.Collect();\n  System.Threading.Thread.Sleep (10000);    // Wait 10 seconds \n}\n\nstatic void TimerTick (object notUsed) { Console.WriteLine (\"tick\"); }\n```", "```cs\nusing (var tmr = new System.Threading.Timer (TimerTick, null, 1000, 1000))\n{\n  GC.Collect();\n  System.Threading.Thread.Sleep (10000);    // Wait 10 seconds \n}\n```", "```cs\nlong memoryUsed = GC.GetTotalMemory (true);\n```", "```cs\nvar sb = new StringBuilder (\"this is a test\");\nvar weak = new WeakReference (sb);\nConsole.WriteLine (weak.Target);     // This is a test\n```", "```cs\nvar weak = GetWeakRef();\nGC.Collect();\nConsole.WriteLine (weak.Target);   // (nothing)\n\nWeakReference GetWeakRef () => \n  new WeakReference (new StringBuilder (\"weak\"));\n```", "```cs\nvar sb = (StringBuilder) weak.Target;\nif (sb != null) { /* Do something with sb */ }\n```", "```cs\nclass Widget\n{\n  static List<WeakReference> _allWidgets = new List<WeakReference>();\n\n  public readonly string Name;\n\n  public Widget (string name)\n  {\n    Name = name;\n    _allWidgets.Add (new WeakReference (this));\n  }\n\n  public static void ListAllWidgets()\n  {\n    foreach (WeakReference weak in _allWidgets)\n    {\n      Widget w = (Widget)weak.Target;\n      if (w != null) Console.WriteLine (w.Name);\n    }\n  }\n}\n```", "```cs\n_weakCache = new WeakReference (...);   // _weakCache is a field\n...\nvar cache = _weakCache.Target;\nif (cache == null) { /* Re-create cache & assign it to _weakCache */ }\n```", "```cs\npublic class WeakDelegate<TDelegate> where TDelegate : Delegate\n{\n  class MethodTarget\n  {\n    public readonly WeakReference Reference;\n    public readonly MethodInfo Method;\n\n    public MethodTarget (Delegate d)\n    {\n      // d.Target will be null for static method targets:\n      if (d.Target != null) Reference = new WeakReference (d.Target);\n      Method = d.Method;\n    }\n  }\n\n  List<MethodTarget> _targets = new List<MethodTarget>();\n\n  public void Combine (TDelegate target)\n  {\n    if (target == null) return;\n\n    foreach (Delegate d in (target as Delegate).GetInvocationList())\n      _targets.Add (new MethodTarget (d));\n  }\n\n  public void Remove (TDelegate target)\n  {\n    if (target == null) return;\n    foreach (Delegate d in (target as Delegate).GetInvocationList())\n    {\n      MethodTarget mt = _targets.Find (w => \n        Equals (d.Target, w.Reference?.Target) &&\n        Equals (d.Method.MethodHandle, w.Method.MethodHandle));\n\n      if (mt != null) _targets.Remove (mt);\n    }\n  }\n\n  public TDelegate Target\n  {\n    get\n    {\n      Delegate combinedTarget = null;\n\n      foreach (MethodTarget mt in _targets.ToArray())\n      {\n        WeakReference wr = mt.Reference;\n\n        // Static target || alive instance target\n        if (wr == null || wr.Target != null)\n        {\n          var newDelegate = Delegate.CreateDelegate (\n            typeof(TDelegate), wr?.Target, mt.Method);\n            combinedTarget = Delegate.Combine (combinedTarget, newDelegate);\n        }\n        else\n          _targets.Remove (mt);\n      }\n\n      return combinedTarget as TDelegate;\n    }\n    set\n    {\n      _targets.Clear();\n      Combine (value);\n    }\n  }\n}\n```", "```cs\npublic class Foo\n{\n  WeakDelegate<EventHandler> _click = new WeakDelegate<EventHandler>();\n\n  public event EventHandler Click\n  {\n    add { _click.Combine (value); } remove { _click.Remove (value); }\n  }\n\n  protected virtual void OnClick (EventArgs e)\n    => _click.Target?.Invoke (this, e);\n}\n```"]