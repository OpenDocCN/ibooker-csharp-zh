- en: Chapter 5\. Localizing the App
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第五章。本地化应用程序
- en: In this chapter, I’m going to show you how to localize Blazor WebAssembly apps.
    Using the Learning Blazor App as an example, I’ll show you how an app can be automatically
    localized into dozens of languages. You’ll see how Blazor WebAssembly recognizes
    static resource files for the client browser’s corresponding language. You will
    also learn how to consume the framework-provided `IStringLocalizer<T>` interface
    type. Additionally, I’ll show you one possible way to machine translate static
    files at rest with a GitHub Action using the [Azure Cognitive Services Translator](https://oreil.ly/4RTN0).
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我将向您展示如何本地化 Blazor WebAssembly 应用程序。以学习 Blazor 应用程序为例，我将展示应用程序如何自动本地化为数十种语言。您将了解到
    Blazor WebAssembly 如何识别客户端浏览器对应的静态资源文件的语言。您还将学习如何使用框架提供的 `IStringLocalizer<T>`
    接口类型。此外，我还将向您展示使用 [Azure Cognitive Services Translator](https://oreil.ly/4RTN0)
    在静态文件上使用 GitHub Action 进行机器翻译的一种可能方法。
- en: We live in a global society, and an application that speaks to one group of
    people is a disappointment. Not only will this dramatically affect the UX for
    those who do not speak the app’s language, but if the app contributes to an online
    shopping experience, for example, it will have a detrimental effect on sales as
    well. This is where localization comes in.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们生活在一个全球化社会，一款只面向某一群体的应用程序会让人失望。这不仅会极大地影响不会讲该应用程序语言的用户的用户体验，而且如果该应用程序参与在线购物体验，也会对销售产生不利影响。这就是本地化的用武之地。
- en: What Is Localization?
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是本地化？
- en: '*Localization* is the act of translating static resources, such as those found
    in resource files, into a specific language that an app plans to support. When
    your app supports many languages, it will have various resource files for each
    supported locale. In .NET, localization maintains locale-specific resource files
    in an XML format with the *.resx* file extension.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '*本地化* 是将静态资源（例如资源文件中的资源）翻译为应用程序计划支持的特定语言的行为。当您的应用程序支持多种语言时，它将为每个支持的区域设置有各种资源文件。在
    .NET 中，本地化使用 XML 格式维护特定区域的资源文件，并使用 *.resx* 文件扩展名。'
- en: Note
  id: totrans-5
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Localization is not the same thing as globalization. Globalization is when you
    code your app in a way that makes it easy to localize. For an overview of globalization,
    see Microsoft’s [“Globalization” .NET documentation](https://oreil.ly/cRRVw).
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本地化并不等同于全球化。全球化是指您在编写应用程序时使其易于本地化。有关全球化的概述，请参阅微软的 [“全球化” .NET 文档](https://oreil.ly/cRRVw)。
- en: The Learning Blazor app supports roughly 40 languages. Supporting these languages
    is possible with the help of AI. As an English-speaking developer, I write my
    resource files in English. This means the resources filenames end with *.en.resx*
    and the other supported locales are machine-translated as an automated pull request.
    You’ll learn how you can use this functionality in your apps later in this chapter.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 学习 Blazor 应用程序支持大约 40 种语言。借助 AI 的帮助，支持这些语言是可能的。作为一名讲英语的开发者，我用英语编写我的资源文件。这意味着资源文件名以
    *.en.resx* 结尾，其他支持的区域设置则是通过自动化的拉取请求进行机器翻译。您将在本章后面学习如何在您的应用程序中使用这一功能。
- en: As part of .NET, Blazor WebAssembly can dynamically determine which translated
    version of the file to pull resources from. The browser will determine the language
    it is using, and this information is available on the Web.Client app. Using the
    appropriate resource file, the app will render the correct content, following
    various numerical and date formatting rules. To support an app’s many languages
    is to *localize* it. For more information about localization in .NET, see Microsoft’s
    [“Localization in .NET” documentation](https://oreil.ly/Nm2vS).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 作为 .NET 的一部分，Blazor WebAssembly 可以动态确定从哪个翻译版本的文件中提取资源。浏览器将确定其使用的语言，并且此信息在 Web.Client
    应用程序中是可用的。使用适当的资源文件，应用程序将根据各种数字和日期格式规则呈现正确的内容。支持应用程序的多种语言即是 *本地化*。有关在 .NET 中的本地化的更多信息，请参阅微软的
    [“.NET 中的本地化” 文档](https://oreil.ly/Nm2vS)。
- en: Warning
  id: totrans-9
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: Localizing an app using only machine-translated text is not ideal. Instead,
    developers should hire professional translators who can help maintain post-machine-translated
    files. This approach yields more reliable translations. They’re not free, but
    you get what you pay for. Machine translations are not always accurate, but they
    strive to be natural sounding and can accommodate simple user needs for limited
    text.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 仅使用机器翻译文本进行应用本地化并不理想。相反，开发人员应聘请专业翻译人员来帮助维护机器翻译后的文件。这种方法可以提供更可靠的翻译。虽然不是免费的，但你得到了你付出的代价。机器翻译并不总是准确的，但它们力求自然，并能满足有限文本的简单用户需求。
- en: Localization is largely accomplished by using the app’s resource files. Resource
    (*.resx*) files have their language encoded as a subextension `.{lang-id}.resx`,
    where the `{lang-id}` placeholder is the browser’s specified language. The app
    exposes the language configuration through the `LanguageSelectionComponent`, which
    uses the `ModalComponent` to prompt the user to select from a list of languages
    that the app supports. These languages are accessible to the app through an `"api/cultures/all"`
    endpoint.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本地化主要通过应用程序的资源文件完成。资源（*.resx*）文件将其语言编码为子扩展名`.{lang-id}.resx`，其中`{lang-id}`占位符是浏览器指定的语言。该应用程序通过`LanguageSelectionComponent`暴露语言配置，后者使用`ModalComponent`提示用户从应用程序支持的语言列表中进行选择。这些语言可通过`"api/cultures/all"`端点访问应用程序。
- en: The Localization Process
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 本地化过程
- en: 'Let’s prepare to localize our Learning Blazor sample app. To localize any Blazor
    WebAssembly app, you’ll need the following:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们准备将我们的 Learning Blazor 示例应用本地化。要本地化任何 Blazor WebAssembly 应用程序，您需要以下内容：
- en: A client reference to the `Microsoft.Extensions.Localization` NuGet package
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个客户端对`Microsoft.Extensions.Localization` NuGet包的引用
- en: The ability to call `AddLocalization()` when registering services for DI
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在注册服务进行 DI 时调用`AddLocalization()`的能力
- en: The ability to update culture based on user preferences and at app startup,
    as shown in [“Detecting Client Culture at Startup”](ch02.html#detect-client-culture)
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据用户偏好和应用程序启动时更新文化的能力，如在[“在启动时检测客户端文化”](ch02.html#detect-client-culture)中所示
- en: Resource files available to the Web.Client project
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Web.Client 项目可用的资源文件
- en: '`IStringLocalizer<T>` instances injected into components where localization
    is used'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`IStringLocalizer<T>`实例注入到使用本地化的组件中
- en: An opportunity to call upon the localizer instances through their indexer method
    APIs
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过它们的索引器方法 API 调用本地化实例的机会
- en: Blazor relies on `CultureInfo.DefaultThreadCurrentCulture` and `Cultur⁠eInfo​.DefaultThreadCurrentUICulture`
    values to determine which resource file to use.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Blazor 依赖于`CultureInfo.DefaultThreadCurrentCulture`和`CultureInfo.DefaultThreadCurrentUICulture`值来确定使用哪个资源文件。
- en: Let’s take a moment to understand how this process comes together. The Blazor
    app needs to register the localization services. When the Web.Client project starts,
    all services it relies on are registered as being discoverable through the framework-provided
    DI service provider. Each client app instance makes use of the internal HTTP clients
    and business logic services, with one, in particular, coming from the [`Microsoft.Extensions.Localization`
    NuGet package](https://oreil.ly/4olfW). This package contains the services required
    to use localization. Recall from [“The Web.Client ConfigureServices Functionality”](ch04.html#web-client-configure-services)
    that when setting up `IServiceCollection`, we made a call to `AddLocalization()`.
    This method, from the Localization NuGet package, adds the `IStringLocalizer<T>`
    service types to the client app’s DI container.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们花点时间了解这个过程是如何组合在一起的。Blazor 应用程序需要注册本地化服务。当 Web.Client 项目启动时，所有它依赖的服务都注册为可以通过框架提供的
    DI 服务提供程序发现。每个客户端应用实例都使用内部 HTTP 客户端和业务逻辑服务，其中一个特别来自[`Microsoft.Extensions.Localization`
    NuGet包](https://oreil.ly/4olfW)。该包含了使用本地化所需的服务。回想一下[“Web.Client ConfigureServices
    功能”](ch04.html#web-client-configure-services)中的设置`IServiceCollection`时，我们调用了`AddLocalization()`。该方法来自本地化
    NuGet 包，将`IStringLocalizer<T>`服务类型添加到客户端应用程序的 DI 容器中。
- en: With the `IStringLocalizer<T>` type, a component can use the resources within
    the translation files. Each Blazor component potentially has many resource files
    that correspond to it. An instance of `IStringLocalizer<T>` corresponds to a single
    type of `T`, where `T` is any type that might have resources.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`IStringLocalizer<T>`类型，组件可以使用翻译文件中的资源。每个 Blazor 组件可能对应多个资源文件。`IStringLocalizer<T>`的一个实例对应于单个`T`类型，其中`T`可以是任何可能有资源的类型。
- en: 'You can use a shared object (`SharedResource`) that contains resources with
    these common values. When you’re using `IStringLocalizer<T>` and `IStringLocal⁠izer​<SharedResource>`,
    it becomes redundant to inject both of these types over and over again. To solve
    this redundancy, a custom `CoalescingStringLocalizer<T>` service exists to coalesce
    these multiple localizer types, favoring the type of `T` and coalescing to the
    `SharedResource` type when a value is not found. Examples of common text would
    be the text of command-centric buttons on the UI, like “Okay” or “Cancel.” This
    approach could be used in other Blazor apps, or any localized .NET app, for that
    matter. Consider the following *CoalescingStringLocalizer.cs* C# file:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用包含这些常见值资源的共享对象（`SharedResource`）。当您使用`IStringLocalizer<T>`和`IStringLocal⁠izer​<SharedResource>`时，反复注入这两种类型会变得冗余。为了解决这种冗余，存在一个自定义的`CoalescingStringLocalizer<T>`服务，用于合并这些多个本地化类型，偏向于`T`类型，并在找不到值时合并到`SharedResource`类型。常见文本示例包括
    UI 上以命令为中心的按钮的文本，如“确定”或“取消”。这种方法可以在其他 Blazor 应用程序中使用，或者任何本地化的 .NET 应用程序中使用。请考虑以下*C​​oalescingStringLocalizer.cs*
    C# 文件：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[![1](assets/1.png)](#co_localizing_the_app_CO1-1)'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_localizing_the_app_CO1-1)'
- en: 'The `CoalescingStringLocalizer<T>` object relies on two fields:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`CoalescingStringLocalizer<T>`对象依赖于两个字段：'
- en: '`_localizer`: The localizer for the `T` type, where `T` is a component'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`_localizer`：`T` 类型的本地化程序，其中`T`是一个组件'
- en: '`_sharedLocalizer`: The localizer for the `SharedResource` type'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`_sharedLocalizer`：`SharedResource` 类型的本地化程序'
- en: '[![2](assets/2.png)](#co_localizing_the_app_CO1-2)'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_localizing_the_app_CO1-2)'
- en: The constructor requires both localizer instances, and they’re assigned to the
    class-scoped fields.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数需要两个本地化实例，并分配给类范围的字段。
- en: '[![3](assets/3.png)](#co_localizing_the_app_CO1-3)'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_localizing_the_app_CO1-3)'
- en: The first of two indexers accepts the `name` of the resource and coalesces on
    both localizer instances. When not found, the given `name` is returned.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 两个索引器中的第一个接受资源的`name`，并在两个本地化实例上合并。当找不到时，返回给定的`name`。
- en: '[![4](assets/4.png)](#co_localizing_the_app_CO1-4)'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_localizing_the_app_CO1-4)'
- en: The second indexer accepts the `name` of the resource and the `arguments`. It
    too coalesces on both localizer instances and returns the given `name` when no
    resource is found.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个索引器接受资源的`name`和`arguments`。当找不到资源时，它也会聚合两个本地化实例，并返回给定的`name`。
- en: '`CoalescingStringLocalizer<T>` is used throughout the Web.Client project of
    our Learning Blazor app and is injected into `LocalizableComponentBase<T>`. Components
    that inherit from the `LocalizableComponentBase<T>` type will have access to the
    `Localizer` property. `LocalizableComponentBase<T>` is a descendant of the framework-provided
    `ComponentBase` class. `LanguageSelectionComponent<T>` provides a great example
    for binding to `Localizer`, and this component is responsible for exposing the
    client language configuration. In the next section, we’ll explore how this component
    binds localized content and lets the user choose the app’s language.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`CoalescingStringLocalizer<T>` 在我们的 Learning Blazor 应用程序的 Web.Client 项目中广泛使用，并注入到`LocalizableComponentBase<T>`中。从`LocalizableComponentBase<T>`类型继承的组件将可以访问`Localizer`属性。`LocalizableComponentBase<T>`是框架提供的`ComponentBase`类的后代。`LanguageSelectionComponent<T>`为绑定到`Localizer`提供了一个很好的示例，该组件负责暴露客户端语言配置。在接下来的部分中，我们将探讨此组件如何绑定本地化内容并允许用户选择应用程序的语言。'
- en: The Language Selection Component
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 语言选择组件
- en: While exposing the ability for the user to select the app’s language isn’t specifically
    part of the *localization process*, it’s an important feature to provide. When
    localizing apps, you should be mindful to include such functionality.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管允许用户选择应用程序的语言不是*本地化过程*的具体部分，但提供这一功能非常重要。在本地化应用程序时，应考虑包含这样的功能。
- en: The language selection component prompts the user for their desired language
    when the user selects the Language top-level navigation button. Its markup introduces
    a new framework-provided component used for handling errors, the `ErrorBoundary`
    component. Whenever you write code that doesn’t handle errors, for example, potentially
    errant code that’s not wrapped in a `try`/`catch` block, that code has the potential
    to negatively impact the component’s ability to render properly. As such, as an
    alternative to writing `try`/`catch`, you could handle errors by displaying error-specific
    markup. The `ErrorBoundary` component allows consumers to template both `ChildContent`
    for successful logic and `ErrorContent` when an error is thrown. This is useful
    for conditionally rendering content even if the component encounters an error.
    For example, if the endpoint that serves the app’s supported languages is unavailable,
    the `ErrorBoundary` component can render a disabled button.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 语言选择组件在用户选择顶级语言导航按钮时提示用户选择他们所需的语言。其标记引入了一个新的框架提供的组件用于处理错误，即 `ErrorBoundary`
    组件。每当编写不处理错误的代码时，例如没有包装在 `try`/`catch` 块中的潜在错误代码，该代码有可能会对组件的正确渲染能力产生负面影响。因此，作为写入
    `try`/`catch` 的替代方案，可以通过显示特定于错误的标记处理错误。 `ErrorBoundary` 组件允许消费者模板化成功逻辑的 `ChildContent`
    和在抛出错误时的 `ErrorContent`。即使组件遇到错误也能有条件地渲染内容。例如，如果服务应用程序支持的语言的端点不可用，`ErrorBoundary`
    组件可以渲染一个禁用的按钮。
- en: Assuming no errors are present, the modal dialog acts as a user prompt. When
    `LanguageSelectionComponent` is displayed, clicking its `button` will show the
    modal dialog that renders similar to [Figure 5-1](#language-selection-component).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 假设没有错误存在，模态对话框充当用户提示。当显示 `LanguageSelectionComponent` 时，点击其 `button` 将显示类似于
    [图 5-1](#language-selection-component) 的模态对话框。
- en: '![](assets/lblz_0501.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/lblz_0501.png)'
- en: Figure 5-1\. An example `LanguageSelectionComponent` rendering with the modal
    shown
  id: totrans-41
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 5-1\. 使用模态展示的 `LanguageSelectionComponent` 示例渲染
- en: 'Now, let’s look at the following *LanguageSelectionComponent.razor* markup
    file, which is responsible for rendering the modal dialog:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看一下 *LanguageSelectionComponent.razor* 标记文件，负责渲染模态对话框：
- en: '[PRE1]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[![1](assets/1.png)](#co_localizing_the_app_CO2-1)'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_localizing_the_app_CO2-1)'
- en: An `ErrorBoundary` component is used to wrap the potentially errant component.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`ErrorBoundary` 组件用于包装潜在的错误组件。'
- en: '[![2](assets/2.png)](#co_localizing_the_app_CO2-2)'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_localizing_the_app_CO2-2)'
- en: '`ModalComponent` is used to render the modal dialog.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`ModalComponent` 用于渲染模态对话框。'
- en: '[![3](assets/3.png)](#co_localizing_the_app_CO2-3)'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_localizing_the_app_CO2-3)'
- en: The body is an HTML `form` element.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 主体是 HTML `form` 元素。
- en: '[![4](assets/4.png)](#co_localizing_the_app_CO2-4)'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_localizing_the_app_CO2-4)'
- en: '`ButtonContent` renders both cancel and confirm buttons.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`ButtonContent` 渲染了取消和确认按钮。'
- en: The `LanguageSelectionComponent` markup file starts with an `ErrorBoundary`
    component. Its `ChildContent` renders a `button` that binds its `onclick` event
    handler to the `ShowAsync` method. `ErrorContent` renders a disabled `button`.
    Both render fragments use the same syntax to call into the `LocalizableComponentBase.Localizer`
    instance. The `@Localizer["Language"]` invocation asks the localizer to fetch
    the corresponding value for the `"Language"` key. This returns a framework-provided
    `LocalizedString` type that represents a locale-specific `string`. The `LocalizedString`
    type defines an implicit operator as a `string`.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`LanguageSelectionComponent` 标记文件以 `ErrorBoundary` 组件开头。其 `ChildContent` 渲染一个
    `button`，将其 `onclick` 事件处理程序绑定到 `ShowAsync` 方法。 `ErrorContent` 渲染一个禁用的 `button`。两个渲染片段使用相同的语法调用
    `LocalizableComponentBase.Localizer` 实例。 `@Localizer["Language"]` 调用请求本地化器为 `"Language"`
    键获取相应的值。这返回一个由框架提供的 `LocalizedString` 类型，表示特定于区域设置的 `string`。 `LocalizedString`
    类型定义了一个隐式操作符作为 `string`。'
- en: The localization services understand that for `IStringLocalizer<LanguageSelectionComponent>`,
    they should look for resources that match by naming convention. For example, the
    *LanguageSelectionComponent.razor* and *LanguageSelectionCompo⁠nent​.razor.cs*
    files are related, as they’re two `partial class` definitions for the same object.
    The same relationship exists for this component’s resource files. I defined a
    single *LanguageSelectionComponent.razor.en.resx* resource file for this, and
    that is shown later in [Example 5-1](#language-selection-component-en-resx).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 本地化服务了解到对于 `IStringLocalizer<LanguageSelectionComponent>`，它们应该按命名约定查找资源。例如，*LanguageSelectionComponent.razor*
    和 *LanguageSelectionCompo⁠nent​.razor.cs* 文件是相关的，因为它们是同一个对象的两个 `partial class`
    定义。这个组件的资源文件也有相同的关系。我为此定义了一个单独的 *LanguageSelectionComponent.razor.en.resx* 资源文件，稍后会在
    [Example 5-1](#language-selection-component-en-resx) 中显示。
- en: '`ModalComponent` is captured as a reference and assigned to the `_modal` field
    using the `@ref="_modal"` syntax. `BodyContent` contains a native HTML `form`
    element, and it binds to a native HTML `selection` element. Each `option` node
    is bound from the current `culture` in the iteration to the `value` attribute.
    It’s `selected` when the current culture’s Language Code Identifier (or `LCID`)
    matches the one being iterated over. A `ToDisplayName` helper method is used to
    convert the `culture` and `azureCulture` objects into their text representation.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `@ref="_modal"` 语法将 `ModalComponent` 捕获为引用并分配给 `_modal` 字段。`BodyContent`
    包含一个本地 HTML `form` 元素，并绑定到本地 HTML `selection` 元素。每个 `option` 节点从当前迭代中的 `culture`
    绑定到 `value` 属性。当当前文化的语言代码标识符（或 `LCID`）与正在迭代的文化匹配时，它被 `selected`。使用 `ToDisplayName`
    辅助方法将 `culture` 和 `azureCulture` 对象转换为它们的文本表示。
- en: '`ButtonContent` defines two buttons. The first `button` is the `"Okay"` button
    that calls `ConfirmAsync` when clicked. The other `button` is the `"Cancel"` button,
    and when it’s clicked, it will call `_modal.CancelAsync()`.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`ButtonContent` 定义了两个按钮。第一个按钮是 `"Okay"` 按钮，点击时调用 `ConfirmAsync`。另一个按钮是 `"Cancel"`
    按钮，点击时调用 `_modal.CancelAsync()`。'
- en: When the user expands all of the supported cultures, the dialog will render
    similar to that shown in [Figure 5-2](#language-selection-component-expanded).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户展开所有支持的文化时，对话框将呈现类似于 [Figure 5-2](#language-selection-component-expanded)
    中显示的内容。
- en: '![](assets/lblz_0502.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/lblz_0502.png)'
- en: Figure 5-2\. An example `LanguageSelectionComponent` rendering with an open
    modal dialog and culture selection expanded
  id: totrans-58
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 5-2\. 一个示例 `LanguageSelectionComponent` 渲染，带有打开的模态对话框和展开的文化选择。
- en: Tip
  id: totrans-59
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: At the time of writing this book, there was [a bug](https://oreil.ly/Gwu5T)
    concerning ASP.NET Core’s ability to locate resources when the component used
    a file-scoped namespace. As such, components that do not display any text or user
    inputs do not need to be localized. So they’re free to use file-scoped namespaces.
    You will see both namespace formats in the code, so don’t be alarmed.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写本书时，关于 ASP.NET Core 在组件使用文件作用域命名空间时定位资源的能力存在 [一个 bug](https://oreil.ly/Gwu5T)。因此，不显示任何文本或用户输入的组件不需要本地化。因此，它们可以自由使用文件作用域命名空间。您将在代码中看到这两种命名空间格式，不必惊慌。
- en: 'The corresponding component partial code is reflected in the *LanguageSelection​Com⁠ponent.razor.cs*
    C# file. Let’s look at that next:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 对应的组件部分代码反映在 *LanguageSelection​Com⁠ponent.razor.cs* 的 C# 文件中。让我们接下来看看它：
- en: '[PRE2]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[![1](assets/1.png)](#co_localizing_the_app_CO3-1)'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_localizing_the_app_CO3-1)'
- en: Component state is managed by private fields.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 组件状态由私有字段管理。
- en: '[![2](assets/2.png)](#co_localizing_the_app_CO3-2)'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_localizing_the_app_CO3-2)'
- en: The `OnInitializedAsync` method is used to fetch the supported cultures from
    the server.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`OnInitializedAsync` 方法用于从服务器获取支持的文化。'
- en: '[![3](assets/3.png)](#co_localizing_the_app_CO3-3)'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_localizing_the_app_CO3-3)'
- en: The `ToDisplayName` helper method is used to convert the `culture` and `azure​Cul⁠ture`
    objects into their text representation.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`ToDisplayName` 辅助方法用于将 `culture` 和 `azure​Cul⁠ture` 对象转换为它们的文本表示。'
- en: '[![4](assets/4.png)](#co_localizing_the_app_CO3-4)'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_localizing_the_app_CO3-4)'
- en: Several methods expose `_modal` functionality to the component.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 几种方法向组件公开了 `_modal` 功能。
- en: '`LanguageSelectionComponent` defines a few fields and a few injected properties:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`LanguageSelectionComponent` 定义了几个字段和几个注入的属性：'
- en: '`_supportedCultures`'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`_supportedCultures`'
- en: An `IDictionary<CultureInfo, AzureCulture>` field that represents the supported
    cultures. The field’s keys are the framework-provided `CultureInfo`, and their
    value is a custom `AzureCulture` positional `record class`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 一个`IDictionary<CultureInfo, AzureCulture>`字段，表示支持的文化。字段的键是框架提供的`CultureInfo`，它们的值是自定义的`AzureCulture`位置记录类。
- en: '`_selectedCulture`'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`_selectedCulture`'
- en: This value is bound in the Razor markup to the `select` element and corresponds
    to what the user has selected as their desired culture.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 此值在Razor标记中绑定到`select`元素，并对应于用户选择的期望文化。
- en: '`_modal`'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`_modal`'
- en: The reference to `ModalComponent`. With this reference, we will call `ShowAsync`
    and `ConfirmAsync` to show and confirm the modal accordingly.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 对`ModalComponent`的引用。通过此引用，我们将调用`ShowAsync`和`ConfirmAsync`来显示和确认模态框。
- en: '`Http`'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`Http`'
- en: A framework-provided `HttpClient` instance used to fetch the supported cultures.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 由框架提供的`HttpClient`实例，用于获取支持的文化。
- en: '`Navigation`'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`Navigation`'
- en: A framework-provided `NavigationManager` used to force reloading of the current
    page. When changing the culture, this is required to reload the entire app.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 由框架提供的`NavigationManager`，用于强制重新加载当前页面。在更改文化时，需要重新加载整个应用程序。
- en: When the component is initialized (`OnInitializedAsync`), the `"api/cultures/all"`
    server endpoint is called. The `_supportedCultures` map is assigned from the returned
    values and a calculation of the intersecting supported cultures. These values
    reflect the set of overlapping client cultures and the server’s supported set,
    as shown in the example Venn diagram in [Figure 5-3](#supported-cultures-venn-diagram),
    where each small circle represents a two-letter language identifier.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 当组件初始化（`OnInitializedAsync`）时，调用`"api/cultures/all"`服务器端点。`_supportedCultures`映射从返回的值中分配，并计算交集的支持文化集。这些值反映了重叠客户端文化和服务器支持集的示例Venn图中的集合，在[图 5-3](#supported-cultures-venn-diagram)中显示，其中每个小圆表示一个两字母语言标识符。
- en: '![](assets/lblz_0503.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/lblz_0503.png)'
- en: Figure 5-3\. Supported cultures are the intersection of the client and server
    cultures
  id: totrans-84
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 5-3。支持的文化是客户端和服务器文化的交集。
- en: 'The remaining methods rely on the `_modal` instance:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 剩余的方法依赖于`_modal`实例：
- en: '`ShowAsync`'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`ShowAsync`'
- en: Delegate to `_modal.ShowAsync()`.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 委托给`_modal.ShowAsync()`。
- en: '`ConfirmAsync`'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`ConfirmAsync`'
- en: If the user has selected a different culture, a reload is forced, and the new
    value is persisted to local storage. The modal is closed by the call to `_modal.Confirm​A⁠sync()`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户选择了不同的文化，将强制重新加载，并将新值持久化到本地存储。模态框通过调用`_modal.Confirm​A⁠sync()`关闭。
- en: '`LanguageSelectionComponent` supports 41 languages. From the earlier markup
    shown in the *LanguageSelectionComponent.razor* file, you may have noticed that
    `@Localizer` has its indexer called with the given arguments:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`LanguageSelectionComponent`支持41种语言。从*LanguageSelectionComponent.razor*文件中显示的早期标记中，您可能已经注意到`@Localizer`使用给定的参数调用其索引器：'
- en: '`"Language"`'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`"Language"`'
- en: Bound in the `<button title=@Localizer["Language"]></button>` markup
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 绑定在`<button title=@Localizer["Language"]></button>`标记中
- en: '`"ChangeLanguage"`'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`"ChangeLanguage"`'
- en: Bound to the `TitleContent` markup
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 绑定到`TitleContent`标记
- en: '`"Okay"`'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`"Okay"`'
- en: Bound to the `ButtonContent` confirm button text
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 绑定到`ButtonContent`确认按钮文本
- en: '`"Cancel"`'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`"Cancel"`'
- en: Bound to the `ButtonContent` cancel button text
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 绑定到`ButtonContent`取消按钮文本
- en: Each of these keys (or names) corresponds to the resource files of `Lan⁠guage​Selec⁠tionComponent`.
    Consider the *LanguageSelectionComponent.razor.en.resx* resource file, shown in
    [Example 5-1](#language-selection-component-en-resx).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 每个键（或名称）对应于`Lan⁠guage​Selec⁠tionComponent`的资源文件。考虑*LanguageSelectionComponent.razor.en.resx*资源文件，显示在[示例 5-1](#language-selection-component-en-resx)中。
- en: Example 5-1\. Resource files for the `LanguageSelectionComponent`
  id: totrans-100
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-1。`LanguageSelectionComponent`的资源文件
- en: '[PRE3]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Each `data` node has a `name` attribute. This `name` matches the name you use
    when asking an `IStringLocalizer<T>` for a corresponding value. The `value` returned
    corresponds to the English version of the resource. Consider the *LanguageSelection​Component.razor.es.resx*
    resource file, shown in [Example 5-2](#language-selection-component-es-resx).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 每个`data`节点具有一个`name`属性。此`name`与您在请求`IStringLocalizer<T>`相应值时使用的名称相匹配。返回的`value`对应于资源的英文版本。考虑*LanguageSelection​Component.razor.es.resx*资源文件，显示在[示例 5-2](#language-selection-component-es-resx)中。
- en: Example 5-2\. Web.Client/Components/LanguageSelectionComponent.razor.es.resx
  id: totrans-103
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-2。Web.Client/Components/LanguageSelectionComponent.razor.es.resx
- en: '[PRE4]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This resource file has a subextension of *.es.resx* instead of *.en.resx*, and
    each `value` is in Spanish. These resource files contain only two `data` nodes.
    There were two additional names referenced in the markup, and that’s where `CoalescingString​Lo⁠calizer<T>`
    comes in. The `"Okay"` and `"Cancel"` resources are part of the `SharedResource`
    object resource files. This approach of coalescing does incur a minor performance
    implication, but saying it’s *minor* is an overstatement. It’s proven unmeasurable
    with all of my testing.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 此资源文件的子扩展名为 *.es.resx* 而不是 *.en.resx*，每个 `value` 都是西班牙语。这些资源文件仅包含两个 `data` 节点。在标记中引用了两个额外的名称，这就是
    `CoalescingString​Lo⁠calizer<T>` 的用武之地。`"Okay"` 和 `"Cancel"` 资源属于 `SharedResource`
    对象资源文件的一部分。这种聚合方法确实会带来轻微的性能影响，但说它是*轻微的*是一种夸大。在我所有的测试中，这已被证明是不可测量的。
- en: Warning
  id: totrans-106
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: This code is fully functional and readable. While it might seem advantageous
    to spend time trying to optimize it, you should heed the famous words of Professor
    Donald Knuth. He warns developers that “premature optimization is the root of
    all evil” in programming.^([1](ch05.html#idm46365018501872))
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码完全功能齐全且易读。虽然花时间尝试优化它可能看起来有利，但你应该牢记教授唐纳德·克努斯的著名警句。他警告开发者，“过早优化是所有邪恶之源”[^1]。
- en: Automating Translations with GitHub Actions
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 GitHub Actions 自动化翻译
- en: If it’s right for your app, you may want to have it support as many languages
    as possible. This can be done manually by creating a static resource file for
    each language your app supports, or you could consider a more automated approach.
    How might you manage the creation and maintenance of many resource files? If you’re
    to do this manually, when a single translation file changes, you’d have to update
    each corresponding supported language translation file by hand. Many larger apps
    will have teams assigned to translation tasks, monitoring changes to translation
    files and creating pull requests to make the appropriate changes, and this can
    become expensive. As an alternative, you can automate this.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果适合你的应用程序，你可能希望支持尽可能多的语言。这可以通过为应用程序支持的每种语言创建静态资源文件来手动完成，或者你可以考虑更自动化的方法。你如何管理创建和维护多个资源文件？如果你要手动完成这项工作，当单个翻译文件发生变化时，你必须手动更新每个相应的支持语言翻译文件。许多更大的应用程序将有团队负责翻译任务，监控翻译文件的变化，并创建拉取请求来进行适当的更改，这可能成本高昂。作为一种替代方案，你可以自动化这一过程。
- en: You can create your own GitHub Action to automate translation, or you can use
    an existing GitHub Action that’s available on the GitHub Action Marketplace that
    does the same thing. If this is new to you, I suggest using an existing GitHub
    Action, such as the one I made for this book, called [Machine Translator](https://oreil.ly/fFmmQ).
    It relies on [Azure’s Cognitive Services Text Translator service](https://oreil.ly/KjO9d),
    and it’s written in TypeScript. The Machine Translator workflow in the Learning
    Blazor’s repo requires my Azure’s encrypted subscription key so that it can access
    a cloud-based neural machine translation technology. This allows for source-to-text
    translation, taking the static *.resx* resource files as input and writing out
    translated text for non-English languages. Within a GitHub repo, as an admin you
    can access the *Settings > Secrets* page, where you’ll add several repository
    secrets that the action will rely on as it runs.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以创建自己的 GitHub Action 来自动化翻译，或者你可以使用 GitHub Action 市场上提供的现有 GitHub Action 来完成同样的工作。如果这对你来说是新的，我建议使用一个现有的
    GitHub Action，比如我为这本书制作的一个叫做[Machine Translator](https://oreil.ly/fFmmQ)的 GitHub
    Action。它依赖于[Azure 的认知服务文本翻译器服务](https://oreil.ly/KjO9d)，并且是用 TypeScript 编写的。Learning
    Blazor 仓库中的 Machine Translator 工作流需要我的 Azure 加密订阅密钥，以便它可以访问基于云的神经机器翻译技术。这允许将静态的
    *.resx* 资源文件作为输入进行源到文本的翻译，并为非英语语言写出翻译文本。在 GitHub 仓库中，作为管理员你可以访问*设置 > 秘密* 页面，在那里你将添加若干仓库密钥，这些密钥将在操作运行时被使用。
- en: 'If you’re following along in your clone of the Learning Blazor App repo, see
    Microsoft’s [“Quickstart: Azure Cognitive Services Translator” documentation](https://oreil.ly/82O5w).
    With an Azure Translator subscription key, you can run the action and see the
    results in GitHub Action’s output. You need to set the `AZURE_TRANSLATOR_SUBSCRIPTION_KEY`,
    `AZURE_TRANSLATOR_ENDPOINT`, and `AZURE_TRANSLATOR_REGION` secrets.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在跟随学习 Blazor 应用程序库的克隆版本，请查看微软的[“快速入门：Azure 认知服务翻译器”文档](https://oreil.ly/82O5w)。通过
    Azure Translator 订阅密钥，你可以运行操作并在 GitHub Action 的输出中查看结果。你需要设置 `AZURE_TRANSLATOR_SUBSCRIPTION_KEY`、`AZURE_TRANSLATOR_ENDPOINT`
    和 `AZURE_TRANSLATOR_REGION` 三个密钥。
- en: 'To automate the translation of the Learning Blazor app, we start with the following
    [*machine-translation.yml* workflow file](https://oreil.ly/Otzm9):'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 要自动化翻译 Learning Blazor 应用程序，我们从以下 [*machine-translation.yml* 工作流文件](https://oreil.ly/Otzm9)
    开始：
- en: '[PRE5]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[![1](assets/1.png)](#co_localizing_the_app_CO4-1)'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_localizing_the_app_CO4-1)'
- en: The *machine-translation.yml* workflow is named `Azure Translation`.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '*machine-translation.yml* 工作流的名称为 `Azure Translation`。'
- en: '[![2](assets/2.png)](#co_localizing_the_app_CO4-2)'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_localizing_the_app_CO4-2)'
- en: The primary step in this workflow is to run the `IEvangelist/resource-translator@main`
    GitHub Action.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 此工作流中的主要步骤是运行 `IEvangelist/resource-translator@main` GitHub Action。
- en: '[![3](assets/3.png)](#co_localizing_the_app_CO4-3)'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_localizing_the_app_CO4-3)'
- en: The `create-pull-request` step is run only if the `translator` step outputs
    changes.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 仅当 `translator` 步骤输出更改时才运行 `create-pull-request` 步骤。
- en: 'The GitHub Action workflow file describes the `name` as `"Azure Translation"`,
    which is used later by the GitHub Action real-time status screen. The `on` syntax
    is used to describe when the action will run; this action runs when any *.en.resx*
    files are updated and `pushed` to the `main` branch. The hosting environment maps
    the `secrets` context object’s GitHub token value as `GITHUB_TOKEN`. The workflow
    defines a single job in the `jobs` node, where named `translate` operation `runs-on:
    ubuntu-latest` (the latest supported version of Ubuntu). Like most other GitHub
    Action workflow files, it needs to check out the repo’s source code using the
    `action/checkout@v2` action.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 'GitHub Action 工作流文件将 `name` 描述为 `"Azure Translation"`，稍后在 GitHub Action 实时状态屏幕中使用。`on`
    语法用于描述操作将在何时运行；此操作在任何 *.en.resx* 文件更新并 `pushed` 到 `main` 分支时运行。托管环境将 `secrets`
    上下文对象的 GitHub 令牌值映射为 `GITHUB_TOKEN`。工作流在 `jobs` 节点中定义了一个单一作业，其中命名为 `translate`
    操作 `runs-on: ubuntu-latest`（Ubuntu 的最新支持版本）。与大多数其他 GitHub Action 工作流文件一样，它需要使用
    `action/checkout@v2` 动作检出存储库的源代码。'
- en: 'The second step of the `steps` node describes my [`IEvangelist/resource-translator@main`
    GitHub Action](https://oreil.ly/0m9jO). This reference is identified as `translator`,
    which later allows the workflow to reference it by name (or `id`) through expressions.
    The `with` syntax allows this step to provide the required GitHub Action input.
    The keys listed in the `with` node map directly to the names the GitHub Action
    publishes as input:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`steps` 节点的第二步描述了我的 [`IEvangelist/resource-translator@main` GitHub Action](https://oreil.ly/0m9jO)。此引用被标识为
    `translator`，稍后允许工作流通过表达式按名称（或 `id`）引用它。`with` 语法允许此步骤提供所需的 GitHub Action 输入。`with`
    节点中列出的键直接映射到 GitHub Action 发布为输入的名称：'
- en: '`subscriptionKey`'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`subscriptionKey`'
- en: A string value from the repo’s `secrets` context named `AZURE_TRANSLATOR_SUBSCRIPTION_KEY`
    using expression syntax. This value should come from the Azure Translator resource’s
    Keys and Endpoint page, and either KEY 1 or KEY 2 is valid.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 从名为 `AZURE_TRANSLATOR_SUBSCRIPTION_KEY` 的存储库 `secrets` 上下文中使用表达式语法的字符串值。此值应来自
    Azure Translator 资源的 Keys and Endpoint 页面，KEY 1 或 KEY 2 都是有效的。
- en: '`endpoint`'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`endpoint`'
- en: A string value from the repo’s `secrets` context named `AZURE_TRANSLATOR_ENDPOINT`
    using expression syntax. This value should come from the Azure Translator resource’s
    Keys and Endpoint page, and either KEY 1 or KEY 2 is valid.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 从名为 `AZURE_TRANSLATOR_ENDPOINT` 的存储库 `secrets` 上下文中使用表达式语法的字符串值。此值应来自 Azure
    Translator 资源的 Keys and Endpoint 页面，KEY 1 或 KEY 2 都是有效的。
- en: '`region`'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`region`'
- en: A string value from the repo’s `secrets` context named `AZURE_TRANSLA⁠TOR​_REGION`
    using expression syntax.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 从名为 `AZURE_TRANSLA⁠TOR​_REGION` 的存储库 `secrets` 上下文中使用表达式语法的字符串值。
- en: '`sourceLocale`'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`sourceLocale`'
- en: A literal value that equals the `'en'` string.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 一个等于 `'en'` 字符串的文字值。
- en: '`toLocales`'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`toLocales`'
- en: A string array of values for the locals to translate to using literal syntax.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 一个字符串数组，使用文字语法指定要翻译为的本地化值。
- en: 'Now, we need an action to conditionally run. We can use another action that’s
    available in the Github Action Marketplace. GitHub user and community member Peter
    Evans has a `create-pull-request` action that we can use. The `Create pull request`
    step will run only when changes to resource files have occurred. This occurs when
    the `translator` step has an output that indicates that new translations were
    created. The pull requests are automated and appear as requests from the `github-actions`
    bot. The pull requests’ description (`title`) and `body` are dynamically determined
    from the output of the previous step. If you’re curious what an actual pull request
    from a GitHub Action bot looks like, see [automated pull request #13](https://oreil.ly/8bp3v)
    in the Learning Blazor sample app’s GitHub repo.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '现在，我们需要一个条件运行的操作。我们可以使用 GitHub Action Marketplace 中提供的另一个操作。GitHub 用户和社区成员
    Peter Evans 提供了一个 `create-pull-request` 操作，我们可以使用它。当资源文件发生更改时，`Create pull request`
    步骤将仅运行。这发生在 `translator` 步骤产生的输出指示创建了新的翻译时。这些拉取请求是自动化的，并显示为来自 `github-actions`
    机器人的请求。拉取请求的描述（`title`）和 `body` 是根据上一步骤的输出动态确定的。如果你想看看 GitHub Action 机器人生成的实际拉取请求是什么样子，请查看
    [automated pull request #13](https://oreil.ly/8bp3v)，它在 Learning Blazor 示例应用的
    GitHub 仓库中。'
- en: Now that we’ve covered how resource files are used and their translation files
    are generated, we can move on to exploring various localization formatting examples.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经介绍了资源文件的使用及其生成的翻译文件，接下来我们将探索各种本地化格式的示例。
- en: Localization in Action
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 本地化实战
- en: Thus far, we’ve scrutinized the XML resource files, and we saw a mechanism for
    accessing the data in these files with the framework-provided `IStringLocalizer<T>`
    abstraction. In this section, you’ll learn how the “Have I Been Pwned” (HIBP)
    service (see [“Leveraging “Pwned” Functionality”](ch03.html#have-i-been-pwned))
    of the Learning Blazor sample app works and how its content is affected by localization.
    You’ll also learn the role of the `LocalizableComponentBase<T>​.Local⁠izer` property.
    As an example, this functionality pairs nicely with both localized and nonlocalized
    content, as you will see. As we look through this, you’ll learn a bit more about
    how the app uses the HIBP services. The site has a *Pwned?!* top-level navigation,
    and clicking this link navigates the user to the `https://webassemblyof.net/pwned`
    route, as depicted in [Figure 5-4](#pwned-sub-routes).
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经详细检查了 XML 资源文件，并看到了使用框架提供的 `IStringLocalizer<T>` 抽象访问这些文件中数据的机制。在本节中，您将了解
    Learning Blazor 示例应用中的“Have I Been Pwned”（HIBP）服务的工作原理及其内容如何受到本地化的影响。您还将了解 `LocalizableComponentBase<T>​.Local⁠izer`
    属性的作用。例如，此功能很好地配合了本地化和非本地化内容，如您所见。随着我们的深入，您将更多了解应用如何使用 HIBP 服务。该站点具有一个 *Pwned?!*
    的顶级导航，点击此链接将用户导航到 `https://webassemblyof.net/pwned` 路由，如 [Figure 5-4](#pwned-sub-routes)
    所示。
- en: '![](assets/lblz_0504.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/lblz_0504.png)'
- en: Figure 5-4\. Pwned page rendering with Breaches and Passwords subroutes
  id: totrans-137
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 5-4\. 使用 Breaches 和 Passwords 子路由呈现 Pwned 页面
- en: The `/pwned` route renders a page with two buttons, each with a link to its
    corresponding subroute. The *Breaches* button routes to `/pwned/breaches`, and
    the *Passwords* button routes to `/pwned/passwords`.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`/pwned` 路由呈现一个页面，其中有两个按钮，每个按钮链接到其相应的子路由。*Breaches* 按钮链接到 `/pwned/breaches`，*Passwords*
    按钮链接到 `/pwned/passwords`。'
- en: 'The markup for the *Pwned.razor* page is as follows:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '*Pwned.razor* 页面的标记如下：'
- en: '[PRE6]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[![1](assets/1.png)](#co_localizing_the_app_CO5-1)'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_localizing_the_app_CO5-1)'
- en: The page uses the framework-provided `PageTitle` component. This sets the browser
    tab title to `Pwned`.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 页面使用框架提供的 `PageTitle` 组件。这将浏览器标签标题设置为 `Pwned`。
- en: '[![2](assets/2.png)](#co_localizing_the_app_CO5-2)'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_localizing_the_app_CO5-2)'
- en: The button text is localized using the `Localizer` instance and the `"Breaches"`
    resource.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 按钮文本使用 `Localizer` 实例和 `"Breaches"` 资源进行本地化。
- en: '[![3](assets/3.png)](#co_localizing_the_app_CO5-3)'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_localizing_the_app_CO5-3)'
- en: The button text is localized using the `Localizer` instance and the `"Passwords"`
    resource.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 按钮文本使用 `Localizer` 实例和 `"Passwords"` 资源进行本地化。
- en: 'This is the first time you’re seeing the `@attribute` directive in this book.
    This directive lets you add any valid class-scoped attribute to the page. In this
    case, the `Authorize` attribute is added to the page. This attribute is used by
    the framework to determine whether the user is logged in. If the user is not logged
    in, they are redirected to the login page. Next, let’s look at the component shadow.
    Consider the *Pwned.razor.cs* C# file:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这是你第一次在本书中看到 `@attribute` 指令。此指令允许您向页面添加任何有效的类作用域属性。在这种情况下，`Authorize` 属性被添加到页面中。此属性由框架用于确定用户是否已登录。如果用户未登录，则会被重定向到登录页面。接下来，让我们看看组件的阴影。考虑
    *Pwned.razor.cs* C# 文件：
- en: '[PRE7]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[![1](assets/1.png)](#co_localizing_the_app_CO6-1)'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_localizing_the_app_CO6-1)'
- en: The `Pwned` page depends on the injected `NavigationManager` instance, using
    its navigation functionality.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`Pwned` 页面依赖注入的 `NavigationManager` 实例，使用其导航功能。'
- en: '[![2](assets/2.png)](#co_localizing_the_app_CO6-2)'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_localizing_the_app_CO6-2)'
- en: The page has two navigation methods that navigate to the Breaches and Passwords
    subroutes when called.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 页面有两种导航方法，分别在调用时导航到 `Breaches` 和 `Passwords` 子路由。
- en: 'The `Pwned` page has the following English *Pwned.razor.en.resx* resource file:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`Pwned` 页面有以下英文 *Pwned.razor.en.resx* 资源文件：'
- en: '[PRE8]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[![1](assets/1.png)](#co_localizing_the_app_CO7-1)'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_localizing_the_app_CO7-1)'
- en: The first `data` node is named `"Breaches"` and has a child `value` node of
    `Breaches`.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个 `data` 节点命名为 `"Breaches"`，并有一个名为 `Breaches` 的子 `value` 节点。
- en: '[![2](assets/2.png)](#co_localizing_the_app_CO7-2)'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_localizing_the_app_CO7-2)'
- en: The last `data` node is named `"Passwords"` and has a child `value` node of
    `Passwords`.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个 `data` 节点命名为 `"Passwords"`，并有一个名为 `Passwords` 的子 `value` 节点。
- en: You might be wondering why we aren’t using only the `name` attribute. That’s
    because, when localized, `name` isn’t translated, only the `value`. This is based
    on the schema of the resource file XML and is universal to all .NET apps.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道为什么我们不只使用 `name` 属性。因为在本地化时，`name` 不会被翻译，只有 `value`。这基于资源文件 XML 的架构，适用于所有
    .NET 应用程序。
- en: The `Breaches` page lets the user freely enter any email address and check if
    it has been part of a data breach. This page renders as shown in [Figure 5-5](#breaches-empty).
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`Breaches` 页面允许用户自由输入任何电子邮件地址，并检查其是否曾经泄露过数据。页面显示如 [图 5-5](#breaches-empty)
    所示。'
- en: '![](assets/lblz_0505.png)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/lblz_0505.png)'
- en: Figure 5-5\. The `Breaches` page rendering
  id: totrans-162
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 5-5\. `Breaches` 页面渲染
- en: When the language of the app is set to (`es-ES`), the page renders as shown
    in [Figure 5-6](#breaches-empty-es).
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序的语言设置为(`es-ES`)时，页面显示如 [图 5-6](#breaches-empty-es) 所示。
- en: '![](assets/lblz_0506.png)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/lblz_0506.png)'
- en: Figure 5-6\. The `Breaches` page rendering in Spanish
  id: totrans-165
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 5-6\. `Breaches` 页面的西班牙语渲染
- en: 'Before entering an email address, there are several textual values drawn on
    the screen, as shown in [Figure 5-5](#breaches-empty):'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在输入电子邮件地址之前，屏幕上显示了几个文本值，如 [图 5-5](#breaches-empty) 所示：
- en: '`'';--have i been pwned?`'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`'';--have i been pwned?`'
- en: This value is not translated and is hardcoded in the markup because it’s a name
    and shouldn’t be translated.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 此值未被翻译，并且在标记中硬编码，因为它是一个名称，不应该被翻译。
- en: '`pwned`'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`pwned`'
- en: Likewise, this value isn’t translated either because it’s a term that’s well
    known on the internet and doesn’t need to be translated.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，此值也不会被翻译，因为它是一个在互联网上广为人知的术语，无需翻译。
- en: '`Email address`'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`Email address`'
- en: This value is translated, and its name is `"EmailAddress"` in `Localizer`.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 此值已被翻译，并在 `Localizer` 中命名为 `"EmailAddress"`。
- en: '`Breaches`'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`Breaches`'
- en: This value is translated, and its name is `"Breaches"` in `Localizer`.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 此值已被翻译，并在 `Localizer` 中命名为 `"Breaches"`。
- en: '`Apply filter`'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`Apply filter`'
- en: This value is translated, and its name is `"ApplyFilter"` in `Localizer`.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 此值已被翻译，并在 `Localizer` 中命名为 `"ApplyFilter"`。
- en: 'Rather than showing the entire markup file, I’m going to focus on specific
    parts of the markup as it relates to localization. Consider the following snippet
    from the *Breaches.razor* markup file, which focuses on the email address input
    field:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 不显示整个标记文件，我将专注于与本地化相关的标记的特定部分。考虑来自 *Breaches.razor* 标记文件的以下片段，重点是电子邮件地址输入字段：
- en: '[PRE9]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This is the markup for the email address input. The framework-provided `InputText`
    is used to render the text input for the email address. Its `placeholder` displays
    a hint for the user, expressing what the expected value is for a given HTML `input`
    element. In this case, a localized string of `"Email address"` is rendered.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这是用于电子邮件地址输入的标记。框架提供的`InputText`用于呈现电子邮件地址的文本输入。它的`placeholder`显示了用户的提示，表达了给定HTML
    `input`元素的期望值。在这种情况下，渲染了本地化字符串`"电子邮件地址"`。
- en: 'Imagine that the user starts searching for data breaches. When an email isn’t
    found in any data-breach records (such is the case with *fake-email@not-real.com*),
    the results are formatted using the `IStringLocalizer<T>` indexer with parameter
    overload. Consider the following snippet from the *Breaches.razor* markup file:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，用户开始搜索数据泄露。当电子邮件地址未在任何数据泄露记录中找到（例如*fake-email@not-real.com*），结果将使用带有参数重载的`IStringLocalizer<T>`索引器进行格式化。考虑来自*Breaches.razor*标记文件的以下片段：
- en: '[PRE10]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In this scenario, the `Localizer` instance calls its indexer and passes the
    `"NoBreachesFormat"` resource name and the model’s `EmailAddress`. This renders
    as shown in [Figure 5-7](#breaches-no-results).
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`Localizer`实例调用其索引器，并传递`"NoBreachesFormat"`资源名称和模型的`EmailAddress`。这将呈现如[图5-7](#breaches-no-results)所示。
- en: The lack of a data breach is certainly a relief; however, it’s not entirely
    realistic. Chances are your email address has been compromised in a data breach.
    As an example, when the user searches for `test@user.org`, the `Breaches` page
    queries the Web.Api service’s `/api/pwned/breaches` endpoint. When the results
    are returned, the component updates to show a list of data breaches. To verify
    that the breaches page is capable of successfully communicating with the Web.PwnedApi
    project’s endpoints, we can use a test user email address that is known to have
    been breached seven times. If you visit the Learning Blazor sample app’s `Breaches`
    page and [enter the “test@user.org” email](https://oreil.ly/MimnM), you’ll see
    that it has, indeed, been *pwned* seven times, as shown in [Figure 5-8](#breaches).
    The `Breaches` page makes use of the custom-shared `ModalComponent` and displays
    the details of each breach when the result row is clicked.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 缺乏数据泄露确实是一种解脱；但这并非完全现实。您的电子邮件地址很可能已经在数据泄露中受到影响。例如，当用户搜索`test@user.org`时，`Breaches`页面会查询Web.Api服务的`/api/pwned/breaches`端点。返回结果后，组件更新以显示数据泄露列表。要验证`Breaches`页面是否能成功与Web.PwnedApi项目的端点进行通信，我们可以使用已知已被泄露七次的测试用户电子邮件地址。如果您访问学习Blazor示例应用程序的`Breaches`页面并[输入“test@user.org”电子邮件地址](https://oreil.ly/MimnM)，您将看到它确实已经被*pwned*了七次，如[图5-8](#breaches)所示。`Breaches`页面使用自定义共享的`ModalComponent`，在单击结果行时显示每次泄露的详细信息。
- en: '![](assets/lblz_0507.png)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/lblz_0507.png)'
- en: Figure 5-7\. The `Breaches` page rendering when no results are found
  id: totrans-185
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图5-7\. 在没有结果时呈现的`Breaches`页面
- en: '![](assets/lblz_0508.png)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/lblz_0508.png)'
- en: Figure 5-8\. The `Breaches` page rendering for test@user.org
  id: totrans-187
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图5-8\. 对于test@user.org的`Breaches`页面呈现
- en: Let’s say you’re interested in learning more about the Dropbox data breach.
    You can click on the breach to learn more information. This action displays the
    modal and passes the selected data breach record as a component parameter, as
    shown in [Figure 5-9](#dropbox-breach).
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您对了解更多关于Dropbox数据泄露感兴趣。您可以单击泄露以获取更多信息。此操作显示模态框，并将所选的数据泄露记录作为组件参数传递，如[图5-9](#dropbox-breach)所示。
- en: '![](assets/lblz_0509.png)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/lblz_0509.png)'
- en: Figure 5-9\. The Dropbox data breach modal
  id: totrans-190
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图5-9\. Dropbox数据泄露模态框
- en: 'To help further understand how localization works, we’ll look at the translation
    resource file of the *Breaches.razor.en.resx* XML:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助进一步理解本地化的工作原理，我们将查看*Breaches.razor.en.resx* XML的翻译资源文件：
- en: '[PRE11]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: There are several name-value pairs with English values in this resource file.
    Other languages will have their translated values. Most components inherit either
    from the custom `LocalizableComponentBase` or the framework-provided `IStringLocalizer`.
    Then each component defines resource files and uses the localizer instance to
    retrieve the resources at runtime.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在此资源文件中，有几对英文值的名称-值对。其他语言将有其翻译值。大多数组件都继承自自定义的`LocalizableComponentBase`或框架提供的`IStringLocalizer`。然后，每个组件定义资源文件，并在运行时使用本地化实例检索资源。
- en: 'Next, let’s look at the `Passwords` page and a select few segments from its
    *Passwords.razor* markup:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看`Passwords`页面及其*Passwords.razor*标记的几个片段：
- en: '[PRE12]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[![1](assets/1.png)](#co_localizing_the_app_CO8-1)'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_localizing_the_app_CO8-1)'
- en: The password `InputText` component has its `placeholder` and `DisplayName` attributes
    assigned from the localizer `"Password"` resource.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 密码 `InputText` 组件的 `placeholder` 和 `DisplayName` 属性来自本地化的 `"Password"` 资源。
- en: When the user first lands on this page, the results are empty, but the heading
    text and the message prompt are both localized resources. These are rendered as
    shown in [Figure 5-10](#passwords-empty).
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户首次进入此页面时，结果为空，但标题文本和消息提示均为本地化资源。如 [Figure 5-10](#passwords-empty) 所示渲染。
- en: '![](assets/lblz_0510.png)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/lblz_0510.png)'
- en: Figure 5-10\. The `Passwords` page
  id: totrans-200
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 5-10\. `Passwords` 页面
- en: 'Now we’ll see the following segment from the *Passwords.razor* markup, which
    is responsible for rendering the results content:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将看到 *Passwords.razor* 标记的以下部分，负责渲染结果内容：
- en: '[PRE13]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[![1](assets/1.png)](#co_localizing_the_app_CO9-1)'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_localizing_the_app_CO9-1)'
- en: The localizer gets the resource value matching the `"Results"` name and plots
    it into the `article` element heading.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 本地化器获取与 `"Results"` 名称匹配的资源值，并将其绘制到 `article` 元素标题中。
- en: '[![2](assets/2.png)](#co_localizing_the_app_CO9-2)'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_localizing_the_app_CO9-2)'
- en: Using a control structure, when the component’s `_pwnedPassword` object is not
    `null` and has a `IsPwned` value of `true`, two bits of information are added.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 使用控制结构时，当组件的 `_pwnedPassword` 对象不为 `null` 且具有 `IsPwned` 值为 `true` 时，添加了两个信息位。
- en: '[![3](assets/3.png)](#co_localizing_the_app_CO9-3)'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_localizing_the_app_CO9-3)'
- en: The number of times that the given password has been pwned is formatted as a
    string using the standard C# number formatting and the current culture.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 给定密码已被泄露的次数将使用标准的 C# 数字格式化和当前区域设置进行格式化为字符串。
- en: Imagine that a user types `"password"` into the input field and searches to
    see if it has ever been pwned. It’s easy to imagine that this password has been
    used many times, and you’re not wrong. See [Figure 5-11](#passwords-password)
    for an example rendering of how many times `"password"` has been pwned. Yikes!
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下用户在输入字段中输入 `"password"` 并搜索以查看其是否曾经被泄露。很容易想象这个密码已经被使用了很多次，你并没有错。参见 [Figure 5-11](#passwords-password)
    以查看 `"password"` 被泄露多少次的渲染示例。哎呀！
- en: '![](assets/lblz_0511.png)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/lblz_0511.png)'
- en: Figure 5-11\. The `Passwords` page with a pwned password
  id: totrans-211
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 5-11\. 具有泄露密码的 `Passwords` 页面
- en: 'There are a few additional control structures within the `Passwords` page.
    Consider the remaining *Passwords.razor* markup:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Passwords` 页面内还有几个额外的控制结构。考虑剩余的 *Passwords.razor* 标记：
- en: '[PRE14]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[![1](assets/1.png)](#co_localizing_the_app_CO10-1)'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_localizing_the_app_CO10-1)'
- en: If the password has been pwned, the `OhNoFormat` resource is used to format
    the localized message.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 如果密码已经被泄露，将使用 `OhNoFormat` 资源来格式化本地化消息。
- en: '[![2](assets/2.png)](#co_localizing_the_app_CO10-2)'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_localizing_the_app_CO10-2)'
- en: A message is displayed indicating that the password has not been compromised.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 显示消息指示密码未被泄露。
- en: '[![3](assets/3.png)](#co_localizing_the_app_CO10-3)'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_localizing_the_app_CO10-3)'
- en: Otherwise, a prompt localizer message is displayed.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，显示本地化提示消息。
- en: For relying on whether the `_pwnedPassword` object is `null` and when it has
    an `IsPwned` value of `true`, there is conditional rendering. This will show the
    exclamation icon with a formatted resource matching the `"OhNoFormat"` name and
    given the number of times the password has been pwned. This relies on the `Localizer`
    indexer overload that accepts `params object[] arguments`. When the `_state` object
    is set as loaded, but the `_pwnedPassword` object is either `null` or has a nonpwned
    result, the `"NotPwned"` resource is rendered. When the page is first rendered,
    neither the `_pwnedPassword` object nor the `_state` object is set; in this case,
    the `"EnterPassword"` resource is rendered. This prompts the user to enter a password.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 根据 `_pwnedPassword` 对象是否为 `null` 以及其具有 `IsPwned` 值为 `true` 的情况，进行条件渲染。这将显示带有格式化资源的感叹号图标，匹配
    `"OhNoFormat"` 名称，并给出密码被泄露的次数。这依赖于接受 `params object[] arguments` 的 `Localizer`
    索引器重载。当 `_state` 对象设置为加载状态，但 `_pwnedPassword` 对象为 `null` 或具有非泄露结果时，将渲染 `"NotPwned"`
    资源。当页面首次渲染时，既不设置 `_pwnedPassword` 对象也不设置 `_state` 对象；在这种情况下，将渲染 `"EnterPassword"`
    资源。提示用户输入密码。
- en: 'Notice in the following XML resource that each `data` node has a `name` attribute
    and a single `value` subnode. Consider the *Passwords.razor.en.resx* file:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的 XML 资源中注意，每个 `data` 节点都有一个 `name` 属性和一个单独的 `value` 子节点。考虑 *Passwords.razor.en.resx*
    文件：
- en: '[PRE15]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Summary
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, I showed you how to localize Blazor WebAssembly apps. You learned
    what *localization* means as it pertains to .NET apps and what it means to *localize*
    an app. I showed you how to localize apps into dozens of languages using a GitHub
    Action that relies on Azure Cognitive Services. I explained how Blazor WebAssembly
    recognizes resource files using a familiar resource manager. I also covered how
    to consume the `IStringLocalizer<T>` interface.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我向你展示了如何本地化 Blazor WebAssembly 应用程序。你学到了在 .NET 应用程序中什么是*本地化*，以及*本地化*应用程序的含义。我向你展示了如何使用依赖于
    Azure Cognitive Services 的 GitHub Action 将应用程序本地化到数十种语言。我解释了 Blazor WebAssembly
    如何使用熟悉的资源管理器识别资源文件。我还介绍了如何使用`IStringLocalizer<T>`接口消耗资源。
- en: In the next chapter, you’ll learn how to use ASP.NET Core SignalR with Blazor
    WebAssembly. You’ll learn a pattern for using real-time web functionality throughout
    the app, along with a custom notification system, messaging page, and live tweet
    streaming page.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，你将学习如何在 Blazor WebAssembly 中使用 ASP.NET Core SignalR。你将学习一种模式，可以在整个应用中使用实时
    web 功能，包括自定义通知系统、消息页面和实时推特流页面。
- en: '^([1](ch05.html#idm46365018501872-marker)) Donald Knuth, “Structured Programming
    with go to Statements,” *ACM Computing Surveys* 6, no. 4 (Dec. 1974): 261–301,
    [*https://doi.org/10.1145/356635.356640*](https://doi.org/10.1145/356635.356640).'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch05.html#idm46365018501872-marker)) Donald Knuth，“带有 go to 语句的结构化编程”，*ACM
    Computing Surveys* 6, no. 4（1974 年 12 月）：261–301，[*https://doi.org/10.1145/356635.356640*](https://doi.org/10.1145/356635.356640)。
