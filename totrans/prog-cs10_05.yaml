- en: Chapter 5\. Collections
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第五章\. 集合
- en: Most programs need to deal with multiple pieces of data. Your code might have
    to iterate through some transactions to calculate the balance of an account, for
    example, or display recent messages in a social media web application, or update
    the positions of characters in a game. In most kinds of applications, the ability
    to work with collections of information is likely to be important.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数程序需要处理多个数据片段。例如，你的代码可能需要迭代一些交易来计算账户的余额，或者在社交媒体Web应用程序中显示最近的消息，或者更新游戏中角色的位置。在大多数应用程序中，处理信息集合的能力可能是非常重要的。
- en: C# offers a simple kind of collection called an *array*. The CLR’s type system
    supports arrays intrinsically, so they are efficient, but for some scenarios they
    can be too basic, so the runtime libraries build on the fundamental services provided
    by arrays to provide more powerful and flexible collection types. I’ll start with
    arrays, because they are the foundation of most of the collection classes.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: C# 提供了一种简单的集合类型，称为*数组*。CLR 的类型系统本身支持数组，因此它们很高效，但对于某些场景来说可能太基础了，因此运行库在数组提供的基础服务上构建了更强大和灵活的集合类型。我会从数组开始讲起，因为它们是大多数集合类的基础。
- en: Arrays
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数组
- en: An array is an object that contains multiple *elements* of a particular type.
    Each element is a storage location similar to a field, but whereas with fields
    we give each storage slot a name, array elements are simply numbered. The number
    of elements is fixed for the lifetime of the array, so you must specify the size
    when you create it. [Example 5-1](#creating_arrays) shows the syntax for creating
    new arrays.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 数组是一个包含特定类型多个*元素*的对象。每个元素都是一个类似于字段的存储位置，但不同于字段的是，数组元素仅仅是按数字编号。数组的元素数量在其生命周期内是固定的，因此在创建数组时必须指定大小。[示例 5-1](#creating_arrays)展示了创建新数组的语法。
- en: Example 5-1\. Creating arrays
  id: totrans-5
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-1\. 创建数组
- en: '[PRE0]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As with all objects, we construct an array with the `new` keyword followed by
    a type name, but instead of parentheses with constructor arguments, we put square
    brackets containing the array size. As the example shows, the expression defining
    the size can be a constant, but it doesn’t have to be—the second array’s size
    will be determined by evaluating `numbers.Length` at runtime. In this case, the
    second array will have 10 elements, because we’re using the first array’s `Length`
    property. All arrays have this read-only property, and it returns the total number
    of elements in the array.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 与所有对象一样，我们使用 `new` 关键字和类型名称构造数组，但是与构造函数参数用括号不同的是，我们使用包含数组大小的方括号。正如示例所示，定义大小的表达式可以是一个常量，但不必如此——第二个数组的大小将通过在运行时评估
    `numbers.Length` 来确定。在这种情况下，第二个数组将有10个元素，因为我们使用了第一个数组的 `Length` 属性。所有数组都有这个只读属性，它返回数组中的总元素数。
- en: The `Length` property’s type is `int`, which means it can cope with arrays of
    up to about 2.1 billion elements. In a 32-bit process, the limiting factor on
    array size is likely to be available address space, but back when .NET added support
    for 64-bit processes, larger arrays became possible, so there’s also a `LongLength`
    property of type `long`. However, you don’t see that used much, because the runtime
    does not currently support creation of arrays with more than 2,147,483,591 (0x7FFFFFC7)
    elements in any single dimension. So only rectangular multidimensional arrays
    (described later in this chapter) can contain more elements than `Length` can
    report. And even those have an upper limit of 4,294,967,295 (0xFFFFFFFF) elements
    on current versions of .NET.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '`Length` 属性的类型是 `int`，这意味着它可以处理多达约 21 亿个元素的数组。在32位进程中，数组大小的限制因素可能是可用地址空间，但在.NET支持64位进程后，可以使用更大的数组，因此还有一个
    `LongLength` 属性，类型为 `long`。然而，你不经常看到它被使用，因为运行时当前不支持创建超过 2,147,483,591 (0x7FFFFFC7)
    个元素的数组。因此，只有矩形多维数组（本章后面描述）可以包含比 `Length` 报告的更多元素。甚至这些数组在当前版本的.NET上也有上限，为 4,294,967,295
    (0xFFFFFFFF) 个元素。'
- en: Note
  id: totrans-9
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'If you’re using .NET Framework, you’ll run into another limit first: a single
    array cannot normally take more than 2 GB of memory. (This is an upper limit on
    the size of any single object. In practice, only arrays usually run into this
    limit, although you could conceivably hit it with a particularly long string.)
    You can overcome this by adding a `<gcAllowVeryLargeObjects enabled="true" />`
    element inside the `<runtime>` section of a project’s *App.config* file. The limits
    in the preceding paragraph still apply, along with an additional restriction that
    arrays with an element type other than `byte` cannot have more than 0x7FFEFFFF
    elements. Even so, these are significantly less restrictive than a 2 GB ceiling.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是.NET Framework，你将首先遇到另一个限制：单个数组通常不能占用超过2 GB的内存。（这是任何单个对象大小的上限。实际上，通常只有数组会遇到这个限制，尽管你可能会用特别长的字符串达到这个限制。）你可以通过在项目的*App.config*文件的`<runtime>`部分内添加`<gcAllowVeryLargeObjects
    enabled="true" />`元素来克服这一限制。前面段落中的限制仍然适用，另外还有一个额外的限制：元素类型不是`byte`的数组不能超过0x7FFEFFFF个元素。即便如此，这些限制要比2
    GB的上限宽松得多。
- en: In [Example 5-1](#creating_arrays), I’ve broken my normal rule of avoiding redundant
    type names in variable declarations. The initializer expressions make it clear
    that the variables are arrays of `int` and `string`, respectively, so I’d normally
    use `var` for this sort of code, but I’ve made an exception here so that I can
    show how to write the name of an array type. Array types are distinct types in
    their own right, and if we want to refer to the type that is a single dimensional
    array of some particular element type, we put `[]` after the element type name.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在[示例5-1](#creating_arrays)中，我打破了避免变量声明中多余类型名称的常规规则。初始化表达式清楚地表明变量分别是`int`和`string`数组，所以我通常会对这种代码使用`var`，但我在这里做了一个例外，以便展示如何写出数组类型的名称。数组类型在其自身的权利中是不同的类型，如果我们想引用特定元素类型的单维数组类型，我们将在元素类型名称之后放置`[]`。
- en: All array types derive from a common base class called `System.Array`. This
    defines the `Length` and `LongLength` properties and various other members we’ll
    be looking at in due course. You can use array types in all the usual places you
    can use other types. So you could declare a field, or a method parameter of type
    `string[]`. You can also use an array type as a generic type argument. For example,
    `IEnumerable<int[]>` would be a sequence of arrays of integers (each of which
    could be a different size).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的数组类型都派生自一个名为`System.Array`的共同基类。这个类定义了`Length`和`LongLength`属性以及其他我们接下来会看到的成员。你可以在所有可以使用其他类型的地方使用数组类型。所以你可以声明一个类型为`string[]`的字段或者方法参数。你也可以将数组类型用作泛型类型参数。例如，`IEnumerable<int[]>`将会是一个整数数组的序列（每个数组可能大小不同）。
- en: An array type is always a reference type, regardless of the element type. Nonetheless,
    the choice between reference type and value type elements makes a significant
    difference in an array’s behavior. As discussed in [Chapter 3](ch03.xhtml#ch_types),
    when an object has a field with a value type, the value itself lives inside the
    memory allocated for the object. The same is true for arrays—when the elements
    are value types, the value lives in the array element itself, but with a reference
    type, elements contain only references. Each instance of a reference type has
    its own identity, and since multiple variables may all end up referring to that
    instance, the CLR needs to manage its lifetime independently of any other object,
    so it will end up with its own distinct block of memory. So while an array of
    1,000 `int` values can all live in one contiguous memory block, with reference
    types, the array just contains the references, not the actual instances. An array
    of 1,000 different strings would need 1,001 heap blocks—one for the array and
    one for each string.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 无论元素类型如何，数组类型始终是引用类型。尽管如此，在引用类型和值类型元素之间的选择在数组的行为上有重大差异。正如在[第3章](ch03.xhtml#ch_types)中讨论的，当对象具有值类型字段时，该值本身存在于为对象分配的内存中。对于数组也是如此——当元素为值类型时，值存在于数组元素本身，但对于引用类型，元素只包含引用。每个引用类型的实例都有其自己的标识，由于多个变量可能最终都引用该实例，CLR需要独立管理其生存周期，因此它将拥有自己独立的内存块。因此，虽然包含1,000个`int`值的数组可以全部存在于一个连续的内存块中，但对于引用类型，数组只包含引用，而不包含实际实例。包含1,000个不同字符串的数组将需要1,001个堆块——一个用于数组本身，每个字符串一个。
- en: Note
  id: totrans-14
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注
- en: When using reference type elements, you’re not obliged to make every element
    in an array of references refer to a distinct object. You can leave as many elements
    as you like set to `null`, and you’re also free to make multiple elements refer
    to the same object. This is just another variation on the theme that references
    in array elements work in much the same way as they do in local variables and
    fields.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用引用类型元素时，你不必让引用数组中的每个元素都引用不同的对象。你可以将任意数量的元素设置为`null`，而且还可以自由地使多个元素引用同一个对象。这只是数组元素中引用工作方式的另一种变化，它与局部变量和字段中的引用工作方式基本相同。
- en: To access an element in an array, we use square brackets containing the index
    of the element we’d like to use. The index is zero-based. [Example 5-2](#accessing_array_elements)
    shows a few examples.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问数组中的元素，我们使用包含我们想要使用的元素索引的方括号。索引是从零开始的。[示例 5-2](#accessing_array_elements)展示了一些示例。
- en: Example 5-2\. Accessing array elements
  id: totrans-17
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-2\. 访问数组元素
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As with the array’s size at construction, the array index can be a constant,
    but it can also be a more complex expression, calculated at runtime. In fact,
    that’s also true of the part that comes directly before the opening bracket. In
    [Example 5-2](#accessing_array_elements), I’ve just used a variable name to refer
    to an array, but you can use brackets after any array-typed expression. [Example 5-3](#convoluted_array_access)
    retrieves the first element of an array returned by a method call. (The details
    of the example aren’t strictly relevant, but in case you’re wondering, it finds
    the copyright message associated with the component that defines an object’s type.
    For example, if you pass a `string` to the method, it will return “© Microsoft
    Corporation. All rights reserved.” This uses the reflection API and custom attributes,
    the topics of Chapters [13](ch13.xhtml#ch_reflection) and [14](ch14.xhtml#ch_attributes).)
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 与数组大小在构建时一样，数组索引可以是一个常量，但也可以是在运行时计算的更复杂的表达式。实际上，直接位于开放括号之前的部分也是如此。在[示例 5-2](#accessing_array_elements)中，我只是使用了一个变量名来引用一个数组，但是你可以在任何数组类型的表达式之后使用括号。[示例 5-3](#convoluted_array_access)检索由方法调用返回的数组的第一个元素。（示例的细节并不严格相关，但如果你在想，它找到与定义对象类型的组件相关联的版权信息。例如，如果你将一个`string`传递给方法，它将返回“©
    Microsoft Corporation. All rights reserved.” 这使用了反射API和自定义属性，这些是第[13](ch13.xhtml#ch_reflection)和第[14](ch14.xhtml#ch_attributes)章的主题。）
- en: Example 5-3\. Convoluted array access
  id: totrans-20
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-3\. 复杂的数组访问
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Expressions involving array element access are special, in that C# considers
    them to be a kind of variable. This means that as with local variables and fields,
    you can use them on the lefthand side of an assignment statement, whether they’re
    simple, like the expressions in [Example 5-2](#accessing_array_elements), or more
    complex, like those in [Example 5-3](#convoluted_array_access). You can also use
    them with the `ref` keyword (as described in [Chapter 3](ch03.xhtml#ch_types))
    to pass a reference to a particular element to a method, to store it in a `ref`
    local variable, or to return it from a method with a `ref` return type.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 涉及数组元素访问的表达式是特殊的，因为C#将它们视为一种变量。这意味着与局部变量和字段一样，无论是简单的表达式（如[示例 5-2](#accessing_array_elements)中的表达式）还是更复杂的表达式（如[示例 5-3](#convoluted_array_access)中的表达式），你都可以将它们用作赋值语句的左操作数。你还可以使用`ref`关键字（如[第 3](ch03.xhtml#ch_types)章所述）将特定元素的引用传递给方法，将其存储在`ref`局部变量中，或者将其作为具有`ref`返回类型的方法的返回值。
- en: The CLR always checks the index against the array size. If you try to use either
    a negative index or an index greater than or equal to the length of the array,
    the runtime will throw an `IndexOutOfRangeException`.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: CLR始终检查索引与数组大小是否匹配。如果尝试使用负索引或大于或等于数组长度的索引，运行时将抛出`IndexOutOfRangeException`异常。
- en: Although the size of an array is invariably fixed, its contents are always modifiable—there
    is no such thing as a read-only array. (As we’ll see in [“ReadOnlyCollection<T>”](#readonlycollection_of_t),
    .NET provides a class that can act as a read-only façade for an array.) You can,
    of course, create an array with an immutable element type, and this will prevent
    you from modifying the element in place. So [Example 5-4](#how_not_to_modify_an_array_with_immutabl),
    which uses the immutable `Complex` value type provided by .NET, will not compile.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管数组的大小固定不变，但其内容始终可修改——并不存在只读数组。 （正如我们将在[“ReadOnlyCollection<T>”](#readonlycollection_of_t)中看到的，.NET提供了一个可以作为数组的只读外观的类。）当然，您可以创建一个具有不可变元素类型的数组，这将阻止您在原地修改元素。因此，使用.NET提供的不可变`Complex`值类型的[示例 5-4](#how_not_to_modify_an_array_with_immutabl)将无法编译。
- en: Example 5-4\. How not to modify an array with immutable elements
  id: totrans-25
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-4\. 如何不修改具有不可变元素的数组
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The compiler complains because the `Real` and `Imaginary` properties are read-only;
    `Complex` does not provide any way to modify its values. Nevertheless, you can
    modify the array: even if you can’t modify an existing element in place, you can
    always overwrite it by supplying a different value, as [Example 5-5](#modifying_an_array_with_immutable_elemen)
    shows.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器抱怨因为`Real`和`Imaginary`属性是只读的；`Complex`不提供任何修改其值的方法。尽管如此，您仍然可以修改数组：即使无法就地修改现有元素，您始终可以通过提供不同的值来覆盖它，正如[示例 5-5](#modifying_an_array_with_immutable_elemen)所示。
- en: Example 5-5\. Modifying an array with immutable elements
  id: totrans-28
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-5\. 修改具有不可变元素的数组
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Read-only arrays wouldn’t be much use in any case, because all arrays start
    out filled with a default value that you don’t get to specify. The CLR fills the
    memory for a new array with zeros, so you’ll see `0`, `null`, or `false`, depending
    on the array’s element type.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，只读数组在任何情况下都没有什么用，因为所有数组最初都填充了默认值，您无法指定。CLR会用零填充新数组的内存，因此您将看到`0`、`null`或`false`，具体取决于数组的元素类型。
- en: Warning
  id: totrans-31
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: C# 10.0 adds the ability to write a zero-argument constructor for a `struct`.
    You might have expected array creation to invoke constructors of this kind automatically.
    It does not.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: C# 10.0添加了为`struct`编写零参数构造函数的能力。您可能期望数组创建自动调用此类构造函数。事实并非如此。
- en: For some applications, all-zero (or equivalent) content might be a useful initial
    state for an array, but in some cases, you’ll want to set some other content before
    starting to work.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 对于某些应用程序来说，全零（或等效）内容可能是数组的有用初始状态，但在某些情况下，您可能需要在开始工作之前设置一些其他内容。
- en: Array Initialization
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数组初始化
- en: The most straightforward way to initialize an array is to assign values into
    each element in turn. [Example 5-6](#laborious_array_initialization) creates a
    `string` array, and since `string` is a reference type, creating a five-element
    array doesn’t create five strings. Our array starts out with five nulls. (This
    is true even if you’ve enabled C#’s nullable references feature, as described
    in [Chapter 3](ch03.xhtml#ch_types). Unfortunately, array initialization is one
    of the holes that make it impossible for that feature to offer absolute guarantees
    of non-nullness.) So the example goes on to populate each array element with a
    reference to a string.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化数组最直接的方法是依次为每个元素分配值。[示例 5-6](#laborious_array_initialization)创建了一个`string`数组，由于`string`是引用类型，创建五个元素的数组并不会创建五个字符串。我们的数组最初有五个空值。（即使您已启用C#的可空引用功能，如[第3章](ch03.xhtml#ch_types)所述。不幸的是，数组初始化是使该功能无法提供绝对非空性保证的漏洞之一。）因此，示例继续为每个数组元素填充了对字符串的引用。
- en: Example 5-6\. Laborious array initialization
  id: totrans-36
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-6\. 繁琐的数组初始化
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This works, but it is unnecessarily verbose. C# supports a shorter syntax that
    achieves the same thing, shown in [Example 5-7](#array_initializer_syntax). The
    compiler turns this into code that works like [Example 5-6](#laborious_array_initialization).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法虽然可行，但冗长了。C#支持一种更简洁的语法，可以实现相同的效果，详见[示例 5-7](#array_initializer_syntax)。编译器将其转换为与[示例 5-6](#laborious_array_initialization)类似的代码。
- en: Example 5-7\. Array initializer syntax
  id: totrans-39
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-7\. 数组初始化语法
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: You can go further. [Example 5-8](#shorter_array_initializer_syntax) shows that
    if you specify the type explicitly in the variable declaration, you can write
    just the initializer list, leaving out the `new` keyword. This works only in initializer
    expressions, by the way; you can’t use this syntax to create an array in other
    expressions, such as assignments or method arguments. (The more verbose initializer
    expression in [Example 5-7](#array_initializer_syntax) works in all those contexts.)
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以更进一步。[示例 5-8](#shorter_array_initializer_syntax) 显示，如果在变量声明中明确指定类型，你可以只写初始化列表，省略
    `new` 关键字。顺便说一句，这只在初始化表达式中有效；在其他表达式中（如赋值或方法参数），你不能使用这种语法创建数组。（在 [示例 5-7](#array_initializer_syntax)
    中更详细的初始化表达式在所有这些上下文中都有效。）
- en: Example 5-8\. Shorter array initializer syntax
  id: totrans-42
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-8\. 更短的数组初始化语法
- en: '[PRE7]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We can go further still: if all the expressions inside the array initializer
    list are of the same type, the compiler can infer the array type, so we can write
    just `new[]` without an explicit element type. [Example 5-9](#array_initializer_infer_element_type)
    does this.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以更进一步：如果数组初始化列表内的所有表达式都是相同类型，编译器可以推断出数组类型，因此我们可以只写 `new[]` 而不需要显式元素类型。[示例 5-9](#array_initializer_infer_element_type)
    就是这样做的。
- en: Example 5-9\. Array initializer syntax with element type inference
  id: totrans-45
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-9\. 元素类型推断的数组初始化语法
- en: '[PRE8]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: That was actually slightly longer than [Example 5-8](#shorter_array_initializer_syntax).
    However, as with [Example 5-7](#array_initializer_syntax), this style is not limited
    to variable initialization. You can also use it when you need to pass an array
    as an argument to a method, for example. If the array you are creating will only
    be passed into a method and never referred to again, you may not want to declare
    a variable to refer to it. It might be neater to write the array directly in the
    argument list. [Example 5-10](#array_as_argument) passes an array of strings to
    a method using this technique.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这比 [示例 5-8](#shorter_array_initializer_syntax) 稍微长一些。但是，与 [示例 5-7](#array_initializer_syntax)
    一样，这种风格并不局限于变量初始化。例如，在需要将数组作为参数传递给方法时，也可以使用它。如果你创建的数组只会被传递到方法中并且不再被引用，你可能不想声明一个变量来引用它。直接在参数列表中写数组可能更加简洁。[示例 5-10](#array_as_argument)
    就是使用这种技术将字符串数组传递给方法的示例。
- en: Example 5-10\. Array as argument
  id: totrans-48
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-10\. 作为参数的数组
- en: '[PRE9]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Searching and Sorting
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 搜索和排序
- en: Sometimes, you will not know the index of the array element you need. For example,
    suppose you are writing an application that shows a list of recently used files.
    Each time the user opens a file in your application, you would want to bring that
    file to the top of the list, and you’d need to detect when the file was already
    in the list to avoid having it appear multiple times. If the user happened to
    use your recent file list to open the file, you would already know it’s in the
    list and at what offset. But what if the user opens the file some other way? In
    that case, you’ve got a filename, and you need to find out where that appears
    in your list, if it’s there at all.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，你可能不知道需要的数组元素的索引。例如，假设你正在编写一个显示最近使用文件列表的应用程序。每次用户在你的应用程序中打开一个文件时，你都希望将该文件移动到列表顶部，并且你需要检测文件是否已经在列表中，以避免出现多次显示。如果用户恰好使用你的最近文件列表打开文件，你已经知道它在列表中且位于哪个偏移量。但是如果用户以其他方式打开文件呢？在这种情况下，你有一个文件名，需要找出它在列表中的位置，如果存在的话。
- en: Arrays can help you find the item you want in this kind of scenario. There are
    methods that examine each element in turn, stopping at the first match, and there
    are also methods that can work considerably faster if your array stores its elements
    in a particular order. To help with that, there are also methods for sorting the
    contents of an array into whichever order you require.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 数组可以帮助你在这种情况下找到你想要的项。有些方法会逐个检查每个元素，停在第一个匹配项上，还有一些方法可以在特定顺序存储其元素的数组中更快地工作。为了帮助处理这种情况，还有一些方法可以对数组内容进行排序，按照你需要的任何顺序排序。
- en: 'The static `Array.IndexOf` method provides the most straightforward way to
    search for an element. It does not need your array elements to be in any particular
    order: you just pass it the array in which to search and the value you’re looking
    for, and it will walk through the elements until it finds a value equal to the
    one you want. It returns the index at which it found the first matching element,
    or −1 if it reached the end of the array without finding a match. [Example 5-11](#searching_with_indexof)
    shows how you might use this method as part of the logic for updating a list of
    recently opened files.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 静态的 `Array.IndexOf` 方法提供了搜索元素的最简单方法。它不需要你的数组元素处于任何特定顺序：你只需传递要搜索的数组和你要查找的值，它将遍历元素直到找到与你想要的值相等的元素。它返回找到的第一个匹配元素的索引，如果在数组末尾没有找到匹配项则返回
    −1。[示例 5-11](#searching_with_indexof) 展示了如何在更新最近打开文件列表的逻辑中使用此方法。
- en: Example 5-11\. Searching with `IndexOf`
  id: totrans-54
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-11\. 使用 `IndexOf` 进行搜索
- en: '[PRE10]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: That example starts its search at the beginning of the array, but you have other
    options. The `IndexOf` method is overloaded, and you can pass an index from which
    to start searching and optionally a second number indicating how many elements
    you want it to look at before it gives up. There’s also a `LastIndexOf` method,
    which works in reverse. If you do not specify an index, it starts from the end
    of the array and works backward. As with `IndexOf`, you can provide one or two
    more arguments, indicating the offset at which you’d like to start and the number
    of elements to check.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 该示例从数组的开头开始搜索，但你也有其他选项。`IndexOf` 方法是重载的，你可以传递一个起始搜索的索引，还可以选择传递第二个数字，表示在放弃搜索之前要查看的元素数。还有一个
    `LastIndexOf` 方法，它是反向工作的。如果你不指定索引，它将从数组的末尾开始向前工作。与 `IndexOf` 类似，你可以提供一个或两个额外的参数，指示你想要开始搜索的偏移量以及要检查的元素数。
- en: 'These methods are fine if you know precisely what value you’re looking for,
    but often, you’ll need to be a bit more flexible: you may want to find the first
    (or last) element that meets some particular criteria. For example, suppose you
    have an array representing the bin values for a histogram. It might be useful
    to find out which is the first nonempty bin. So rather than searching for a particular
    value, you’d want to find the first element with any value other than zero. [Example 5-12](#searching_with_findindex)
    shows how to use the `FindIndex` method to locate the first such entry.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你确切知道你要查找的值，这些方法都很好用。但通常情况下，你可能需要更加灵活：你可能想找到符合某些特定条件的第一个（或最后一个）元素。例如，假设你有一个表示直方图中箱子值的数组。找到第一个非空箱子可能是有用的。因此，你不是在寻找特定值，而是想找到第一个值不为零的元素。[示例 5-12](#searching_with_findindex)
    展示了如何使用 `FindIndex` 方法来定位第一个符合条件的条目。
- en: Example 5-12\. Searching with `FindIndex`
  id: totrans-58
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-12\. 使用 `FindIndex` 进行搜索
- en: '[PRE11]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: My `IsNonZero` method contains the logic that decides whether any particular
    element is a match, and I’ve passed that method as an argument to `FindIndex`.
    You can pass any method with a suitable signature—`FindIndex` requires a method
    that takes an instance of the array’s element type and returns a `bool`. (Strictly
    speaking, it takes a `Predicate<T>`, which is a kind of delegate, something I’ll
    discuss in [Chapter 9](ch09.xhtml#ch_delegates_lambdas_events).) Since any method
    with a suitable signature will do, we can make our search criteria as simple or
    as complex as we like.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我的 `IsNonZero` 方法包含决定任何特定元素是否匹配的逻辑，并将该方法作为参数传递给 `FindIndex`。你可以传递任何具有合适签名的方法
    —— `FindIndex` 需要一个接受数组元素类型的实例并返回 `bool` 的方法。（严格来说，它接受一个 `Predicate<T>`，这是一种委托，我将在[第9章](ch09.xhtml#ch_delegates_lambdas_events)讨论。）由于任何具有适当签名的方法都可以，我们可以使我们的搜索条件简单或者复杂，随心所欲。
- en: By the way, the logic for this particular example is so simple that writing
    a separate method for the condition is probably overkill. For simple cases such
    as these, you’d almost certainly use the lambda syntax (using `=>` to indicate
    that an expression represents an inline function) instead. That’s also something
    I’ll be discussing in [Chapter 9](ch09.xhtml#ch_delegates_lambdas_events), so
    this is jumping ahead, but I’ll just show how it looks because it’s more concise.
    [Example 5-13](#using_a_lambda_with_findindex) has exactly the same effect as
    [Example 5-12](#searching_with_findindex) but doesn’t require us to declare and
    write a whole extra method explicitly. (And at the time of writing this, it’s
    also more efficient, because with a lambda, the compiler generates code that reuses
    the `Predicate<T>` object that it creates, whereas [Example 5-12](#searching_with_findindex)
    will construct a new one each time.)
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便提一句，这个特定示例的逻辑如此简单，以至于为条件单独编写一个方法可能有些大材小用。对于这类简单情况，你几乎肯定会使用 lambda 语法（使用 `=>`
    表示表达式代表内联函数），而不是单独编写方法。这也是我将在 [第9章](ch09.xhtml#ch_delegates_lambdas_events) 中讨论的内容，所以这有些超前，但我只是展示一下它的样子，因为更为简洁。[示例
    5-13](#using_a_lambda_with_findindex) 的效果与 [示例 5-12](#searching_with_findindex)
    完全相同，但不需要我们显式声明和编写一个完整的额外方法。（并且在撰写本文时，它也更高效，因为使用 lambda，编译器生成代码以重用它创建的 `Predicate<T>`
    对象，而 [示例 5-12](#searching_with_findindex) 每次都会构造一个新的对象。）
- en: Example 5-13\. Using a lambda with `FindIndex`
  id: totrans-62
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-13\. 使用 lambda 和 `FindIndex`
- en: '[PRE12]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: As with `IndexOf`, `FindIndex` provides overloads that let you specify the offset
    at which to start searching and the number of elements to check before giving
    up. The `Array` class also provides `FindLastIndex`, which works backward—it corresponds
    to `LastIndexOf`, much as `FindIndex` corresponds to `IndexOf`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `IndexOf` 类似，`FindIndex` 提供了重载，允许您指定开始搜索的偏移量和在放弃之前检查的元素数量。`Array` 类还提供了 `FindLastIndex`，它向后工作，对应于
    `LastIndexOf`，就像 `FindIndex` 对应于 `IndexOf` 一样。
- en: 'When you’re searching for an array entry that meets some particular criteria,
    you might not be all that interested in the index of the matching element—you
    might need to know only the value of the first match. Obviously, it’s pretty easy
    to get that: you can just use the value returned by `FindIndex` in conjunction
    with the array index syntax. However, you don’t need to, because the `Array` class
    offers `Find` and `FindLast` methods that search in precisely the same way as
    `FindIndex` and `FindLastIndex` but that return the first or last matching value
    instead of returning the index at which that value was found.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 当您搜索满足某些特定条件的数组条目时，您可能并不那么关心匹配元素的索引，您可能只需要知道第一个匹配的值。显然，获得这个值非常容易：您可以结合数组索引语法使用
    `FindIndex` 返回的值。然而，您并不需要这样做，因为 `Array` 类提供了 `Find` 和 `FindLast` 方法，以完全相同的方式进行搜索，但返回第一个或最后一个匹配的值，而不是返回找到该值的索引。
- en: An array could contain multiple items that meet your criteria, and you might
    want to find all of them. You could write a loop that calls `FindIndex`, adding
    one to the index of the previous match and using that as the starting point for
    the next search, repeating until either reaching the end of the array or getting
    a result of −1, indicating that no more matches were found. And that would be
    the way to go if you needed to know the index of each match. But if you are interested
    only in knowing all of the matching values, and do not need to know exactly where
    those values were in the array, you could use the `FindAll` method shown in [Example 5-14](#finding_multiple_items_with_findall)
    to do all the work for you.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 数组可能包含多个满足您条件的项，您可能希望找到它们全部。您可以编写一个循环调用 `FindIndex`，将前一个匹配项的索引加一作为下一个搜索的起点，重复此过程，直到达到数组的末尾或得到一个结果为
    -1，表示没有找到更多的匹配项。如果您只对知道所有匹配值感兴趣，而不需要准确知道这些值在数组中的位置，您可以使用 [示例 5-14](#finding_multiple_items_with_findall)
    中展示的 `FindAll` 方法来完成所有工作。
- en: Example 5-14\. Finding multiple items with `FindAll`
  id: totrans-67
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-14\. 使用 `FindAll` 查找多个项
- en: '[PRE13]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This takes any array with reference type elements and returns an array that
    contains only the non-null elements in that array.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法接受任何包含引用类型元素的数组，并返回一个仅包含该数组中非空元素的数组。
- en: All of the search methods I’ve shown so far run through an array’s elements
    in order, testing each element in turn. This works well enough, but with large
    arrays it may be unnecessarily expensive, particularly in cases where comparisons
    are relatively complex. Even for simple comparisons, if you need to deal with
    arrays with millions of elements, this sort of search can take long enough to
    introduce visible delays. However, we can do much better. For example, given an
    array of values sorted into ascending order, a *binary search* can perform many
    orders of magnitude better. [Example 5-15](#sort_array_and_binarysearch) shows
    two methods. The first, `Sort`, sorts an array of numbers into ascending order.
    And if we have such a sorted array, we can then pass it to `Find`, which uses
    the `Array.BinarySearch` method.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我展示的所有搜索方法都是按顺序遍历数组的元素，逐个测试每个元素。这种方法已经足够有效，但对于大型数组来说，可能会显得不必要地昂贵，特别是在比较相对复杂的情况下。即使是简单的比较，如果你需要处理数百万个元素的数组，这种搜索方式也可能耗费足够长的时间以至于引入明显的延迟。但是，我们可以做得更好。例如，如果给定一个按升序排序的值数组，*二分查找*
    的性能可以提高数个数量级。[示例 5-15](#sort_array_and_binarysearch) 展示了两种方法。首先，`Sort` 方法将数字数组按升序排序。然后，如果我们有这样一个已排序的数组，我们可以将其传递给
    `Find` 方法，该方法使用 `Array.BinarySearch` 方法。
- en: Example 5-15\. Sorting an array, and `BinarySearch`
  id: totrans-71
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-15\. 排序数组和 `BinarySearch`
- en: '[PRE14]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Binary search is a widely used algorithm that exploits the fact that its input
    is sorted to be able to rule out half of the array at each step. It starts with
    the element in the middle of the array. If that happens to be the value required,
    it can stop, but otherwise, depending on whether the value it found is higher
    or lower than the value we want, it can know instantly which half of the array
    the value will be in (if it’s present at all). It then leaps to the middle of
    the remaining half, and if that’s not the right value, again it can determine
    which quarter will contain the target. At each step, it narrows the search down
    by half, and after halving the size a few times, it will be down to a single item.
    If that’s not the value it’s looking for, the item it wants is missing.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 二分查找是一种广泛使用的算法，利用输入已排序的事实，能够在每一步排除一半的数组。它从数组中间开始。如果恰好这个值就是我们需要的值，搜索可以停止，否则，根据它找到的值是高于还是低于我们想要的值，它可以立即知道值会在数组的哪一半（如果存在的话）。然后它跳到剩余一半的中间，如果那不是正确的值，再次可以确定哪一部分将包含目标。在每一步中，它通过一半来缩小搜索范围，几次减半后，搜索将缩小到单个项。如果这不是它正在寻找的值，那么所需的项就不存在。
- en: Tip
  id: totrans-74
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: '`BinarySearch` produces negative numbers when the value is not found. In these
    cases, this binary chop process will finish at the value nearest to the one we
    are looking for, and that might be useful information. So a negative number still
    tells us the search failed, but that number is the negation of the index of the
    closest match.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`BinarySearch` 在未找到值时会生成负数。在这些情况下，这个二分搜索过程将会在最接近我们正在寻找的值处结束，并且这可能是有用的信息。因此，负数仍然告诉我们搜索失败，但这个数是最接近匹配的索引的负数。'
- en: 'A binary search is more complex than a simple linear search, but with large
    arrays, it pays off because far fewer iterations are needed. Given an array of
    100,000,000 elements, it has to perform only 27 steps instead of 100,000,000\.
    Obviously, with smaller arrays, the improvement is reduced, and there will be
    some minimum size of array at which the relative complexity of a binary search
    outweighs the benefit. If your array contains only 10 values, a linear search
    may well be faster. But a binary search is certainly the clear winner with 100,000,000
    `int` elements. The cases that require the most work are where it finds no match
    (producing a negative result), and in these cases, `BinarySearch` determines that
    an element is missing over 19,000 times faster than the linear search performed
    by `Array.IndexOf` does. However, you need to take care: a binary search works
    only for data that is already ordered, and the cost of getting your data into
    order could well outweigh the benefits. With an array of 100,000,000 `int`s, you
    would need to do about 500 searches before the cost of sorting was outweighed
    by the improved search speed, and, of course, that would work only if nothing
    changed in the meantime that forced you to redo the sort. With performance tuning,
    it’s always important to look at the whole scenario and not just the microbenchmarks.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 二分查找比简单的线性搜索更复杂，但对于大数组来说，它效果很明显，因为需要的迭代次数大大减少。给定一个包含100,000,000个元素的数组，它只需执行27步，而不是100,000,000步。显然，对于较小的数组，改进有限，而二分查找的相对复杂性达到了一定的最小数组大小，超过这个最小数组大小时，线性搜索可能更快。但对于包含100,000,000个`int`元素的数组，二分查找肯定是明显的胜利者。需要最多工作的情况是它找不到匹配项（产生负结果），在这些情况下，`BinarySearch`比`Array.IndexOf`执行的线性搜索快了超过19,000倍。但是，你需要注意：二分查找仅适用于已经排序的数据，将数据排序的成本可能会超过改进搜索速度的好处。对于包含100,000,000个`int`的数组，你需要在成本超过改进搜索速度之前进行大约500次搜索，并且，当然，只有在这期间没有任何强制您重新排序的变化时才有效。在性能调整中，查看整体场景而不仅仅是微基准测试非常重要。
- en: Incidentally, `Array.BinarySearch` offers overloads for searching within some
    subsection of the array, similar to those we saw for the other search methods.
    It also lets you customize the comparison logic. This works with the comparison
    interfaces I showed in earlier chapters. By default, it will use the `IComparable<T>`
    implementation provided by the array elements themselves, but you can provide
    a custom `IComparer<T>` instead. The `Array.Sort` method I used to put the elements
    into order also supports narrowing down the range and using custom comparison
    logic.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一下，`Array.BinarySearch`提供了用于在数组某个子段内搜索的重载，类似于我们看到的其他搜索方法。它还允许您自定义比较逻辑。这与我在早期章节展示的比较接口一起工作。默认情况下，它将使用数组元素自身提供的`IComparable<T>`实现，但您可以提供自定义的`IComparer<T>`。我用来对元素进行排序的`Array.Sort`方法也支持缩小范围和使用自定义比较逻辑。
- en: There are other searching and sorting methods besides the ones provided by the
    `Array` class itself. All arrays implement `IEnumerable<T>` (where `T` is the
    array’s element type), which means you can also use any of the operations provided
    by .NET’s *LINQ to Objects* functionality. This offers a much wider range of features
    for searching, sorting, grouping, filtering, and generally working with collections
    of objects; [Chapter 10](ch10.xhtml#ch_linq) will describe these features. Arrays
    have been in .NET for longer than LINQ, which is one reason for this overlap in
    functionality, but where arrays provide their own equivalents of standard LINQ
    operators, the array versions can sometimes be more efficient because LINQ is
    a more generalized solution.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`Array`类本身提供的搜索和排序方法之外，还有其他的搜索和排序方法。所有的数组都实现了`IEnumerable<T>`（其中`T`是数组的元素类型），这意味着你也可以使用.NET的*LINQ
    to Objects*功能提供的任何操作。这为搜索、排序、分组、过滤以及一般对象集合处理提供了更广泛的功能；[第10章](ch10.xhtml#ch_linq)将详细描述这些功能。数组在.NET中存在的时间比LINQ更长，这是功能重叠的一个原因，但数组提供了自己的标准LINQ操作符等价物，有时会更高效，因为LINQ是一个更通用的解决方案。
- en: Multidimensional Arrays
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多维数组
- en: 'The arrays I’ve shown so far have all been one-dimensional, but C# supports
    two multidimensional forms: *jagged arrays* and *rectangular arrays*.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我展示的数组都是一维的，但C#支持两种多维形式：*交错数组*和*矩形数组*。
- en: Jagged arrays
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 交错数组
- en: A jagged array is simply an array of arrays. The existence of this kind of array
    is a natural upshot of the fact that arrays have types that are distinct from
    their element type. Because `int[]` is a type, you can use that as the element
    type of another array. [Example 5-16](#creating_a_jagged_array) shows the syntax,
    which is very nearly unsurprising.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 不规则数组简单地是数组的数组。这种类型的数组的存在是数组类型与其元素类型不同的自然结果。因为`int[]`是一种类型，您可以将其用作另一个数组的元素类型。[示例 5-16](#creating_a_jagged_array)展示了几乎毫不意外的语法。
- en: Example 5-16\. Creating a jagged array
  id: totrans-83
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-16\. 创建不规则数组
- en: '[PRE15]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Again, I’ve broken my usual rule for variable declarations—normally I’d use
    `var` on the first line because the type is evident from the initializer, but
    I wanted to show the syntax both for declaring the variable and for constructing
    the array. And there’s a second redundancy in [Example 5-16](#creating_a_jagged_array):
    when using the array initializer syntax, you don’t have to specify the size explicitly,
    because the compiler will work it out for you. I’ve exploited that for the nested
    arrays, but I’ve set the size (`5`) explicitly for the outer array to show where
    the size appears, because it might not be where you would expect.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我打破了通常的变量声明规则 —— 通常我会在第一行使用`var`，因为类型从初始化器中就能明确，但我想展示声明变量和构造数组的语法。在[示例 5-16](#creating_a_jagged_array)中还有第二个冗余之处：使用数组初始化器语法时，不必明确指定大小，因为编译器会自动计算。我已经利用了这一点来处理嵌套数组，但为了显示大小（`5`）出现的位置，我明确为外部数组设置了大小，因为这可能不是您期望的位置。
- en: The type name for a jagged array is simple enough. In general, array types have
    the form `*ElementType*[]`, so if the element type is `int[]`, we’d expect the
    resulting array type to be written as `int[][]`, and that’s what we see. The constructor
    syntax is a bit more peculiar. It declares an array of five arrays, and at a first
    glance, `new int[5][]` seems like a perfectly reasonable way to express that.
    It is consistent with array index syntax for jagged arrays; we can write `arrays[1][3]`,
    which fetches the second of those five arrays and then retrieves the fourth element
    from that second array. (This is not a specialized syntax, by the way—there is
    no need for special handling here, because any expression that evaluates to an
    array can be followed by the index in square brackets. The expression `arrays[1]`
    evaluates to an `int[]` array, and so we can follow that with `[3]`.)
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 不规则数组的类型名称足够简单。一般而言，数组类型的形式是`*ElementType*[]`，因此如果元素类型是`int[]`，我们期望结果数组类型应写成`int[][]`，这也是我们看到的。构造函数的语法稍微奇特一些。它声明了一个包含五个数组的数组，乍一看，`new
    int[5][]`似乎是表达这种意图的完全合理的方式。对于不规则数组的数组索引语法保持一致；我们可以写`arrays[1][3]`，它获取这五个数组中的第二个数组，然后从该第二个数组中检索第四个元素。（顺便说一句，这不是专门的语法
    —— 这里没有需要特别处理的地方，因为任何求值为数组的表达式都可以跟随方括号中的索引。表达式`arrays[1]`求值为一个`int[]`数组，所以我们可以跟随`[3]`。）
- en: However, the `new` keyword *does* treat jagged arrays specially. It makes them
    look consistent with array element access syntax, but it has to twist things a
    little to do that. With a one-dimensional array, the pattern for constructing
    a new array is `new *ElementType*[*length*]`, so for creating an array of five
    things, you’d expect to write `new *ElementType*[5]`. If the things you are creating
    are arrays of `int`, wouldn’t you expect to see `int[]` in place of `*ElementType*`?
    That would imply that the syntax should be `new int[][5]`.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`new`关键字确实会特殊对待不规则数组。它使它们看起来与数组元素访问语法一致，但必须稍微扭曲一下才能做到这一点。对于一维数组，构造新数组的模式是`new
    *ElementType*[*length*]`，因此创建五个元素的数组，您希望写成`new *ElementType*[5]`。如果您要创建的是`int`数组，您是否期望看到`int[]`代替`*ElementType*`？这将意味着语法应该是`new
    int[][5]`。
- en: That would be logical, but it looks like it’s the wrong way around, and that’s
    because the array type syntax itself is effectively reversed. Arrays are constructed
    types, like generics. With generics, the name of the generic type from which we
    construct the actual type comes before the type argument (e.g., `List<int>` takes
    the generic `List<T>` type and constructs it with a type argument of `int`). If
    arrays had generic-like syntax, we might expect to see `array<int>` for a one-dimensional
    array, `array<array<int>>` for two dimensions, and so on—the element type would
    come *after* the part that signifies that we want an array. But array types do
    it the other way around—the arrayness is signified by the `[]` characters, so
    the element type comes first. This is why the hypothetical logically correct syntax
    for array construction looks weird. C# avoids the weirdness by not getting overly
    stressed about logic here and just puts the size where most people expect it to
    go rather than where it arguably should go.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来是逻辑的，但似乎是错误的，这是因为数组类型的语法本身实际上是反向的。数组是构造类型，就像泛型一样。对于泛型，我们从中构造实际类型的泛型类型名称在类型参数之前（例如，`List<int>`
    使用泛型 `List<T>` 类型，并用 `int` 类型参数构造它）。如果数组具有类似泛型的语法，我们可能会期望看到 `array<int>` 表示一维数组，`array<array<int>>`
    表示二维数组，依此类推——元素类型会在表示我们想要数组的部分之后出现。但数组类型反其道而行——数组性由 `[]` 字符表示，因此元素类型首先出现。这就是为什么数组构造的假设逻辑正确的语法看起来很奇怪。C#
    避免了这种奇怪感，不过于强调逻辑，在大多数人期望的地方放置尺寸而不是应该放置的地方。
- en: Note
  id: totrans-89
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The syntax extends in the obvious way—for example, `int[][][]` for the type
    and `new int[5][][]` for construction. C# does not define particular limits to
    the number of dimensions, but there are some implementation-specific runtime limits.
    (Microsoft’s compiler didn’t flinch when I asked for a 5,000-dimensional jagged
    array, but the CLR refused to load the resulting program. In fact, it wouldn’t
    load anything with more than 1,166 dimensions.)
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 语法可以显而易见地扩展——例如，`int[][][]` 表示类型，`new int[5][][]` 表示构造。C# 不定义维度数量的特定限制，但存在一些特定于实现的运行时限制。（微软的编译器在我要求创建一个
    5000 维 jagged 数组时毫不畏惧，但 CLR 拒绝加载生成的程序。事实上，它不会加载超过 1166 维的任何东西。）
- en: '[Example 5-16](#creating_a_jagged_array) initializes the array with five one-dimensional
    `int[]` arrays. The layout of the code should make it fairly clear why this sort
    of array is referred to as *jagged*: each row has a different length. With arrays
    of arrays, there is no requirement for a rectangular layout. I could go further.
    Arrays are reference types, so I could have set some rows to `null`. If I abandoned
    the array initializer syntax and initialized the array elements individually,
    I could have decided to make some of the one-dimensional `int[]` arrays appear
    in more than one row.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 5-16](#creating_a_jagged_array) 用五个一维 `int[]` 数组初始化数组。代码的布局应该很清楚地说明为什么这种类型的数组被称为
    *jagged*：每一行长度不同。对于数组的数组，没有要求是矩形布局。我可以进一步讲解。数组是引用类型，所以我可以将一些行设置为 `null`。如果我放弃数组初始化器语法，逐个初始化数组元素，我可以决定让一些一维
    `int[]` 数组出现在多行中。'
- en: Because each row in this jagged array contains an array, I’ve ended up with
    six objects here—the five `int[]` arrays and then the `int[][]` array that contains
    references to them. If you introduce more dimensions, you’ll get yet more arrays.
    For certain kinds of work, the nonrectangularity and the large numbers of objects
    can be problematic, which is why C# supports another kind of multidimensional
    array.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这个 jagged 数组中的每一行都包含一个数组，所以这里我最终有了六个对象——五个 `int[]` 数组，然后是包含对它们引用的 `int[][]`
    数组。如果引入更多维度，将会得到更多数组。对于某些工作来说，非矩形和大量对象可能会成为问题，这就是为什么 C# 支持另一种多维数组的原因。
- en: Rectangular arrays
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 矩形数组
- en: A rectangular array is a single array object that supports multidimensional
    indexing. If C# didn’t offer multidimensional arrays, we could build something
    a bit like them by convention. If you want an array with 10 rows and 5 columns,
    you could construct a one-dimensional array with 50 elements, and then use code
    like `myArray[i + (5 * j)]` to access it, where `i` is the column index and `j`
    is the row index. That would be an array that you had chosen to think of as being
    two-dimensional, even though it’s really just one big contiguous block. A rectangular
    array is essentially the same idea, but where C# does the work for you. [Example 5-17](#rectangular_arrays_example)
    shows how to declare and construct rectangular arrays.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 矩形数组是支持多维索引的单个数组对象。如果C#没有提供多维数组，我们可以按照惯例构建类似它们的东西。如果您想要一个包含10行和5列的数组，您可以构造一个具有50个元素的一维数组，然后使用像`myArray[i
    + (5 * j)]`这样的代码来访问它，其中`i`是列索引，`j`是行索引。那将是一个您选择将其视为二维的数组，尽管它实际上只是一个大的连续块。矩形数组本质上是相同的概念，但是在其中C#为您做了这项工作。
    [示例 5-17](#rectangular_arrays_example) 展示了如何声明和构造矩形数组。
- en: Note
  id: totrans-95
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'Rectangular arrays are not just about convenience. There’s a type safety aspect
    too: `int[,]` is a different type than `int[]` or `int[,,]`, so if you write a
    method that expects a two-dimensional rectangular array, C# will not allow anything
    else to be passed.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 矩形数组不仅仅是便利性问题。还有一个类型安全的方面：`int[,]`是与`int[]`或`int[,,]`不同的类型，因此如果您编写一个期望二维矩形数组的方法，C#将不允许传递其他类型。
- en: Example 5-17\. Rectangular arrays
  id: totrans-97
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-17\. 矩形数组
- en: '[PRE16]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Rectangular array type names use only a single pair of square brackets, no matter
    how many dimensions they have. The number of commas inside the brackets denotes
    the number of dimensions, so these examples with one comma are two-dimensional.
    The runtime seems to impose a much lower limit on the number of dimensions than
    for a jagged array. .NET 6.0 won’t load a program that tries to use more than
    32 dimensions in a rectangular array.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 矩形数组类型名称仅使用一对方括号，无论它们有多少维。括号内部逗号的数量表示维度的数量，因此这些具有一个逗号的示例是二维的。与不规则数组相比，运行时似乎对矩形数组的维度数设置了一个更低的限制。在.NET
    6.0中，试图使用超过32个维度的矩形数组的程序将无法加载。
- en: The initializer syntax is very similar to that for multidimensional arrays (see
    [Example 5-16](#creating_a_jagged_array)), except I do not start each row with
    `new[]`, because this is one big array, not an array of arrays. The numbers in
    [Example 5-17](#rectangular_arrays_example) form a shape that is clearly rectangular,
    and if you attempt to make things jagged (with different row sizes), the compiler
    will report an error. This extends to higher dimensions. If you wanted a three-dimensional
    “rectangular” array, it would need to be a *cuboid*. [Example 5-18](#cuboid_array)
    shows a cuboid array. You could think of the initializer as being a list of two
    rectangular slices making up the cuboid. And you can go higher, with *hypercuboid*
    arrays (although they are still known as rectangular arrays, regardless of how
    many dimensions you use).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化语法与多维数组非常相似（参见[示例 5-16](#creating_a_jagged_array)），但我没有像那样用`new[]`来开始每一行，因为这是一个大数组，而不是数组的数组。
    [示例 5-17](#rectangular_arrays_example) 中的数字形成了一个明显是矩形的形状，如果您尝试使事情变得不规则（使用不同的行大小），编译器将报告错误。这种情况也适用于更高的维度。如果您想要一个三维的“矩形”数组，它将需要是一个*cuboid*。
    [示例 5-18](#cuboid_array) 展示了一个cuboid数组。您可以将初始化器视为由两个矩形切片组成的cuboid的列表。而且您可以升级，使用*hypercuboid*数组（尽管无论您使用多少维度，它们仍然被称为矩形数组）。
- en: Example 5-18\. A 2 × 3 × 5 cuboid “rectangular” array
  id: totrans-101
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-18\. 一个2 × 3 × 5的cuboid“矩形”数组
- en: '[PRE17]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The syntax for accessing rectangular arrays is predictable enough. If the second
    variable from [Example 5-17](#rectangular_arrays_example) is in scope, we could
    write `smallerGrid[2, 3]` to access the final item in the array; as with single-dimensional
    arrays, indices are zero-based, so this refers to the third row’s fourth item.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 访问矩形数组的语法足够可预测。如果来自[示例 5-17](#rectangular_arrays_example) 的第二个变量在作用域内，我们可以写`smallerGrid[2,
    3]`来访问数组中的最后一项；与单维数组一样，索引是从零开始的，因此这指的是第三行的第四个项目。
- en: Remember that an array’s `Length` property returns the total number of elements
    in the array. Since rectangular arrays have all the elements in a single array
    (rather than being arrays that refer to some other arrays), this will return the
    product of the sizes of all the dimensions. A rectangular array with 5 rows and
    10 columns would have a `Length` of 50, for example. If you want to discover the
    size along a particular dimension at runtime, use the `GetLength` method, which
    takes a single `int` argument indicating the dimension for which you’d like to
    know the size.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，数组的 `Length` 属性返回数组中的元素总数。由于矩形数组将所有元素存储在单个数组中（而不是引用其他数组），因此它将返回所有维度大小的乘积。例如，一个具有
    5 行和 10 列的矩形数组的 `Length` 为 50。如果你想在运行时发现特定维度的大小，请使用 `GetLength` 方法，该方法接受一个 `int`
    参数，指示你想知道大小的维度。
- en: Copying and Resizing
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 复制和调整大小
- en: Sometimes you will want to move chunks of data around in arrays. You might want
    to insert an item in the middle of an array, moving the items that follow it up
    by one position (and losing one element at the end, since array sizes are fixed).
    Or you might want to move data from one array to another, perhaps one of a different
    size.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 有时你会希望在数组中移动数据块。也许你想在数组的中间插入一个项目，将其后的项目向上移动一个位置（并丢失最后一个元素，因为数组大小是固定的）。或者你可能想要将数据从一个数组移动到另一个数组，也许它们大小不同。
- en: 'The static `Array.Copy` method takes two references to arrays, along with a
    number indicating how many elements to copy. It offers overloads so that you can
    specify the positions in the two arrays at which to start the copy. (The simpler
    overload starts at the first element of each array.) You are allowed to pass the
    same array as the source and destination, and it will handle overlap correctly:
    the copy acts as though the elements were first all copied to a temporary location
    before starting to write them to the target.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 静态 `Array.Copy` 方法接受两个数组的引用，以及一个指示要复制多少个元素的数字。它提供了多个重载，以便你可以指定在两个数组中开始复制的位置。（更简单的重载从每个数组的第一个元素开始。）你可以将源数组和目标数组作为同一个数组传递，并且它会正确处理重叠：复制动作就像首先将所有元素复制到临时位置，然后开始将它们写入目标位置。
- en: Warning
  id: totrans-108
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: As well as the static `Copy` method, the `Array` class defines a nonstatic `CopyTo`
    method, which copies the entire array into a target array, starting at the specified
    offset. This method is present because all arrays implement certain collection
    interfaces, including `ICollection<T>` (where `T` is the array’s element type),
    which defines this `CopyTo` method. It is less flexible than `Copy`—`CopyTo` cannot
    copy a subrange of the array. In cases where either method would work, the documentation
    recommends using `Array.Copy`—`CopyTo` is just for the benefit of general-purpose
    code that can work with any implementation of a collection interface.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 除了静态的 `Copy` 方法外，`Array` 类还定义了非静态的 `CopyTo` 方法，它将整个数组复制到目标数组中，从指定的偏移位置开始。此方法存在的原因是因为所有数组实现了某些集合接口，包括
    `ICollection<T>`（其中 `T` 是数组的元素类型），该接口定义了这个 `CopyTo` 方法。它比 `Copy` 方法不够灵活 —— `CopyTo`
    不能复制数组的子范围。在两种方法都能使用的情况下，文档建议使用 `Array.Copy` —— `CopyTo` 只是为了通用代码的利益，可以与任何集合接口的实现一起使用。
- en: Copying elements from one array to another can become necessary when you need
    to deal with variable amounts of data. You would typically allocate an array larger
    than initially necessary, and if this eventually fills up, you’ll need a new,
    larger array, and you’d need to copy the contents of the old array into the new
    one. In fact, the `Array` class can do this for you for one-dimensional arrays
    with its `Resize` method. The method name is slightly misleading, because arrays
    cannot be resized, so it allocates a new array and copies the data from the old
    one into it. `Resize` can build either a larger or a smaller array, and if you
    ask it for a smaller one, it will just copy as many elements as will fit.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 当需要处理可变数量的数据时，将元素从一个数组复制到另一个数组可能是必要的。通常情况下，你会分配一个比最初需要的更大的数组，如果最终填满了，你将需要一个新的更大数组，并且需要将旧数组的内容复制到新数组中。事实上，`Array`
    类可以通过其 `Resize` 方法为一维数组执行此操作。方法名有些误导，因为数组无法调整大小，所以它会分配一个新的数组，并将旧数组的数据复制到其中。`Resize`
    可以构建一个更大或更小的数组，如果你要求一个更小的数组，它只会复制尽可能多的元素。
- en: While I’m talking about methods that copy the array’s data around, I should
    mention `Reverse`, which simply reverses the order of the array’s elements. Also,
    while this isn’t strictly about copying, the `Array.Clear` method is often useful
    in scenarios where you’re juggling array sizes—it allows you to reset some range
    of the array to its initial zero-like state.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 当我谈论复制数组数据的方法时，我应该提到`Reverse`，它简单地颠倒数组元素的顺序。还有，虽然这不严格属于复制的范畴，但`Array.Clear`方法在处理需要频繁变换数组大小的场景时非常有用——它允许你将数组的某个范围重置为初始的零值状态。
- en: These methods for moving data around within arrays are useful for building more
    flexible data structures on top of the basic services offered by arrays. But you
    often won’t need to use them yourself, because the runtime libraries provide several
    useful collection classes that do this for you.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这些在数组内部移动数据的方法对于在基本数组服务的基础上构建更灵活的数据结构非常有用。但通常你自己不需要使用它们，因为运行时库提供了几个有用的集合类来代替这些工作。
- en: List<T>
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`List<T>`'
- en: The `List<T>` class, defined in the `System.Collections.Generic` namespace,
    contains a variable-length sequence of elements of type `T`. It provides an indexer
    that lets you get and set elements by number, so a `List<T>` behaves like a resizable
    array. It’s not completely interchangeable—you cannot pass a `List<T>` as the
    argument for a parameter that expects a `T[]` array—but both arrays and `List<T>`
    implement various common generic collection interfaces that we’ll be looking at
    later. For example, if you write a method that accepts an `IList<T>`, it will
    be able to work with either an array or a `List<T>`.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`List<T>`类定义在`System.Collections.Generic`命名空间中，包含类型为`T`的元素的可变长度序列。它提供了一个索引器，允许你按编号获取和设置元素，因此`List<T>`表现得像一个可调整大小的数组。它并非完全可互换—你不能将`List<T>`作为期望`T[]`数组的参数传递—但数组和`List<T>`都实现了各种常见的泛型集合接口，我们稍后将会讨论这些接口。例如，如果你编写一个接受`IList<T>`的方法，它将能够与数组或`List<T>`一起使用。'
- en: Although code that uses an indexer resembles array element access, it is not
    quite the same thing. An indexer is a kind of property, so it has the same issues
    with mutable value types that I discussed in [Chapter 3](ch03.xhtml#ch_types).
    Given a variable `pointList` of type `List<Point>` (where `Point` is the mutable
    value type in the `System.Windows` namespace), you cannot write `pointList[2].X
    = 2`, because `pointList[2]` returns a copy of the value, and this code is effectively
    asking to modify that temporary copy. This would lose the update, so C# forbids
    it. But this does work with arrays. If `pointArray` is of type `Point[]`, `pointArray[2]`
    does not *get* an element, it *identifies* an element, making it possible to modify
    an array element’s value in situ by writing `pointArray[2].X = 2`. (Since `ref`
    return values were added to C#, it has become possible to write indexers that
    work this way, but `List<T>` and `IList<T>` were created long before that.) With
    immutable value types such as `Complex`, this distinction is moot, because you
    cannot modify their values in place in any case—you would have to overwrite an
    element with a new value whether using an array or a list.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然使用索引器的代码看起来像是访问数组元素，但实际上并非完全相同。索引器是一种属性，因此它在可变值类型方面与我在[第三章](ch03.xhtml#ch_types)中讨论过的问题相同。给定类型为`List<Point>`（其中`Point`是`System.Windows`命名空间中的可变值类型）的变量`pointList`，你不能编写`pointList[2].X
    = 2`，因为`pointList[2]`返回的是值的副本，而这段代码实际上是要求修改那个临时副本。这会导致更新丢失，因此C#禁止这样做。但对于数组来说，这是可行的。如果`pointArray`的类型是`Point[]`，`pointArray[2]`不是获取元素，而是标识元素，这使得通过写`pointArray[2].X
    = 2`可以直接修改数组元素的值。尽管在C#中添加了`ref`返回值后，可以编写按此方式工作的索引器，但`List<T>`和`IList<T>`是在此之前创建的。对于像`Complex`这样的不可变值类型，这种区别是无关紧要的，因为无论是使用数组还是列表，你都不能直接修改它们的值—你必须用新值覆盖元素。
- en: Unlike an array, a `List<T>` provides methods that change its size. The `Add`
    method appends a new element to the end of the list, while `AddRange` can add
    several. `Insert` and `InsertRange` add elements at any point in the list, shuffling
    all the elements after the insertion point down to make space. These four methods
    all make the list longer, but `List<T>` also provides `Remove`, which removes
    the first instance of the specified value; `RemoveAt`, which removes an element
    at a particular index; and `RemoveRange`, which removes multiple elements starting
    at a particular index. These all shuffle elements back down, closing up the gap
    left by the removed element or elements, making the list shorter.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 不像数组，`List<T>` 提供了可以改变其大小的方法。`Add` 方法将一个新元素追加到列表的末尾，而 `AddRange` 可以添加多个元素。`Insert`
    和 `InsertRange` 在列表的任意位置添加元素，将插入点后的所有元素向下移动以腾出空间。这四种方法都使列表变长，但是 `List<T>` 也提供了
    `Remove` 方法，用于移除指定值的第一个实例；`RemoveAt` 方法用于移除特定索引处的元素；以及 `RemoveRange` 方法，用于从特定索引开始移除多个元素。所有这些方法都会将元素向下移动，以关闭被移除元素或元素留下的空隙，从而使列表变短。
- en: Note
  id: totrans-117
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: '`List<T>` uses an array internally to store its elements. This means all the
    elements live in a single block of memory, and it stores them contiguously. This
    makes normal element access very efficient, but it is also why insertion needs
    to shift elements up to make space for the new element, and removal needs to shift
    them down to close up the gap.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`List<T>` 在内部使用数组来存储其元素。这意味着所有元素都存储在单个内存块中，并且它们是连续存储的。这使得正常的元素访问非常高效，但也是为什么插入需要将元素向上移动以腾出空间，并且移除需要将元素向下移动以关闭空隙的原因。'
- en: '[Example 5-19](#using_a_listoft) shows how to create a `List<T>`. It’s just
    a class, so we use the normal constructor syntax. It shows how to add and remove
    entries and also how to access elements using the array-like indexer syntax. This
    also shows that `List<T>` provides its size through a `Count` property. This name
    may seem needlessly different than the `Length` provided by arrays, but there
    is a reason: this property is defined by `ICollection<T>`, which `List<T>` implements.
    Not all `ICollection<T>` implementations are sequences, so `Length` would in some
    cases be a misnomer. (As it happens, arrays also offer `Count`, because they also
    implement `ICollection` and `ICollection<T>`. However, they use explicit interface
    implementation, meaning that you can see an array’s `Count` property only through
    a reference of one of these interface types.)'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 5-19](#using_a_listoft) 展示了如何创建一个 `List<T>`。它只是一个类，因此我们使用常规的构造函数语法。它展示了如何添加和移除条目，以及如何使用类似数组的索引器语法访问元素。这还显示了
    `List<T>` 通过 `Count` 属性提供其大小。这个名字可能看起来和数组提供的 `Length` 有些不同，但原因是：这个属性是由 `ICollection<T>`
    定义的，而 `List<T>` 实现了它。并非所有的 `ICollection<T>` 实现都是序列，因此在某些情况下 `Length` 可能不合适。（恰好，数组也提供
    `Count`，因为它们也实现了 `ICollection` 和 `ICollection<T>`。然而，它们使用显式接口实现，这意味着只能通过这些接口类型的引用看到数组的
    `Count` 属性。）'
- en: Example 5-19\. Using a `List<T>`
  id: totrans-120
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-19\. 使用 `List<T>`
- en: '[PRE18]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Because a `List<T>` can grow and shrink as required, you don’t need to specify
    its size at construction. However, if you want to, you can specify its *capacity*.
    A list’s capacity is the amount of space it currently has available for storing
    elements, and this will often be different than the number of elements it contains.
    To avoid allocating a new internal array every time you add or remove an element,
    it keeps track of how many elements are in use independently of the size of the
    array. When it needs more space, it will overallocate, creating a new array that
    is larger than needed by an amount proportional to the size. This means that,
    if your program repeatedly adds items to a list, the larger it gets, the less
    frequently it needs to allocate a new array, but the proportion of spare capacity
    after each reallocation will remain about the same.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 `List<T>` 可以根据需要增长和收缩，所以在构造时不需要指定其大小。但是，如果需要的话，可以指定其*容量*。列表的容量是它当前可用于存储元素的空间量，这通常与它包含的元素数量不同。为了避免在每次添加或移除元素时都分配一个新的内部数组，它会独立跟踪使用的元素数量，而不是数组的大小。当需要更多空间时，它会过度分配，创建一个比需要的大的新数组，过度分配的量与列表当前大小成比例。这意味着，如果程序重复向列表添加项目，列表越大，它需要分配新数组的频率就越低，但每次重新分配后剩余容量的比例将保持大致相同。
- en: If you know up front that you will eventually store a specific number of elements
    in a list, you can pass that number to the constructor, and it will allocate exactly
    that much capacity, meaning that no further reallocation will be required. If
    you get this wrong, it won’t cause an error—you’re just requesting an initial
    capacity, and it’s OK to change your mind later.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: If you know up front that you will eventually store a specific number of elements
    in a list, you can pass that number to the constructor, and it will allocate exactly
    that much capacity, meaning that no further reallocation will be required. If
    you get this wrong, it won’t cause an error—you’re just requesting an initial
    capacity, and it’s OK to change your mind later.
- en: If the idea of unused memory going to waste in a list offends you, but you don’t
    know exactly how much space will be required before you start, you could call
    the `TrimExcess` method once you know the list is complete. This reallocates the
    internal storage to be exactly large enough to hold the list’s current contents,
    eliminating waste. This will not always be a win. To ensure that it is using exactly
    the right amount of space, `TrimExcess` has to create a new array of the right
    size, leaving the old, oversized one to be reclaimed by the garbage collector
    later on, and in some scenarios, the overhead of forcing an extra allocation just
    to trim things down to size may be higher than the overhead of having some unused
    capacity.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: If the idea of unused memory going to waste in a list offends you, but you don’t
    know exactly how much space will be required before you start, you could call
    the `TrimExcess` method once you know the list is complete. This reallocates the
    internal storage to be exactly large enough to hold the list’s current contents,
    eliminating waste. This will not always be a win. To ensure that it is using exactly
    the right amount of space, `TrimExcess` has to create a new array of the right
    size, leaving the old, oversized one to be reclaimed by the garbage collector
    later on, and in some scenarios, the overhead of forcing an extra allocation just
    to trim things down to size may be higher than the overhead of having some unused
    capacity.
- en: Lists have a third constructor. Besides the default constructor, and the one
    that takes a capacity, you can also pass in a collection of data with which to
    initialize the list. You can pass any `IEnumerable<T>`.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: Lists have a third constructor. Besides the default constructor, and the one
    that takes a capacity, you can also pass in a collection of data with which to
    initialize the list. You can pass any `IEnumerable<T>`.
- en: You can provide initial content for lists with syntax similar to an array initializer.
    [Example 5-20](#list_initializer) loads the same three values into the new list
    as at the start of [Example 5-19](#using_a_listoft).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: You can provide initial content for lists with syntax similar to an array initializer.
    [Example 5-20](#list_initializer) loads the same three values into the new list
    as at the start of [Example 5-19](#using_a_listoft).
- en: Example 5-20\. List initializer
  id: totrans-127
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 5-20\. List initializer
- en: '[PRE19]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: If you’re not using `var`, you can omit the type name after the `new` keyword,
    as [Example 5-21](#list_initializer_target_type_new) shows. But in contrast to
    arrays, you cannot omit the `new` keyword entirely. Nor will the compiler infer
    the type argument, so whereas with an array you can write just `new[]` followed
    by an initializer, you cannot write `new List<>`.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: If you’re not using `var`, you can omit the type name after the `new` keyword,
    as [Example 5-21](#list_initializer_target_type_new) shows. But in contrast to
    arrays, you cannot omit the `new` keyword entirely. Nor will the compiler infer
    the type argument, so whereas with an array you can write just `new[]` followed
    by an initializer, you cannot write `new List<>`.
- en: Example 5-21\. List initializer with target-typed `new`
  id: totrans-130
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 5-21\. List initializer with target-typed `new`
- en: '[PRE20]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Examples [5-20](#list_initializer) and [5-21](#list_initializer_target_type_new)
    are equivalent, and each compile into code that calls `Add` once for each item
    in the list. You can use this syntax with any type that has a suitable `Add` method
    and implements the `IEnumerable` interface. This works even if `Add` is an extension
    method. (So if some type implements `IEnumerable`, but does not supply an `Add`
    method, you are free to use this initializer syntax if you provide your own `Add`.)
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: Examples [5-20](#list_initializer) and [5-21](#list_initializer_target_type_new)
    are equivalent, and each compile into code that calls `Add` once for each item
    in the list. You can use this syntax with any type that has a suitable `Add` method
    and implements the `IEnumerable` interface. This works even if `Add` is an extension
    method. (So if some type implements `IEnumerable`, but does not supply an `Add`
    method, you are free to use this initializer syntax if you provide your own `Add`.)
- en: '`List<T>` provides `IndexOf`, `LastIndexOf`, `Find`, `FindLast`, `FindAll`,
    `Sort`, and `Bin⁠ary​Sea⁠rch` methods for finding and sorting list elements. These
    provide the same services as their array namesakes, although `List<T>` chooses
    to provide these as instance methods rather than statics.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`List<T>` provides `IndexOf`, `LastIndexOf`, `Find`, `FindLast`, `FindAll`,
    `Sort`, and `Bin⁠ary​Sea⁠rch` methods for finding and sorting list elements. These
    provide the same services as their array namesakes, although `List<T>` chooses
    to provide these as instance methods rather than statics.'
- en: 'We’ve now seen two ways to represent a list of values: arrays and lists. Fortunately,
    interfaces make it possible to write code that can work with either, so you won’t
    need to write two sets of functions if you want to support both lists and arrays.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经看到了两种表示值列表的方式：数组和列表。幸运的是，接口使得可以编写既可以与数组又可以与列表一起工作的代码，因此如果想支持这两种情况，您不需要编写两套函数。
- en: List and Sequence Interfaces
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 列表和序列接口
- en: 'The runtime libraries define several interfaces representing collections. Three
    of these are relevant to simple linear sequences of the kind you can store in
    an array or a list: `IList<T>`, `ICollection<T>`, and `IEnumerable<T>`, all in
    the `Sys⁠tem.​Col⁠lec⁠tio⁠ns.⁠Gen⁠eri⁠cs` namespace. There are three interfaces,
    because different code makes different demands. Some methods need random access
    to any numbered element in a collection, but not everything does, and not all
    collections can support that—some sequences produce elements gradually, and there
    may be no way to leap straight to the *n*th element. Consider a sequence representing
    keypresses, for example—each item will emerge only as the user presses the next
    key. Your code can work with a wider range of sources if you opt for less demanding
    interfaces.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 运行时库定义了几个代表集合的接口。其中三个与简单线性序列相关，可以存储在数组或列表中：`IList<T>`、`ICollection<T>` 和 `IEnumerable<T>`，全部位于
    `Sys⁠tem.​Col⁠lec⁠tio⁠ns.⁠Gen⁠eri⁠cs` 命名空间。这里有三个接口，因为不同的代码有不同的要求。有些方法需要对集合中的任何编号元素进行随机访问，但并非所有情况都需要，也不是所有集合都能支持这样做——有些序列会逐渐产生元素，可能没有办法直接跳到第
    *n* 个元素。例如，考虑表示按键的序列——每个项目只会在用户按下下一个键时出现。如果选择较少要求的接口，您的代码可以与更广泛的数据源一起工作。
- en: '`IEnumerable<T>` is the most general of collection interfaces, because it demands
    the least from its implementers. I’ve mentioned it a few times already because
    it’s an important interface that crops up a lot, but I’ve not shown the definition
    until now. As [Example 5-22](#ienumerable_definition) shows, it declares just
    a single method.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`IEnumerable<T>` 是集合接口中最通用的一个，因为它对其实现者的要求最少。我已经多次提到它了，因为它是一个经常出现的重要接口，但直到现在我还没有展示其定义。正如[示例 5-22](#ienumerable_definition)
    所示，它只声明了一个方法。'
- en: Example 5-22\. `IEnumerable<T>` and `IEnumerable`
  id: totrans-138
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-22\. `IEnumerable<T>` 和 `IEnumerable`
- en: '[PRE21]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Using inheritance, `IEnumerable<T>` requires its implementers also to implement
    `IEnumerable`, which appears to be almost identical. It’s a nongeneric version
    of `IEnumerable<T>`, and its `GetEnumerator` method will typically do nothing
    more than invoke the generic implementation. The reason we have both forms is
    that the nongeneric `IEnumerable` has been around since .NET 1.0, which didn’t
    support generics. The arrival of generics in .NET 2.0 made it possible to express
    the intent behind `IEnumerable` more precisely, but the old interface had to remain
    for compatibility. So these two interfaces effectively require the same thing:
    a method that returns an enumerator. What’s an enumerator? [Example 5-23](#ienumerator_definition)
    shows both the generic and nongeneric interfaces.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 使用继承，`IEnumerable<T>` 要求其实现者同时实现 `IEnumerable`，后者几乎与前者相同。它是 `IEnumerable<T>`
    的非泛型版本，其 `GetEnumerator` 方法通常不会做更多事情，只是调用泛型实现。之所以存在这两种形式，是因为在 .NET 1.0 中就有非泛型的
    `IEnumerable`，但该版本不支持泛型。在 .NET 2.0 中引入泛型后，可以更精确地表达 `IEnumerable` 的意图，但为了保持兼容性，旧接口仍然存在。因此，这两个接口实际上要求相同的内容：一个返回枚举器的方法。什么是枚举器？[示例 5-23](#ienumerator_definition)
    显示了泛型和非泛型接口。
- en: Example 5-23\. `IEnumerator<T>` and `IEnumerator`
  id: totrans-141
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-23\. `IEnumerator<T>` 和 `IEnumerator`
- en: '[PRE22]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The usage model for an `IEnumerable<T>` (and also `IEnumerable`) is that you
    call `GetEnumerator` to obtain an enumerator, which can be used to iterate through
    all the items in the collection. You call the enumerator’s `MoveNext()`; if it
    returns `false`, it means the collection was empty. Otherwise, the `Current` property
    will now provide the first item from the collection. Then you call `MoveNext()`
    again to move to the next item, and for as long as it keeps returning `true`,
    the next item will be available in `Current`. (The `Reset` method is a historical
    artifact added to help compatibility with COM, the Windows pre-.NET cross-language
    object model. The documentation allows implementations to throw a `NotSupportedException`
    from `Reset`, so you will not normally use this method.)
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `IEnumerable<T>`（以及 `IEnumerable`），使用模型是调用 `GetEnumerator` 来获取枚举器，该枚举器可用于遍历集合中的所有项目。您调用枚举器的
    `MoveNext()` 方法；如果它返回 `false`，则表示集合为空。否则，`Current` 属性现在将提供集合中的第一个项目。然后，再次调用 `MoveNext()`
    来移动到下一个项目，并且只要它继续返回 `true`，`Current` 将提供下一个项目。（`Reset` 方法是一种历史遗留物，用于帮助与 COM（Windows
    中的 .NET 之前的跨语言对象模型）兼容。文档允许实现从 `Reset` 抛出 `NotSupportedException`，因此您通常不会使用此方法。）
- en: Note
  id: totrans-144
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Notice that `IEnumerator<T>` implementations are required to implement `IDisposable`.
    You must call `Dispose` on enumerators once you’re finished with them, because
    many of them rely on this.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`IEnumerator<T>` 的实现必须实现 `IDisposable`。完成枚举后，您必须调用枚举器的 `Dispose` 方法，因为其中许多依赖于此。
- en: The `foreach` loop in C# does all of the work required to iterate through an
    enumerable collection for you,^([1](ch05.xhtml#fn23)) including generating code
    that calls `Dispose` even if the loop terminates early due to a `break` statement,
    an error, or, perish the thought, a `goto` statement. [Chapter 7](ch07.xhtml#ch_object_lifetime)
    will describe the uses of `IDisposable` in more detail.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C# 中，`foreach` 循环会为您完成遍历可枚举集合所需的所有工作[^1]，包括生成调用 `Dispose` 的代码，即使循环由于 `break`
    语句、错误或者（不可思议的）`goto` 语句而提前终止。[第 7 章](ch07.xhtml#ch_object_lifetime)将更详细地描述 `IDisposable`
    的用法。
- en: '`IEnumerable<T>` is at the heart of LINQ to Objects, which I’ll discuss in
    [Chapter 10](ch10.xhtml#ch_linq). LINQ operators are available on any object that
    implements this interface. The runtime libraries define a related interface, `IAsyncEnumerable<T>`.
    Conceptually, this is identical to `IEnumerable<T>`: it represents the ability
    to provide a sequence of items. The difference is that it enables items to be
    enumerated asynchronously. As [Example 5-24](#async_enumeration_interfaces) shows,
    this interface and its counterpart, `IAsyncEnumerator<T>`, resemble `IEnumerable<T>`
    and `IEnumerator<T>`. The main difference is the use of the asynchronous programming
    features `ValueTask<T>` and `CancellationToken`, which [Chapter 16](ch16.xhtml#ch_multithreading)
    will describe. There are also some minor differences: there are no nongeneric
    versions of these interfaces, and also, there’s no facility to reset an existing
    asynchronous enumerator (although as noted earlier, many synchronous enumerators
    throw a `NotSupportedException` if you call `Reset`).'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`IEnumerable<T>` 是 LINQ to Objects 的核心，在[第 10 章](ch10.xhtml#ch_linq)中将进行讨论。LINQ
    操作符可用于实现此接口的任何对象。运行时库定义了一个相关的接口 `IAsyncEnumerable<T>`。从概念上讲，它与 `IEnumerable<T>`
    相同：它表示提供项目序列的能力。不同之处在于，它允许异步枚举项目。正如[示例 5-24](#async_enumeration_interfaces)所示，此接口及其对应的
    `IAsyncEnumerator<T>` 与 `IEnumerable<T>` 和 `IEnumerator<T>` 类似。主要区别在于使用异步编程功能
    `ValueTask<T>` 和 `CancellationToken`，将在[第 16 章](ch16.xhtml#ch_multithreading)中描述。还有一些小的区别：这些接口没有泛型版本，也没有重置现有异步枚举器的功能（尽管如前所述，许多同步枚举器在调用
    `Reset` 时会抛出 `NotSupportedException`）。'
- en: Example 5-24\. `IAsyncEnumerable<T>` and `IAsyncEnumerator<T>`
  id: totrans-148
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-24\. `IAsyncEnumerable<T>` 和 `IAsyncEnumerator<T>` 的用法模型
- en: '[PRE23]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: You can consume an `IAsyncEnumerable<T>` with a specialized form of `foreach`
    loop, in which you prefix it with the `await` keyword. This can only be used in
    a method marked with the `async` keyword. [Chapter 17](ch17.xhtml#ch_asynchronous_language_features)
    describes the `async` and `await` keywords in detail, and also the use of `await
    foreach`.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用特殊形式的 `foreach` 循环消耗 `IAsyncEnumerable<T>`，在这种情况下，您需要在前面加上 `await` 关键字。这只能在使用
    `async` 关键字标记的方法中使用。[第 17 章](ch17.xhtml#ch_asynchronous_language_features)详细描述了
    `async` 和 `await` 关键字，以及 `await foreach` 的用法。
- en: Although `IEnumerable<T>` is important and widely used, it’s pretty restrictive.
    You can ask it only for one item after another, and it will hand them out in whatever
    order it sees fit. It does not provide a way to modify the collection, or even
    to find out how many items the collection contains without having to iterate through
    the whole lot. For these jobs, we have `ICollection<T>`, which is shown in [Example 5-25](#icollection_of_t).
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`IEnumerable<T>`非常重要且被广泛使用，但它相当受限制。你只能依次要求它一个项，并且它会按照它认为合适的顺序分发它们。它不提供修改集合的方法，甚至没有办法在不迭代整个集合的情况下找出集合包含的项数。对于这些工作，我们有`ICollection<T>`，它在[示例 5-25](#icollection_of_t)中展示。
- en: Example 5-25\. `ICollection<T>`
  id: totrans-152
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-25\. `ICollection<T>`
- en: '[PRE24]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This requires implementers also to provide `IEnumerable<T>`, but notice that
    this does not inherit the nongeneric `ICollection`. There is such an interface,
    but it represents a different abstraction: it’s missing all of the methods except
    `CopyTo`. When introducing generics, Microsoft reviewed how the nongeneric collection
    types were used and concluded that the one extra method that the old `ICollection`
    added didn’t make it noticeably more useful than `IEnumerable`. Worse, it also
    included a property called `SyncRoot` that was intended to help manage certain
    multithreaded scenarios but that turned out to be a poor solution to that problem
    in practice. So the abstraction represented by `ICollection` did not get a generic
    equivalent and has not been greatly missed. During the review, Microsoft also
    found that the absence of a general-purpose interface for modifiable collections
    was a problem, and so it made `ICollection<T>` fit that bill. It was not entirely
    helpful to attach this old name to a different abstraction, but since almost nobody
    was using the old nongeneric `ICollection`, it doesn’t seem to have caused much
    trouble.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这要求实现者还必须提供`IEnumerable<T>`，但注意这个接口并不继承非泛型的`ICollection`。确实有这样一个接口，但它代表了一个不同的抽象：它除了`CopyTo`方法外没有任何方法。在引入泛型时，微软审查了旧的非泛型集合类型的使用方式，并得出结论，旧的`ICollection`增加的那一个额外方法并没有使它比`IEnumerable`更加有用。更糟糕的是，它还包含了一个名为`SyncRoot`的属性，旨在帮助管理某些多线程场景，但实际上证明这是一个解决该问题的不良方案。因此，`ICollection`所代表的抽象并没有得到泛型等价物，并且并没有被深切怀念。在审查过程中，微软还发现缺少一个通用的可修改集合的接口是一个问题，因此制定了`ICollection<T>`以解决这个问题。将这个旧名称附加到不同的抽象上固然不完全有助于问题的解决，但由于几乎没有人在使用旧的非泛型`ICollection`，这似乎并没有造成太大麻烦。
- en: The third interface for sequential collections is `IList<T>`, and all types
    that implement this are required to implement `ICollection<T>`, and therefore
    also `IEnumerable<T>`. As you’d expect, `List<T>` implements `IList<T>`. Arrays
    implement it too, using their element type as the argument for `T`. [Example 5-26](#ilist_of_t)
    shows how the interface looks.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个顺序集合的接口是`IList<T>`，所有实现它的类型都必须实现`ICollection<T>`，因此也必须实现`IEnumerable<T>`。正如你所预料的那样，`List<T>`实现了`IList<T>`。数组也实现了它，使用它们的元素类型作为`T`的参数。[示例 5-26](#ilist_of_t)展示了接口的样子。
- en: Example 5-26\. `IList<T>`
  id: totrans-156
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-26\. `IList<T>`
- en: '[PRE25]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Again, although there is a nongeneric `IList`, this interface has no direct
    relationship to it, even though both interfaces represent similar concepts—the
    nongeneric `IList` has equivalents to the `IList<T>` members, and it also includes
    equivalents to most of `ICollection<T>`, including all the members missing from
    `ICollection`. So it would have been possible to require `IList<T>` implementations
    to implement `IList`, but that would have forced implementations to provide two
    versions of most members, one working in terms of the type parameter `T` and the
    other using `object`, because that’s what the old nongeneric interfaces had to
    use. It would also force collections to provide the nonuseful `SyncRoot` property.
    The benefits would not outweigh these inconveniences, and so `IList<T>` implementations
    are not obliged to implement `IList`. They can if they want to, and `List<T>`
    does, but it’s up to the individual collection class to choose.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然有一个非泛型的`IList`，但这个接口与它没有直接关系，尽管两个接口表示类似的概念——非泛型的`IList`有`IList<T>`成员的对应物，它还包括了几乎所有`ICollection<T>`的成员，包括`ICollection`缺失的所有成员。因此，要求`IList<T>`的实现同时实现`IList`本来是可能的，但这将会强制实现者提供大多数成员的两个版本，一个使用类型参数`T`，另一个使用`object`，因为旧的非泛型接口就是这样使用的。这也将迫使集合提供没有用处的`SyncRoot`属性。这些不便之处远不值得好处，因此`IList<T>`的实现不需要实现`IList`。它们可以选择这样做，`List<T>`选择了，但这取决于各个集合类。
- en: One unfortunate upshot of the way these three generic interfaces are related
    is that they do not provide an abstraction representing indexed collections that
    are read-only, or even ones that are fixed-size. While `IEnumerable<T>` is a read-only
    abstraction, it’s an in-order one with no way to go directly to the *n*th value.
    `IList<T>` provides indexed access, but it also defines methods for insertion
    and indexed removal, as well as mandating an implementation of `ICollection<T>`
    with its addition and value-based removal methods. So you might be wondering how
    arrays can implement these interfaces, given that all arrays are fixed-size.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这三个泛型接口的关系方式，不幸的是它们没有提供一个表示只读索引集合的抽象，甚至没有提供固定大小的抽象。虽然`IEnumerable<T>`是一个只读的抽象，但它是一个按顺序的抽象，没有直接访问第*n*个值的方法。`IList<T>`提供了索引访问，但它还定义了插入和索引移除的方法，并且要求实现`ICollection<T>`，其包括添加和基于值的移除方法。所以你可能会想知道为什么数组可以实现这些接口，因为所有的数组都是固定大小的。
- en: Arrays mitigate this problem by using explicit interface implementation to hide
    the `IList<T>` methods that can change a list’s length, discouraging you from
    trying to use them. (As you saw in [Chapter 3](ch03.xhtml#ch_types), this technique
    enables you to provide a full implementation of an interface but to be selective
    about which members are directly visible.) However, you can store a reference
    to an array in a variable of type `IList<T>`, making those methods visible—[Example 5-27](#trying_land_failing_array_add)
    uses this to call an array’s `IList<T>.Add` method. However, this results in a
    runtime error.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 数组通过使用显式接口实现来缓解这个问题，隐藏可以改变列表长度的`IList<T>`方法，阻止你尝试使用它们。（正如你在[第3章](ch03.xhtml#ch_types)看到的，这种技术使你能够提供接口的完整实现，但可以选择性地使某些成员直接可见。）然而，你可以将数组的引用存储在类型为`IList<T>`的变量中，从而使这些方法可见——[示例
    5-27](#trying_land_failing_array_add)使用此方法调用数组的`IList<T>.Add`方法。然而，这将导致运行时错误。
- en: Example 5-27\. Trying (and failing) to enlarge an array
  id: totrans-161
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-27\. 尝试（并失败）扩展数组
- en: '[PRE26]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The `Add` method throws a `NotSupportedException`, with an error message stating
    that the collection has a fixed size. If you inspect the documentation for `IList<T>`
    and `ICollection<T>`, you’ll see that all the members that would modify the collection
    are allowed to throw this error. You can discover at runtime whether this will
    happen for *all* modifications with the `ICollection<T>` interface’s `IsReadOnly`
    property. However, that won’t help you discover up front when a collection allows
    only certain changes. (For example, an array’s size is fixed, but you can still
    modify elements.)
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`Add`方法抛出一个`NotSupportedException`，错误消息表明集合的大小是固定的。如果你查看`IList<T>`和`ICollection<T>`的文档，你会看到所有可能修改集合的成员都可以抛出此错误。你可以使用`ICollection<T>`接口的`IsReadOnly`属性在运行时发现是否会发生这种情况。然而，这并不能帮助你事先发现集合只允许某些更改。（例如，数组的大小是固定的，但你仍然可以修改元素。）'
- en: 'This causes an irritating problem: if you’re writing code that does in fact
    require a modifiable collection, there’s no way to advertise that fact. If a method
    takes an `IList<T>`, it’s hard to know whether that method will attempt to resize
    that list or not. Mismatches cause runtime exceptions, and those exceptions may
    well appear in code that isn’t doing anything wrong, and where the mistake—passing
    the wrong sort of collection—was made by the caller. These problems are not showstoppers;
    in dynamically typed languages, this degree of compile-time uncertainty is in
    fact the norm, and it doesn’t stop you from writing good code.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这造成了一个令人恼火的问题：如果你在编写确实需要可修改集合的代码，却无法声明这一事实。如果一个方法接受`IList<T>`，很难知道该方法是否会尝试调整列表的大小。不匹配会导致运行时异常，这些异常很可能出现在并没有做错事情的代码中，而错误——传递了错误类型的集合——是调用者的问题。这些问题并不是致命错误；在动态类型语言中，这种编译时不确定性实际上是常态，并且不会妨碍你编写良好的代码。
- en: There is a `ReadOnlyCollection<T>` class, but as we’ll see later, that solves
    a different problem—it’s a wrapper class, not an interface, so there are plenty
    of things that are fixed-size collections that do not present a `ReadOnlyCollection<T>`.
    If you were to write a method with a parameter of type `ReadOnlyCollection<T>`,
    it would not be able to work directly with certain kinds of collections (including
    arrays). In any case, it’s not even the same abstraction—read-only is a tighter
    restriction than fixed-size.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个`ReadOnlyCollection<T>`类，但正如我们稍后将看到的，它解决的是不同的问题——它是一个包装类，而不是一个接口，因此有很多固定大小的集合并不提供`ReadOnlyCollection<T>`。如果您要编写一个参数类型为`ReadOnlyCollection<T>`的方法，它将无法直接与某些类型的集合（包括数组）一起工作。无论如何，它甚至不是相同的抽象——只读比固定大小的限制更严格。
- en: '.NET defines `IReadOnlyList<T>`, an interface that provides a better solution
    for representing read-only indexed collections (although it still doesn’t help
    with modifiable fixed-sized ones such as arrays). Like `IList<T>`, it requires
    an implementation of `IEnumerable<T>`, but it does not require `ICollection<T>`.
    It defines two members: `Count`, which returns the size of the collection (just
    like `ICollection<T>.Count`), and a read-only indexer. This solves most of the
    problems associated with using `IList<T>` for read-only collections. One minor
    problem is that because it’s newer than most of the other interfaces I’ve described
    here it is not universally supported. (It was introduced in .NET 4.5 in 2012,
    seven years after `IList<T>`.) So if you come across an API that requires an `IReadOnlyList<T>`,
    you can be sure it will not attempt to modify the collection, but if an API requires
    `IList<T>`, it’s difficult to know whether that’s because it intends to modify
    the collection or merely because it was written before `IReadOnlyList<T>` was
    invented.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 定义了`IReadOnlyList<T>`，这是一个更好的解决方案，用于表示只读索引集合（尽管它仍然无法处理像数组这样的可修改的固定大小集合）。像`IList<T>`一样，它要求实现`IEnumerable<T>`，但不需要`ICollection<T>`。它定义了两个成员：`Count`，返回集合的大小（就像`ICollection<T>.Count`一样），以及一个只读的索引器。这解决了使用`IList<T>`处理只读集合时遇到的大部分问题。一个小问题是，由于它比我在此处描述的大多数其他接口都要新，因此并不是普遍受支持的。（它在2012年的.NET
    4.5中推出，比`IList<T>`晚了七年。）因此，如果遇到要求`IReadOnlyList<T>`的 API，您可以确信它不会尝试修改集合，但如果一个
    API 要求`IList<T>`，那么很难知道这是因为它打算修改集合，还是仅仅是因为它是在`IReadOnlyList<T>`被发明之前编写的。
- en: Note
  id: totrans-167
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Collections do not need to be read-only to implement `IReadOnlyList<T>`—a modifiable
    list can easily present a read-only façade. So this interface is implemented by
    all arrays and also `List<T>`.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 集合并不需要是只读的才能实现`IReadOnlyList<T>`——一个可修改的列表可以很容易地呈现一个只读的外观。因此，所有数组和`List<T>`都实现了这个接口。
- en: 'The issues and interfaces I’ve just discussed raise a question: When writing
    code or classes that work with collections, what type should you use? You will
    typically get the most flexibility if your API demands the least specific type
    it can work with. For example, if an `IEnumerable<T>` suits your needs, don’t
    demand an `IList<T>`. Likewise, interfaces are usually better than concrete types,
    so you should prefer `IList<T>` over either `List<T>` or `T[]`. Just occasionally,
    there may be performance arguments for using a more specific type; if you have
    a tight loop critical to the overall performance of your application that works
    through the contents of a collection, you may find such code runs faster if it
    works only with array types, because the CLR may be able to perform better optimizations
    when it knows exactly what to expect. But in many cases, the difference will be
    too small to measure and will not justify the inconvenience of being tied to a
    particular implementation, so you should never take such a step without measuring
    the performance for the task at hand to see what the benefit might be. (And if
    you’re considering such a performance-oriented change, you should also look at
    the techniques described in [Chapter 18](ch18.xhtml#ch_memory_efficiency).) If
    you find that there is a possible performance win, but you’re writing a shared
    library in which you want to provide both flexibility and the best possible performance,
    there are a couple of options for having it both ways. You could offer overloads,
    so callers can pass in either an interface or a specific type. Alternatively,
    you could write a single public method that accepts the interface but that tests
    for known types and chooses between different internal code paths based on what
    the caller passes.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我刚刚讨论的问题和接口引发了一个问题：在编写与集合工作的代码或类时，应该使用什么类型？如果你的API要求能够处理最少具体类型的需求，通常会得到最大的灵活性。例如，如果`IEnumerable<T>`适合你的需求，就不要要求一个`IList<T>`。同样，接口通常比具体类型更好，所以你应该优先选择`IList<T>`而不是`List<T>`或`T[]`。偶尔可能会有性能优化的争论，如果你有一个关键循环对应用程序整体性能至关重要，通过集合内容工作时，如果仅使用数组类型可能会使代码运行更快，因为CLR在知道期望的情况下可以执行更好的优化。但在许多情况下，差异可能太小而无法测量，并且不足以证明被绑定到特定实现的不便，因此在没有测量任务的性能之前，不应采取此类步骤。
    (如果您正在考虑这样的性能导向变更，您还应该查看[第18章](ch18.xhtml#ch_memory_efficiency)中描述的技术。) 如果您发现有可能提高性能，但正在编写共享库，希望同时提供灵活性和最佳性能，有几种同时满足两者的选项。您可以提供重载，以便调用者可以传递接口或特定类型。或者，您可以编写一个单一的公共方法，接受接口但测试已知类型，并根据调用者传递的内容选择不同的内部代码路径。
- en: 'The interfaces we’ve just examined are not the only generic collection interfaces,
    because simple linear lists are not the only kind of collection. But before moving
    on to the others, I want to show enumerables and lists from the flip side: How
    do we implement these interfaces?'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚查看的接口并不是唯一的通用集合接口，因为简单的线性列表并不是唯一的集合类型。但在转向其他接口之前，我想展示一下可枚举和列表的另一面：我们如何实现这些接口？
- en: Implementing Lists and Sequences
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现列表和序列
- en: It is often useful to provide information in the form of either an `IEnumerable<T>`
    or an `IList<T>`. The former is particularly important because .NET provides a
    powerful toolkit for working with sequences in the form of LINQ to Objects, which
    I’ll show in [Chapter 10](ch10.xhtml#ch_linq). LINQ to Objects provides various
    operators that all work in terms of `IEnumerable<T>`. `IList<T>` is a useful abstraction
    anywhere that random access to any element by index is required. Some frameworks
    expect an `IList<T>`. If you want to bind a collection of objects to some kind
    of list control, for example, some UI frameworks will expect either an `IList`
    or an `IList<T>`.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 以`IEnumerable<T>`或`IList<T>`的形式提供信息通常很有用。前者尤其重要，因为.NET提供了一个强大的工具包，用于处理序列，即LINQ
    to Objects，我将在[第10章](ch10.xhtml#ch_linq)中展示。 LINQ to Objects提供了各种操作符，所有这些操作符都以`IEnumerable<T>`的形式工作。
    `IList<T>`在任何需要通过索引随机访问任何元素的地方都是一个有用的抽象。某些框架期望一个`IList<T>`。例如，如果你想将一组对象绑定到某种列表控件，一些UI框架将期望一个`IList`或`IList<T>`。
- en: You could implement these interfaces by hand, as none of them is particularly
    complicated. However, C# and the runtime libraries can help. There is direct language-level
    support for implementing `IEnumerable<T>`, and the runtime libraries provide support
    for the generic and nongeneric list interfaces.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以手动实现这些接口，因为它们都不是特别复杂。然而，C# 和运行时库可以提供帮助。直接支持在语言级别实现`IEnumerable<T>`，而运行时库则为通用和非通用列表接口提供支持。
- en: Implementing IEnumerable<T> with Iterators
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用迭代器实现 IEnumerable<T>
- en: C# supports a special form of method called an *iterator*. An iterator is a
    method that produces enumerable sequences using the `yield` keyword. [Example 5-28](#simple_iterator)
    shows a simple iterator and some code that uses it. This will display numbers
    counting down from 5 to 1.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: C# 支持一种称为*迭代器*的特殊方法。迭代器是使用`yield`关键字生成可枚举序列的方法。 [示例 5-28](#simple_iterator)展示了一个简单的迭代器及其使用的一些代码。这将显示从5到1倒数的数字。
- en: Example 5-28\. A simple iterator
  id: totrans-176
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-28\. 一个简单的迭代器
- en: '[PRE27]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: An iterator looks much like any normal method, but the way it returns values
    is different. The iterator in [Example 5-28](#simple_iterator) has a return type
    of `IEnumerable<int>`, and yet it does not appear to return anything of that type.
    Instead of a normal `return` statement, it uses a `yield return` statement, and
    that returns a single `int`, not a collection. Iterators produce values one at
    a time with `yield return` statements, and unlike with a normal `return`, the
    method can continue to execute after returning a value—it’s only when the method
    either runs to the end or decides to stop early with a `yield break` statement
    or by throwing an exception that it is complete. [Example 5-29](#very_simple_iterator)
    shows this rather more starkly. Each `yield return` causes a value to be emitted
    from the sequence, so this one will produce the numbers 1–3.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代器看起来很像任何普通方法，但它返回值的方式不同。示例 [5-28](#simple_iterator) 中的迭代器具有`IEnumerable<int>`的返回类型，但看起来并未返回任何该类型的内容。它不是使用普通的`return`语句，而是使用`yield
    return`语句，该语句返回单个`int`，而不是一个集合。迭代器通过`yield return`语句逐个产生值，并且与普通的`return`不同，方法在返回值后可以继续执行
    —— 只有当方法运行到结尾或通过`yield break`语句或抛出异常提前结束时，它才算完成。 [示例 5-29](#very_simple_iterator)
    更明显地展示了这一点。每个`yield return`导致从序列中发出一个值，因此这个迭代器将产生数字1到3。
- en: Example 5-29\. A very simple iterator
  id: totrans-179
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-29\. 一个非常简单的迭代器
- en: '[PRE28]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Although this is fairly straightforward in concept, the way it works is somewhat
    involved because code in iterators does not run in the same way as other code.
    Remember, with `IEnumerable<T>`, the caller is in charge of when the next value
    is retrieved; a `foreach` loop will get an enumerator and then repeatedly call
    `MoveNext()` until that returns `false`, and expect the `Current` property to
    provide the current value. So how do Examples [5-28](#simple_iterator) and [5-29](#very_simple_iterator)
    fit into that model? You might think that perhaps C# stores all the values an
    iterator yields in a `List<T>`, returning that once the iterator is complete,
    but it’s easy to demonstrate that that’s not true by writing an iterator that
    never finishes, such as the one in [Example 5-30](#infinite_iterator).
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这在概念上相当简单，但它的工作方式有些复杂，因为迭代器中的代码不像其他代码那样运行。记住，对于`IEnumerable<T>`，调用者负责何时检索下一个值；`foreach`循环将获取一个枚举器，然后重复调用`MoveNext()`直到返回`false`，并期望`Current`属性提供当前值。那么示例
    [5-28](#simple_iterator) 和 [5-29](#very_simple_iterator) 如何适应这个模型呢？也许你会认为，也许 C#
    在一个`List<T>`中存储迭代器产生的所有值，并在迭代器完成后返回它，但很容易通过编写一个永不完成的迭代器（如 [示例 5-30](#infinite_iterator)
    中的迭代器）来证明这并不正确。
- en: Example 5-30\. An infinite iterator
  id: totrans-182
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-30\. 一个无限迭代器
- en: '[PRE29]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This iterator runs indefinitely; it has a `while` loop with a `true` condition,
    and it contains no `break` statement, so this will never voluntarily stop. If
    C# tried to run an iterator to completion before returning anything, it would
    get stuck here. (The numbers grow, so if it ran for long enough, the method would
    eventually terminate by throwing an `OutOfMemoryException`.) But if you try this,
    you’ll find it starts returning values from the Fibonacci series immediately and
    will continue to do so for as long as you continue to iterate through its output.
    Clearly, C# is not simply running the whole method before returning.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 此迭代器运行无限期；它有一个带有`true`条件的`while`循环，并且不包含`break`语句，因此它永远不会自愿停止。如果C#试图在返回任何内容之前完成迭代器的运行，它将在此处卡住。
    (数字会增长，因此如果运行时间足够长，该方法最终会通过抛出`OutOfMemoryException`而终止。) 但是如果你尝试这样做，你会发现它立即开始从斐波那契序列中返回值，并且只要你继续迭代其输出，它将继续这样做。
    显然，C#并非简单地在返回之前运行整个方法。
- en: C# performs some serious surgery on your code to make this work. If you examine
    the compiler’s output for an iterator using a tool such as ILDASM (the disassembler
    for .NET code, provided with the .NET SDK), you’ll find it generates a private
    nested class that acts as the implementation for both the `IEnumerable<T>` that
    the method returns and also the `IEnumerator<T>` that the `IEnumerable<T>`’s `GetEnumerator`
    method returns. The code from your iterator method ends up inside this class’s
    `MoveNext` method, but it is barely recognizable, because the compiler splits
    it up in a way that enables each `yield return` to return to the caller, but for
    execution to continue from where it left off the next time `MoveNext` is called.
    Where necessary, it will store local variables inside this generated class so
    that their values can be preserved across multiple calls to `MoveNext`. Perhaps
    the easiest way to get a feel for what C# has to do when compiling an iterator
    is to write the equivalent code by hand. [Example 5-31](#implementing_ienumerableless_thantgreate)
    provides the same Fibonacci sequence as [Example 5-30](#infinite_iterator) without
    the aid of an iterator. It’s not precisely what the compiler does, but it illustrates
    some of the challenges.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: C#对您的代码进行了一些严肃的手术以使其工作。 如果您使用像ILDASM（与.NET SDK一起提供的.NET代码反汇编器）这样的工具检查迭代器的编译器输出，您会发现它生成了一个作为方法返回的`IEnumerable<T>`的实现以及`IEnumerable<T>`的`GetEnumerator`方法返回的`IEnumerator<T>`的私有嵌套类。
    您的迭代器方法的代码最终位于此类的`MoveNext`方法内部，但几乎无法识别，因为编译器以一种方式将其拆分，使得每次`yield return`都能返回给调用者，但在下次调用`MoveNext`时继续执行。
    在必要时，它将存储局部变量在此生成的类中，以便它们的值可以在多次调用`MoveNext`时保持不变。 或许了解C#在编译迭代器时所需做的工作的最简单方法就是手动编写等效代码。
    [示例 5-31](#implementing_ienumerableless_thantgreate)提供了与[示例 5-30](#infinite_iterator)相同的斐波那契序列，但没有使用迭代器的帮助。
    它不完全是编译器所做的，但它展示了其中的一些挑战。
- en: Example 5-31\. Implementing `IEnumerable<T>` by hand
  id: totrans-186
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-31\. 手动实现`IEnumerable<T>`
- en: '[PRE30]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This is not a particularly complex example, because its enumerator is essentially
    in either of two states—either it is running for the first time and therefore
    needs to run the code that comes before the loop or it is inside the loop. Even
    so, this code is much harder to read than [Example 5-30](#infinite_iterator),
    because the mechanics of supporting enumeration have obscured the essential logic.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是一个特别复杂的例子，因为它的枚举器基本上处于两种状态之一——要么是第一次运行，因此需要运行循环之前的代码，要么是在循环内部。 即便如此，这段代码比[示例 5-30](#infinite_iterator)要难读得多，因为支持枚举的机制掩盖了基本逻辑的本质。
- en: The code would get even more convoluted if we needed to deal with exceptions.
    You can write `using` blocks and `finally` blocks, which enable your code to behave
    correctly in the face of errors, as I’ll show in Chapters [7](ch07.xhtml#ch_object_lifetime)
    and [8](ch08.xhtml#ch_exceptions), and the compiler can end up doing a lot of
    work to preserve the correct semantics for these when the method’s execution is
    split up over multiple iterations.^([2](ch05.xhtml#fn24)) You wouldn’t need to
    write too many enumerations by hand this way before being grateful that C# can
    do it for you.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要处理异常，代码会变得更加复杂。 您可以编写`using`块和`finally`块，这使得您的代码能够在面对错误时正确运行，正如我将在第[7](ch07.xhtml#ch_object_lifetime)和[8](ch08.xhtml#ch_exceptions)章中展示的那样，编译器最终可能会为了保留这些正确的语义而做很多工作，当方法的执行在多个迭代之间分割时。^([2](ch05.xhtml#fn24))
    在您手动编写多个枚举之前，您可能会感谢C#可以为您完成这些工作的方式。
- en: Iterator methods don’t have to return an `IEnumerable<T>`, by the way. If you
    prefer, you can return an `IEnumerator<T>` instead. And, as you saw earlier, objects
    that implement either of these interfaces also always implement the nongeneric
    equivalents, so if you need a plain `IEnumerable` or `IEnumerator`, you don’t
    need to do extra work—you can pass an `IEnumerable<T>` to anything that was expecting
    a plain `IEnumerable`, and likewise for enumerators. If for some reason you want
    to provide one of these nongeneric interfaces and you don’t wish to provide the
    generic version, you are allowed to write iterators that return the nongeneric
    forms directly.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一下，迭代器方法并不一定要返回 `IEnumerable<T>`。如果你愿意，你可以返回 `IEnumerator<T>`。而且，正如你之前看到的，实现这些接口的对象也总是实现它们的非泛型版本，因此如果你需要一个普通的
    `IEnumerable` 或 `IEnumerator`，你不需要额外的工作——你可以将一个 `IEnumerable<T>` 传递给任何期望普通 `IEnumerable`
    的地方，对于枚举器也是一样。如果出于某种原因你想要提供其中一个非泛型接口，并且你不想提供泛型版本，你可以直接编写返回非泛型形式的迭代器。
- en: One thing to be careful of with iterators is that they run very little code
    until the first time the caller calls `MoveNext`. So if you were to single-step
    through code that calls the `Fibonacci` method in [Example 5-30](#infinite_iterator),
    the method call would appear not to do anything at all. If you try to step into
    the method at the point at which it’s invoked, none of the code in the method
    runs. It’s only when iteration begins that you’d see your iterator’s body execute.
    This has a couple of consequences.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代器需要小心的一点是，直到调用者第一次调用 `MoveNext` 方法时，它们才会执行非常少的代码。因此，如果你逐步执行调用 [示例 5-30](#infinite_iterator)
    中的 `Fibonacci` 方法的代码，该方法调用似乎根本不会做任何事情。如果你尝试在调用时步入方法，在方法运行时将不会执行任何代码。只有当迭代开始时，你才会看到迭代器的主体执行。这有几个后果。
- en: The first thing to bear in mind is that if your iterator method takes arguments,
    and you want to validate those arguments, you may need to do some extra work.
    By default, the validation won’t happen until iteration begins, so errors will
    occur later than you might expect. If you want to validate arguments immediately,
    you will need to write a wrapper. [Example 5-32](#iterator_argument_validation)
    shows an example—it provides a normal method called `Fibonacci` that doesn’t use
    `yield return` and will therefore not get the special compiler behavior for iterators.
    This normal method validates its argument before going on to call a nested iterator
    method. (This also illustrates that local methods can use `yield return`.)
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要记住的是，如果你的迭代器方法接受参数，并且你想要验证这些参数，你可能需要做一些额外的工作。默认情况下，验证将在迭代开始时才会发生，因此错误可能会比预期晚发生。如果你想立即验证参数，你需要编写一个包装器。[示例 5-32](#iterator_argument_validation)
    展示了一个例子——它提供了一个名为 `Fibonacci` 的普通方法，不使用 `yield return`，因此不会得到迭代器的特殊编译器行为。这个普通方法在调用嵌套的迭代器方法之前验证其参数。（这也说明了局部方法可以使用
    `yield return`。）
- en: Example 5-32\. Iterator argument validation
  id: totrans-193
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-32\. 迭代器参数验证
- en: '[PRE31]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The second thing to remember is that iterators may execute several times. `IEnumerable<T>`
    provides a `GetEnumerator` that can be called many times over, and your iterator
    body will run from the start each time. So even though your iterator method may
    only have been called once, it could run several times.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 第二点需要记住的是，迭代器可能会执行多次。`IEnumerable<T>` 提供了一个 `GetEnumerator` 方法，可以被多次调用，而你的迭代器体每次都会从头开始运行。所以即使你的迭代器方法可能只被调用了一次，它也可能会运行多次。
- en: Collection<T>
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Collection<T>
- en: If you look at types in the runtime libraries, you’ll find that when they offer
    properties that expose an implementation of `IList<T>`, they often do so indirectly.
    Instead of an interface, properties often provide some concrete type, although
    it’s usually not `List<T>` either. `List<T>` is designed to be used as an implementation
    detail of your code, and if you expose it directly, you may be giving users of
    your class too much control. Do you want them to be able to modify the list? And
    even if you do, mightn’t your code need to know when that happens?
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看运行时库中的类型，你会发现当它们提供暴露 `IList<T>` 实现的属性时，通常是间接的。与接口不同，属性通常提供某种具体类型，尽管通常不是
    `List<T>`。`List<T>` 被设计为你代码的实现细节，如果直接暴露它，可能会给你的类的用户过多的控制权。你希望他们能修改列表吗？即使你希望如此，你的代码是否需要知道这种情况发生的时机呢？
- en: The runtime libraries provide a `Collection<T>` class that is designed to be
    used as the base class for collections that a type will make publicly available.
    It is similar to `List<T>`, but there are two significant differences. First,
    it has a smaller API—it offers `IndexOf`, but all the other searching and sorting
    methods available for `List<T>` are missing, and it does not provide ways to discover
    or change its capacity independently of its size. Second, it provides a way for
    derived classes to discover when items have been added or removed. `List<T>` does
    not, on the grounds that it’s your list so you presumably know when you add and
    remove items. Notification mechanisms are not free, so `List<T>` avoids unnecessary
    overhead by not offering them. But `Collection<T>` assumes that external code
    will have access to your collection and that you will therefore not be in control
    of every addition and removal, justifying the overhead involved in providing a
    way for you to find out when the list is modified. (This is only available to
    the code deriving from `Collection<T>`. If you want code using your collection
    to be able to detect changes, the `ObservableCollection<T>` type is designed for
    that exact scenario. For example, if you use this type as the source for a list
    in desktop and mobile UI frameworks such as WPF, UWP, MAUI, and Xamarin, they
    will be able to display the list automatically when you modify the collection.)
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 运行时库提供了一个`Collection<T>`类，旨在作为类型公开的集合的基类使用。它类似于`List<T>`，但有两个显著的区别。首先，它的API更小——它提供了`IndexOf`，但所有其他适用于`List<T>`的搜索和排序方法都不包括，并且它不提供独立于其大小的方式来发现或更改其容量。其次，它为派生类提供了一种发现添加或移除项时机制的方法。`List<T>`则没有这样的机制，因为它是你的列表，所以你应该知道何时添加和移除项。通知机制并不是免费的，所以`List<T>`通过不提供它们来避免不必要的开销。但`Collection<T>`假设外部代码将访问你的集合，并且你因此不能控制每一次添加和移除，这正当了提供一种让你发现列表何时被修改的开销。
    （这仅适用于从`Collection<T>`派生的代码。如果你希望使用你的集合的代码能够检测到变化，`ObservableCollection<T>`类型就是为这种情况设计的。例如，如果你在桌面和移动UI框架（如WPF、UWP、MAUI和Xamarin）中将此类型用作列表的源，它们将能够在修改集合时自动显示列表。）
- en: You typically derive a class from `Collection<T>`, and you can override the
    virtual methods it defines to discover when the collection changes. ([Chapter 6](ch06.xhtml#ch_inheritance)
    will discuss inheritance and overriding.) `Collection<T>` implements both `IList`
    and `IList<T>`, so you could present a `Collection<T>`-based collection through
    an interface type property, but it’s common to make a derived collection type
    public and to use that instead of an interface as the property type.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 你通常从`Collection<T>`派生一个类，并且你可以重写它定义的虚方法来发现集合的变化。([第六章](ch06.xhtml#ch_inheritance)将讨论继承和重写。)`Collection<T>`实现了`IList`和`IList<T>`，因此你可以通过接口类型的属性展示基于`Collection<T>`的集合，但通常会将派生的集合类型公开并使用它而不是接口作为属性类型。
- en: ReadOnlyCollection<T>
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ReadOnlyCollection<T>
- en: 'If you want to provide a nonmodifiable collection, then instead of using `Collection<T>`,
    you can use `ReadOnlyCollection<T>`. This goes further than the restrictions imposed
    by arrays, by the way: not only can you not add, remove, or insert items, but
    you cannot even replace elements. This class implements `IList<T>`, which requires
    an indexer with both a `get` and a `set`, but the `set` throws an exception. (Of
    course, it also implements `IReadOnlyCollection<T>`.)'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想提供一个不可修改的集合，那么你可以使用`ReadOnlyCollection<T>`而不是使用`Collection<T>`。顺便说一下，这比数组施加的限制更进一步：不仅你不能添加、移除或插入项目，而且你甚至不能替换元素。这个类实现了`IList<T>`，它要求一个带有`get`和`set`的索引器，但是`set`会抛出异常。（当然，它也实现了`IReadOnlyCollection<T>`。）
- en: If your collection’s element type is a reference type, making the collection
    read-only does not prevent the objects to which the elements refer from being
    modified. I can retrieve, say, the 12th element from a read-only collection, and
    it will hand me back a reference. Fetching a reference counts as a read-only operation,
    but now that I have got that reference, the collection object is out of the picture,
    and I am free to do whatever I like with that reference. Since C# does not offer
    any concept of a read-only reference (there’s nothing equivalent to C++ `const`
    references), the only way to present a truly read-only collection is to use an
    immutable type in conjunction with `ReadOnlyCollection<T>`.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你集合的元素类型是引用类型，将集合设为只读并不能防止元素引用的对象被修改。例如，我可以从只读集合中检索第12个元素，并且它会返回给我一个引用。获取引用算是一个只读操作，但现在我已经得到了那个引用，集合对象已经不再受限制，我可以随心所欲地对那个引用进行操作。由于
    C# 并没有提供任何类似于 C++ `const` 引用的概念，因此要展示一个真正只读的集合的唯一方法是与不可变类型结合使用 `ReadOnlyCollection<T>`。
- en: There are two ways to use `ReadOnlyCollection<T>`. You can use it directly as
    a wrapper for an existing list—its constructor takes an `IList<T>`, and it will
    provide read-only access to that. (`List<T>` provides a method called `AsReadOnly`
    that constructs a read-only wrapper for you, by the way.) Alternatively, you could
    derive a class from it. As with `Collection<T>`, some classes do this for collections
    they wish to expose via properties, and it’s usually because they want to define
    additional methods specific to the collection’s purpose. Even if you derive from
    this class, you will still be using it to wrap an underlying list, because the
    only constructor it provides is the one that takes a list.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `ReadOnlyCollection<T>` 有两种方法。你可以直接将它用作现有列表的包装器——它的构造函数接受一个 `IList<T>`，并且会提供对其的只读访问。（顺便说一句，`List<T>`
    提供了一个名为 `AsReadOnly` 的方法，用于为你构造一个只读包装器。）或者，你可以从它派生一个类。与 `Collection<T>` 一样，一些类为希望通过属性公开的集合执行此操作，通常是因为它们希望定义与集合用途相关的附加方法。即使从这个类派生，你仍然会使用它来包装一个底层列表，因为它提供的唯一构造函数就是接受列表的构造函数。
- en: Warning
  id: totrans-204
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: '`ReadOnlyCollection<T>` is typically not a good fit with scenarios that automatically
    map between object models and an external representation. For example, it causes
    problems in types used as Data Transfer Objects (DTOs) that get converted to and
    from JSON messages sent over network connections, and also in object-relational
    mapping systems that present the contents of a database through an object model.
    Frameworks for these scenarios need to be able to instantiate your types and populate
    them with data, so although a read-only collection might be a good conceptual
    match for what some part of your model represents, it might not fit in with the
    way these mapping frameworks expect to initialize objects.'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '`ReadOnlyCollection<T>` 通常不适合自动映射对象模型和外部表示之间的场景。例如，在作为数据传输对象（DTOs）使用的类型中，它会在转换为和从通过网络连接发送的
    JSON 消息中引起问题，并且在通过对象关系映射系统通过对象模型呈现数据库内容时也会出现问题。这些场景的框架需要能够实例化你的类型并将其填充数据，因此，尽管只读集合可能是你的模型某些部分的理想匹配，但它可能与这些映射框架期望初始化对象的方式不符。'
- en: Addressing Elements with Index and Range Syntax
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用索引和范围语法访问元素
- en: Whether using arrays, `List<T>`, `IList<T>`, or the various related types and
    interfaces just discussed, we’ve identified elements using simple examples such
    as `items[0]`, and more generally, expressions of the form `*arrayOrListExpression*[*indexExpression*]`.
    So far, all the examples have used an expression of type `int` for the index,
    but that is not the only choice. [Example 5-33](#relative_index_last_element)
    accesses the final element of an array using an alternative syntax.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 无论是使用数组、`List<T>`、`IList<T>` 还是前面讨论的各种相关类型和接口，我们都使用简单的示例来识别元素，例如 `items[0]`，以及更一般的形式为
    `*arrayOrListExpression*[*indexExpression*]` 的表达式。到目前为止，所有示例都使用了 `int` 类型的表达式作为索引，但这并不是唯一的选择。[示例 5-33](#relative_index_last_element)
    使用了另一种语法来访问数组的最后一个元素。
- en: Example 5-33\. Accessing the last element of an array with an end-relative index
  id: totrans-208
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-33\. 使用端相对索引访问数组的最后一个元素
- en: '[PRE32]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This demonstrates one of two operators for use in indexers: the `^` operator
    and the *range operator*. The latter, shown in [Example 5-34](#subarray_range_operator),
    is a pair of periods (`..`), and it is used to identify subranges of arrays, strings,
    or any indexable type that implements a certain pattern.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这展示了用于索引器的两个运算符之一：`^`运算符和*范围运算符*。后者在[示例 5-34](#subarray_range_operator)中展示，是一对点号(`..`)，用于标识数组、字符串或任何实现特定模式的可索引类型的子范围。
- en: Example 5-34\. Getting a subrange of an array with the range operator
  id: totrans-211
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-34\. 使用范围运算符获取数组的子范围
- en: '[PRE33]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Expressions using the `^` and `..` operators are of type `Index` and `Range`,
    respectively. These types are available in .NET Standard 2.1, meaning they are
    built into .NET Core 3.1 and .NET 5.0 or later. However, these types are not available
    on .NET Framework, meaning that you can only use these language features on newer
    runtimes.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`^`和`..`运算符的表达式分别是`Index`和`Range`类型。这些类型在.NET Standard 2.1中可用，意味着它们内置于.NET
    Core 3.1和.NET 5.0或更高版本中。然而，在.NET Framework上这些类型不可用，这意味着你只能在较新的运行时中使用这些语言特性。
- en: System.Index
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`System.Index`'
- en: You can put the `^` operator in front of any `int` expression. It produces a
    `System.Index`, a value type that represents a position. When you create an index
    with `^`, it is end-relative, but you can also create start-relative indexes.
    There’s no special operator for that, but since `Index` offers an implicit conversion
    from `int`, you can just assign `int` values directly into variables of type `Index`,
    as [Example 5-35](#various_indexes) shows. You can also explicitly construct an
    index, as the line with `var` shows. The final `bool` argument is optional—it
    defaults to `false`—but I’m showing it to illustrate how `Index` knows which kind
    you want.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将`^`运算符放在任何`int`表达式的前面。它产生一个`System.Index`，这是一个值类型，表示一个位置。当你用`^`创建一个索引时，它是结束相对的，但你也可以创建起始相对索引。没有特殊的运算符，但由于`Index`提供从`int`的隐式转换，你可以直接将`int`值分配到`Index`类型的变量中，正如[示例
    5-35](#various_indexes)所示。你也可以显式地构造一个索引，就像`var`行所示。最后的`bool`参数是可选的——默认为`false`——但我展示它来说明`Index`如何知道你想要哪种类型。
- en: Example 5-35\. Some start-relative and end-relative `Index` values
  id: totrans-216
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-35\. 一些起始相对和结束相对的`Index`值
- en: '[PRE34]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: As [Example 5-35](#various_indexes) shows, end-relative indexes exist independently
    of any particular collection. (Internally, `Index` stores end-relative indexes
    as negative numbers. This means that an `Index` is the same size as an `int`.
    It also means that negative start- or end-relative values are illegal—you’ll get
    an exception if you try to create one.) C# generates code that determines the
    actual element position when you use an index. If `small` and `big` are arrays
    with 3 and 30 elements, respectively, `small[last]` would return the third, and
    `big[last]` would return the 30th. C# will turn these into `small[last.GetOffset(small.Length)]`
    and `big[last.GetOffset(big.Length)]`, respectively.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 如[示例 5-35](#various_indexes)所示，结束相对索引存在于任何特定集合之外。（在内部，`Index`将结束相对索引存储为负数。这意味着`Index`与`int`大小相同。这也意味着负的起始或结束相对值是非法的——如果尝试创建一个，你会得到一个异常。）C#会生成代码，在使用索引时确定实际元素位置。如果`small`和`big`分别是包含3和30个元素的数组，`small[last]`将返回第三个元素，而`big[last]`将返回第30个元素。C#将把这些转换为`small[last.GetOffset(small.Length)]`和`big[last.GetOffset(big.Length)]`。
- en: It has often been said that three of the hardest problems in computing are picking
    names for things and off-by-one errors. At first glance, [Example 5-35](#various_indexes)
    makes it look like `Index` might be contributing to these problems. It may be
    vexing that the index for the third item is two, not three, but that at least
    is consistent with how arrays have always worked in C# and is normal for any zero-based
    indexing system. But given that zero-based convention, why on earth do the end-relative
    indexes appear to be one-based? We denote the first element with `0` but the last
    element with `^1`!
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 人们常说，计算机科学中三大难题是为事物命名和一错再错的错误。乍一看，[示例 5-35](#various_indexes)使人觉得`Index`可能在加剧这些问题。第三个项目的索引是二而不是三可能会使人困惑，但这至少与C#中数组的工作方式一致，并且对于任何零基索引系统都是正常的。但鉴于零基准约定，为什么结束相对索引看起来是一基的呢？我们用`0`表示第一个元素，但用`^1`表示最后一个元素！
- en: 'There are some good reasons for this. The fundamental insight is that in C#,
    indexes have always specified distances. When programming language designers choose
    a zero-based indexing system, this is not really a decision to call the first
    element 0: it is a decision to interpret an index as a distance from the start
    of an array. An upshot of this is that an index doesn’t really refer to an item.
    [Figure 5-1](#where_indexes_points) shows a collection with four elements and
    indicates where various index values would point in that collection. Notice that
    the indexes all refer to the boundaries between the items. This may seem like
    splitting hairs, but it’s the key to understanding all zero-based index systems,
    and it is behind the apparent inconsistency in [Example 5-35](#various_indexes).'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做有一些很好的理由。其核心洞见是，在C#中，索引始终指定距离。当编程语言设计者选择零基索引系统时，并非真的决定将第一个元素称为0：而是决定将索引解释为从数组开始的距离。由此产生的一个结果是，索引并不真正指代一个项。[图 5-1](#where_indexes_points)展示了一个包含四个元素的集合，并指示了在该集合中各种索引值指向的位置。注意，所有的索引都指向各个项之间的边界。这可能看起来有些吹毛求疵，但这是理解所有零基索引系统的关键，也是[示例 5-35](#various_indexes)中显露的表面不一致的背后原因。
- en: '![Index Positions](assets/pc10_0501.png)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![索引位置](assets/pc10_0501.png)'
- en: Figure 5-1\. Where `Index` values point
  id: totrans-222
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 5-1\. `Index`值指向的位置
- en: When you access an element of a collection by index, you are asking for the
    element that *starts* at the position indicated by the index. So `array[0]` retrieves
    the single element that starts at the beginning of the array, the element that
    fills the space between indexes 0 and 1\. Likewise, `array[1]` retrieves the element
    between indexes 1 and 2\. What would `array[^0]` mean?^([3](ch05.xhtml#idm45884821262096))
    That would be an attempt to fetch the element that *starts* at the very end of
    the array. Since elements all take up a certain amount of space, an element that
    starts at the very end of the array would necessarily finish one position after
    the end of the array. In this four-element array, `array[^0]` is equivalent to
    `array[4]`, so we’re asking for the element occupying the space that starts four
    elements from the start and that ends five elements from the start. And since
    this is a four-element array, that’s obviously not going to work.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 当你通过索引访问集合的元素时，你要求的是从索引指示的位置*开始*的元素。因此，`array[0]`检索的是从数组开头开始的单个元素，填充索引0和1之间的空间的元素。同样，`array[1]`检索的是索引1和2之间的元素。那么`array[^0]`意味着什么？^([3](ch05.xhtml#idm45884821262096))
    这将尝试获取从数组末尾开始的元素。由于元素都占据一定的空间，从数组末尾开始的元素必然会在数组末尾之后一个位置结束。在这个四元素数组中，`array[^0]`相当于`array[4]`，因此我们要求的是占据从开头计算起四个元素开始并结束在开头五个元素的空间的元素。由于这是一个四元素数组，显然是行不通的。
- en: 'The apparent discrepancy—the fact that `array[0]` gets the first, but we need
    to write `array[^1]` to get the last—occurs because elements sit between two indexes,
    and array indexers always retrieve the element between the index specified and
    the index after that. The fact that they do this even when you’ve specified an
    end-relative index is the reason those appear to be one-based. This language feature
    could have been designed differently: you could imagine a rule in which end-relative
    indexes always access the element that *ends* at the specified distance from the
    end and that starts one position earlier than that. There would have been a pleasing
    symmetry to this, because it would have made `array[^0]` refer to the final element,
    but this would have caused more problems than it solved.'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 表面上的差异——即`array[0]`获取第一个元素，但我们需要写`array[^1]`来获取最后一个元素——是因为元素位于两个索引之间，而数组索引器总是检索指定索引和其后索引之间的元素。即使指定了一个末尾相关的索引，它们也会这样做，这就是为什么这些看起来是基于一的原因。这种语言特性本可以设计得不同：你可以想象一种规则，即末尾相关的索引始终访问从末尾指定距离结束并从这之前一位置开始的元素。这样设计本应更对称，因为这会使得`array[^0]`指向最后一个元素，但这样做带来的问题比解决的问题更多。
- en: It would be confusing to have indexers interpret an index in two different ways—it
    would mean that two different indexes might refer to the same position and yet
    fetch different elements. In any case, C# developers are already used to things
    working this way. As [Example 5-36](#end_relative_indexes_and_equivalents) shows,
    the way to access the final element of an array prior to the `^` index operator
    was to use an index calculated by subtracting one from the length. And if you
    wanted the element before last, you subtracted two from the length, and so on.
    As you can see, the new end-relative syntax is entirely consistent with the long-established
    existing practice.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 使索引器在两种不同方式下解释索引会很令人困惑——这意味着两个不同的索引可能指向同一个位置，但提取不同的元素。无论如何，C# 开发人员已经习惯了这种工作方式。正如
    [Example 5-36](#end_relative_indexes_and_equivalents) 所示，在 `^` 索引运算符之前，访问数组的最后一个元素的方法是使用从长度中减去一计算出的索引。如果想要倒数第二个元素，则从长度中减去两个，依此类推。正如你所见，新的结束相对语法与长期存在的现有实践完全一致。
- en: Example 5-36\. End-relative indexing and pre-`Index` equivalents
  id: totrans-226
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-36\. 结束相对索引和 `Index` 前等价物
- en: '[PRE35]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: One more way to think of this is to wonder what it might look like if we accessed
    arrays by specifying ranges. The first element is in the range 0–1, and the last
    is in the range ^1–^0\. Expressed this way, there is clearly symmetry between
    the start-relative and end-relative forms. And speaking of ranges…
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一种思考方法是想象如果我们通过指定范围来访问数组会是什么样子。第一个元素在范围 0–1 中，最后一个元素在范围 ^1–^0 中。以这种方式表达，起始相对和结束相对形式之间显然存在对称性。说到范围……
- en: System.Range
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`System.Range`'
- en: As I said earlier, C# has two operators useful for working with arrays and other
    indexable types. We’ve just looked at `^` and the corresponding `Index` type.
    The other is called the *range operator*, and it has a corresponding type, `Range`,
    also in the `System` namespace. A `Range` is a pair of `Index` values, which it
    makes available through `Start` and `End` properties. `Range` offers a constructor
    taking two `Index` values, but in C# the idiomatic way to create one is with the
    range operator, as [Example 5-37](#various_ranges) shows.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我之前所说，C# 有两个对处理数组和其他可索引类型非常有用的运算符。我们刚刚看过 `^` 和对应的 `Index` 类型。另一个称为 *范围运算符*，它在
    `System` 命名空间中也有相应的类型 `Range`。`Range` 是一对 `Index` 值，通过 `Start` 和 `End` 属性提供。`Range`
    提供了一个接受两个 `Index` 值的构造函数，但在 C# 中，创建它的习惯方式是使用范围运算符，正如 [Example 5-37](#various_ranges)
    所示。
- en: Example 5-37\. Various ranges
  id: totrans-231
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-37\. 不同的范围
- en: '[PRE36]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: As you can see, if you do not put a start index before the `..`, it defaults
    to 0, and if you omit the end, it defaults to `^0` (i.e., the very start and end,
    respectively). The example also shows that the start can be either start-relative
    or end-relative, as can the end.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，如果在 `..` 前面没有放置起始索引，默认为 0；如果省略结束索引，默认为 `^0`（即最开始和最后，分别）。示例还显示，起始索引可以是起始相对的，也可以是结束相对的，结束索引也是如此。
- en: Warning
  id: totrans-234
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: The default value for `Range`—the one you’ll get in a field or array element
    that you do not explicitly initialize—is 0..0\. This denotes an empty range. While
    this is a natural upshot of the fact that value types are always initialized to
    zero-like values by default, it might not be what you’d expect given that `..`
    is equivalent to `Range.All`.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '`Range` 的默认值——在未显式初始化的字段或数组元素中得到的值——是 0..0。这表示一个空范围。虽然这是由于值类型默认总是初始化为类似于零的值所导致的自然结果，但这可能与你期望的不同，因为
    `..` 等同于 `Range.All`。'
- en: Since `Range` works in terms of `Index`, the start and end denote offsets, not
    elements. For example, consider what the range `1..3` would mean for the elements
    shown in [Figure 5-1](#where_indexes_points). In this case, both indexes are start-relative.
    The start index, `1`, is the boundary between the first and second elements (`a`
    and `b`), and the end index, `3`, is the boundary between the third and fourth
    elements (`c` and `d`). So this is a range that starts at the beginning of `b`
    and ends at the end of `c`, as [Figure 5-2](#range_illustrated) shows. So this
    identifies a two-element range (`b` and `c`).
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `Range` 是基于 `Index` 工作的，起始和结束表示偏移量，而不是元素。例如，考虑范围 `1..3` 对应于 [Figure 5-1](#where_indexes_points)
    中显示的元素的含义。在这种情况下，两个索引都是起始相对的。起始索引 `1` 是第一个和第二个元素（`a` 和 `b`）之间的边界，结束索引 `3` 是第三个和第四个元素（`c`
    和 `d`）之间的边界。因此，这是一个从 `b` 的开头到 `c` 的结尾的范围，正如 [Figure 5-2](#range_illustrated) 所示。因此，这确定了一个包含两个元素
    `b` 和 `c` 的范围。
- en: '![The Range 1..3](assets/pc10_0502.png)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![范围 1..3](assets/pc10_0502.png)'
- en: Figure 5-2\. A range
  id: totrans-238
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: Figure 5-2\. 一个范围
- en: 'The interpretation of ranges sometimes surprises people when they first see
    it: some expect `1..3` to represent the first, second, and third elements (or,
    if they take into account C#’s zero-based indexing, perhaps the second, third,
    and fourth elements). It can seem inconsistent at first that the start index appears
    to be inclusive while the end index is exclusive. But once you remember that an
    index refers not to an item but to an offset, and therefore the boundary between
    two items, it all makes sense. If you draw the positions represented by a range’s
    indexes, as [Figure 5-2](#range_illustrated) does, it becomes perfectly obvious
    that the range identified by `1..3` covers just two elements.'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 数组范围的解释有时会让人感到惊讶，当他们第一次看到时：有些人期望`1..3`表示第一、第二和第三个元素（或者，如果考虑到 C# 的从零开始索引，可能是第二、第三和第四个元素）。起始索引看起来是包含的，而结束索引是排除的，这一点一开始可能显得不一致。但是一旦你记住索引指的不是项目而是偏移量，因此是两个项目之间的边界，这一切就都说得通了。如果你画出范围索引表示的位置，就像[图 5-2](#range_illustrated)那样，就会完全明白`1..3`范围只覆盖了两个元素。
- en: So what can we do with a `Range`? As [Example 5-34](#subarray_range_operator)
    showed, we can use one to get a subrange of an array. That creates a new array
    of the relevant size and copies the values from the range into it. This same syntax
    also works for getting substrings, as [Example 5-38](#range_substring) shows.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 那么我们可以用`Range`做什么呢？正如[示例 5-34](#subarray_range_operator)所示，我们可以使用它来获取数组的子范围。这会创建一个相应大小的新数组，并将范围内的值复制到其中。同样的语法也适用于获取子字符串，正如[示例 5-38](#range_substring)所示。
- en: Example 5-38\. Getting a substring with a range
  id: totrans-241
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-38\. 使用范围获取子字符串
- en: '[PRE37]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: You can also use `Range` with `ArraySegment<T>`, a value type that refers to
    a range of elements within an array. [Example 5-39](#subsegment_range_operator)
    makes a slight modification to [Example 5-34](#subarray_range_operator). Instead
    of passing the range to the array’s indexer, this first creates an `Ar⁠ray​Seg⁠men⁠t<i⁠nt>`
    that represents the entire array, and then uses a range to get a second `ArraySegment<int>`
    representing the fourth and fifth elements. The advantage of this is that it does
    not need to allocate a new array—both `ArraySegment<int>` values refer to the
    same underlying array; they just point to different sections of it, and since
    `ArraySegment<int>` is a value type, this can avoid allocating new heap blocks.
    (`ArraySegment<int>` has no direct support for range, by the way. The compiler
    turns this into a call to the segment’s `Slice` method.)
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以在`ArraySegment<T>`中使用`Range`，这是一个值类型，用于引用数组中的一段元素。[示例 5-39](#subsegment_range_operator)对[示例 5-34](#subarray_range_operator)稍作修改。它不是将范围传递给数组的索引器，而是首先创建一个表示整个数组的`Ar⁠ray​Seg⁠men⁠t<i⁠nt>`，然后使用范围获取第四和第五个元素的第二个`ArraySegment<int>`。这样做的好处是不需要分配新的数组——两个`ArraySegment<int>`值引用相同的基础数组；它们只是指向它的不同部分，并且由于`ArraySegment<int>`是值类型，这可以避免分配新的堆块。（顺便说一句，`ArraySegment<int>`没有直接支持范围。编译器会将此转换为调用段的`Slice`方法。）
- en: Example 5-39\. Getting a subrange of an `ArraySegment<T>` with the range operator
  id: totrans-244
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-39\. 使用范围运算符获取`ArraySegment<T>`的子范围
- en: '[PRE38]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The `ArraySegment<T>` type has been around since .NET 2.0 (and has been in
    .NET Standard since 1.0). It’s a useful way to avoid extra allocations, but it’s
    limited: it only works with arrays. What about strings? All current versions of
    .NET support types offering a more general form of this concept, `Span<T>` and
    `ReadOnlySpan<T>`. (On .NET Framework, these are available through to the `System.Memory`
    NuGet package. They are built into other .NET versions.) Just like `ArraySegment<T>`,
    `Span<T>` represents a subsequence of items inside something else, but it is much
    more flexible about what that “something else” might be. It could be an array,
    but it can also be a string, memory in a stack frame, or memory allocated by some
    library or system call entirely outside of .NET. The `Span<T>` and `ReadOnlySpan<T>`
    types are discussed in more detail in [Chapter 18](ch18.xhtml#ch_memory_efficiency),
    but for now, [Example 5-40](#span_range_operator) illustrates their basic use.'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 自 .NET 2.0 起（并在 .NET Standard 1.0 中存在），`ArraySegment<T>` 类型是一种避免额外分配的有用方式，但它有限制：它只适用于数组。那么字符串呢？所有当前版本的
    .NET 都支持提供这个概念更一般化的类型，即 `Span<T>` 和 `ReadOnlySpan<T>`。（在 .NET Framework 中，通过 `System.Memory`
    NuGet 包可用。它们内置于其他 .NET 版本中。）与 `ArraySegment<T>` 类似，`Span<T>` 表示其他某物中的子序列，但关于这个“其他某物”它更加灵活。它可以是一个数组，也可以是字符串，堆栈帧中的内存，或者完全在
    .NET 之外由某个库或系统调用分配的内存。关于 `Span<T>` 和 `ReadOnlySpan<T>` 类型的更详细讨论见[第 18 章](ch18.xhtml#ch_memory_efficiency)，但现在，[示例
    5-40](#span_range_operator) 展示了它们的基本用法。
- en: Example 5-40\. Getting a subrange of a span with the range operator
  id: totrans-247
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-40\. 使用范围运算符获取跨度的子范围
- en: '[PRE39]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: These have much the same logical meaning as the preceding examples, but they
    avoid making copies of the underlying data.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 这些与前面的示例在逻辑上具有相同的含义，但它们避免了复制底层数据。
- en: 'We’ve now seen that we can use ranges with several types: arrays, strings,
    `Arr⁠ay​Seg⁠men⁠t<T>`, `Span<T>`, and `ReadOnlySpan<T>`. This raises a question:
    Does C# have a list of types that get special handling, or can we support indexers
    and ranges in our own types? The answers are, respectively, yes and yes. C# has
    some baked-in handling for arrays and strings: it knows to call specific runtime
    library methods to produce subarrays and substrings. However, there is no special
    range handling for array segments or spans: they work because they conform to
    a pattern. There is also a pattern to enable use of `Index`. If you support these
    same patterns, you can make `Index` and `Range` work with your own types.'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到可以在几种类型上使用范围：数组、字符串、`Arr⁠ay​Seg⁠men⁠t<T>`、`Span<T>` 和 `ReadOnlySpan<T>`。这引发了一个问题：C#
    是否有一个特殊处理的类型列表，或者我们可以在我们自己的类型中支持索引器和范围？答案分别是肯定的。C# 对数组和字符串有一些内建处理：它知道调用特定的运行时库方法以生成子数组和子字符串。然而，对于数组段或跨度没有特殊的范围处理：它们之所以有效是因为它们符合一种模式。支持使用
    `Index` 也有一种模式。如果你支持相同的模式，你可以让 `Index` 和 `Range` 在你自己的类型中工作。
- en: Supporting Index and Range in Your Own Types
  id: totrans-251
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 支持在自定义类型中使用索引和范围
- en: The array type does not define an indexer that accepts an argument of type `Index`.
    Nor do any of the generic array-like types shown earlier in this chapter—they
    all just have ordinary `int`-based indexers; however, you can use `Index` with
    them nonetheless. And as I explained earlier, code of the form `col[index]` will
    expand to `col[index.GetOffset(a.Length)]`.^([4](ch05.xhtml#idm45884820788208))
    So all you need is an `int`-based indexer and a property of type `int` called
    either `Length` or `Count`. [Example 5-41](#minimal_enable_index) shows about
    the least amount of work you can possibly do to enable code to pass an `Index`
    to your type’s indexer. It’s not a very useful implementation, but it’s enough
    to keep C# happy.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 数组类型并没有定义接受 `Index` 类型参数的索引器。在本章早些时候展示的任何泛型数组样式类型也没有 —— 它们都只有普通的基于 `int` 的索引器；然而，你仍然可以与它们一起使用
    `Index`。正如我之前解释的那样，形如 `col[index]` 的代码将展开为 `col[index.GetOffset(a.Length)]`。^([4](ch05.xhtml#idm45884820788208))
    因此，你只需要一个基于 `int` 的索引器和一个名为 `Length` 或 `Count` 的 `int` 类型属性。[示例 5-41](#minimal_enable_index)
    展示了使你的类型的索引器能接受 `Index` 参数的最小化实现。它不是一个非常有用的实现，但足以让 C# 快乐。
- en: Example 5-41\. Minimally enabling `Index`
  id: totrans-253
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-41\. 最小化启用 `Index`
- en: '[PRE40]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Tip
  id: totrans-255
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: Tip
- en: 'There’s an even simpler way: just define an indexer that takes an argument
    of type `Index`. However, most indexable types supply an `int`-based indexer,
    so in practice you’d be overloading your indexer, offering both forms. That is
    not simpler, but it would enable your code to distinguish between start- and end-relative
    indexes. If we use either `1` or `^9` with [Example 5-41](#minimal_enable_index),
    its indexer sees 1 in either case, because C# generates code that converts the
    `Index` to a start-based `int`, but if you write an indexer with an `Index` parameter,
    C# will pass the `Index` straight in. If you overload the indexer so that both
    `int` and `Index` forms are available, it will never generate code that converts
    an `Index` to an `int` in order to call the `int` indexer: the pattern only kicks
    in if no `Index`-specific indexer is available.'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个更简单的方法：只需定义一个接受`Index`类型参数的索引器即可。但是，大多数可索引类型都提供了基于`int`的索引器，因此在实践中，你会重载你的索引器，提供这两种形式。这并不简单，但它可以使你的代码区分起始和结束相对索引。如果我们在[示例 5-41](#minimal_enable_index)中使用`1`或`^9`，无论哪种情况，其索引器都会看到1，因为C#会生成将`Index`转换为基于起始的`int`的代码，但如果你编写一个接受`Index`参数的索引器，C#会直接传递`Index`。如果你重载索引器以使`int`和`Index`形式都可用，它将永远不会生成将`Index`转换为`int`的代码以调用`int`索引器：只有在没有`Index`特定索引器可用时才会出现这种模式。
- en: '`IList<T>` meets the pattern’s requirements (as do types that implement it,
    such as `List<T>`), so you can pass an `Index` to the indexer of anything that
    implements this. (It supplies a `Count` property instead of `Length`, but the
    pattern accepts either.) This is a widely implemented interface, so in practice,
    many types automatically get support for `Index` despite having been written before
    `Index` was introduced. This is an example of how the pattern-based support for
    `Index` means libraries that target older .NET versions (such as .NET Standard
    2.0) where `Index` is not available can nonetheless define types that will work
    with `Index` when used with newer versions of .NET.'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '`IList<T>`符合模式的要求（例如实现它的`List<T>`类型），因此你可以将`Index`传递给任何实现此接口的内容的索引器。它提供`Count`属性而不是`Length`，但是模式接受任何一种。这是一个广泛实现的接口，因此在实践中，许多类型在`Index`引入之前就自动获得了对`Index`的支持。这是一个模式化支持`Index`的例子，即使是面向较旧.NET版本（如.NET
    Standard 2.0）的库也可以定义在新版本.NET中使用`Index`的类型。'
- en: 'The pattern for supporting `Range` is different: if your type supplies an instance
    method called `Slice` that takes two integer arguments, C# will allow code to
    supply a `Range` as an indexer argument. [Example 5-42](#minimal_enable_range)
    shows the least a type can do to enable this, although it’s not a very useful
    implementation. (As with `Index`, you can alternatively just define an indexer
    overload that accepts a `Range` directly. But again, an advantage to the pattern
    approach is that you can use it when targeting older versions—such as .NET Standard
    2.0 that does not offer the `Range` or `Index` types—while still supporting ranges
    for code that targets newer versions.)'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 支持`Range`的模式不同：如果你的类型提供了一个接受两个整数参数的实例方法`Slice`，C#允许代码将`Range`作为索引器参数。[示例 5-42](#minimal_enable_range)展示了使类型最少支持`Range`的方式，尽管这不是一个非常有用的实现。（与`Index`类似，你也可以直接定义一个接受`Range`的索引器重载。但是，模式方法的优势在于你可以在针对较旧版本（如不支持`Range`或`Index`类型的.NET
    Standard 2.0）时使用它，同时仍支持针对新版本的代码的范围。）
- en: Example 5-42\. Minimally enabling `Range`
  id: totrans-259
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-42\. 最小化启用`Range`
- en: '[PRE41]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: You might have noticed that this type doesn’t define an indexer. That’s because
    this pattern-based support for expressions of the form `x[1..^1]` doesn’t need
    one. It may look like we’re using an indexer, but this just calls the `Slice`
    method. (Likewise, the earlier range examples with `string` and arrays compile
    into method calls.) You need the `Length` property (or `Count`) because the compiler
    generates code that relies on this to resolve the range’s indexes. [Example 5-43](#effect_of_range_index)
    shows roughly how the compiler uses types that support this pattern.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，这种类型并没有定义索引器。这是因为基于模式的支持形式`x[1..^1]`不需要索引器。它看起来像是在使用索引器，但实际上只是调用了`Slice`方法。（同样，先前的使用`string`和数组的范围示例会编译成方法调用。）你需要`Length`属性（或`Count`），因为编译器生成的代码依赖于此来解析范围的索引。[示例 5-43](#effect_of_range_index)大致展示了编译器如何使用支持此模式的类型。
- en: Example 5-43\. How range indexing expands
  id: totrans-262
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-43\. 范围索引的扩展方式
- en: '[PRE42]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'So far, all of the collections we’ve looked at have been linear: I’ve shown
    only simple sequences of objects or values, some of which offer indexed access.
    However, .NET provides other kinds of collections.'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们看到的所有集合都是线性的：我只展示了一些对象或值的简单序列，其中一些提供了索引访问。但是，.NET提供了其他类型的集合。
- en: Dictionaries
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字典
- en: One of the most useful kinds of collections is a dictionary. .NET offers the
    `Dictionary<TKey, TValue>` class, and there’s a corresponding interface called,
    predictably, `IDictionary<TKey, TValue>`, and also a read-only version, `IReadOnlyDictionary<TKey,
    TValue>`. These represent collections of key/value pairs, and their most important
    capability is to look up a value based on its key, making dictionaries useful
    for representing associations.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 最有用的一种集合之一是字典。.NET提供了`Dictionary<TKey, TValue>`类，还有一个相应的接口称为`IDictionary<TKey,
    TValue>`，以及一个只读版本`IReadOnlyDictionary<TKey, TValue>`。这些表示键/值对的集合，它们最重要的功能是根据键查找值，使字典在表示关联时非常有用。
- en: Suppose you are writing a UI for an application that supports online discussions.
    When displaying a message, you might want to show certain things about the user
    who sent it, such as their name and picture, and you’d probably want to avoid
    fetching these details from a persistent store every time; if the user is in conversation
    with a few friends, the same people will crop up repeatedly, so you’d want some
    sort of cache to avoid duplicate lookups. You might use a dictionary as part of
    this cache. [Example 5-44](#using_a_dictionary_as_part_of_a_cache) shows an outline
    of this approach. (It omits application-specific details of how the data is actually
    fetched and when old data is removed from memory.)
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您正在为支持在线讨论的应用程序编写用户界面。在显示消息时，您可能希望显示发送消息的用户的某些信息，例如他们的姓名和图片，并且您可能希望避免每次从持久存储获取这些详细信息；如果用户正在与几个朋友进行对话，那么同样的人将会重复出现，因此您需要某种缓存来避免重复查找。您可以在此缓存的一部分中使用字典。[示例 5-44](#using_a_dictionary_as_part_of_a_cache)展示了这种方法的概要（省略了实际获取数据的应用程序特定细节以及何时从内存中删除旧数据）。
- en: Example 5-44\. Using a dictionary as part of a cache
  id: totrans-268
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-44\. 将字典用作缓存的一部分
- en: '[PRE43]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The first type argument, `TKey`, is used for lookups, and in this example, I’m
    using a string that identifies the user in some way. The `TValue` argument is
    the type of value associated with the key—information previously fetched for the
    user and cached locally in a `UserInfo` instance, in this case. The `GetInfo`
    method uses `TryGetValue` to look in the dictionary for the data associated with
    a user handle. There is a simpler way to retrieve a value. As [Example 5-45](#dictionary_lookup_with_indexer)
    shows, dictionaries provide an indexer. However, that throws a `KeyNotFoundException`
    if there is no entry with the specified key. That would be fine if your code always
    expects to find what it’s looking for, but in our case, the key will be missing
    for any user whose data is not already in the cache. This will probably happen
    rather a lot, which is why I’m using `TryGetValue`. As an alternative, we could
    have used the `ContainsKey` method to see if the entry exists before retrieving
    it, but that’s inefficient if the value is present—the dictionary would end up
    looking up the entry twice, once in the call to `ContainsKey` and then again when
    we use the indexer. `TryGetValue` performs the test and the lookup as a single
    operation.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个类型参数，`TKey`，用于查找，本例中我使用的是某种方式标识用户的字符串。`TValue`参数是与键相关联的值的类型，在这种情况下是先前为用户获取并在`UserInfo`实例中本地缓存的信息。`GetInfo`方法使用`TryGetValue`在字典中查找与用户句柄关联的数据。还有一种更简单的方法来检索值。正如[示例 5-45](#dictionary_lookup_with_indexer)所示，字典提供了一个索引器。但是，如果指定的键没有条目，它会抛出`KeyNotFoundException`。如果您的代码始终期望找到它正在查找的内容，那么这没问题，但在我们的情况下，对于任何数据不在缓存中的用户，键将丢失。这可能会经常发生，这就是为什么我使用`TryGetValue`。作为替代方案，我们可以使用`ContainsKey`方法来查看条目是否存在，但如果值存在，则效率低下——字典将在调用`ContainsKey`时两次查找条目，然后在使用索引器时再次查找。`TryGetValue`将测试和查找作为单个操作执行。
- en: Example 5-45\. Dictionary lookup with indexer
  id: totrans-271
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-45\. 使用索引器进行字典查找
- en: '[PRE44]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'As you might expect, we can also use the indexer to set the value associated
    with a key. I’ve not done that in [Example 5-44](#using_a_dictionary_as_part_of_a_cache).
    Instead, I’ve used the `Add` method, because it has subtly different semantics:
    by calling `Add`, you are indicating that you do not think any entry with the
    specified key already exists. Whereas the dictionary’s indexer will silently overwrite
    an existing entry if there is one, `Add` will throw an exception if you attempt
    to use a key for which an entry already exists. In situations where the presence
    of an existing key would imply that something is wrong, it’s better to call `Add`
    so that the problem doesn’t go undetected.'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所预期的那样，我们也可以使用索引器来设置与键相关联的值。在[示例5-44](#using_a_dictionary_as_part_of_a_cache)中，我并没有这样做。相反，我使用了`Add`方法，因为它具有微妙的不同语义：通过调用`Add`，你表明你认为不存在具有指定键的任何条目。而字典的索引器如果存在相同键的条目则会悄无声息地覆盖它，如果你尝试使用已存在的键，`Add`会抛出异常。在存在已有键可能意味着有问题的情况下，最好调用`Add`，这样问题就不会被忽视。
- en: The `IDictionary<TKey, TValue>` interface requires its implementations also
    to provide the `ICollection<KeyValuePair<TKey, TValue>>` interface, and therefore
    also `IEnumerable<KeyValuePair<TKey, TValue>>`. The read-only counterpart requires
    the latter but not the former. These interfaces depend on a generic struct, `KeyValuePair<TKey,
    TValue>`, which is a simple container that wraps a key and a value in a single
    instance. This means you can iterate through a dictionary using `foreach`, and
    it will return each key/value pair in turn.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '`IDictionary<TKey, TValue>`接口要求其实现也提供`ICollection<KeyValuePair<TKey, TValue>>`接口，因此也提供`IEnumerable<KeyValuePair<TKey,
    TValue>>`。只读对应接口要求后者但不要求前者。这些接口依赖于泛型结构`KeyValuePair<TKey, TValue>`，它是一个简单的容器，将键和值包装在单个实例中。这意味着你可以使用`foreach`遍历字典，并依次返回每个键值对。'
- en: 'The presence of an `IEnumerable<T>` and an `Add` method also means that we
    can use the collection initializer syntax. It’s not quite the same as with a simple
    list, because a dictionary’s `Add` takes two arguments: the key and value. However,
    the collection initializer syntax can cope with multiargument `Add` methods. You
    wrap each set of arguments in nested braces, as [Example 5-46](#collection_initializer_dictionary)
    shows.'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 存在`IEnumerable<T>`和`Add`方法意味着我们可以使用集合初始化器语法。这与简单列表不完全相同，因为字典的`Add`方法接受两个参数：键和值。但集合初始化器语法可以处理多参数的`Add`方法。你需要将每组参数包裹在嵌套的大括号中，就像[示例5-46](#collection_initializer_dictionary)所示。
- en: Example 5-46\. Collection initializer syntax with a dictionary
  id: totrans-276
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例5-46. 使用字典的集合初始化器语法
- en: '[PRE45]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'As you saw in [Chapter 3](ch03.xhtml#ch_types), there’s an alternative way
    to populate a dictionary: instead of using a collection initializer, you can use
    the object initializer syntax. As you may recall, this syntax lets you set properties
    on a newly created object. It is the only way to initialize the properties of
    an anonymous type, but you can use it on any type. Indexers are just a special
    kind of property, so it makes sense to be able to set them with an object initializer.
    Although [Chapter 3](ch03.xhtml#ch_types) showed this already, it’s worth comparing
    object initializers with collection initializers, so [Example 5-47](#object_initializer_dictionary)
    shows the alternative way to initialize a dictionary.'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 如你在[第三章](ch03.xhtml#ch_types)中所看到的，有一种替代方式来填充字典：不使用集合初始化器，而是使用对象初始化器语法。你可能还记得，这种语法允许你在新创建的对象上设置属性。这是初始化匿名类型属性的唯一方法，但你可以在任何类型上使用它。索引器只是一种特殊的属性，因此能够使用对象初始化器设置它们是有道理的。尽管[第三章](ch03.xhtml#ch_types)已经展示了这一点，但将对象初始化器与集合初始化器进行比较仍是值得的，因此[示例5-47](#object_initializer_dictionary)展示了初始化字典的替代方式。
- en: Example 5-47\. Object initializer syntax with a dictionary
  id: totrans-279
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例5-47. 使用字典的对象初始化器语法
- en: '[PRE46]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Although the effect is the same here with Examples [5-46](#collection_initializer_dictionary)
    and [5-47](#object_initializer_dictionary), the compiler generates slightly different
    code for each. With [Example 5-46](#collection_initializer_dictionary), it populates
    the collection by calling `Add`, whereas [Example 5-47](#object_initializer_dictionary)
    uses the indexer. For `Dictionary<TKey, TValue>`, the result is the same, so there’s
    no objective reason to choose one over the other, but the difference could matter
    for some classes. For example, if you are using a class that has an indexer but
    no `Add` method, only the index-based code would work. Also, with the object initializer
    syntax, it would be possible to set both indexed values and properties on types
    that support this (although you can’t do that with `Dictionary<TKey, TValue>`
    because it has no writable properties other than its indexer).
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管此处效果与示例 [5-46](#collection_initializer_dictionary) 和 [5-47](#object_initializer_dictionary)
    相同，但编译器对每种情况生成的代码略有不同。对于 [示例 5-46](#collection_initializer_dictionary)，它通过调用 `Add`
    来填充集合，而 [示例 5-47](#object_initializer_dictionary) 使用索引器。对于 `Dictionary<TKey, TValue>`，结果是相同的，因此没有客观理由选择其中之一，但对于某些类来说，这种差异可能很重要。例如，如果你正在使用一个具有索引器但没有
    `Add` 方法的类，那么只有基于索引的代码才能工作。另外，使用对象初始化语法，可以在支持此操作的类型上设置索引值和属性（尽管你不能在 `Dictionary<TKey,
    TValue>` 上这样做，因为它除了索引器之外没有可写的属性）。
- en: The `Dictionary<TKey, TValue>` collection class relies on hashes to offer fast
    lookup. [Chapter 3](ch03.xhtml#ch_types) described the `GetHashCode` method, and
    you should ensure that whatever type you are using as a key provides a good hash
    implementation. The `string` class works well. For other types, the default `GetHashCode`
    method is viable only if different instances of a type are always considered to
    have different values, but types for which that is true function well as keys.
    Alternatively, the dictionary class provides constructors that accept an `IEqualityComparer<TKey>`,
    which allows you to provide an implementation of `GetHashCode` and `Equals` to
    use instead of the one supplied by the key type itself. [Example 5-48](#case-insensitive_dictionary)
    uses this to make a case-insensitive version of [Example 5-46](#collection_initializer_dictionary).
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '`Dictionary<TKey, TValue>` 集合类依赖哈希来提供快速查找。[第 3 章](ch03.xhtml#ch_types) 描述了
    `GetHashCode` 方法，你应确保作为键使用的任何类型都提供了良好的哈希实现。`string` 类的工作效果良好。对于其他类型，只有当类型的不同实例始终被视为具有不同值时，默认的
    `GetHashCode` 方法才可行，但对于这种情况，对键类型本身提供的 `GetHashCode` 和 `Equals` 实现而言，字典类提供了接受 `IEqualityComparer<TKey>`
    的构造函数。[示例 5-48](#case-insensitive_dictionary) 使用此功能制作了 [示例 5-46](#collection_initializer_dictionary)
    的不区分大小写版本。'
- en: Example 5-48\. A case-insensitive dictionary
  id: totrans-283
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-48\. 不区分大小写的字典
- en: '[PRE47]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: This uses the `StringComparer` class, which provides various implementations
    of `IComparer<string>` and `IEqualityComparer<string>`, offering different comparison
    rules. Here, I’ve chosen an ordering that ignores case and also ignores the configured
    locale, ensuring consistent behavior in different regions. If I were using strings
    to be displayed, I’d probably use one of its culture-aware comparisons.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 这里使用了 `StringComparer` 类，它提供了 `IComparer<string>` 和 `IEqualityComparer<string>`
    的各种实现，提供不同的比较规则。在这里，我选择了一个忽略大小写并且忽略配置的区域设置的排序，以确保在不同区域中表现一致。如果我要使用字符串进行显示，我可能会使用其中一种支持文化感知的比较方式。
- en: Sorted Dictionaries
  id: totrans-286
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 排序字典
- en: Because `Dictionary<TKey, TValue>` uses hash-based lookup, the order in which
    it returns elements when you iterate over its contents is hard to predict and
    not very useful. It will generally bear no relation to the order in which the
    contents were added and no obvious relationship to the contents themselves. (The
    order typically looks random, although it’s actually related to the hash code.)
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 `Dictionary<TKey, TValue>` 使用基于哈希的查找，当你遍历其内容时返回元素的顺序很难预测并且没有什么用处。它通常与添加内容的顺序无关，并且与内容本身也没有明显的关系。（顺序通常看起来是随机的，尽管实际上与哈希码有关。）
- en: Sometimes, it’s useful to be able to retrieve the contents of a dictionary in
    some meaningful order. You could always get the contents into an array and then
    sort them, but the `System.Collections.Generic` namespace contains two more implementations
    of the `IDictionary<TKey, TValue>` interface, which keep their contents permanently
    in order. There’s `SortedDictionary<TKey, TValue>` and the more confusingly titled
    `SortedList<TKey, TValue>`, which—despite the name—implements the `IDictionary<TKey`,
    `TValue>` interface and does not directly implement `IList<T>`.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，能够以某种有意义的顺序检索字典的内容是很有用的。您可以将内容放入数组中然后进行排序，但是`System.Collections.Generic`命名空间包含两个更实用的`IDictionary<TKey,
    TValue>`接口实现，它们会保持其内容永久有序。这就是`SortedDictionary<TKey, TValue>`和更令人困惑的`SortedList<TKey,
    TValue>`，尽管名字相似，但实现了`IDictionary<TKey, TValue>`接口并且并没有直接实现`IList<T>`。
- en: These classes do not use hash codes. They still provide reasonably fast lookup,
    but they do it by keeping their contents sorted. They maintain the order every
    time you add a new entry, which makes addition rather slower for both these classes
    than with the hash-based dictionary, but it means that when you iterate over the
    contents, they come out in order. As with array and list sorting, you can specify
    custom comparison logic, but if you don’t supply that, these dictionaries require
    the key type to implement `IComparable<T>`.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类不使用哈希码。它们仍然提供相对快速的查找，但是通过保持其内容排序来实现。每次添加新条目时，它们都会保持顺序，这使得这两个类的添加速度比基于哈希的字典慢，但这意味着当您遍历内容时，它们会按顺序输出。与数组和列表排序一样，您可以指定自定义比较逻辑，但如果您不提供它，这些字典要求键类型实现`IComparable<T>`接口。
- en: The ordering maintained by a `SortedDictionary<TKey, TValue>` is apparent only
    when you use its enumeration support (e.g., with `foreach`). `SortedList<TKey,
    TValue>` also enumerates its contents in order, but it additionally provides numerically
    indexed access to the keys and values. This does not work through the object’s
    indexer—that expects to be passed a key just like any dictionary. Instead, the
    sorted list dictionary defines two properties, `Keys` and `Values`, which provide
    all the keys and values as `IList<TKey>` and `IList<TValue>`, respectively, sorted
    so that the keys will be in ascending order. (The `Values` are in key order as
    well as the `Keys`.)
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '`SortedDictionary<TKey, TValue>`维护的顺序只有在使用其枚举支持（例如，通过`foreach`）时才显现出来。`SortedList<TKey,
    TValue>`也按顺序枚举其内容，但它还额外提供了对键和值的数值索引访问。这不是通过对象的索引器来完成的——它期望像任何字典一样传递一个键。相反，排序列表字典定义了两个属性，`Keys`和`Values`，分别提供所有键和值作为`IList<TKey>`和`IList<TValue>`，并按升序排序键。（`Values`也按键的顺序排序，就像`Keys`一样。）'
- en: Inserting and removing objects is relatively expensive for the sorted list because
    it has to shuffle the key and value list contents up or down. (This means a single
    insertion has *O(n)* complexity.) The sorted dictionary, on the other hand, uses
    a tree data structure to keep its contents sorted. The exact details are not specified,
    but insertion and removal performance are documented as having *O(log n)* complexity,
    which is much better than for the sorted list.^([5](ch05.xhtml#fn25)) However,
    this more complex data structure gives a sorted dictionary a significantly larger
    memory footprint. This means that neither is definitively faster or better than
    the other—it all depends on the usage pattern, which is why the runtime libraries
    supply both.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 对排序列表进行插入和删除对象操作相对较昂贵，因为它必须上移或下移键和值列表的内容。（这意味着单个插入具有*O(n)*的复杂度。）另一方面，排序字典使用树数据结构来保持其内容排序。具体细节未指定，但插入和删除性能被记录为具有*O(log
    n)*的复杂度，这比排序列表好得多。^([5](ch05.xhtml#fn25)) 然而，这种更复杂的数据结构使得排序字典的内存占用显著增加。这意味着两者都没有绝对更快或更好的选择——这完全取决于使用模式，这也是为什么运行时库同时提供了这两种。
- en: In most cases, the hash-based `Dictionary<TKey, Value>` will provide better
    insertion, removal, and lookup performance than either of the sorted dictionaries,
    and much lower memory consumption than a `SortedDictionary<TKey, TValue>`, so
    you should use these sorted dictionary collections only if you need to access
    the dictionary’s contents in order.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，基于哈希的`Dictionary<TKey, Value>`比排序字典在插入、删除和查找性能上都更好，并且比`SortedDictionary<TKey,
    TValue>`具有更低的内存消耗，因此只有在需要按顺序访问字典内容时才应使用这些排序字典集合。
- en: Sets
  id: totrans-293
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集合
- en: 'The `System.Collections.Generic` namespace defines an `ISet<T>` interface.
    This offers a simple model: a particular value is either a member of the set or
    not. You can add or remove items, but a set does not keep track of how many times
    you’ve added an item, nor does `ISet<T>` require items to be stored in any particular
    order.'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 命名空间`System.Collections.Generic`定义了`ISet<T>`接口。这提供了一个简单的模型：特定值要么是集合的成员，要么不是。您可以添加或删除项目，但集合不会跟踪您添加项目的次数，而且`ISet<T>`不要求项目以任何特定顺序存储。
- en: 'All set types implement `ICollection<T>`, which provides the methods for adding
    and removing items. In fact, it also defines the method for determining membership:
    although I’ve not drawn attention to it before now, you can see in [Example 5-25](#icollection_of_t)
    that `ICollection<T>` defines a `Contains` method. This takes a single value and
    returns `true` if that value is in the collection.'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 所有集合类型都实现了`ICollection<T>`，它提供了添加和删除项目的方法。事实上，它还定义了用于确定成员资格的方法：虽然我现在还没有引起注意，但您可以在[示例 5-25](#icollection_of_t)中看到，`ICollection<T>`定义了一个`Contains`方法。这个方法接受一个值，并在集合中返回`true`，如果该值在集合中。
- en: Given that `ICollection<T>` already provides the defining operations for a set,
    you might wonder why we need `ISet<T>`. But it does add a few things. Although
    `ICollection<T>` defines an `Add` method, `ISet<T>` defines its own subtly different
    version, which returns a `bool`, so you can find out whether the item you just
    added was already in the set. [Example 5-49](#iset_add) uses this to detect duplicates
    in a method that displays each string in its input once. (This illustrates the
    usage, but in practice it would be simpler to use the `Distinct` LINQ operator
    described in [Chapter 10](ch10.xhtml#ch_linq).)
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于`ICollection<T>`已经为集合提供了定义操作，您可能会想知道为什么我们还需要`ISet<T>`。但它确实增加了一些东西。虽然`ICollection<T>`定义了一个`Add`方法，但`ISet<T>`定义了自己略有不同的版本，它返回一个`bool`，因此您可以找出刚刚添加的项是否已经在集合中。[示例 5-49](#iset_add)使用这个功能在显示其输入中的每个字符串时检测重复项。（这展示了使用方法，但实际上使用在[第10章](ch10.xhtml#ch_linq)描述的`Distinct`
    LINQ运算符会更简单。）
- en: Example 5-49\. Using a set to determine what’s new
  id: totrans-297
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-49\. 使用集合来确定新内容
- en: '[PRE48]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '`ISet<T>` also defines some operations for combining sets. The `UnionWith`
    method takes an `IEnumerable<T>` and adds to the set all the values from that
    sequence that were not already in the set. The `ExceptWith` method removes from
    the set items that are also in the sequence you pass. The `IntersectWith` method
    removes from the set items that are not also in the sequence you pass. And `SymmetricExceptWith`
    also takes a sequence and removes from the set elements that are in the sequence,
    but also adds to the set values in the sequence that were not previously in the
    set.'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '`ISet<T>`还定义了一些用于合并集合的操作。`UnionWith`方法接受一个`IEnumerable<T>`，并将该序列中之前不在集合中的所有值添加到集合中。`ExceptWith`方法从集合中删除也在您传递的序列中的项目。`IntersectWith`方法从集合中删除不在您传递的序列中的项目。而`SymmetricExceptWith`还接受一个序列，并从集合中删除序列中的元素，但还将序列中以前不在集合中的值添加到集合中。'
- en: There are also some methods for comparing sets. Again, these all take an `IEnumerable<T>`
    argument representing the other set with which the comparison is to be performed.
    `IsSubsetOf` and `IsProperSubsetOf` both let you check whether the set on which
    you invoke the method contains only elements that are also present in the sequence,
    with the latter method additionally requiring the sequence to contain at least
    one item not present in the set. `IsSupersetOf` and `IsProperSupersetOf` perform
    the same tests in the opposite direction. The `Overlaps` method tells you whether
    the two sets share at least one element in common.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些用于比较集合的方法。同样，这些方法都接受一个`IEnumerable<T>`参数，表示要执行比较的另一个集合。`IsSubsetOf`和`IsProperSubsetOf`允许您检查调用方法的集合是否仅包含也存在于序列中的元素，后者方法还要求序列至少包含一个不在集合中的项。`IsSupersetOf`和`IsProperSupersetOf`在相反的方向执行相同的测试。`Overlaps`方法告诉您这两个集合是否至少共享一个公共元素。
- en: Mathematical sets do not define an order for their contents, so it’s not meaningful
    to refer to the 1st, 10th, or *n*th element of a set—you can ask only whether
    an element is in the set or not. In keeping with this feature of mathematical
    sets, .NET sets do not support indexed access, so `ISet<T>` does not demand support
    for `IList<T>`. Sets are free to produce the members in whatever order they like
    in their `IEnumerable<T>` implementation.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 数学集合不为其内容定义顺序，因此引用集合的第1个、第10个或第 *n* 个元素是没有意义的——你只能询问元素是否在集合中。为了符合数学集合的这一特性，.NET
    集合不支持索引访问，因此 `ISet<T>` 不要求支持 `IList<T>`。集合可以按照它们喜欢的任何顺序生成其成员在其 `IEnumerable<T>`
    实现中。
- en: 'The runtime libraries offer two classes that provide this interface, with different
    implementation strategies: `HashSet` and `SortedSet`. As you may have guessed
    from the names, one of the two built-in set implementations does in fact choose
    to keep its elements in order; `SortedSet` keeps its contents sorted at all times
    and presents items in this order through its `IEnumerable<T>` implementation.
    The documentation does not describe the exact strategy used to maintain the order,
    but it appears to use a balanced binary tree to support efficient insertion and
    removal, and to offer fast lookup when trying to determine whether a particular
    value is already in the list.'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 运行时库提供了两个类来提供这个接口，采用不同的实现策略：`HashSet` 和 `SortedSet`。从名称可以猜到，这两个内置的集合实现中的一个确实选择保持其元素的顺序；`SortedSet`
    始终保持其内容排序，并通过其 `IEnumerable<T>` 实现以此顺序呈现项目。文档没有描述用于维护顺序的确切策略，但似乎使用了平衡二叉树来支持高效的插入和删除，并在尝试确定特定值是否已在列表中时提供快速查找。
- en: The other implementation, `HashSet`, works more like `Dictionary<TKey, TValue>`.
    It uses hash-based lookup, which can often be faster than the ordered approach,
    but if you enumerate through the collection with `foreach`, the results will not
    be in any useful order. (So the relationship between `HashSet` and `SortedSet`
    is much like that between the hash-based dictionary and the sorted dictionaries.)
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种实现方式，`HashSet`，更像是 `Dictionary<TKey, TValue>`。它使用基于哈希的查找，这通常比有序方法更快，但如果你用
    `foreach` 枚举集合，结果将不会按任何有用的顺序排列。（因此，`HashSet` 和 `SortedSet` 之间的关系与基于哈希的字典与有序字典之间的关系非常类似。）
- en: Queues and Stacks
  id: totrans-304
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 队列和栈
- en: A *queue* is a list where you can only add items to the end of the list, and
    you can only remove the first item (at which point the second item, if there was
    one, becomes the new first item). This style of list is often called a first-in,
    first-out (FIFO) list. This makes it less useful than a `List<T>`, because you
    can read, write, insert, or remove items at any point in a `List<T>`. However,
    the constraints make it possible to implement a queue with considerably better
    performance characteristics for insertion and removal. When you remove an item
    from a `List<T>`, it has to shuffle all the items after the one removed to close
    up the gap, and insertions require a similar shuffle. Insertion and removal at
    the end of a `List<T>` is efficient, but if you need FIFO semantics, you can’t
    work entirely at the end—you’ll need to do either insertions or removals at the
    start, making `List<T>` a bad choice. `Queue<T>` can use a much more efficient
    strategy because it needs only to support queue semantics. (It uses a circular
    buffer internally, although that’s an undocumented implementation detail.)
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '*队列* 是一个只能在列表末尾添加项目，并且只能移除第一个项目（此时，如果有第二个项目，则成为新的第一个项目）的列表。这种列表风格通常称为先进先出（FIFO）列表。这使得它比
    `List<T>` 更不方便，因为你可以在 `List<T>` 中的任何位置读取、写入、插入或删除项目。然而，这些限制使得可以实现具有更好插入和删除性能特征的队列。从
    `List<T>` 中移除项目时，必须将被移除项目后的所有项目移动到前面来填补空隙，插入需要类似的移动。在 `List<T>` 的末尾进行插入和删除是高效的，但如果需要
    FIFO 语义，不能完全在末尾工作，而是需要在开始时进行插入或移除操作，使得 `List<T>` 不是一个好的选择。`Queue<T>` 可以使用更高效的策略，因为它只需要支持队列语义。（它在内部使用一个循环缓冲区，尽管这是一个未记录的实现细节。）'
- en: To add a new item to the end of a queue, call the `Enqueue` method. To remove
    the item at the head of the queue, call `Dequeue`, or use `Peek` if you want to
    look at the item without removing it. Both operations will throw an `InvalidOperationException`
    if the queue is empty. You can find out how many items are in the queue with the
    `Count` property.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 要向队列末尾添加新项，请调用 `Enqueue` 方法。要移除队列头部的项，请调用 `Dequeue` 方法，或者使用 `Peek` 方法查看项而不移除它。如果队列为空，这两种操作都会抛出
    `InvalidOperationException` 异常。你可以通过 `Count` 属性查看队列中的项数。
- en: Although you cannot insert, remove, or change items in the middle of the list,
    you can inspect the whole queue, because `Queue<T>` implements `IEnumerable<T>`
    and also provides a `ToArray` method that returns an array containing a copy of
    the current queue contents.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你无法在列表中间插入、移除或更改项，但可以检查整个队列，因为 `Queue<T>` 实现了 `IEnumerable<T>`，并且提供了 `ToArray`
    方法，返回包含当前队列内容副本的数组。
- en: 'A *stack* is similar to a queue, except you retrieve items from the same end
    as you insert them—so this is a last-in, first-out (LIFO) list. `Stack<T>` looks
    very similar to `Queue<T>` except instead of `Enqueue` and `Dequeue`, the methods
    for adding and removing items use the traditional names for stack operations:
    `Push` and `Pop`. (Other methods—such as `Peek`, `ToArray`, and so on—remain the
    same.)'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '*栈* 类似于队列，但你从插入的同一端检索项，所以这是一个后进先出（LIFO）列表。`Stack<T>` 看起来与 `Queue<T>` 非常相似，但是添加和移除项的方法使用了传统的栈操作名称：`Push`
    和 `Pop`（其他方法如 `Peek`、`ToArray` 等保持不变）。'
- en: The runtime libraries do not offer a double-ended queue. However, linked lists
    can offer a superset of that functionality.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 运行时库不提供双端队列。然而，链表可以提供该功能的超集。
- en: Linked Lists
  id: totrans-310
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 链表
- en: The `LinkedList<T>` class provides an implementation of the classic doubly linked
    list data structure, in which each item in the sequence is wrapped in an object
    (of type `LinkedListNode<T>`) that provides a reference to its predecessor and
    its successor. The advantage of a linked list is that insertion and removal is
    inexpensive—it does not require elements to be moved around in arrays and does
    not require binary trees to be rebalanced. It just requires a few references to
    be swapped around. The downsides are that linked lists have fairly high memory
    overheads, requiring an extra object on the heap for every item in the collection,
    and it’s also relatively expensive for the CPU to get to the *n*th item because
    you have to go to the start and then traverse *n* nodes.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '`LinkedList<T>` 类提供了经典的双向链表数据结构的实现，在此结构中，序列中的每个项都被包装在一个对象中（类型为 `LinkedListNode<T>`），该对象提供对其前驱和后继的引用。链表的优势在于插入和删除操作成本低廉，不需要在数组中移动元素，也不需要重新平衡二叉树。它只需要交换几个引用。缺点是链表在内存开销上相对较高，每个集合中的项都需要额外的堆对象，并且获取第
    *n* 个项对 CPU 来说比较昂贵，因为你必须从开头开始遍历 *n* 个节点。'
- en: The first and last nodes in a `LinkedList<T>` are available through the predictably
    named `First` and `Last` properties. You can insert items at the start or end
    of the list with `AddFirst` and `AddLast`, respectively. To add items in the middle
    of a list, call either `AddBefore` or `AddAfter`, passing in the `LinkedListNode<T>`
    before or after which you’d like to add the new item.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '`LinkedList<T>` 中的第一个和最后一个节点可以通过可预见的 `First` 和 `Last` 属性访问。你可以使用 `AddFirst`
    和 `AddLast` 在列表的开头或结尾插入项。要在列表中间添加项，请调用 `AddBefore` 或 `AddAfter` 方法，传入要在其前面或后面添加新项的
    `LinkedListNode<T>`。'
- en: The list also provides `RemoveFirst` and `RemoveLast` methods and two overloads
    of a `Remove` method that allow you to remove either the first node that has a
    specified value or a particular `LinkedListNode<T>`.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 该列表还提供了 `RemoveFirst` 和 `RemoveLast` 方法，以及两个重载的 `Remove` 方法，允许你移除具有特定值的第一个节点或特定的
    `LinkedListNode<T>`。
- en: The `LinkedListNode<T>` itself provides a `Value` property of type `T` containing
    the actual item for this node’s point in the sequence. Its `List` property refers
    back to the containing `LinkedList<T>`, and the `Previous` and `Next` properties
    allow you to find the previous or next node.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '`LinkedListNode<T>` 本身提供了一个 `Value` 属性，类型为 `T`，包含序列中该节点点的实际项。其 `List` 属性引用回包含它的
    `LinkedList<T>`，`Previous` 和 `Next` 属性允许你找到前一个或后一个节点。'
- en: To iterate through the contents of a linked list, you could, of course, retrieve
    the first node from the `First` property and then follow each node’s `Next` property
    until you get a `null`. However, `LinkedList<T>` implements `IEnumerable<T>`,
    so it’s easier just to use a `foreach` loop. If you want to get the elements in
    reverse order, start with `Last` and follow each node’s `Previous`. If the list
    is empty, `First` and `Last` will be `null`.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 要遍历链表的内容，你可以从`First`属性检索第一个节点，然后按照每个节点的`Next`属性依次遍历，直到遇到`null`为止。但是，`LinkedList<T>`实现了`IEnumerable<T>`，所以更容易的方法是使用`foreach`循环。如果想要逆序获取元素，从`Last`开始，按照每个节点的`Previous`遍历。如果链表为空，`First`和`Last`将都是`null`。
- en: Concurrent Collections
  id: totrans-316
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并发集合
- en: The collection classes described so far are designed for single-threaded usage.
    You are free to use different instances on different threads simultaneously, but
    a particular instance of any of these types must be used only from one thread
    at any one time.^([6](ch05.xhtml#fn26)) But some types are designed to be used
    by many threads simultaneously, without needing to use the synchronization mechanisms
    discussed in [Chapter 16](ch16.xhtml#ch_multithreading). These are in the `System.Collections.Concurrent`
    namespace.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止描述的集合类都是为单线程使用设计的。你可以在不同的线程上同时使用不同的实例，但任何这些类型的特定实例在任一时刻只能由一个线程使用。^([6](ch05.xhtml#fn26))
    但是有些类型设计成可以同时被多个线程使用，而不需要使用在[第16章](ch16.xhtml#ch_multithreading)讨论过的同步机制。这些类型位于`System.Collections.Concurrent`命名空间中。
- en: The concurrent collections do not offer equivalents for every nonconcurrent
    collection type. Some classes are designed to solve specific concurrent programming
    problems. Even with the ones that do have nonconcurrent counterparts, the need
    for concurrent use without locking can mean that they present a somewhat different
    API than any of the normal collection classes.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 并发集合并不为每种非并发集合类型提供等价物。某些类是为了解决特定的并发编程问题而设计的。即使是那些有非并发对应物的集合，由于需要在不锁定的情况下并发使用，它们的API可能与任何普通集合类略有不同。
- en: The `ConcurrentQueue<T>` and `ConcurrentStack<T>` classes are the ones that
    look most like the nonconcurrent collections we’ve already seen, although they
    are not identical. The queue’s `Dequeue` and `Peek` have been replaced with `TryDequeue`
    and `TryPeek`, because in a concurrent world, there’s no reliable way to know
    in advance whether attempting to get an item from the queue will succeed. (You
    could check the queue’s `Count`, but even if that is nonzero, some other thread
    may get in there and empty the queue between when you check the count and when
    you attempt to retrieve an item.) So the operation to get an item has to be atomic
    with the check for whether an item is available, hence the `Try` forms that can
    fail without throwing an exception. Likewise, the concurrent stack provides `TryPop`
    and `TryPeek`.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '`ConcurrentQueue<T>`和`ConcurrentStack<T>`类看起来最像我们已经见过的非并发集合，尽管它们并非完全相同。队列的`Dequeue`和`Peek`方法被`TryDequeue`和`TryPeek`替代，因为在并发世界中，无法可靠地预知尝试从队列获取项是否成功（你可以检查队列的`Count`，但即使这个值非零，其他线程也可能在你检查计数和尝试检索项之间清空队列）。因此，获取项的操作必须与检查项是否可用的操作原子化，因此引入了可能失败而不抛出异常的`Try`形式。同样，并发栈提供了`TryPop`和`TryPeek`方法。'
- en: '`ConcurrentDictionary<TKey, TValue>` looks fairly similar to its nonconcurrent
    cousin, but it adds some extra methods to provide the atomicity required in a
    concurrent world: the `TryAdd` method combines the test for the presence of a
    key with the addition of a new entry; `GetOrAdd` does the same thing but also
    returns the existing value if there is one as part of the same atomic operation.'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '`ConcurrentDictionary<TKey, TValue>`看起来与其非并发版本相似，但它添加了一些额外的方法，以提供并发世界所需的原子性：`TryAdd`方法结合了对键是否存在的测试和新条目的添加；`GetOrAdd`方法在同一原子操作中执行相同的操作，并返回已存在的值（如果有的话）。'
- en: There is no concurrent list, because you tend to need more coarse-grained synchronization
    to use ordered, indexed lists successfully in a concurrent world. But if you just
    want a bunch of objects, there’s `ConcurrentBag<T>`, which does not maintain any
    particular order.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 没有并发列表，因为在并发世界中，为了成功使用有序的、索引的列表，你往往需要更粗粒度的同步。但如果你只想要一堆对象，可以使用`ConcurrentBag<T>`，它不保持任何特定的顺序。
- en: There’s also `BlockingCollection<T>`, which acts like a queue but allows threads
    that want to take items off the queue to choose to block until an item is available.
    You can also set a limited capacity and make threads that put items onto the queue
    block if the queue is currently full, waiting until space becomes available.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个`BlockingCollection<T>`，它的作用类似于队列，但允许想要从队列中取出项目的线程选择阻塞，直到有可用的项目为止。您还可以设置有限的容量，并使将项目放入队列的线程在队列当前已满时阻塞，直到空间可用为止。
- en: Immutable Collections
  id: totrans-323
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不可变集合
- en: Microsoft provides a set of collection classes that guarantee immutability and
    yet provide a lightweight way to produce a modified version of the collection
    without having to make an entire new copy. (These are built into .NET Core and
    .NET, but in .NET Framework, you will need a reference to the `System.Collections.Immutable`
    NuGet package to use these.)
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: Microsoft 提供了一组保证不可变性的集合类，并提供一种轻量级方法来生成集合的修改版本，而无需制作完整的新副本。（这些内置在 .NET Core
    和 .NET 中，但在 .NET Framework 中，您需要引用 `System.Collections.Immutable` NuGet 包才能使用这些功能。）
- en: Immutability can be a very useful characteristic in multithreaded environments,
    because if you know that the data you are working with cannot change, you don’t
    need to take special precautions to synchronize your access to it. (This is a
    stronger guarantee than you get with `IReadOnlyList<T>`, which merely prevents
    you from modifying the collection; it could just be a façade over a collection
    that some other thread is able to modify.) But what do you do if your data needs
    to be updated occasionally? It seems a shame to give up on immutability and to
    take on the overhead of traditional multithreaded synchronization in cases where
    you expect conflicts to be rare.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 在多线程环境中，不可变性可以是一个非常有用的特性，因为如果您知道正在使用的数据不会更改，那么您就不需要采取特殊预防措施来同步对其的访问。（这比仅防止修改集合的
    `IReadOnlyList<T>` 提供了更强的保证；它可能只是一个外观，覆盖了其他线程能够修改的集合。）但是，如果您的数据偶尔需要更新，该怎么办？在您预期冲突很少的情况下，放弃不可变性并承担传统多线程同步的开销似乎有些可惜。
- en: A low-tech approach is to build a new copy of all of your data each time something
    changes (e.g., when you want to add an item to a collection, create a whole new
    collection with a copy of all the old elements and also the new one, and use that
    new collection from then on). This works but can be extremely inefficient. However,
    techniques exist that can effectively reuse parts of existing collections. The
    basic principle is that if you want to add an item to a collection, you build
    a new collection that just points to the data that is already there, along with
    some extra information to say what has changed. It is rather more complex in practice,
    but the key point is that there are well-established ways in which to implement
    various kinds of collections so that you can efficiently build what look like
    complete self-contained copies of the original data with some small modification
    applied, without either having to modify the original data or having to build
    a complete new copy of the collection. The immutable collections do all this for
    you, encapsulating the work behind some straightforward interfaces.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 一种低技术手段是每次数据发生变化时（例如，当您想要向集合添加项目时），构建所有数据的新副本（创建一个包含所有旧元素和新元素副本的新集合，并从那时起使用该新集合）。这种方法有效，但可能效率极低。然而，存在技术可以有效地重用现有集合的部分。其基本原则是，如果要向集合添加项目，则构建一个新集合，该集合仅指向已有数据，并附加一些额外信息以表明发生了什么变化。实际上要复杂得多，但关键点在于，已经建立了可以实现各种集合的方式，因此您可以高效地构建看起来像原始数据的完整独立副本，并应用一些小的修改，而无需修改原始数据或完全构建新副本的集合。不可变集合为您完成所有这些工作，并将工作封装在一些简单的接口背后。
- en: This enables a model where you’re free to update your application’s model without
    affecting code that was in the middle of using the current version of the data.
    Consequently, you don’t need to hold locks while reading data—you might need some
    synchronization when getting the latest version of the data, but thereafter, you
    can process the data without any concurrency concerns. This can be especially
    useful when writing multithreaded code. The .NET Compiler Platform (often known
    by its codename, Roslyn) that is the basis of Microsoft’s C# compiler uses this
    technique to enable compilation to exploit multiple CPU cores efficiently.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得一种模型成为可能，即在不影响正在使用当前数据版本的代码的情况下更新应用程序的模型。因此，您无需在读取数据时保持锁定状态——在获取数据的最新版本时可能需要一些同步，但此后，您可以在不考虑并发问题的情况下处理数据。编写多线程代码时，这一点尤为有用。微软的C#编译器基础.NET编译器平台（通常以其代号Roslyn而闻名）使用这种技术来实现有效利用多个CPU核心进行编译。
- en: The `System.Collections.Immutable` namespace defines its own interfaces— `IImmutableList<T>`,
    `IImmutableDictionary<TKey, TValue>`, `IImmutableQueue<T>`, `IImutableStack<T>`,
    and `IImutableSet<T>`. This is necessary because all operations that modify the
    collection in any way need to return a new collection. [Example 5-50](#creating_immutable_dictionaries)
    shows what this means for adding entries to a dictionary.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '`System.Collections.Immutable` 命名空间定义了其自己的接口—— `IImmutableList<T>`、 `IImmutableDictionary<TKey,
    TValue>`、 `IImmutableQueue<T>`、 `IImutableStack<T>` 和 `IImutableSet<T>`。这是必要的，因为所有修改集合的操作都需要返回一个新的集合。[示例
    5-50](#creating_immutable_dictionaries)展示了向字典添加条目的意义。'
- en: Example 5-50\. Creating immutable dictionaries
  id: totrans-329
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-50\. 创建不可变字典
- en: '[PRE49]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The whole point of immutable types is that code using an existing object can
    be certain that nothing will change, so additions, removals, or modifications
    necessarily mean creating a new object that looks just like the old one but with
    the modification applied. (The built-in `string` type works in exactly the same
    way because it is also immutable—the methods that sound like they will change
    the value, such as `Trim`, actually return a new string.) So in [Example 5-50](#creating_immutable_dictionaries),
    the variable `d` refers successively to four different immutable dictionaries:
    an empty one, one with one value, one with two values, and finally one with all
    three values.'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 不可变类型的整个要点在于，使用现有对象的代码可以确保不会发生任何变化，因此添加、删除或修改必然意味着创建一个新对象，该对象看起来与旧对象完全相同，但应用了修改。（内置的
    `string` 类型也是不可变的，工作方式完全相同——诸如 `Trim` 这类看起来会改变值的方法实际上返回一个新的字符串。）因此，在 [示例 5-50](#creating_immutable_dictionaries)
    中，变量 `d` 连续引用四个不同的不可变字典：一个空字典，一个包含一个值的字典，一个包含两个值的字典，最后一个包含所有三个值的字典。
- en: If you are adding a range of values like this, and you won’t be making intermediate
    results available to other code, it is more efficient to add multiple values in
    a single operation, because it doesn’t have to produce a separate `IIm⁠mut⁠ab⁠le​Dic⁠tio⁠nar⁠y<T⁠Key⁠,
    TValue>` for each entry you add. (You could think of immutable collections as
    working a bit like a source control system, with each change corresponding to
    a commit—for every commit you do, a version of the collection will exist that
    represents its contents immediately after that change.) It’s more efficient to
    batch a bunch of related changes into a single “version” so the collections all
    have `AddRange` methods that let you add multiple items in one step.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您像这样添加一系列值，并且不会将中间结果提供给其他代码，那么通过单个操作添加多个值更为高效，因为它不必为每个添加的条目生成单独的 `IIm⁠mut⁠ab⁠le​Dic⁠tio⁠nar⁠y<T⁠Key⁠,
    TValue>`。（您可以将不可变集合视为类似源代码控制系统的工作方式，其中每个更改对应一个提交——对于每个提交，将存在一个版本的集合，该版本代表其在该更改之后的内容。）将一组相关的更改批量处理为单个“版本”更为高效，因此所有集合都具有
    `AddRange` 方法，可让您一次添加多个项。
- en: 'When you’re building a new collection from scratch, the same principle applies:
    it will be more efficient if you put all of the initial content into the first
    version of the collection, instead of adding items one at a time. Each immutable
    collection type offers a nested `Builder` class to make this easier, enabling
    you to add items one at a time but to defer the creation of the actual collection
    until you have finished. [Example 5-51](#creating_an_immutable_dictionary_with_a)
    shows how this is done.'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 当你从头开始构建一个新集合时，同样的原则适用：如果你将所有初始内容放入集合的第一个版本中，而不是逐个添加项目，那么效率会更高。每种不可变集合类型都提供了一个嵌套的`Builder`类，使这一过程更加简单，使你能够逐个添加项目，但在完成后延迟实际集合的创建。[示例 5-51](#creating_an_immutable_dictionary_with_a)展示了如何做到这一点。
- en: Example 5-51\. Creating an immutable dictionary with a builder
  id: totrans-334
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-51\. 使用构建器创建不可变字典
- en: '[PRE50]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The builder object is not immutable. Much like `StringBuilder`, it is a mutable
    object that provides an efficient way to build a description of an immutable object.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 构建器对象不是不可变的。与`StringBuilder`类似，它是一个可变对象，提供了一种有效的方式来构建不可变对象的描述。
- en: 'In addition to the immutable list, dictionary, queue, stack, and set types,
    there’s one more immutable collection class that is a bit different than the rest:
    `Imm⁠uta⁠ble​Ar⁠ray⁠<T>`. This is essentially a wrapper providing an immutable
    façade around an array. It implements `IImmutableList<T>`, meaning that it offers
    the same services as an immutable list, but it has quite different performance
    characteristics.'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 除了不可变列表、字典、队列、栈和集合类型之外，还有一种不同于其他的不可变集合类：`ImmutableArray<T>`。这本质上是一个包装器，在数组周围提供了一个不可变的外观。它实现了`IImmutableList<T>`，这意味着它提供了与不可变列表相同的服务，但性能特征有着显著的不同。
- en: When you call `Add` on an immutable list, it will attempt to reuse most of the
    data that is already there, so if you have a million items in your list, the “new”
    list returned by `Add` won’t contain a new copy of those items—it will mostly
    reuse the data that was already there. However, to achieve this, `ImmutableList<T>`
    uses a somewhat complex tree data structure internally. The upshot is that looking
    up values by index in an `ImmutableList<T>` is not nearly as efficient as using
    an array (or a `List<T>`). The indexer for `ImmutableList<T>` has *O(log n)* complexity.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在不可变列表上调用`Add`方法时，它会尝试重用已经存在的大部分数据，因此如果你的列表中有一百万个项目，“新”列表由`Add`返回的并不包含这些项目的新副本，而是大部分重用了已经存在的数据。然而，为了实现这一点，`ImmutableList<T>`在内部使用了一种相当复杂的树数据结构。结果是，在`ImmutableList<T>`中通过索引查找值的效率远不如使用数组（或`List<T>`）。`ImmutableList<T>`的索引器具有*O(log
    n)*的复杂度。
- en: An `ImmutableArray<T>` is much more efficient for reads—being a wrapper around
    an array, it has *O(1)* complexity, i.e., the time taken to fetch an entry is
    constant, regardless of how large the collection may be. The trade-off is that
    all of the `IImmutableList<T>` methods for building a modified version of the
    list (`Add`, `Remove`, `Insert`, `SetItem`, etc.) build a complete new array,
    including a new copy of any data that needs to be carried over. (In other words,
    unlike all the other immutable collection types, `ImmutableArray<T>` employs the
    low-tech approach to immutability that I described earlier.) This makes modifications
    very much more expensive, but if you have some data you do not expect to modify
    after the initial creation of the array, this is an excellent trade-off, because
    you will only ever build one copy of the array. And if you need to make very occasional
    modifications, the high cost of each change might still be worth it overall.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 对于读取操作来说，`ImmutableArray<T>`要高效得多——作为数组的包装器，它具有*O(1)*的复杂度，即获取条目的时间是常数，无论集合大小如何。然而，代价是对于构建修改版本的所有`IImmutableList<T>`方法（`Add`、`Remove`、`Insert`、`SetItem`等）来说，都需要构建一个完整的新数组，包括需要传递的任何数据的新副本。（换句话说，与所有其他不可变集合类型不同，`ImmutableArray<T>`采用了我之前描述的低技术方法来实现不可变性。）这使得修改变得非常昂贵，但如果你有一些数据在创建数组后不期望修改，这是一个很好的权衡，因为你只会构建一个数组的副本。如果偶尔需要进行修改，每次变更的高成本总体来看可能仍然是值得的。
- en: Summary
  id: totrans-340
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, we saw the intrinsic support for arrays offered by the runtime
    and also the various collection classes that .NET provides when you need more
    than a fixed-size list of items. Next, we’ll look at a more advanced topic: inheritance.'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到了运行时提供的数组的固有支持，以及.NET在需要更多于固定大小项目列表时提供的各种集合类。接下来，我们将看一个更高级的主题：继承。
- en: ^([1](ch05.xhtml#fn23-marker)) Surprisingly, `foreach` doesn’t require any particular
    interface; it will use anything with a `GetEnumerator` method that returns an
    object providing a `MoveNext` method and a `Current` property. Before generics,
    this was the only way to enable iteration through collections of value-typed elements
    without boxing every item. [Chapter 7](ch07.xhtml#ch_object_lifetime) describes
    boxing. Even though generics have fixed that, non-interface-based enumeration
    continues to be useful because it enables collection classes to provide an extra
    `GetEnumerator` that returns a `struct`, avoiding an additional heap allocation
    when the `foreach` loop starts. `List<T>` does this.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch05.xhtml#fn23-marker)) 令人惊讶的是，`foreach`并不需要任何特定的接口；它将使用任何具有返回提供`MoveNext`方法和`Current`属性的对象的`GetEnumerator`方法的类型。在泛型出现之前，这是通过值类型元素集合进行迭代的唯一方法，而不会对每个项进行装箱。[第7章](ch07.xhtml#ch_object_lifetime)描述了装箱。尽管泛型已经解决了这个问题，但基于非接口的枚举继续很有用，因为它使集合类能够提供额外的`GetEnumerator`方法，返回一个`struct`，在`foreach`循环开始时避免额外的堆分配。`List<T>`就是这样做的。
- en: ^([2](ch05.xhtml#fn24-marker)) Some of this cleanup work happens in the call
    to `Dispose`. Remember, `IEnumerator<T>` implementations all implement `IDisposable`.
    The `foreach` keyword calls `Dispose` after iterating through a collection (even
    if iteration was terminated by an error). If you’re not using `foreach` and are
    performing iteration by hand, it’s vitally important to remember to call `Dispose`.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch05.xhtml#fn24-marker)) 在调用`Dispose`时，部分清理工作已经完成。请记住，所有`IEnumerator<T>`的实现都实现了`IDisposable`接口。`foreach`关键字在遍历集合后会调用`Dispose`（即使遍历由于错误而提前终止）。如果不使用`foreach`，而是手动进行迭代，则必须牢记调用`Dispose`的重要性。
- en: ^([3](ch05.xhtml#idm45884821262096-marker)) Since end-relative indexes are stored
    as negative numbers, you might be wondering whether `^0` is even legal, given
    that the `int` type does not distinguish between positive and negative zero. It
    is allowed because, as you’ll soon see, `^0` is useful when using ranges, so `Index`
    is able to make the distinction.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: ^([3](ch05.xhtml#idm45884821262096-marker)) 由于终点相对索引存储为负数，你可能会想知道`^0`是否合法，因为`int`类型不区分正零和负零。它是允许的，因为正如你很快就会看到的那样，当使用范围时，`^0`在`Index`中是有用的，所以`Index`能够进行区分。
- en: ^([4](ch05.xhtml#idm45884820788208-marker)) In cases where you use `^` directly
    against an `int` inside an array indexer (e.g., `a[^i]` where `i` is an `int`),
    the compiler generates marginally simpler code. Instead of converting `i` to an
    `Index`, then calling `GetOffset`, it will generate code equivalent to `a[a.Length
    - i]`.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: ^([4](ch05.xhtml#idm45884820788208-marker)) 在直接针对`int`类型的数组索引器使用`^`的情况下（例如，`a[^i]`，其中`i`是一个`int`），编译器会生成稍微简单的代码。它不会将`i`转换为`Index`，然后调用`GetOffset`，而是会生成等效于`a[a.Length
    - i]`的代码。
- en: ^([5](ch05.xhtml#fn25-marker)) The usual complexity analysis caveats apply—for
    small collections, the simpler data structure might well win, its theoretical
    advantage only coming into effect with larger collections.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: ^([5](ch05.xhtml#fn25-marker)) 常规的复杂性分析警告适用于小型集合，更简单的数据结构可能表现更好，其理论优势只在处理较大集合时才能显现。
- en: '^([6](ch05.xhtml#fn26-marker)) There’s an exception to this rule: you can use
    a collection from multiple threads as long as none of the threads attempts to
    modify it.'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: ^([6](ch05.xhtml#fn26-marker)) 这个规则有一个例外：只要没有线程尝试修改它，你可以在多个线程中使用同一个集合。
