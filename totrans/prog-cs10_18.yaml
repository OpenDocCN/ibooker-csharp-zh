- en: Chapter 18\. Memory Efficiency
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第18章。内存效率
- en: 'As [Chapter 7](ch07.xhtml#ch_object_lifetime) described, the CLR is able to
    perform automatic memory management thanks to its garbage collector (GC). This
    comes at a price: when a CPU spends time on garbage collection, that stops it
    from getting on with more productive work. On laptops and phones, GC work drains
    power from the battery. In a cloud computing environment where you may be paying
    for CPU time based on consumption, extra work for the CPU corresponds directly
    to increased costs. More subtly, on a computer with many cores, spending too much
    time in the GC can dramatically reduce throughput, because many of the cores may
    end up blocked, waiting for the GC to complete before they can proceed.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 正如[第7章](ch07.xhtml#ch_object_lifetime)所述，CLR能够通过其垃圾收集器（GC）执行自动内存管理。这样做是有代价的：当CPU在进行垃圾收集时，就停止了它更有生产力的工作。在笔记本电脑和手机上，GC工作会耗尽电池的电量。在云计算环境中，您可能根据消耗支付CPU时间，因此CPU额外工作直接对应增加的成本。更微妙的是，在具有多个核心的计算机上，如果GC花费太多时间，可能会显著降低吞吐量，因为许多核心可能会因为等待GC完成而被阻塞。
- en: In many cases, these effects will be small enough not to cause visible problems.
    However, when certain kinds of programs experience heavy load, GC costs can come
    to dominate the overall execution time. In particular, if you write code that
    performs relatively simple but highly repetitive processing, GC overhead can have
    a substantial impact on throughput.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，这些影响可能不会造成明显问题。然而，当某些类型的程序承受重载时，GC成本可能主导整体执行时间。特别是，如果您编写的代码执行相对简单但高度重复的处理，GC开销可能会对吞吐量产生重大影响。
- en: To give you an example of the kinds of improvements that can sometimes be possible,
    early versions of Microsoft’s ASP.NET Core web server framework frequently ran
    into hard limits due to GC overhead. To enable .NET applications to break through
    these barriers, C# introduced various features that can enable dramatic reductions
    in the number of allocations. Fewer allocations means fewer blocks of memory for
    the GC to recover, so this translates directly to lower GC overhead. When ASP.NET
    Core first started making extensive use of these features, performance improved
    across the board, but for the simplest performance benchmark, known as *plaintext*
    (part of the TechEmpower suite of web performance tests), this release improved
    the request handling rate by over 25%.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 举个例子，微软早期版本的ASP.NET Core Web服务器框架经常因为GC开销而遇到硬性限制。为了让.NET应用程序突破这些障碍，C#引入了各种功能，可以大幅减少分配数量。分配减少意味着GC需要回收的内存块减少，因此直接转化为较低的GC开销。当ASP.NET
    Core首次大量使用这些功能时，性能在各方面都有所提升，但对于最简单的性能基准测试，即*明文*（TechEmpower Web性能测试套件的一部分），此版本的请求处理速率提高了超过25%。
- en: In some specialized scenarios, the differences can be more dramatic. In 2019,
    I worked on a project that processed diagnostic information from a broadband provider’s
    networking equipment (in the form of RADIUS packets). Adopting the techniques
    described in this chapter boosted the rate at which a single CPU core in our system
    could process the messages from around 300,000/s to about 7 million/s.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些专业场景中，差异可能更加显著。例如，2019年，我参与了一个项目，该项目处理宽带提供商网络设备的诊断信息（以RADIUS数据包形式）。采用本章描述的技术，我们系统中单个CPU核心处理消息的速率从约300,000个/秒提高到约7,000,000个/秒。
- en: 'There is a price to pay, of course: these GC-efficient techniques add significant
    complication to your code. And the payoff won’t always be so large—although the
    first ASP.NET Core release to be able to use these features improved over the
    previous version on all benchmarks, only the simplest shows a 25% boost, and most
    improved more modestly. The practical improvement will really depend on the nature
    of your workload, and for some applications you might find that applying these
    techniques delivers no measurable improvement. So before you even consider using
    them, you should use performance monitoring tools to find out how much time your
    code spends in the GC. If it’s only a few percent, then you might not be able
    to realize order-of-magnitude improvements. But if testing suggests that there’s
    room for significant improvement, the next step is to ask whether the techniques
    in this chapter are likely to help. So let’s start by exploring exactly how these
    new techniques can help you reduce GC overhead.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这是有代价的：这些高效的GC技术会显著增加你的代码复杂性。而且收益并不总是那么大——尽管第一个能够使用这些特性的ASP.NET Core版本在所有基准测试中都比上一个版本有所改进，但只有最简单的显示出了25%的提升，大多数只有较为适度的改进。实际的改进将取决于你的工作负载的特性，对于一些应用程序，你可能会发现应用这些技术并没有带来可测量的改进。因此，在你考虑使用它们之前，你应该使用性能监控工具来找出你的代码在GC中花费了多少时间。如果只有几个百分点，那么你可能无法实现数量级的改进。但是，如果测试表明有显著改进的空间，下一步就是询问这一章中的技术是否有助于改进。因此，让我们首先探讨这些新技术如何帮助你减少GC开销。
- en: (Don’t) Copy That
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: （不要）复制那个
- en: 'The way to reduce GC overhead is to allocate less memory on the heap. And the
    most important technique for minimizing allocations is to avoid making copies
    of data. For example, consider the URL *http://example.com/books/1323?edition=6&format=pdf*.
    There are several elements of interest in here, such as the protocol (`http`),
    the hostname (`example.com`), or the query string. The latter has its own structure:
    it is a sequence of name/value pairs. The obvious way to work with a URL in .NET
    is to use the `System.Uri` type, as [Example 18-1](#ex_basic_url_parsing) shows.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 减少GC开销的方法是在堆上分配更少的内存。而最重要的减少分配技术是避免复制数据。例如，考虑URL *http://example.com/books/1323?edition=6&format=pdf*。这里有几个感兴趣的元素，比如协议（`http`）、主机名（`example.com`）或查询字符串。后者有其自己的结构：它是一系列名称/值对。在.NET中处理URL的明显方法是使用`System.Uri`类型，如[示例 18-1](#ex_basic_url_parsing)所示。
- en: Example 18-1\. Deconstructing a URL
  id: totrans-8
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 18-1\. 解构URL
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'It produces the following output:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 它会生成以下输出：
- en: '[PRE1]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This is convenient, but by getting the values of these four properties, we have
    forced the `Uri` to provide four `string` objects in addition to the original
    one. You could imagine a smart implementation of `Uri` that recognized certain
    standard values for `Scheme`, such as `http`, and that always returned the same
    string instance for these instead of allocating new ones, but for all the other
    parts, it’s likely to have to allocate new strings on the heap.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这很方便，但通过获取这四个属性的值，我们不得不让`Uri`除了原始的字符串外，还提供了四个`string`对象。你可以想象一个聪明的`Uri`实现，识别某些标准的`Scheme`值，比如`http`，并且总是返回相同的字符串实例，而不是分配新的实例，但对于所有其他部分来说，它很可能必须在堆上分配新的字符串。
- en: There is another way. Instead of creating new `string` objects for each section,
    we could take advantage of the fact that all of the information we want was already
    in the string containing the whole URL. There’s no need to copy each section into
    a new string, when instead we can just keep track of the position and lengths
    of the relevant sections within the string. Instead of creating a string for each
    section, we would need just two numbers. And since we can represent numbers using
    value types (e.g., `int` or, for very long strings, `long`), we don’t need any
    additional objects on the heap beyond the single string with the full URL. For
    example, the scheme (`http`) is at position 0 and has length 4\. [Figure 18-1](#fig_UrlByOffsetAndSize)
    shows each of the elements by their offset and position within the string.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 还有另一种方法。与其为每个部分创建新的`string`对象，我们可以利用这样一个事实，即我们想要的所有信息已经包含在包含整个URL的字符串中。没有必要将每个部分复制到新的字符串中，我们可以仅仅跟踪字符串中相关部分的位置和长度。我们不再需要为每个部分创建一个字符串，而只需两个数字。并且由于我们可以使用值类型表示数字（例如`int`或对于非常长的字符串，`long`），除了包含完整URL的单个字符串外，我们不需要在堆上再创建额外的对象。例如，协议（`http`）位于位置0，并且长度为4。[图 18-1](#fig_UrlByOffsetAndSize)显示了每个元素在字符串中的偏移和位置。
- en: '![URL elements by their offset and size in a string](assets/pc10_1801.png)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![字符串中的 URL 元素根据其偏移量和大小](assets/pc10_1801.png)'
- en: Figure 18-1\. URL substrings
  id: totrans-15
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 18-1\. URL 子字符串
- en: 'This works, but already we can see the first problem with working this way:
    it is somewhat awkward. Instead of representing, say, the `Host` with a convenient
    `string` object, which is easily understood and readily inspected in the debugger,
    we now have a pair of numbers, and as developers, we now have to remember which
    string they point into. It’s not rocket science, but it makes it slightly harder
    to understand our code, and easier to introduce bugs. But there’s a payoff: instead
    of five strings (the original URL and the four properties), we just have one.
    And if you’re trying to process millions of events each second, that could easily
    be worth the effort.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法是有效的，但我们已经可以看到通过这种方式工作的第一个问题：它有些笨拙。与使用一个方便的 `string` 对象来表示 `Host` 不同，后者在调试器中易于理解和检查，我们现在有一对数字，作为开发人员，我们现在必须记住它们指向的哪个字符串。这并不是什么高深的科学，但它使我们稍微难以理解我们的代码，并且更容易引入错误。但有一个回报：与五个字符串（原始
    URL 和四个属性）相比，我们只有一个字符串。如果您正在尝试每秒处理数百万事件，这可能很容易值得付出这种努力。
- en: 'Obviously this technique would work for a more fine-grained structure too.
    The offset and position `(25, 4)` locates the text `1323` in this URL. We might
    want to parse that as an `int`. But at this point we run into the second problem
    with this style of working: it is not widely supported in .NET libraries. The
    usual way to parse text into an `int` is to use the `int` type’s static `Parse`
    or `TryParse` methods. Unfortunately, these do not provide overloads that accept
    a position or offset within a `string`. They require a string containing only
    the number to be parsed. This means you end up writing code such as [Example 18-2](#ex_substring_defeating_the_purpose).'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，这种技术也适用于更细粒度的结构。偏移量和位置 `(25, 4)` 定位了这个 URL 中的文本 `1323`。我们可能希望将其解析为一个 `int`。但在这一点上，我们遇到了这种工作方式的第二个问题：在
    .NET 库中并不广泛支持这种方式。将文本解析为 `int` 的常规方式是使用 `int` 类型的静态 `Parse` 或 `TryParse` 方法。不幸的是，这些方法不提供接受字符串中位置或偏移量的重载。它们要求字符串仅包含要解析的数字。这意味着你最终会编写类似于
    [Example 18-2](#ex_substring_defeating_the_purpose) 的代码。
- en: Example 18-2\. Defeating the point of the exercise by using `Substring`
  id: totrans-18
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 18-2\. 使用 `Substring` 打破了这个练习的初衷
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This works, but by using `Substring` to go from our (offset, length) representation
    back to the plain `string` that `int.Parse` wants, we’ve allocated a new `string`.
    The whole point of this exercise was to reduce allocations, so this doesn’t seem
    like progress. One solution might be for Microsoft to go through the entire .NET
    API surface area, adding overloads that accept offset and length parameters in
    any situation where we might want to work with something in the middle of something
    else (either a substring, as in this example, or perhaps a subrange of an array).
    In fact, there are examples of this already: the `Stream` API for working with
    byte streams has various methods that accept a `byte[]` array, and also offset
    and length arguments to indicate exactly which part of the array you want to work
    with.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法是有效的，但通过使用 `Substring` 从我们的 (偏移量，长度) 表示回到 `int.Parse` 需要的普通 `string`，我们分配了一个新的
    `string`。这个练习的整个目的是减少分配，所以这看起来并不像是进步。一个解决方案可能是微软要检查整个 .NET API 表面，添加接受偏移量和长度参数的重载，无论我们想在其他中间部分工作的情况是什么（例如子字符串，就像这个例子中一样，或者可能是数组的子范围）。事实上，已经有这样的例子了：用于处理字节流的
    `Stream` API 具有各种方法，这些方法接受一个 `byte[]` 数组，还有偏移量和长度参数，以确切地指示您要处理的数组的哪一部分。
- en: 'However, there’s one more problem with this technique: it is inflexible about
    the type of container that the data lives in. Microsoft could add an overload
    to `int.Parse` that takes a `string`, an offset, and a length, but it would only
    be able to parse data inside a `string`. What if the data happens to be in a `char[]`?
    In that case, you’d have to convert it to a `string` first, at which point we’re
    back to additional allocations. Alternatively, every API that wants to support
    this approach would need multiple overloads to support all the containers that
    anyone might want to use, each potentially requiring a different implementation
    of the same basic method.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种技术还有一个问题：它对数据所在的容器类型不够灵活。微软可以为 `int.Parse` 添加一个重载，接受一个 `string`、一个偏移量和一个长度，但它只能解析
    `string` 内的数据。如果数据恰好在 `char[]` 中呢？在这种情况下，你必须先将其转换为 `string`，到那时我们又回到了额外的分配上。或者说，所有想支持这种方法的
    API 都需要多个重载来支持所有人可能想使用的容器，每个容器可能需要不同的基本方法实现。
- en: More subtly, what if the data you have is currently in memory that’s not on
    the CLR’s heap? This is a particularly important question when it comes to the
    performance of servers that accept requests over the network (e.g., a web server).
    Sometimes it is not possible to arrange for data received by a network card to
    be delivered directly into memory on .NET’s heap. Also, some forms of interprocess
    communication involve arranging for the OS to map a particular region of memory
    into two different processes’ address spaces. The .NET heap is local to the process
    and cannot use such memory.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 更微妙的是，如果你目前的数据存储在 CLR 堆之外的内存中呢？当涉及到通过网络接受请求的服务器性能时，这尤其重要（例如，Web 服务器）。有时无法安排网络卡接收到的数据直接传送到
    .NET 的堆内存中。另外，一些进程间通信的形式涉及安排操作系统将特定区域的内存映射到两个不同进程的地址空间中。.NET 堆是进程本地的，不能使用这样的内存。
- en: C# has always supported use of external memory through *unsafe code*, which
    supports raw unmanaged pointers that work in a similar way to pointers in the
    C and C++ languages. However, there are a couple of problems with these. First,
    they would add yet another entry to the list of overloads that everything would
    need to support in a world where we can parse data in place. Second, code using
    pointers cannot pass .NET’s type safety verification rules. This means it becomes
    possible to make certain kinds of programming errors that are normally impossible
    in C#. It may also mean that the code will not be allowed to run in certain scenarios,
    since the loss of type safety would enable unsafe code to bypass certain security
    constraints.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: C# 一直支持通过 *unsafe code* 使用外部内存，这支持类似于 C 和 C++ 语言中的指针的原始未管理指针。然而，这些指针存在一些问题。首先，它们会在我们可以就地解析数据的世界中，增加另一项所有重载都需要支持的条目。其次，使用指针的代码不能通过
    .NET 的类型安全验证规则。这意味着可能会产生某些在 C# 中通常不可能的编程错误。这也可能意味着在某些情况下代码将不被允许运行，因为失去类型安全将使未安全代码绕过某些安全约束。
- en: 'To summarize, it has always been possible to reduce allocations and copying
    in .NET by working with offsets and lengths and either a reference to a containing
    string or array or an unmanaged pointer to memory, but there was considerable
    room for improvement on these fronts:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 总结起来，通过使用偏移量和长度以及对包含字符串或数组的引用或对内存的未管理指针，始终可以在 .NET 中减少分配和复制，但在这些方面还有相当大的改进空间：
- en: Convenience
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 便利性
- en: Wide support across .NET APIs
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .NET API 的广泛支持
- en: 'Unified, safe handling of the following:'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对以下内容的统一、安全处理：
- en: Strings
  id: totrans-28
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串
- en: Arrays
  id: totrans-29
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组
- en: Unmanaged memory
  id: totrans-30
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 未管理内存
- en: '.NET offers a type that addresses all three points: `Span<T>`. (See the next
    sidebar, [“Support Across Language and Runtime Versions”](#span_runtime_and_langauge_versions_sidebar),
    for more information on how the features described in this chapter relate to C#
    language and .NET runtime versions.)'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 提供了一个类型，解决了这三点问题：`Span<T>`。 (请参见下一侧边栏，[“跨语言和运行时版本的支持”](#span_runtime_and_langauge_versions_sidebar)，了解本章描述的特性与
    C# 语言和 .NET 运行时版本之间的关系。)
- en: Representing Sequential Elements with Span<T>
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Span<T> 表示顺序元素
- en: The `System.Span<T>` value type represents a sequence of elements of type `T`
    stored contiguously in memory. Those elements can live inside an array, a string,
    a managed block of memory allocated in a stack frame, or unmanaged memory. Let’s
    look at how `Span<T>` addresses each of the requirements enumerated in the preceding
    section.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`System.Span<T>` 值类型表示内存中连续存储的类型为 `T` 的元素序列。这些元素可以存在于数组、字符串、在堆栈帧中分配的托管内存块或非托管内存中。让我们看看
    `Span<T>` 如何处理前一节中列出的每个要求。'
- en: 'A `Span<T>` encapsulates three things: a pointer or reference to the containing
    memory (e.g., the `string` or array), the position of the data within that memory,
    and its length.^([1](ch18.xhtml#idm45884782468272)) To access the contents of
    a span, you use it much as you would an array, as [Example 18-3](#ex_sum_span_contents)
    shows. This makes it much more convenient to use than ad hoc techniques in which
    you define a couple of `int` variables and have to remember what they refer to.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`Span<T>` 封装了三件事：指向包含内存的指针或引用（例如 `string` 或数组）、数据在该内存中的位置和其长度。^([1](ch18.xhtml#idm45884782468272))
    要访问 span 的内容，您使用它的方式几乎与数组相同，正如[示例 18-3](#ex_sum_span_contents) 所示。这使得它比定义几个 `int`
    变量并记住它们所引用的内容等临时技术更加方便使用。'
- en: Example 18-3\. Iterating over a `Span<int>`
  id: totrans-35
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 18-3\. 迭代 `Span<int>`
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Since a `Span<T>` knows its own length, its indexer checks that the index is
    in range, just as the built-in array type does. And if you are running on .NET
    Core or .NET, the performance is very similar to using a built-in array. This
    includes the optimizations that detect certain loop patterns—for example, the
    CLR will recognize the preceding code as a loop that iterates over the entire
    contents, enabling it to generate code that doesn’t need to check that the index
    is in range each time around the loop. In some cases it is even able to generate
    code that uses the vector-oriented instructions available in some CPUs to accelerate
    the loop. (On .NET Framework, `Span<T>` is a little slower than an array, because
    its CLR does not include the optimizations that were added in .NET Core to support
    `Span<T>`.)
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `Span<T>` 知道自己的长度，其索引器检查索引是否在范围内，就像内置数组类型一样。如果你运行在 .NET Core 或 .NET 上，性能与使用内置数组非常相似。这包括检测某些循环模式的优化，例如
    CLR 将识别前面的代码作为遍历整个内容的循环，从而生成在每次循环时不需要检查索引是否在范围内的代码。在某些情况下，它甚至能够生成使用某些 CPU 提供的矢量指令加速循环的代码。（在
    .NET Framework 上，`Span<T>` 比数组稍慢一些，因为它的 CLR 不包括 .NET Core 中支持 `Span<T>` 添加的优化。）
- en: You may have noticed that the method in [Example 18-3](#ex_sum_span_contents)
    takes a `ReadOnlySpan<T>`. This is a close relative of `Span<T>`, and there is
    an implicit conversion enabling you to pass any `Span<T>` to a method that takes
    a `ReadOnlySpan<T>`. The read-only form enables a method to declare clearly that
    it will only read from the span, and not write to it. (This is enforced by the
    fact that the read-only form’s indexer offers just a `get` accessor, and no `set`.)
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到[示例 18-3](#ex_sum_span_contents) 中的方法接受 `ReadOnlySpan<T>`。这是 `Span<T>`
    的近亲，并且有一个隐式转换，使您可以将任何 `Span<T>` 传递给接受 `ReadOnlySpan<T>` 的方法。只读形式清楚地声明方法只会从 span
    中读取，而不会写入它。（这是通过只读形式的索引器只提供 `get` 访问器而不提供 `set` 来强制执行的。）
- en: Tip
  id: totrans-39
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: Whenever you write a method that works with a span and that does not mean to
    modify it, you should use `ReadOnlySpan<T>`.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 每当你编写一个处理 span 但不意味着修改它的方法时，应使用`ReadOnlySpan<T>`。
- en: There are implicit conversions from the various supported containers to `Span<T>`
    (and also to `ReadOnlySpan<T>`). This enables [Example 18-4](#ex_pass_int_array_as_span)
    to pass an array to the `SumSpan` method.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 支持的各种容器到 `Span<T>`（以及到 `ReadOnlySpan<T>`）都有隐式转换。这使得[示例 18-4](#ex_pass_int_array_as_span)
    可以将数组传递给 `SumSpan` 方法。
- en: Example 18-4\. Passing an `int[]` as a `ReadOnlySpan<int>`
  id: totrans-42
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 18-4\. 将 `int[]` 作为 `ReadOnlySpan<int>` 传递
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Of course, we’ve gone and allocated an array on the heap there, so this particular
    example defeats the whole point of using spans, but if you already have an array
    on hand, this is a useful technique. `Span<T>` also works with stack-allocated
    arrays, as [Example 18-5](#ex_pass_stack_int_array_as_span) shows. (The `stackalloc`
    keyword enables you to create an array in memory allocated on the current stack
    frame.)
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在这里我们已经在堆上分配了一个数组，所以这个特定示例违背了使用 spans 的初衷，但如果你已经有一个数组在手，这是一个有用的技巧。`Span<T>`
    也可以与在堆栈上分配的数组一起使用，正如[示例 18-5](#ex_pass_stack_int_array_as_span) 所示。(`stackalloc`
    关键字允许您在当前堆栈帧上分配内存中创建数组。)
- en: Example 18-5\. Passing a stack-allocated array as a `ReadOnlySpan<int>`
  id: totrans-45
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 18-5\. 将堆栈分配的数组作为`ReadOnlySpan<int>`传递
- en: '[PRE5]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Normally, C# won’t allow you to use `stackalloc` outside of code marked as `unsafe`.
    The keyword allocates memory on the current method’s stack frame, and it does
    not create a real array object. Arrays are reference types, so they must live
    on the GC heap. A `stackalloc` expression produces a pointer type, because it
    produces plain memory without the usual .NET object headers. In this case, it
    would be an `int*`. You can only use pointer types directly in unsafe code blocks.
    However, the compiler makes an exception to this rule if you assign the pointer
    produced by a `stackalloc` expression directly into a span. This is permitted
    because spans impose bounds checking, preventing undetected out-of-range access
    errors of the kind that normally make pointers unsafe. Also, `Span<T>` and `ReadOnlySpan<T>`
    are both defined as `ref struct` types, and as [“Stack Only”](#stack_only) describes,
    this means they cannot outlive their containing stack frame. This guarantees that
    the stack frame on which the stack-allocated memory lives will not vanish while
    there are still outstanding references to it. (.NET’s type safety verification
    rules include special handling for spans.)
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，C#不会允许您在未标记为`unsafe`的代码之外使用`stackalloc`。该关键字在当前方法的堆栈帧上分配内存，并且不会创建真正的数组对象。数组是引用类型，因此必须存在于GC堆上。`stackalloc`表达式产生指针类型，因为它生成没有通常的.NET对象头的普通内存。在这种情况下，它将是一个`int*`。您只能在不安全代码块中直接使用指针类型。然而，如果您将`stackalloc`表达式产生的指针直接分配给一个span，则编译器将对此规则进行例外处理。这是允许的，因为span施加了边界检查，防止了通常会使指针不安全的未检测到的越界访问错误。此外，`Span<T>`和`ReadOnlySpan<T>`都被定义为`ref
    struct`类型，正如[“仅堆栈”](#stack_only)所描述的，这意味着它们不能超出其包含的堆栈帧。这保证了在仍然存在对它的未解除引用时，包含堆栈分配内存的堆栈帧不会消失。(.NET的类型安全验证规则包括对spans的特殊处理。)
- en: Earlier I mentioned that spans can refer to strings as well as arrays. However,
    we can’t pass a `string` to this `SumSpan` for the simple reason that it requires
    a span with an element type of `int`, whereas a `string` is a sequence of `char`
    values. `int` and `char` have different sizes—they take 4 and 2 bytes each, respectively.
    Although an implicit conversion exists between the two (meaning you can assign
    a `char` value into an `int` variable, giving you the Unicode value of the `char`),
    that does not make a `ReadOnlySpan<char>` implicitly compatible with a `ReadOnlySpan<int>`.^([2](ch18.xhtml#idm45884782266080))
    Remember, the entire point of spans is that they provide a view into a block of
    data without needing to copy or modify that data; since `int` and `char` have
    different sizes, converting a `char[]` to an `int[]` array would double its size.
    However, if we were to write a method accepting a `ReadOnlySpan<char>`, we would
    be able to pass it a `string`, a `char[]` array, a `stackalloc char[]`, or an
    unmanaged pointer of type `char*` (because the in-memory representation of a particular
    span of characters within each of these is the same).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我之前提到过span既可以引用字符串也可以引用数组。然而，我们不能将`string`传递给此`SumSpan`的简单原因是它要求元素类型为`int`的span，而`string`是一系列`char`值。`int`和`char`具有不同的大小——它们分别占用4和2个字节。虽然两者之间存在隐式转换（意味着您可以将`char`值分配给`int`变量，从而得到`char`的Unicode值），但这并不意味着`ReadOnlySpan<char>`隐式兼容于`ReadOnlySpan<int>`。^([2](ch18.xhtml#idm45884782266080))请记住，spans的整个目的是它们提供了对数据块的视图，而无需复制或修改该数据；由于`int`和`char`具有不同的大小，将`char[]`转换为`int[]`数组会使其大小加倍。但是，如果我们编写一个接受`ReadOnlySpan<char>`的方法，我们将能够将`string`、`char[]`数组、`stackalloc
    char[]`或类型为`char*`的未管理指针传递给它（因为在这些对象的内存表示中特定字符跨度的方式是相同的）。
- en: Note
  id: totrans-49
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Since strings are immutable in .NET, you cannot convert a `string` to a `Span<char>`.
    You can only convert it to a `ReadOnlySpan<char>`.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 由于在.NET中字符串是不可变的，因此无法将`string`转换为`Span<char>`。您只能将其转换为`ReadOnlySpan<char>`。
- en: 'We’ve examined two of our requirements from the preceding section: `Span<T>`
    is easier to use than ad hoc storing of an offset and length, and it makes it
    possible to write a single method that can work with data in arrays, strings,
    the stack, or unmanaged memory. This leaves our final requirement: widespread
    support throughout .NET’s runtime libraries. As [Example 18-6](#ex_parse_string_in_situ)
    shows, it is now supported in `int.Parse`, enabling us to fix the problem shown
    in [Example 18-2](#ex_substring_defeating_the_purpose).'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从前一节中检查了两个要求：`Span<T>`比临时存储偏移和长度更容易使用，并且使得能够编写一个可以处理数组、字符串、堆栈或非托管内存中数据的单个方法成为可能。这留下了我们的最后一个要求：在整个.NET运行时库中的广泛支持。正如[示例18-6](#ex_parse_string_in_situ)所示，现在已经在`int.Parse`中支持，使我们能够解决[示例18-2](#ex_substring_defeating_the_purpose)中显示的问题。
- en: Example 18-6\. Parsing integers in a string using `Span<char>`
  id: totrans-52
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例18-6。使用`Span<char>`解析字符串中的整数
- en: '[PRE6]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '`Span<T>` is a relatively new type (it was introduced in 2018; .NET has been
    around since 2002), so although the .NET runtime libraries now support it widely,
    many third-party libraries do not yet support it, and perhaps never will. However,
    it has become increasingly well supported since being introduced, and the situation
    will only improve.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`Span<T>`是一种相对较新的类型（它在2018年被引入；.NET自2002年以来已存在），因此尽管.NET运行时库现在广泛支持它，但许多第三方库尚未支持，也许永远不会支持。然而，自引入以来，它的支持越来越广泛，情况只会变得更好。'
- en: Utility Methods
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实用方法
- en: In addition to the array-like indexer and `Length` properties, `Span<T>` offers
    a few useful methods. The `Clear` and `Fill` methods provide convenient ways to
    initialize all the elements in a span either to the default value for the element
    type or a specific value. Obviously, these are not available on `ReadOnlySpan<T>`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 除了类似数组的索引器和`Length`属性外，`Span<T>`还提供了一些有用的方法。`Clear`和`Fill`方法提供了初始化span中所有元素的便捷方式，可以将它们初始化为元素类型的默认值或特定值。显然，这些方法在`ReadOnlySpan<T>`上不可用。
- en: You may sometimes encounter situations in which you have a span and you need
    to pass its contents to a method that requires an array. Obviously there’s no
    avoiding an allocation in this case, but if you need to do it, you can use the
    `ToArray` method.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，您可能会遇到这样的情况：您有一个跨度（span），需要将其内容传递给需要数组的方法。显然，在这种情况下，无法避免分配，但如果确实需要这样做，可以使用`ToArray`方法。
- en: 'Spans (both normal and read-only) also offer a `TryCopyTo` method, which takes
    as its argument a (non-read-only) span of the same element type. This allows you
    to copy data between spans. This method handles scenarios where the source and
    target spans refer to overlapping ranges within the same container. As the `Try`
    suggests, it’s possible for this method to fail: if the target span is too small,
    this method returns `false`.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: Span（普通和只读）还提供了一个`TryCopyTo`方法，其参数是相同元素类型的（非只读）span。这允许您在span之间复制数据。该方法处理源和目标span引用同一容器内重叠范围的情况。正如`Try`所示，此方法可能失败：如果目标span太小，则此方法返回`false`。
- en: Stack Only
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 仅堆栈
- en: 'The `Span<T>` and `ReadOnlySpan<T>` types are both declared as `ref struct`.
    This means that not only are they value types, they are value types that can live
    only on the stack. So you cannot have fields with span types in a `class`, or
    in any `struct` that is not also a `ref struct`. This also imposes some potentially
    more surprising restrictions. For example, it means you cannot use a span in a
    variable in an `async` method. (These store all their variables as fields in a
    hidden type, enabling them to live on the heap, because asynchronous methods often
    need to outlive their original stack frame. In fact, these methods can even switch
    to a completely different stack altogether, because asynchronous methods can end
    up running on different threads as their execution progresses.) For similar reasons,
    there are restrictions on using spans in anonymous functions and in iterator methods.
    You can use them in local methods, and you can even declare a `ref struct` variable
    in the outer method and use it from the nested one, but with one restriction:
    you must not create a delegate that refers to that local method, because this
    would cause the compiler to move shared variables into an object that lives on
    the heap. (See [Chapter 9](ch09.xhtml#ch_delegates_lambdas_events) for details.)'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`Span<T>`和`ReadOnlySpan<T>`类型都声明为`ref struct`。这意味着它们不仅是值类型，还是只能存在于栈上的值类型。因此你不能在`class`中拥有span类型的字段，也不能在不是`ref
    struct`的任何`struct`中拥有它们。这也施加了一些潜在更令人惊讶的限制。例如，这意味着你不能在`async`方法中的变量中使用span。（这些方法将所有它们的变量存储为字段在隐藏类型中，使得它们可以在堆上存在，因为异步方法经常需要超出它们原始的栈帧的生存期。事实上，这些方法甚至可以切换到完全不同的栈，因为随着执行的进展，异步方法可以在不同的线程上运行。）出于类似的原因，使用span在匿名函数和迭代器方法中也有限制。你可以在局部方法中使用它们，甚至可以在外部方法中声明一个`ref
    struct`变量并从嵌套方法中使用它，但有一个限制：你不能创建一个引用该局部方法的委托，因为这会导致编译器将共享变量移到一个存在于堆上的对象中。（详见[第9章](ch09.xhtml#ch_delegates_lambdas_events)了解详情。）'
- en: This restriction is necessary for .NET to be able to offer the combination of
    array-like performance, type safety, and the flexibility to work with multiple
    different containers. For situations in which this stack-only limitation is problematic,
    we have the `Memory<T>` type.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这种限制对于.NET能够提供类似数组的性能、类型安全性以及与多个不同容器一起工作的灵活性是必要的。对于这种只能在栈上使用的限制有问题的情况，我们有`Memory<T>`类型。
- en: Representing Sequential Elements with Memory<T>
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Memory<T>表示顺序元素
- en: 'The `Memory<T>` type and its counterpart, `ReadOnlyMemory<T>`, represent the
    same basic concept as `Span<T>` and `ReadOnlySpan<T>`: these types provide a uniform
    view over a contiguous sequence of elements of type `T` that could reside in an
    array, unmanaged memory, or, if the element type is `char`, a `string`. But unlike
    spans, these are *not* `ref struct` types, so they can be used anywhere. The downside
    is that this means they cannot offer the same high performance as spans. (It also
    means you cannot create a `Memory<T>` that refers to `stackalloc` memory.)'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`Memory<T>`类型及其对应的`ReadOnlyMemory<T>`类型代表了与`Span<T>`和`ReadOnlySpan<T>`相同的基本概念：这些类型提供了对类型为`T`的连续元素序列的统一视图，这些元素可以位于数组、非托管内存，或者如果元素类型是`char`的话，是一个`string`。但与span不同的是，这些类型不是`ref
    struct`类型，因此可以在任何地方使用。缺点是这意味着它们不能提供与spans相同的高性能。（这也意味着你不能创建一个指向`stackalloc`内存的`Memory<T>`。）'
- en: You can convert a `Memory<T>` to a `Span<T>`, and likewise a `ReadOnlyMemory<T>`
    to a `ReadOnlySpan<T>`, as long as you’re in a context where spans are allowed
    (e.g., in an ordinary method but not an asynchronous one). The conversion to a
    span has a cost. It is not massive, but it is significantly higher than the cost
    of accessing an individual element in a span. (In particular, many of the optimizations
    that make spans attractive only become effective with repeated use of the same
    span.) So if you are going to read or write elements in a `Memory<T>` in a loop,
    you should perform the conversion to `Span<T>` just once, outside of the loop,
    rather than doing it each time around. If you can work entirely with spans, you
    should do so since they offer the best performance. (And if you are not concerned
    with performance, then this is not the chapter for you!)
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 可以将 `Memory<T>` 转换为 `Span<T>`，同样地，可以将 `ReadOnlyMemory<T>` 转换为 `ReadOnlySpan<T>`，只要你处于允许使用
    span 的上下文中（例如，在普通方法中但不是异步方法）。转换为 span 是有成本的。这个成本不是巨大的，但显著高于访问 span 中单个元素的成本。（特别是，使
    span 变得有吸引力的许多优化仅在重复使用相同 span 时才会生效。）因此，如果你要在循环中读取或写入 `Memory<T>` 中的元素，应该在循环外执行一次到
    `Span<T>` 的转换，而不是每次循环都执行。如果完全可以使用 spans 工作，就应该这样做，因为它们提供了最佳的性能。（如果你不关心性能，那么这不适合你！）
- en: ReadOnlySequence<T>
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`ReadOnlySequence<T>`'
- en: The types we’ve looked at so far in this chapter all represent contiguous blocks
    of memory. Unfortunately, data doesn’t always neatly present itself to us in the
    most convenient possible form. For example, on a busy server that is handling
    many concurrent requests, the network messages for requests in progress often
    become interleaved—if a particular request is large enough to need to be split
    across two network packets, it’s entirely possible that after receiving the first
    but before receiving the second of these, one or more packets for other, unrelated
    requests could arrive. So by the time we come to process the contents of the request,
    it might be split across two different chunks of memory. Since span and memory
    values can each represent only a contiguous range of elements, .NET provides another
    type, `ReadOnlySequence`, to represent data that is conceptually a single sequence
    but that has been split into multiple ranges.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在本章中我们看到的类型都表示内存中的连续块。不幸的是，数据并不总是以最方便的形式呈现给我们。例如，在处理许多并发请求的繁忙服务器上，请求正在进行时的网络消息经常变得交错——如果特定请求足够大而需要分成两个网络数据包，那么在接收到第一个数据包但尚未接收到第二个数据包之前，其他不相关请求的一个或多个数据包可能已经到达。因此，当我们来处理请求的内容时，它可能分布在内存的两个不同块中。由于
    Span 和 Memory 值只能表示连续的元素范围，.NET 提供了另一种类型，`ReadOnlySequence`，用于表示在概念上是单一序列但已分成多个范围的数据。
- en: Note
  id: totrans-67
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: There is no corresponding `Sequence<T>`. Unlike spans and memory, this particular
    abstraction is available only in read-only form. That’s because it’s common to
    need to deal with fragmented data as a reader, where you don’t control where the
    data lives, but if you are producing data, you are more likely to be in a position
    to control where it goes.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 不存在相应的 `Sequence<T>`。与 spans 和 memory 不同，这种特定的抽象仅以只读形式存在。这是因为作为读者需要处理碎片化的数据是很常见的，你不能控制数据的位置，但如果你是在生成数据，你更可能能够控制数据的位置。
- en: 'Now that we’ve seen the main types for working with data while minimizing the
    number of allocations, let’s look at how these can all work together to handle
    high volumes of data. To coordinate this kind of processing, we need to look at
    one more feature: pipelines.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了处理数据时最小化分配数量的主要类型，让我们看看如何将它们结合起来处理大量数据。要协调这种处理，我们需要看看另一个特性：管道。
- en: Processing Data Streams with Pipelines
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用管道处理数据流
- en: Everything we’re looking at in this chapter is designed to enable safe, efficient
    processing of large volumes of data. The types we’ve seen so far all represent
    information that is already in memory. We also need to think about how that data
    is going to get into memory in the first place. The preceding section hinted at
    the fact that this can be somewhat messy. The data will very often be split into
    chunks, and not in a way designed for the convenience of the code processing the
    data, because it will likely be arriving either over a network or from a disk.
    If we’re to realize the performance benefits made possible by `Span<T>` and its
    related types, we need to pay close attention to the job of getting data into
    memory in the first place and the way in which this data fetching process cooperates
    with the code that processes the data. Even if you are only going to be writing
    code that consumes data—perhaps you are relying on a framework such as ASP.NET
    Core to get the data into memory for you—it is important to understand how this
    process works.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论的所有内容都旨在实现对大量数据的安全高效处理。到目前为止，我们看到的所有类型都代表已经在内存中的信息。我们还需要考虑如何首先将数据加载到内存中。前一节已经暗示这可能有些混乱。数据往往会被分割成块，但这并不一定是为了方便处理数据的代码而设计的，因为它可能是通过网络传输或从磁盘读取。如果我们要实现由`Span<T>`及其相关类型带来的性能优势，我们需要密切关注首次将数据加载到内存中的工作以及这个数据获取过程如何与处理数据的代码配合工作。即使您只打算编写消费数据的代码——也许您依赖于像ASP.NET
    Core这样的框架将数据加载到内存中——了解这个过程的工作原理也是很重要的。
- en: The `System.Io.Pipelines` NuGet package defines a set of types in a namespace
    of the same name that provide a high-performance system for loading data from
    some source that tends to split data into inconveniently sized chunks, and passing
    that data over to code that wants to be able to process it in situ using spans.
    [Figure 18-2](#fig_PipelineOverview) shows the main participants in a pipeline-based
    process.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`System.Io.Pipelines` NuGet包在同名命名空间中定义了一组类型，提供了一个高性能的系统，用于从某些将数据分割为不便大小块的源加载数据，并将该数据传递给希望能够使用跨度在原地处理它的代码。[图 18-2](#fig_PipelineOverview)展示了基于管道的流程的主要参与者。'
- en: 'At the heart of this is the `Pipe` class. It offers two properties: `Writer`
    and `Reader`. The first returns a `PipeWriter`, which is used by the code that
    loads the data into memory. (This often doesn’t need to be application-specific.
    For example, in a web application, you can let ASP.NET Core control the writer
    on your behalf.) The `Reader` property’s type is, predictably, `PipeReader`, and
    this is most likely to be the part your code interacts with.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 其核心是`Pipe`类。它提供了两个属性：`Writer`和`Reader`。第一个返回一个`PipeWriter`，用于将数据加载到内存中的代码中（通常不需要特定于应用程序。例如，在Web应用程序中，可以让ASP.NET
    Core代表您控制写入操作）。`Reader`属性的类型可预测地是`PipeReader`，这很可能是您的代码与之交互的部分。
- en: '![An overview of the participants in a pipeline](assets/pc10_1802.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![管道参与者概览](assets/pc10_1802.png)'
- en: Figure 18-2\. Pipeline overview
  id: totrans-75
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 18-2\. 管道概述
- en: The basic process for reading data from a pipe is as follows. First, you call
    `Pipe​Rea⁠der.⁠Rea⁠dAs⁠ync`. This returns a task,^([3](ch18.xhtml#idm45884782152672))
    because if no data is available yet, you will need to wait until the data source
    supplies the writer with some data. Once data is available, the task will provide
    a `ReadResult` object. This supplies a `ReadOnlySequence<T>`, which presents the
    available data as one or more `ReadOnlySpan<T>` values. The number of spans will
    depend on how fragmented the data is. If it’s all conveniently in one place in
    memory, there will be just one span, but code using a reader needs to be able
    to cope with more. Your code should then process as much of the available data
    as it can. Once it has done this, it calls the reader’s `AdvanceTo` to tell it
    how much of the data your code has been able to process. Then, if the `ReadResult.IsComplete`
    property is false, we will repeat these steps again from the call to `ReadAsync`.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 从管道读取数据的基本过程如下。首先，调用`PipeReader.ReadAsync`。这会返回一个任务^([3](ch18.xhtml#idm45884782152672))，因为如果尚无可用数据，则需要等待数据源向写入器提供数据。一旦数据可用，任务将提供一个`ReadResult`对象。这个对象提供一个`ReadOnlySequence<T>`，它将可用数据呈现为一个或多个`ReadOnlySpan<T>`值。跨度的数量取决于数据的分片情况。如果数据方便地位于内存中的一个位置，那么将只有一个跨度，但是使用读取器的代码需要能够处理更多跨度。您的代码应该尽可能处理尽可能多的可用数据。处理完毕后，调用读取器的`AdvanceTo`方法，告诉它您的代码已经处理了多少数据。然后，如果`ReadResult.IsComplete`属性为false，则从调用`ReadAsync`开始再次重复这些步骤。
- en: 'An important detail of this is that we are allowed to tell the `PipeReader`
    that we couldn’t process everything it gave us. This would normally be because
    the information got sliced into pieces, and we need to see some of the next chunk
    before we can fully process everything in the current one. For example, a JSON
    message large enough to need to be split across several network packets will probably
    end up with splits in inconvenient places. So you might find that the first chunk
    looks like this:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一个重要细节是，我们可以告诉`PipeReader`我们无法处理它给出的所有内容。这通常是因为信息被切成了几部分，我们需要查看下一个块的一部分才能完全处理当前块中的所有内容。例如，一个大到需要在几个网络数据包中分割的JSON消息可能会以不方便的位置分割。因此，您可能会发现第一个块看起来像这样：
- en: '[PRE7]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'And the second like this:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个块可能是这样的：
- en: '[PRE8]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In practice the chunks would be bigger, but this illustrates the basic problem:
    the chunks that a `PipeReader` returns are likely to slice across the middle of
    important features. With most .NET APIs, you never have to deal with this kind
    of mess because everything has been cleaned up and reassembled by the time you
    see it, but the price you pay for that is the allocation of new strings to hold
    the recombined results. If you want to avoid those allocations, you have to handle
    these challenges.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这些块会更大，但这说明了基本问题：`PipeReader`返回的块可能会横跨重要特征的中间部分。使用大多数.NET API时，您通常不必处理这种混乱，因为一切都已经被清理和重新组合，但为此付出的代价是分配新字符串来保存重新组合的结果。如果要避免这些分配，则必须处理这些挑战。
- en: 'There are a couple of ways to deal with this. One is for code reading data
    to maintain enough state to be able to stop and later restart at any point in
    the sequence. So code processing this JSON might choose to remember that it is
    partway through an object and that it’s in the middle of processing a property
    whose name starts with `prope`. But `PipeReader` offers an alternative. Code processing
    these examples could report with its call to `AdvanceTo` that it has consumed
    everything up to the first comma. If you do that, the `Pipe` will remember that
    we’re not yet finished with this first block, and when the next call to `ReadAsync`
    completes, the `ReadOnlySequence<T>` in `ReadResult.Buffer` will now include at
    least two spans: the first span will point into the same block of memory as last
    time, but now its offset will be set to where we got to last time—that first span
    will refer to the `"prope` text at the end of the first block. And then the second
    span will refer to the text in the second chunk.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 处理这个问题有几种方法。一种方法是，读取数据的代码保持足够的状态，能够在序列的任何点停止，并稍后重新启动。因此，处理这个 JSON 的代码可能选择记住它正在处理一个对象的中间部分，并且正在处理一个属性，其名称以
    `prope` 开头。但 `PipeReader` 提供了另一种选择。处理这些示例的代码可以通过调用 `AdvanceTo` 报告，它已经消耗了直到第一个逗号的所有内容。如果这样做，`Pipe`
    将记住我们尚未完成这个第一个块，当下一个 `ReadAsync` 调用完成时，`ReadResult.Buffer` 中的 `ReadOnlySequence<T>`
    将包含至少两个 spans：第一个 span 将指向与上次相同的内存块，但现在其偏移量将设置为上次到达的位置—该第一个 span 将指向第一个块末尾的 `"prope`
    文本。然后第二个 span 将指向第二块的文本。
- en: The advantage of this second approach is that the code processing the data doesn’t
    need to remember as much between calls to `ReadAsync`, because it knows it’ll
    be able to go back and look at the previously unprocessed data again once the
    next chunk arrives, at which point it should now be able to make sense of it.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这种第二种方法的优势在于，处理数据的代码在调用 `ReadAsync` 时不需要记住太多状态，因为它知道一旦下一个块到达，它可以回头看之前未处理的数据，此时它应该能够理解它。
- en: In practice, this particular example is fairly easy to cope with because there’s
    a type in the runtime libraries called `Utf8JsonReader` that can handle all the
    awkward details around chunk boundaries for us. Let’s look at an example.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，这个特定的例子相当容易处理，因为运行时库中有一个叫做 `Utf8JsonReader` 的类型，它可以处理围绕块边界的所有棘手细节。让我们看一个例子。
- en: Processing JSON in ASP.NET Core
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 ASP.NET Core 中处理 JSON
- en: Suppose you are developing a web service that needs to handle HTTP requests
    containing JSON. This is a pretty common scenario. [Example 18-7](#ex_json_http_handler)
    shows the typical way to do this in ASP.NET Core. This is reasonably straightforward,
    but it does not use any of the low-allocation mechanisms discussed in this chapter,
    so this forces ASP.NET Core to allocate multiple objects for each request.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您正在开发一个需要处理包含 JSON 的 HTTP 请求的 Web 服务。这是一个非常常见的场景。[例子 18-7](#ex_json_http_handler)
    展示了在 ASP.NET Core 中处理这种情况的典型方式。这相当直接，但它没有使用本章讨论的低分配机制中的任何一个，因此这迫使 ASP.NET Core
    为每个请求分配多个对象。
- en: Example 18-7\. Handling JSON in HTTP requests
  id: totrans-87
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 例子 18-7\. 处理 HTTP 请求中的 JSON
- en: '[PRE9]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Before we look at how to change it, for readers not familiar with ASP.NET Core,
    I will quickly explain what’s happening in this example. The `CreateJob` method
    is annotated with attributes telling ASP.NET Core that this will handle HTTP POST
    requests where the URL path is `/jobs/create`. The `[FromBody]` attribute on the
    method’s argument indicates that we expect the body of the request to contain
    data in the form described by the `JobDescription` type. ASP.NET Core can be configured
    to handle various data formats, but if you go with the defaults, it will expect
    JSON.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们讨论如何改变它之前，对于不熟悉 ASP.NET Core 的读者，我会快速解释这个例子中发生了什么。`CreateJob` 方法被标注了属性，告诉
    ASP.NET Core 这将处理 URL 路径为 `/jobs/create` 的 HTTP POST 请求。方法参数上的 `[FromBody]` 属性指示我们期望请求体中包含符合
    `JobDescription` 类型描述的数据。ASP.NET Core 可以配置处理各种数据格式，但默认情况下，它会期望 JSON 格式。
- en: This example is therefore telling ASP.NET Core that for each POST request to
    `/jobs/create`, it should construct a `JobDescription` object, populating its
    `Dep⁠art⁠ment​Id` and `JobCategory` from properties of the same name in JSON in
    the incoming request body.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这个例子告诉 ASP.NET Core，对于每个 POST 请求到 `/jobs/create`，它应该构造一个 `JobDescription`
    对象，并从传入请求体中的 JSON 的同名属性中填充其 `Dep⁠art⁠ment​Id` 和 `JobCategory`。
- en: In other words, we’re asking ASP.NET Core to allocate two objects—a `Job​Des⁠cri⁠pti⁠on`
    and a `string`—for each request, each of which will contain copies of information
    that was in the body of the incoming request. (The other property, `DepartmentId`,
    is an `int`, and since that’s a value type, it lives inside the `Job​Des⁠crip⁠tion`
    object.) And for most applications that will be fine—a couple of allocations is
    not normally anything to worry about in the course of handling a single web request.
    However, in more realistic examples with more complex requests, we might then
    be looking at a much larger number of properties, and if you need to handle a
    very high volume of requests, the copying of data into a `string` for each property
    can start to cause enough extra work for the GC that it becomes a performance
    problem.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，我们要求 ASP.NET Core 为每个请求分配两个对象——`Job​Des⁠cri⁠pti⁠on` 和一个 `string`——每个对象都包含传入请求主体中的信息的副本。（另一个属性
    `DepartmentId` 是一个 `int`，因为它是值类型，所以存在于 `Job​Des⁠crip⁠tion` 对象内。）对于大多数应用程序来说，这是可以接受的——在处理单个
    web 请求过程中分配几个对象通常不是什么问题。然而，在更复杂的请求的更现实的示例中，我们可能需要处理更多的属性，如果您需要处理大量请求，为每个属性复制数据到
    `string` 中可能会导致额外的 GC 工作，从而成为性能问题。
- en: '[Example 18-8](#ex_frugal_json_http_handler) shows how we can avoid these allocations
    using the various features described in the preceding sections of this chapter.
    It makes the code a good deal more complex, demonstrating why you should only
    apply these kinds of techniques in cases where you have established that GC overhead
    is high enough that the extra development effort is justified by the performance
    improvements.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 18-8](#ex_frugal_json_http_handler) 展示了我们如何使用本章前几节描述的各种功能来避免这些分配。这使得代码变得更加复杂，演示了为什么只有在已经确定
    GC 开销足够高，开发额外工作可以通过性能改进来证明其正当性的情况下，才应该应用这些技术。'
- en: Example 18-8\. Handling JSON without allocations
  id: totrans-93
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 18-8\. 处理 JSON 而不进行分配
- en: '[PRE10]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Instead of defining an argument with a `[FromBody]` attribute, this method works
    directly with the `this.Request.BodyReader` property. (Inside an ASP.NET Core
    MVC controller class, `this.Request` returns an object representing the request
    being handled.) This property’s type is `PipeReader`, the consumer side of a `Pipe`.
    ASP.NET Core creates the pipe, and it manages the data production side, feeding
    data from incoming requests into the associated `PipeWriter`.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 不使用 `[FromBody]` 属性定义参数，该方法直接使用 `this.Request.BodyReader` 属性。在 ASP.NET Core
    MVC 控制器类中，`this.Request` 返回表示正在处理的请求的对象。此属性的类型是 `PipeReader`，是 `Pipe` 的消费端。ASP.NET
    Core 创建管道并管理数据生成端，将传入请求的数据提供给关联的 `PipeWriter`。
- en: 'As the property name suggests, this particular `PipeReader` enables us to read
    the contents of the HTTP request’s body. By reading the data this way, we make
    it possible for ASP.NET Core to present the request body to us in situ: our code
    will be able to read the data directly from wherever it happened to end up in
    memory once the computer’s network card received it. (In other words, no copies,
    and no additional GC overhead.)'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 正如属性名所示，这个特定的 `PipeReader` 使我们能够读取 HTTP 请求体的内容。通过这种方式读取数据，我们使 ASP.NET Core 能够直接将请求体在原地呈现给我们：我们的代码将能够直接从计算机网络卡接收到的内存中的数据读取。（换句话说，没有复制，也没有额外的
    GC 开销。）
- en: 'The `while` loop in `CreateJobFrugalAsync` performs the same process you’ll
    see with any code that reads data from a `PipeReader`: it calls `ReadAsync`, processes
    the data that returns, and calls `AdvanceTo` to let the `PipeReader` know how
    much of that data it was able to process. We then check the `IsComplete` property
    of the `ReadResult` returned by `ReadAsync`, and if that is `false`, then we go
    round one more time.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`CreateJobFrugalAsync` 中的 `while` 循环执行与读取 `PipeReader` 数据的任何代码相同的过程：调用 `ReadAsync`，处理返回的数据，然后调用
    `AdvanceTo` 来告知 `PipeReader` 它能够处理多少数据。然后我们检查 `ReadAsync` 返回的 `ReadResult` 的 `IsComplete`
    属性，如果为 `false`，则再次循环一次。'
- en: '[Example 18-8](#ex_frugal_json_http_handler) uses the `Utf8JsonReader` type
    to read the data. As the name suggests, this works directly with text in UTF-8
    encoding. This alone can provide a significant performance improvement: JSON messages
    are commonly sent with this encoding, but .NET strings use UTF-16\. So one of
    the jobs that the simpler [Example 18-7](#ex_json_http_handler) forced ASP.NET
    to do was convert any strings from UTF-8 to UTF-16\. On the other hand, we’ve
    lost some flexibility. The simpler, slower approach has the benefit of being able
    to adapt to incoming requests in more formats: if a client chose to send its request
    in something other than UTF-8—perhaps UTF-16 or UCS-32, or even a non-Unicode
    encoding such as ISO-8859-1—our handler could cope with any of them, because ASP.NET
    Core can do the string conversions for us. But since [Example 18-8](#ex_frugal_json_http_handler)
    works directly with the data in the form the client transmitted, using a type
    that only understands UTF-8, we have traded off that flexibility in exchange for
    higher performance.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 18-8](#ex_frugal_json_http_handler) 使用 `Utf8JsonReader` 类型来读取数据。正如其名称所示，它直接处理
    UTF-8 编码的文本。这一点单独就能带来显著的性能提升：JSON 消息通常使用这种编码发送，但 .NET 字符串使用 UTF-16。因此，简单的 [示例 18-7](#ex_json_http_handler)
    强制 ASP.NET 将任何字符串从 UTF-8 转换为 UTF-16。另一方面，我们失去了一些灵活性。简单且较慢的方法有一个好处，即能够适应更多格式的传入请求：如果客户端选择以其他格式发送其请求，如
    UTF-16 或 UCS-32，甚至是非 Unicode 编码如 ISO-8859-1，我们的处理程序都可以处理，因为 ASP.NET Core 可以为我们进行字符串转换。但由于
    [示例 18-8](#ex_frugal_json_http_handler) 直接使用客户端传输数据的形式与仅理解 UTF-8 的类型一起工作，我们为了更高的性能而牺牲了这种灵活性。'
- en: '`Utf8JsonReader` is able to handle the tricky chunking issues for us—if an
    incoming request ends up being split across multiple buffers in memory because
    it was too large to fit in a single network packet, `Utf8JsonReader` is able to
    cope. In the event of an unhelpfully placed split, it will process what it can,
    and then the `JsonReaderState` value it returns through its `CurrentState` will
    report a `Position` indicating the first unprocessed character. We pass this to
    `PipeReader.AdvanceTo`. The next call to `PipeReader.ReadAsync` will return only
    when there is more data, but its `ReadResult.Buffer` will also include the previously
    unconsumed data.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`Utf8JsonReader` 能够处理棘手的分块问题——如果一个传入的请求因为太大而被分割成多个内存缓冲区，`Utf8JsonReader` 能够处理。在遇到不合适的分割时，它会处理它能处理的部分，然后通过其
    `CurrentState` 返回的 `JsonReaderState` 值会报告一个 `Position`，指示第一个未处理的字符。我们将其传递给 `PipeReader.AdvanceTo`。下一次调用
    `PipeReader.ReadAsync` 仅在有更多数据时返回，但其 `ReadResult.Buffer` 还将包括之前未消耗的数据。'
- en: Like the `ReadOnlySpan<T>` type it uses internally when reading data, `Utf8JsonReader`
    is a `ref struct` type, meaning that it cannot live on the heap. This means it
    cannot be used in an `async` method, because `async` methods store all of their
    local variables on the heap. That is why this example has a separate method, `ProcessBuffer`.
    The outer `CreateJobFrugalAsync` method has to be `async` because the streaming
    nature of the `PipeReader` type means that its `ReadAsync` method requires us
    to use `await`. But the `Utf8JsonReader` cannot be used in an `async` method,
    so we end up having to split our logic across two methods.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于在读取数据时内部使用的 `ReadOnlySpan<T>` 类型，`Utf8JsonReader` 是一个 `ref struct` 类型，意味着它不能存在于堆上。这意味着它不能在
    `async` 方法中使用，因为 `async` 方法将所有本地变量存储在堆上。这就是为什么这个示例有一个单独的方法 `ProcessBuffer`。外部的
    `CreateJobFrugalAsync` 方法必须是 `async` 的，因为 `PipeReader` 类型的流式特性意味着它的 `ReadAsync`
    方法要求我们使用 `await`。但 `Utf8JsonReader` 不能在 `async` 方法中使用，所以我们最终不得不在两个方法之间拆分我们的逻辑。
- en: Note
  id: totrans-101
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: When splitting your pipeline processing into an outer `async` reader loop and
    an inner method that avoids async in order to use `ref struct` types, it can be
    convenient to make the inner method a local method, as [Example 18-8](#ex_frugal_json_http_handler)
    does. This enables it to access variables declared in the outer method. You might
    be wondering whether this causes a hidden extra allocation—to enable sharing of
    variables in this way, the compiler generates a type, storing shared variables
    in fields in that type and not as conventional stack-based variables. With lambdas
    and other anonymous methods, this type will indeed cause an additional allocation,
    because it needs to be a heap-based type so that it can outlive the parent method.
    However, with local methods, the compiler uses a `struct` to hold the shared variables,
    which it passes by reference to the inner method, thus avoiding any extra allocation.
    This is possible because the compiler can determine that all calls to the local
    method will return before the outer method returns.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 当将管道处理分为外部 `async` 读取循环和内部方法时，为了使用 `ref struct` 类型，将内部方法作为本地方法会很方便，就像 [示例 18-8](#ex_frugal_json_http_handler)
    中所做的那样。这使得它可以访问在外部方法中声明的变量。你可能会想知道这是否会导致隐藏的额外分配——为了使这种方式的变量共享成为可能，编译器会生成一个类型，将共享变量存储在该类型的字段中，而不是传统的基于堆栈的变量。对于
    lambda 和其他匿名方法，这种类型确实会导致额外的分配，因为它需要是一个基于堆的类型，以便能够比父方法更长久地存在。然而，对于本地方法，编译器使用 `struct`
    来保存共享变量，并通过引用传递给内部方法，从而避免任何额外的分配。这是可能的，因为编译器可以确定本地方法的所有调用都会在外部方法返回之前返回。
- en: When using `Utf8JsonReader`, our code has to be prepared to receive the content
    in whatever order it happens to arrive. We can’t write code that tries to read
    the properties in an order that is convenient for us, because that would rely
    on something holding those properties and their values in memory. (If you tried
    to rely on going back to the underlying data to retrieve particular properties
    on demand, you might find that the property you wanted was in an earlier chunk
    that’s no longer available.) This defeats the whole goal of minimizing allocations.
    If you want to avoid allocations, your code needs to be flexible enough to handle
    the properties in whatever order they appear.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 `Utf8JsonReader` 时，我们的代码必须准备好按照内容到达的任意顺序接收数据。我们不能编写试图按照对我们方便的顺序读取属性的代码，因为那样会依赖于某种方式将这些属性及其值保存在内存中（如果试图依赖于返回底层数据以按需检索特定属性，可能会发现想要的属性位于早期不再可用的数据块中）。这违背了最小化分配内存的整体目标。如果你想避免分配内存，你的代码需要足够灵活，能够处理出现的任何顺序的属性。
- en: So the `ProcessBuffer` code in [Example 18-8](#ex_frugal_json_http_handler)
    just looks at each JSON element as it comes and works out whether it’s of interest.
    This means that when looking for particular property values, we have to notice
    the `PropertyName` element, and then remember that this was the last thing we
    saw, so that we know how to handle the `Number` or `String` element that follows,
    containing the value.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`ProcessBuffer` 中的代码在 [示例 18-8](#ex_frugal_json_http_handler) 中只是依次查看每个 JSON
    元素，并确定它是否感兴趣。这意味着在查找特定属性值时，我们必须注意 `PropertyName` 元素，然后记住这是我们最后看到的内容，以便知道如何处理后续的
    `Number` 或 `String` 元素，其中包含值。
- en: 'One strikingly odd feature of this code is the way it checks for particular
    strings. It needs to recognize properties of interest (`JobCategory` and `DepartmentId`
    in this example). But we can’t just use normal string comparison. While it’s possible
    to retrieve property names and string values as .NET strings, doing so defeats
    the main purpose of using `Utf8JsonReader`: if you obtain a `string`, the CLR
    has to allocate space for that string on the heap and will eventually have to
    garbage collect the memory. (In this example, every acceptable incoming string
    is known in advance. In some scenarios there will be user-supplied strings whose
    values you will need to perform further processing on, and in those cases, you
    may just need to accept the costs of allocating an actual `string`.) So instead
    we end up performing binary comparisons. Notice that we’re working entirely in
    UTF-8 encoding, and not the UTF-16 encoding used by .NET’s `string` type. (The
    various static fields, such as `Utf8TextJobCategory` and `Utf8TextDepartmentId`,
    are all byte arrays created through `Encoding.UTF8` from the `System.Text` namespace.)
    That’s because all of this code works directly against the request’s payload in
    the form in which it arrived over the network, in order to avoid unnecessary copying.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的一个显著奇特特性是它检查特定字符串的方式。它需要识别感兴趣的属性（例如这个例子中的 `JobCategory` 和 `DepartmentId`）。但我们不能简单地使用正常的字符串比较。虽然可以将属性名和字符串值作为
    .NET 字符串检索出来，但这样做会破坏使用 `Utf8JsonReader` 的主要目的：如果获取一个 `string`，CLR 必须在堆上为该字符串分配空间，并最终必须对内存进行垃圾回收。（在这个例子中，每个可接受的输入字符串都是事先已知的。在某些情况下，会有用户提供的字符串，你需要对其进行进一步处理，而在这些情况下，你可能只需接受分配实际
    `string` 的成本。）因此，我们最终进行二进制比较。请注意，我们完全使用 UTF-8 编码，而不是 .NET 的 `string` 类型所使用的 UTF-16
    编码。（各种静态字段，如 `Utf8TextJobCategory` 和 `Utf8TextDepartmentId`，都是通过 `System.Text`
    命名空间的 `Encoding.UTF8` 创建的字节数组。）这是因为所有这些代码直接针对请求通过网络到达时的有效载荷的形式进行操作，以避免不必要的复制。
- en: Summary
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: APIs that break data down into the constituent components can be very convenient
    to use, but this convenience comes at a price. Each time we want some subelement
    represented either as a string or a child object, we cause another object to be
    allocated on the GC heap. The cumulative cost of these allocations (and the corresponding
    work to recover the memory once they are no longer in use) can be damaging in
    some very performance-sensitive applications. They can also be significant in
    cloud applications or high-volume data processing, where you might be paying for
    the amount of processing work you do—reducing CPU or memory usage can have a nontrivial
    effect on cost.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 将数据拆分为组成部分的 API 可以非常方便地使用，但这种便利性是有代价的。每当我们想要将某些子元素表示为字符串或子对象时，我们都会在 GC 堆上分配另一个对象。这些分配的累积成本（以及一旦它们不再使用时恢复内存的相应工作）在一些对性能非常敏感的应用程序中可能会造成损害。它们在云应用程序或高体积数据处理中也可能很显著，因为您可能会根据您执行的处理工作量来付费——减少
    CPU 或内存使用量可能对成本产生非常重要的影响。
- en: The `Span<T>` type and the related types discussed in this chapter make it possible
    to work with data wherever it already resides in memory. This typically requires
    rather more complex code, but in cases where the payoff justifies the work, these
    features make it possible for C# to tackle whole classes of problems for which
    it would previously have been too slow.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`Span<T>` 类型及本章讨论的相关类型使得可以直接在内存中处理数据。这通常需要更复杂的代码，但在回报能够证明工作成本值得的情况下，这些特性使得
    C# 能够解决以前速度太慢而无法解决的一类问题。'
- en: Thank you for reading this book, and congratulations for making it to the end.
    I hope you enjoy using C#, and I wish you every success with your future projects.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 感谢您阅读本书，并祝贺您成功完成。希望您享受使用C#，并祝您在未来的项目中取得成功。
- en: '^([1](ch18.xhtml#idm45884782468272-marker)) .NET Core and .NET do not store
    the pointer and offset separately: instead, a span just points directly to the
    data of interest. The version of `Span<T>` available for .NET Framework needs
    to maintain the pointer separately to ensure GC handles spans correctly, because
    its CLR does not have the same modifications for supporting spans that .NET Core
    has.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch18.xhtml#idm45884782468272-marker)) .NET Core 和 .NET 并不分开存储指针和偏移量：相反，一个
    span 直接指向感兴趣的数据。为了确保 .NET Framework 上可用的 `Span<T>` 正确处理 GC，它需要单独维护指针，因为其 CLR 没有支持
    span 的相同修改。
- en: '^([2](ch18.xhtml#idm45884782266080-marker)) That said, it is possible to perform
    this kind of conversion explicitly—the `MemoryMarshal` class offers methods that
    can take a span of one type and return another span that provides a view over
    the same underlying memory, interpreted as containing a different element type.
    But it is unlikely to be useful in this case: converting a `ReadOnlySpan<char>`
    to a `ReadOnlySpan<int>` would produce a span with half the number of elements,
    where each `int` contained pairs of adjacent `char` values.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch18.xhtml#idm45884782266080-marker)) 话虽如此，可以显式执行这种转换——`MemoryMarshal`
    类提供了方法，可以接受一个类型的 span 并返回另一个 span，该 span 提供对相同底层内存的视图，解释为包含不同元素类型的内存。但在这种情况下，这种转换可能不太有用：将
    `ReadOnlySpan<char>` 转换为 `ReadOnlySpan<int>` 将产生一个元素数量减半的 span，其中每个 `int` 包含相邻
    `char` 值的对。
- en: ^([3](ch18.xhtml#idm45884782152672-marker)) It is a `ValueTask<ReadResult>`
    because the purpose of this exercise is to minimize allocations. `ValueTask<T>`
    was described in [Chapter 16](ch16.xhtml#ch_multithreading).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: ^([3](ch18.xhtml#idm45884782152672-marker)) 这是一个 `ValueTask<ReadResult>`，因为这个练习的目的是尽量减少分配。`ValueTask<T>`
    在 [第16章](ch16.xhtml#ch_multithreading) 中有描述。
