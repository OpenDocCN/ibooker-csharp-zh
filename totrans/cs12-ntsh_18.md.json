["```cs\nType t1 = DateTime.Now.GetType();     // Type obtained at runtime\nType t2 = typeof (DateTime);          // Type obtained at compile time\n```", "```cs\nType t3 = typeof (DateTime[]);          // 1-d Array type\nType t4 = typeof (DateTime[,]);         // 2-d Array type\nType t5 = typeof (Dictionary<int,int>); // Closed generic type\nType t6 = typeof (Dictionary<,>);       // Unbound generic type\n```", "```cs\nType t = Assembly.GetExecutingAssembly().GetType (\"Demos.TestProgram\");\n```", "```cs\nType t = Type.GetType (\"System.Int32, System.Private.CoreLib\");\n```", "```cs\nType stringType = typeof (string);\nstring name     = stringType.Name;          // String\nType baseType   = stringType.BaseType;      // typeof(Object)\nAssembly assem  = stringType.Assembly;      // System.Private.CoreLib\nbool isPublic   = stringType.IsPublic;      // true\n```", "```cs\nType stringType = typeof(string);\nstring name = stringType.Name;\nType baseType = stringType.GetTypeInfo().BaseType;\nAssembly assem = stringType.GetTypeInfo().Assembly;\nbool isPublic = stringType.GetTypeInfo().IsPublic;\n```", "```cs\nType simpleArrayType = typeof (int).MakeArrayType();\nConsole.WriteLine (simpleArrayType == typeof (int[]));     // True\n```", "```cs\nType cubeType = typeof (int).MakeArrayType (3);       // cube shaped\nConsole.WriteLine (cubeType == typeof (int[,,]));     // True\n```", "```cs\nType e = typeof (int[]).GetElementType();     // e == typeof (int)\n```", "```cs\nint rank = typeof (int[,,]).GetArrayRank();   // 3\n```", "```cs\nforeach (Type t in typeof (System.Environment).GetNestedTypes())\n  Console.WriteLine (t.FullName);\n\nOUTPUT: System.Environment+SpecialFolder\n```", "```cs\nforeach (TypeInfo t in typeof (System.Environment).GetTypeInfo()\n                                                  .DeclaredNestedTypes)\n  Debug.WriteLine (t.FullName);\n```", "```cs\nType t = typeof (System.Environment.SpecialFolder);\nConsole.WriteLine (t.IsPublic);                      // False\nConsole.WriteLine (t.IsNestedPublic);                // True\n```", "```cs\nType t = typeof (System.Text.StringBuilder);\n\nConsole.WriteLine (t.Namespace);      // System.Text\nConsole.WriteLine (t.Name);           // StringBuilder\nConsole.WriteLine (t.FullName);       // System.Text.StringBuilder\n```", "```cs\nType t = typeof (System.Environment.SpecialFolder);\n\nConsole.WriteLine (t.Namespace);      // System\nConsole.WriteLine (t.Name);           // SpecialFolder\nConsole.WriteLine (t.FullName);       // System.Environment+SpecialFolder\n```", "```cs\nType t = typeof (Dictionary<,>); // Unbound\nConsole.WriteLine (t.Name);      // Dictionary'2\nConsole.WriteLine (t.FullName);  // System.Collections.Generic.Dictionary'2\n```", "```cs\nConsole.WriteLine (typeof (Dictionary<int,string>).FullName);\n\n// OUTPUT:\nSystem.Collections.Generic.Dictionary`2[[System.Int32, \nSystem.Private.CoreLib, Version=4.0.0.0, Culture=neutral,\nPublicKeyToken=7cec85d7bea7798e],[System.String, System.Private.CoreLib,\nVersion=4.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]]\n```", "```cs\nConsole.WriteLine (typeof ( int[]  ).Name);      // Int32[]\nConsole.WriteLine (typeof ( int[,] ).Name);      // Int32[,]\nConsole.WriteLine (typeof ( int[,] ).FullName);  // System.Int32[,]\n```", "```cs\nConsole.WriteLine (typeof (byte*).Name);     // Byte*\n```", "```cs\npublic void RefMethod (ref int p)\n{\n  Type t = MethodInfo.GetCurrentMethod().GetParameters()[0].ParameterType;\n  Console.WriteLine (t.Name);    // Int32&\n}\n```", "```cs\nType base1 = typeof (System.String).BaseType;\nType base2 = typeof (System.IO.FileStream).BaseType;\n\nConsole.WriteLine (base1.Name);     // Object\nConsole.WriteLine (base2.Name);     // Stream\n```", "```cs\nforeach (Type iType in typeof (Guid).GetInterfaces())\n  Console.WriteLine (iType.Name);\n\n*IFormattable*\n*IComparable*\n*IComparable'1*\n*IEquatable'1*\n```", "```cs\nobject obj  = Guid.NewGuid();\nType target = typeof (IFormattable);\n\nbool isTrue   = obj is IFormattable;             // Static C# operator\nbool alsoTrue = target.IsInstanceOfType (obj);   // Dynamic equivalent\n```", "```cs\nType target = typeof (IComparable), source = typeof (string);\nConsole.WriteLine (target.IsAssignableFrom (source));         // True\n```", "```cs\nint i = (int) Activator.CreateInstance (typeof (int));\n\nDateTime dt = (DateTime) Activator.CreateInstance (typeof (DateTime),\n                                                   2000, 1, 1);\n```", "```cs\n// Fetch the constructor that accepts a single parameter of type string:\nConstructorInfo ci = typeof (X).GetConstructor (new[] { typeof (string) });\n\n// Construct the object using that overload, passing in null:\nobject foo = ci.Invoke (new object[] { null });\n```", "```cs\nConstructorInfo ci = typeof (X).GetTypeInfo().DeclaredConstructors\n  .FirstOrDefault (c =>\n     c.GetParameters().Length == 1 && \n     c.GetParameters()[0].ParameterType == typeof (string));\n```", "```cs\nclass Program\n{\n  delegate int IntFunc (int x);\n\n  static int Square (int x) => x * x;        // Static method\n  int        Cube   (int x) => x * x * x;    // Instance method\n\n  static void Main()\n  {\n    Delegate staticD = Delegate.CreateDelegate\n      (typeof (IntFunc), typeof (Program), \"Square\");\n\n    Delegate instanceD = Delegate.CreateDelegate\n      (typeof (IntFunc), new Program(), \"Cube\");\n\n    Console.WriteLine (staticD.DynamicInvoke (3));      // 9\n    Console.WriteLine (instanceD.DynamicInvoke (3));    // 27\n  }\n}\n```", "```cs\nIntFunc f = (IntFunc) staticD;\nConsole.WriteLine (f(3));         // 9 *(but much faster!)*\n```", "```cs\nType closed = typeof (List<int>);\nList<int> list = (List<int>) Activator.CreateInstance (closed);  // OK\n\nType unbound   = typeof (List<>);\nobject anError = Activator.CreateInstance (unbound);    // Runtime error\n```", "```cs\nType unbound = typeof (List<>);\nType closed = unbound.MakeGenericType (typeof (int));\n```", "```cs\nType unbound2 = closed.GetGenericTypeDefinition();  // unbound == unbound2\n```", "```cs\nType nullable = typeof (bool?);\nConsole.WriteLine (\n  nullable.IsGenericType &&\n  nullable.GetGenericTypeDefinition() == typeof (Nullable<>));   // True\n```", "```cs\nConsole.WriteLine (closed.GetGenericArguments()[0]);     // System.Int32\nConsole.WriteLine (nullable.GetGenericArguments()[0]);   // System.Boolean\n```", "```cs\nConsole.WriteLine (unbound.GetGenericArguments()[0]);      // T\n```", "```cs\nclass Foo<T>\n{\n  public void Test()\n    => Console.Write (GetType().IsGenericTypeDefinition);  \n}\n```", "```cs\nclass Walnut\n{\n  private bool cracked;\n  public void Crack() { cracked = true; }\n}\n```", "```cs\nMemberInfo[] members = typeof (Walnut).GetMembers();\nforeach (MemberInfo m in members)\n  Console.WriteLine (m);\n```", "```cs\nVoid Crack()\nSystem.Type GetType()\nSystem.String ToString()\nBoolean Equals(System.Object)\nInt32 GetHashCode()\nVoid .ctor()\n```", "```cs\nMemberInfo[] m = typeof (Walnut).GetMember (\"Crack\");\nConsole.WriteLine (m[0]);                              // Void Crack()\n```", "```cs\nAll           Custom        Field        NestedType     TypeInfo\nConstructor   Event         Method       Property\n```", "```cs\n// MethodInfo is a subclass of MemberInfo; see FigureÂ 18-1.\n\nMethodInfo test = typeof (Program).GetMethod (\"ToString\");\nMethodInfo obj  = typeof (object) .GetMethod (\"ToString\");\n\nConsole.WriteLine (test.DeclaringType);      // System.Object\nConsole.WriteLine (obj.DeclaringType);       // System.Object\n\nConsole.WriteLine (test.ReflectedType);      // Program\nConsole.WriteLine (obj.ReflectedType);       // System.Object\n\nConsole.WriteLine (test == obj);             // False\n```", "```cs\nConsole.WriteLine (test.MethodHandle == obj.MethodHandle);    // True\n\nConsole.WriteLine (test.MetadataToken == obj.MetadataToken    // True\n                   && test.Module == obj.Module);\n```", "```cs\nMethodInfo m = typeof (Walnut).GetMethod (\"Crack\");\nConsole.WriteLine (m);                             // Void Crack()\nConsole.WriteLine (m.ReturnType);                  // System.Void\n```", "```cs\nMethodInfo method = typeof (Walnut).GetMethod (\"Crack\");\nMemberInfo member = typeof (Walnut).GetMember (\"Crack\") [0];\n\nConsole.Write (method == member);       // True\n```", "```cs\nclass Test { public int X { get { return 0; } set {} } }\n\nvoid Demo()\n{\n  foreach (MethodInfo mi in typeof (Test).GetMethods())\n    Console.Write (mi.Name + \"  \");\n}\n\n// OUTPUT:\nget_X  set_X  GetType  ToString  Equals  GetHashCode\n```", "```cs\nPropertyInfo pi = typeof (Console).GetProperty (\"Title\");\nMethodInfo getter = pi.GetGetMethod();                   // get_Title\nMethodInfo setter = pi.GetSetMethod();                   // set_Title\nMethodInfo[] both = pi.GetAccessors();                   // Length==2\n```", "```cs\nPropertyInfo p = mi.DeclaringType.GetProperties()\n                   .First (x => x.GetAccessors (true).Contains (mi));\n```", "```cs\nbool IsInitOnly (PropertyInfo pi) => pi\n  .GetSetMethod().ReturnParameter.GetRequiredCustomModifiers()\n  .Any (t => t.Name == \"IsExternalInit\");\n```", "```cs\nvoid PrintPropertyNullability (PropertyInfo pi)\n{\n  var info = new NullabilityInfoContext().Create (pi);\n  Console.WriteLine (pi.Name + \" read \" + info.ReadState);\n  Console.WriteLine (pi.Name + \" write \" + info.WriteState);\n  // Use info.Element to get nullability info for array elements\n}\n```", "```cs\nPropertyInfo unbound = typeof (IEnumerator<>)  .GetProperty (\"Current\");\nPropertyInfo closed = typeof (IEnumerator<int>).GetProperty (\"Current\");\n\nConsole.WriteLine (unbound);   // T Current\nConsole.WriteLine (closed);    // Int32 Current\n\nConsole.WriteLine (unbound.PropertyType.IsGenericParameter);  // True\nConsole.WriteLine (closed.PropertyType.IsGenericParameter);   // False\n```", "```cs\nPropertyInfo unbound = typeof (List<>)  .GetProperty (\"Count\");\nPropertyInfo closed = typeof (List<int>).GetProperty (\"Count\");\n\nConsole.WriteLine (unbound);   // Int32 Count\nConsole.WriteLine (closed);    // Int32 Count\n\nConsole.WriteLine (unbound == closed);   // False\n\nConsole.WriteLine (unbound.DeclaringType.IsGenericTypeDefinition); // True\nConsole.WriteLine (closed.DeclaringType.IsGenericTypeDefinition); // False\n```", "```cs\nstring s = \"Hello\";\nint length = s.Length;\n```", "```cs\nobject s = \"Hello\";\nPropertyInfo prop = s.GetType().GetProperty (\"Length\");\nint length = (int) prop.GetValue (s, null);               // 5\n```", "```cs\nConsole.WriteLine (\"stamp\".Substring(2));                  // \"amp\"\n```", "```cs\nType type = typeof (string);\nType[] parameterTypes = { typeof (int) };\nMethodInfo method = type.GetMethod (\"Substring\", parameterTypes);\n\nobject[] arguments = { 2 };\nobject returnValue = method.Invoke (\"stamp\", arguments);\nConsole.WriteLine (returnValue);                           // \"amp\"\n```", "```cs\nParameterInfo[] paramList = method.GetParameters();\nforeach (ParameterInfo x in paramList)\n{\n  Console.WriteLine (x.Name);                 // startIndex\n  Console.WriteLine (x.ParameterType);        // System.Int32\n}\n```", "```cs\nint x;\nbool successfulParse = int.TryParse (\"23\", out x);\n```", "```cs\nobject[] args = { \"23\", 0 };\nType[] argTypes = { typeof (string), typeof (int).MakeByRefType() };\nMethodInfo tryParse = typeof (int).GetMethod (\"TryParse\", argTypes);\nbool successfulParse = (bool) tryParse.Invoke (null, args);\n\nConsole.WriteLine (successfulParse + \" \" + args[1]);       // True 23\n```", "```cs\npublic static IEnumerable<TSource> Where<TSource>\n (this IEnumerable<TSource> source, Func<TSource, bool> predicate);\n\npublic static IEnumerable<TSource> Where<TSource>\n (this IEnumerable<TSource> source, Func<TSource, int, bool> predicate);\n```", "```cs\nfrom m in typeof (Enumerable).GetMethods()\nwhere m.Name == \"Where\" && m.IsGenericMethod \nlet parameters = m.GetParameters()\nwhere parameters.Length == 2\nlet genArg = m.GetGenericArguments().First()\nlet enumerableOfT = typeof (IEnumerable<>).MakeGenericType (genArg)\nlet funcOfTBool = typeof (Func<,>).MakeGenericType (genArg, typeof (bool))\nwhere parameters[0].ParameterType == enumerableOfT\n   && parameters[1].ParameterType == funcOfTBool\nselect m\n```", "```cs\nvar closedMethod = unboundMethod.MakeGenericMethod (typeof (int));\n```", "```cs\nint[] source = { 3, 4, 5, 6, 7, 8 };\nFunc<int, bool> predicate = n => n % 2 == 1;   // Odd numbers only\n```", "```cs\nvar query = (IEnumerable<int>) closedMethod.Invoke \n  (null, new object[] { source, predicate });\n\nforeach (int element in query) Console.Write (element + \"|\");  // 3|5|7|\n```", "```cs\nint[] source = { 3, 4, 5, 6, 7, 8 };\nFunc<int, bool> predicate = n => n % 2 == 1;\n\nvar sourceExpr = Expression.Constant (source);\nvar predicateExpr = Expression.Constant (predicate);\n\nvar callExpression = Expression.Call (\n  typeof (Enumerable), \"Where\",\n  new[] { typeof (int) },  // Closed generic arg type.\n  sourceExpr, predicateExpr);\n```", "```cs\nMethodInfo trimMethod = typeof (string).GetMethod (\"Trim\", new Type[0]);\nvar trim = (StringToString) Delegate.CreateDelegate\n                                    (typeof (StringToString), trimMethod);\nfor (int i = 0; i < 1000000; i++)\n  trim (\"test\");\n\ndelegate string StringToString (string s);\n```", "```cs\nclass Walnut\n{\n  private bool cracked;\n  public void Crack() { cracked = true; }\n\n  public override string ToString() { return cracked.ToString(); }\n}\n```", "```cs\nType t = typeof (Walnut);\nWalnut w = new Walnut();\nw.Crack();\nFieldInfo f = t.GetField (\"cracked\", BindingFlags.NonPublic |\n                                     BindingFlags.Instance);\nf.SetValue (w, false);\nConsole.WriteLine (w);         // False\n```", "```cs\nBindingFlags.Public    | BindingFlags.Instance\nBindingFlags.Public    | BindingFlags.Static\nBindingFlags.NonPublic | BindingFlags.Instance\nBindingFlags.NonPublic | BindingFlags.Static\n```", "```cs\nBindingFlags publicStatic = BindingFlags.Public | BindingFlags.Static;\nMemberInfo[] members = typeof (object).GetMembers (publicStatic);\n```", "```cs\nBindingFlags nonPublicBinding =\n  BindingFlags.NonPublic | BindingFlags.Static | BindingFlags.Instance;\n\nMemberInfo[] members = typeof (object).GetMembers (nonPublicBinding);\n```", "```cs\nclass Program\n{\n  public static T Echo<T> (T x) { return x; }\n\n  static void Main()\n  {\n    MethodInfo echo = typeof (Program).GetMethod (\"Echo\");\n    Console.WriteLine (echo.IsGenericMethodDefinition);    // True\n    echo.Invoke (null, new object[] { 123 } );             // *Exception*\n  }\n}\n```", "```cs\nMethodInfo echo = typeof (Program).GetMethod (\"Echo\");\nMethodInfo intEcho = echo.MakeGenericMethod (typeof (int));\nConsole.WriteLine (intEcho.IsGenericMethodDefinition);            // False\nConsole.WriteLine (intEcho.Invoke (null, new object[] { 3 } ));   // 3\n```", "```cs\npublic static string ToStringEx <T> (IEnumerable<T> sequence)\n{\n  ...\n}\n```", "```cs\npublic static string ToStringEx <T> (IEnumerable<IEnumerable<T>> sequence)\n```", "```cs\npublic static string ToStringEx (object value)\n{\n  if (value == null) return \"<null>\";\n  StringBuilder sb = new StringBuilder();\n\n  if (value is List<>)                                            // Error\n    sb.Append (\"List of \" + ((List<>) value).Count + \" items\");   // Error\n\n  if (value is IGrouping<,>)                                      // Error\n    sb.Append (\"Group with key=\" + ((IGrouping<,>) value).Key);   // Error\n\n  // Enumerate collection elements if this is a collection,\n  // recursively calling ToStringEx()\n  // ...\n\n  return sb.ToString();\n}\n```", "```cs\n  if (value is IList)\n    sb.AppendLine (\"A list with \" + ((IList) value).Count + \" items\");\n```", "```cs\npublic interface IGrouping <TKey,TElement> : IEnumerable <TElement>,\n                                             IEnumerable\n{\n  TKey Key { get; }\n}\n```", "```cs\npublic static string ToStringEx (object value)\n{\n  if (value == null) return \"<null>\";\n  if (value.GetType().IsPrimitive) return value.ToString();\n\n  StringBuilder sb = new StringBuilder();\n\n  if (value is IList)\n    sb.Append (\"List of \" + ((IList)value).Count + \" items: \");\n\n  Type closedIGrouping = value.GetType().GetInterfaces()\n    .Where (t => t.IsGenericType &&\n                 t.GetGenericTypeDefinition() == typeof (IGrouping<,>))\n    .FirstOrDefault();\n\n  if (closedIGrouping != null)   // Call the Key property on IGrouping<,>\n  {\n    PropertyInfo pi = closedIGrouping.GetProperty (\"Key\");\n    object key = pi.GetValue (value, null);\n    sb.Append (\"Group with key=\" + key + \": \");\n  }\n\n  if (value is IEnumerable)\n    foreach (object element in ((IEnumerable)value))\n      sb.Append (ToStringEx (element) + \" \");\n\n  if (sb.Length == 0) sb.Append (value.ToString());\n\n  return \"\\r\\n\" + sb.ToString();\n}\n```", "```cs\nConsole.WriteLine (ToStringEx (new List<int> { 5, 6, 7 } ));\nConsole.WriteLine (ToStringEx (\"xyyzzz\".GroupBy (c => c) ));\n\n*List of 3 items: 5 6 7*\n\n*Group with key=x: x*\n*Group with key=y: y y*\n*Group with key=z: z z z*\n```", "```cs\npublic interface IParsable<TSelf> where TSelf : IParsable<TSelf>\n{\n  static abstract TSelf Parse (string s, IFormatProvider provider);\n  ...\n}\n```", "```cs\nT ParseAny<T> (string s) where T : IParsable<T> => T.Parse (s, null);\n```", "```cs\nMethodInfo GetParseMethod (Type concreteType) =>\n  concreteType.GetMethod (\"Parse\",\n    new[] { typeof (string), typeof (IFormatProvider) });\n```", "```cs\nMethodInfo GetImplementedInterfaceMethod (Type concreteType,\n  Type interfaceType, string methodName, Type[] paramTypes)\n{\n  var map = concreteType.GetInterfaceMap (interfaceType);\n\n  return map.InterfaceMethods\n    .Zip (map.TargetMethods)\n    .Single (m => m.First.Name == methodName &&\n             m.First.GetParameters().Select (p => p.ParameterType)\n                                    .SequenceEqual (paramTypes))\n    .Second;\n}\n```", "```cs\npublic struct InterfaceMapping\n{   \n   public MethodInfo[] InterfaceMethods;    // These arrays each\n   public MethodInfo[] TargetMethods;       // have the same length.\n   ...\n}\n```", "```cs\nobject ParseAny (Type type, string value)\n{\n  MethodInfo parseMethod = GetImplementedInterfaceMethod (type,\n    type.GetInterface (\"IParsable`1\"),\n    \"Parse\",\n    new[] { typeof (string), typeof (IFormatProvider) });\n\n  return parseMethod.Invoke (null, new[] { value, null });\n}\n\nConsole.WriteLine (ParseAny (typeof (float), \".2\"));   // 0.2\n```", "```cs\ntypeof (IParsable<>).MakeGenericType (type)\n```", "```cs\nType t = Assembly.GetExecutingAssembly().GetType (\"Demos.TestProgram\");\n```", "```cs\ntypeof (Foo).Assembly.GetType (\"Demos.TestProgram\");\n```", "```cs\nAssembly a = Assembly.LoadFile (@\"e:\\demo\\mylib.dll\");\n\nforeach (Type t in a.GetTypes())\n  Console.WriteLine (t);\n```", "```cs\nAssembly a = typeof (Foo).GetTypeInfo().Assembly;\n\nforeach (Type t in a.ExportedTypes)\n  Console.WriteLine (t);\n```", "```cs\nstatic void Main()\n{\n  TypeAttributes ta = typeof (Console).Attributes;\n  MethodAttributes ma = MethodInfo.GetCurrentMethod().Attributes;\n  Console.WriteLine (ta + \"\\r\\n\" + ma);\n}\n```", "```cs\nAutoLayout, AnsiClass, Class, Public, Abstract, Sealed, BeforeFieldInit\nPrivateScope, Private, Static, HideBySig\n```", "```cs\n[Obsolete] public class Foo {...}\n```", "```cs\n[System.Runtime.InteropServices.StructLayout(LayoutKind.Sequential)]\nclass SystemTime { ... }\n```", "```cs\npublic sealed class AttributeUsageAttribute : Attribute\n{\n  public AttributeUsageAttribute (AttributeTargets validOn);\n\n  public bool AllowMultiple        { get; set; }\n  public bool Inherited            { get; set; }\n  public AttributeTargets ValidOn  { get; }\n}\n```", "```cs\n[AttributeUsage (AttributeTargets.Delegate |\n                 AttributeTargets.Enum     |\n                 AttributeTargets.Struct   |\n                 AttributeTargets.Class,     Inherited = false)\n]\npublic sealed class SerializableAttribute : Attribute { }\n```", "```cs\n[AttributeUsage (AttributeTargets.Method)]\npublic sealed class TestAttribute : Attribute\n{\n  public int     Repetitions;\n  public string  FailureMessage;\n\n  public TestAttribute () : this (1)     { }\n  public TestAttribute (int repetitions) { Repetitions = repetitions; }\n}\n```", "```cs\nclass Foo\n{\n  [Test]\n  public void Method1() { ... }\n\n  [Test(20)]\n  public void Method2() { ... }\n\n  [Test(20, FailureMessage=\"Debugging Time!\")]\n  public void Method3() { ... }\n}\n```", "```cs\nforeach (MethodInfo mi in typeof (Foo).GetMethods())\n{\n  TestAttribute att = (TestAttribute) Attribute.GetCustomAttribute\n    (mi, typeof (TestAttribute));\n\n  if (att != null)\n    Console.WriteLine (\"Method {0} will be tested; reps={1}; msg={2}\",\n                        mi.Name, att.Repetitions, att.FailureMessage);\n}\n```", "```cs\nforeach (MethodInfo mi in typeof (Foo).GetTypeInfo().DeclaredMethods)\n...\n```", "```cs\nMethod Method1 will be tested; reps=1; msg=\nMethod Method2 will be tested; reps=20; msg=\nMethod Method3 will be tested; reps=20; msg=Debugging Time!\n```", "```cs\nforeach (MethodInfo mi in typeof (Foo).GetMethods())\n{\n  TestAttribute att = (TestAttribute) Attribute.GetCustomAttribute\n    (mi, typeof (TestAttribute));\n\n  if (att != null)\n    for (int i = 0; i < att.Repetitions; i++)\n      try\n      {\n        mi.Invoke (new Foo(), null);    // Call method with no arguments\n      }\n      catch (Exception ex)       // Wrap exception in att.FailureMessage\n      {\n        throw new Exception (\"Error: \" + att.FailureMessage, ex);\n      }\n}\n```", "```cs\nobject[] atts = Attribute.GetCustomAttributes (typeof (Test));\nforeach (object att in atts) Console.WriteLine (att);\n\n[Serializable, Obsolete]\nclass Test\n{\n}\n```", "```cs\nSystem.ObsoleteAttribute\nSystem.SerializableAttribute\n```", "```cs\npublic class Test\n{\n  static void Main()\n  {\n    var dynMeth = new DynamicMethod (\"Foo\", null, null, typeof (Test));\n    ILGenerator gen = dynMeth.GetILGenerator();\n    gen.EmitWriteLine (\"Hello world\");\n    gen.Emit (OpCodes.Ret);\n    dynMeth.Invoke (null, null);                    // Hello world\n  }\n}\n```", "```cs\nMethodInfo writeLineStr = typeof (Console).GetMethod (\"WriteLine\",\n                           new Type[] { typeof (string) });\ngen.Emit (OpCodes.Ldstr, \"Hello world\");     // Load a string\ngen.Emit (OpCodes.Call, writeLineStr);       // Call a method\n```", "```cs\npublic class Test\n{\n  static void Main()\n  {\n    var dynMeth = new DynamicMethod (\"Foo\", null, null, typeof (Test));\n    ILGenerator gen = dynMeth.GetILGenerator();\n\n    MethodInfo privateMethod = typeof(Test).GetMethod (\"HelloWorld\",\n      BindingFlags.Static | BindingFlags.NonPublic);\n\n    gen.Emit (OpCodes.Call, privateMethod);     // Call HelloWorld\n    gen.Emit (OpCodes.Ret);\n\n    dynMeth.Invoke (null, null);                // Hello world\n  }\n\n  static void HelloWorld()       // private method, yet we can call it\n  {\n    Console.WriteLine (\"Hello world\");\n  }\n}\n```", "```cs\nvar dynMeth = new DynamicMethod (\"Foo\", null, null, typeof(void));\nILGenerator gen = dynMeth.GetILGenerator();\nMethodInfo writeLineInt = typeof (Console).GetMethod (\"WriteLine\",\n                                        new Type[] { typeof (int) });\n\n// The Ldc* op-codes load numeric literals of various types and sizes.\n\ngen.Emit (OpCodes.Ldc_I4, 123);        // Push a 4-byte integer onto stack\ngen.Emit (OpCodes.Call, writeLineInt);\n\ngen.Emit (OpCodes.Ret);\ndynMeth.Invoke (null, null);           // 123\n```", "```cs\ngen.Emit (OpCodes.Ldc_I4, 2);           // Push a 4-byte integer, value=2\ngen.Emit (OpCodes.Ldc_I4, 2);           // Push a 4-byte integer, value=2\ngen.Emit (OpCodes.Add);                 // Add the result together\ngen.Emit (OpCodes.Call, writeLineInt);\n```", "```cs\ngen.Emit (OpCodes.Ldc_I4, 10);\ngen.Emit (OpCodes.Ldc_I4, 2);\ngen.Emit (OpCodes.Div);\ngen.Emit (OpCodes.Ldc_I4, 1);\ngen.Emit (OpCodes.Add);\ngen.Emit (OpCodes.Call, writeLineInt);\n```", "```cs\ngen.Emit (OpCodes.Ldc_I4, 1);\ngen.Emit (OpCodes.Ldc_I4, 10);\ngen.Emit (OpCodes.Ldc_I4, 2);\ngen.Emit (OpCodes.Div);\ngen.Emit (OpCodes.Add);\ngen.Emit (OpCodes.Call, writeLineInt);\n```", "```cs\nDynamicMethod dynMeth = new DynamicMethod (\"Foo\",\n  typeof (int),                              // Return type = int\n  new[] { typeof (int), typeof (int) },      // Parameter types = int, int\n  typeof (void));\n\nILGenerator gen = dynMeth.GetILGenerator();\n\ngen.Emit (OpCodes.Ldarg_0);      // Push first arg onto eval stack\ngen.Emit (OpCodes.Ldarg_1);      // Push second arg onto eval stack\ngen.Emit (OpCodes.Add);          // Add them together (result on stack)\ngen.Emit (OpCodes.Ret);          // Return with stack having 1 value\n\nint result = (int) dynMeth.Invoke (null, new object[] { 3, 4 } );   // 7\n```", "```cs\nvar func = (Func<int,int,int>) dynMeth.CreateDelegate\n                                 (typeof (Func<int,int,int>));\nint result = func (3, 4);  // 7\n```", "```cs\nint x = 6;\nint y = 7;\nx *= y;\nConsole.WriteLine (x);\n```", "```cs\nvar dynMeth = new DynamicMethod (\"Test\", null, null, typeof (void));\nILGenerator gen = dynMeth.GetILGenerator();\n\nLocalBuilder localX = gen.DeclareLocal (typeof (int));    // Declare x\nLocalBuilder localY = gen.DeclareLocal (typeof (int));    // Declare y\n\ngen.Emit (OpCodes.Ldc_I4, 6);        // Push literal 6 onto eval stack\ngen.Emit (OpCodes.Stloc, localX);    // Store in localX\ngen.Emit (OpCodes.Ldc_I4, 7);        // Push literal 7 onto eval stack\ngen.Emit (OpCodes.Stloc, localY);    // Store in localY\n\ngen.Emit (OpCodes.Ldloc, localX);    // Push localX onto eval stack\ngen.Emit (OpCodes.Ldloc, localY);    // Push localY onto eval stack\ngen.Emit (OpCodes.Mul);              // Multiply values together\ngen.Emit (OpCodes.Stloc, localX);    // Store the result to localX\n\ngen.EmitWriteLine (localX);          // Write the value of localX\ngen.Emit (OpCodes.Ret);\n\ndynMeth.Invoke (null, null);         // 42\n```", "```cs\nint x = 5;\nwhile (x <= 10) Console.WriteLine (x++);\n```", "```cs\nILGenerator gen = *...*\n\nLabel startLoop = gen.DefineLabel();                  // Declare labels\nLabel endLoop = gen.DefineLabel();\n\nLocalBuilder x = gen.DeclareLocal (typeof (int));     // int x\ngen.Emit (OpCodes.Ldc_I4, 5);                         //\ngen.Emit (OpCodes.Stloc, x);                          // x = 5\ngen.MarkLabel (startLoop);\n  gen.Emit (OpCodes.Ldc_I4, 10);              // Load 10 onto eval stack\n  gen.Emit (OpCodes.Ldloc, x);                // Load x onto eval stack\n\n  gen.Emit (OpCodes.Blt, endLoop);            // if (x > 10) goto endLoop\n\n  gen.EmitWriteLine (x);                      // Console.WriteLine (x)\n\n  gen.Emit (OpCodes.Ldloc, x);                // Load x onto eval stack\n  gen.Emit (OpCodes.Ldc_I4, 1);               // Load 1 onto the stack\n  gen.Emit (OpCodes.Add);                     // Add them together\n  gen.Emit (OpCodes.Stloc, x);                // Save result back to x\n\n  gen.Emit (OpCodes.Br, startLoop);           // return to start of loop\ngen.MarkLabel (endLoop);\n\ngen.Emit (OpCodes.Ret);\n```", "```cs\nvar dynMeth = new DynamicMethod (\"Test\", null, null, typeof (void));\nILGenerator gen = dynMeth.GetILGenerator();\n\nConstructorInfo ci = typeof (StringBuilder).GetConstructor (new Type[0]);\ngen.Emit (OpCodes.Newobj, ci);\n```", "```cs\ngen.Emit (OpCodes.Callvirt, typeof (StringBuilder)\n                            .GetProperty (\"MaxCapacity\").GetGetMethod());\n\ngen.Emit (OpCodes.Call, typeof (Console).GetMethod (\"WriteLine\",\n                                         new[] { typeof (int) } ));\ngen.Emit (OpCodes.Ret);\ndynMeth.Invoke (null, null);              // 2147483647\n```", "```cs\n// We will call:   new StringBuilder (\"Hello\", 1000)\n\nConstructorInfo ci = typeof (StringBuilder).GetConstructor (\n                     new[] { typeof (string), typeof (int) } );\n\ngen.Emit (OpCodes.Ldstr, \"Hello\");   // Load a string onto the eval stack\ngen.Emit (OpCodes.Ldc_I4, 1000);     // Load an int onto the eval stack\ngen.Emit (OpCodes.Newobj, ci);       // Construct the StringBuilder\n\nType[] strT = { typeof (string) };\ngen.Emit (OpCodes.Ldstr, \", world!\");\ngen.Emit (OpCodes.Call, typeof (StringBuilder).GetMethod (\"Append\", strT));\ngen.Emit (OpCodes.Callvirt, typeof (object).GetMethod (\"ToString\"));\ngen.Emit (OpCodes.Call, typeof (Console).GetMethod (\"WriteLine\", strT));\ngen.Emit (OpCodes.Ret);\ndynMeth.Invoke (null, null);        // Hello, world!\n```", "```cs\ngen.Emit (OpCodes.Callvirt, typeof (StringBuilder).GetMethod (\"ToString\",\n                                                          new Type[0] ));\n```", "```cs\ngen.Emit (OpCodes.Call,\n          typeof (object).GetMethod (\"ToString\"));\n```", "```cs\ntry                               { throw new NotSupportedException(); }\ncatch (NotSupportedException ex)  { Console.WriteLine (ex.Message);    }\nfinally                           { Console.WriteLine (\"Finally\");     }\n```", "```cs\nMethodInfo getMessageProp = typeof (NotSupportedException)\n                            .GetProperty (\"Message\").GetGetMethod();\n\nMethodInfo writeLineString = typeof (Console).GetMethod (\"WriteLine\",\n                                             new[] { typeof (object) } );\ngen.BeginExceptionBlock();\n  ConstructorInfo ci = typeof (NotSupportedException).GetConstructor (\n                                                        new Type[0] );\n  gen.Emit (OpCodes.Newobj, ci);\n  gen.Emit (OpCodes.Throw);\ngen.BeginCatchBlock (typeof (NotSupportedException));\n  gen.Emit (OpCodes.Callvirt, getMessageProp);\n  gen.Emit (OpCodes.Call, writeLineString);\ngen.BeginFinallyBlock();\n  gen.EmitWriteLine (\"Finally\");\ngen.EndExceptionBlock();\n```", "```cs\nAssemblyName aname = new AssemblyName (\"MyDynamicAssembly\");\n\nAssemblyBuilder assemBuilder =\n  AssemblyBuilder.DefineDynamicAssembly (aname, AssemblyBuilderAccess.Run);\n\nModuleBuilder modBuilder = assemBuilder.DefineDynamicModule (\"DynModule\");\n```", "```cs\nTypeBuilder tb = modBuilder.DefineType (\"Widget\", TypeAttributes.Public);\n```", "```cs\nMethodBuilder methBuilder = tb.DefineMethod (\"SayHello\",\n                                             MethodAttributes.Public,\n                                             null, null);\nILGenerator gen = methBuilder.GetILGenerator();\ngen.EmitWriteLine (\"Hello world\");\ngen.Emit (OpCodes.Ret);\n```", "```cs\nType t = tb.CreateType();\n```", "```cs\nobject o = Activator.CreateInstance (t);\nt.GetMethod (\"SayHello\").Invoke (o, null);        // Hello world\n```", "```cs\nMethodInfo writeLine = typeof(Console).GetMethod (\"WriteLine\",\n                                       new Type[] { typeof (string) });\ngen.Emit (OpCodes.Call, writeLine);\n```", "```cs\nTypeBuilder tb = ...\n\nMethodBuilder method1 = tb.DefineMethod (\"Method1\", ...);\nMethodBuilder method2 = tb.DefineMethod (\"Method2\", ...);\n\nILGenerator gen1 = method1.GetILGenerator();\n\n// Suppose we want method1 to call method2:\n\ngen1.Emit (OpCodes.Call, method2);                    // Right\ngen1.Emit (OpCodes.Call, tb.GetMethod (\"Method2\"));   // Wrong\n```", "```cs\nAssemblyName aname = new AssemblyName (\"MyEmissions\");\n\nAssemblyBuilder assemBuilder = AssemblyBuilder.DefineDynamicAssembly (\n  aname, AssemblyBuilderAccess.Run);\n\nModuleBuilder modBuilder = assemBuilder.DefineDynamicModule (\"MainModule\");\n\nTypeBuilder tb = modBuilder.DefineType (\"Widget\", TypeAttributes.Public);\n```", "```cs\npublic static double SquareRoot (double value) => Math.Sqrt (value);\n```", "```cs\nMethodBuilder mb = tb.DefineMethod (\"SquareRoot\",\n  MethodAttributes.Static | MethodAttributes.Public,\n  CallingConventions.Standard,\n  typeof (double),                     // Return type\n  new[]  { typeof (double) } );        // Parameter types\n\nmb.DefineParameter (1, ParameterAttributes.None, \"value\");  // Assign name\n\nILGenerator gen = mb.GetILGenerator();\ngen.Emit (OpCodes.Ldarg_0);                                // Load 1st arg\ngen.Emit (OpCodes.Call, typeof(Math).GetMethod (\"Sqrt\"));\ngen.Emit (OpCodes.Ret);\n\nType realType = tb.CreateType();\ndouble x = (double) tb.GetMethod (\"SquareRoot\").Invoke (null,\n                                                new object[] { 10.0 });\nConsole.WriteLine (x);   // 3.16227766016838\n```", "```cs\npublic static void SquareRoot (ref double value)\n  => value = Math.Sqrt (value);\n```", "```cs\nMethodBuilder mb = tb.DefineMethod (\"SquareRoot\",\n  MethodAttributes.Static | MethodAttributes.Public,\n  CallingConventions.Standard,\n  null,\n  new Type[] { typeof (double).MakeByRefType() } );\n\nmb.DefineParameter (1, ParameterAttributes.None, \"value\");\n\nILGenerator gen = mb.GetILGenerator();\ngen.Emit (OpCodes.Ldarg_0);\ngen.Emit (OpCodes.Ldarg_0);\ngen.Emit (OpCodes.Ldind_R8);\ngen.Emit (OpCodes.Call, typeof (Math).GetMethod (\"Sqrt\"));\ngen.Emit (OpCodes.Stind_R8);\ngen.Emit (OpCodes.Ret);\n\nType realType = tb.CreateType();\nobject[] args = { 10.0 };\ntb.GetMethod (\"SquareRoot\").Invoke (null, args);\nConsole.WriteLine (args[0]);                     // 3.16227766016838\n```", "```cs\nmb.DefineParameter (1, ParameterAttributes.Out, \"value\");\n```", "```cs\nMethodBuilder mb = tb.DefineMethod (\"SquareRoot\",\n  MethodAttributes.Instance | MethodAttributes.Public\n  ...\n```", "```cs\nFieldBuilder field = tb.DefineField (\"length\", typeof (int),\n                                      FieldAttributes.Private);\n```", "```cs\nPropertyBuilder prop = tb.DefineProperty (\n                         \"Text\",                      // Name of property\n                         PropertyAttributes.None,\n                         typeof (string),             // Property type\n                         new Type[0]                  // Indexer types\n                       );\n```", "```cs\nstring _text;\npublic string Text\n{\n  get          => _text;\n  internal set => _text = value;\n}\n```", "```cs\nFieldBuilder field = tb.DefineField (\"_text\", typeof (string),\n                                      FieldAttributes.Private);\nPropertyBuilder prop = tb.DefineProperty (\n                         \"Text\",                      // Name of property\n                         PropertyAttributes.None,\n                         typeof (string),             // Property type\n                         new Type[0]);                // Indexer types\n\nMethodBuilder getter = tb.DefineMethod (\n  \"get_Text\",                                         // Method name\n  MethodAttributes.Public | MethodAttributes.SpecialName,\n  typeof (string),                                    // Return type\n  new Type[0]);                                       // Parameter types\n\nILGenerator getGen = getter.GetILGenerator();\ngetGen.Emit (OpCodes.Ldarg_0);        // Load \"this\" onto eval stack\ngetGen.Emit (OpCodes.Ldfld, field);   // Load field value onto eval stack\ngetGen.Emit (OpCodes.Ret);            // Return\n\nMethodBuilder setter = tb.DefineMethod (\n  \"set_Text\",\n  MethodAttributes.Assembly | MethodAttributes.SpecialName,\n  null,                                                 // Return type\n  new Type[] { typeof (string) } );                     // Parameter types\n\nILGenerator setGen = setter.GetILGenerator();\nsetGen.Emit (OpCodes.Ldarg_0);        // Load \"this\" onto eval stack\nsetGen.Emit (OpCodes.Ldarg_1);        // Load 2nd arg, i.e., value\nsetGen.Emit (OpCodes.Stfld, field);   // Store value into field\nsetGen.Emit (OpCodes.Ret);            // return\n\nprop.SetGetMethod (getter);           // Link the get method and property\nprop.SetSetMethod (setter);           // Link the set method and property\n```", "```cs\nType t = tb.CreateType();\nobject o = Activator.CreateInstance (t);\nt.GetProperty (\"Text\").SetValue (o, \"Good emissions!\", new object[0]);\nstring text = (string) t.GetProperty (\"Text\").GetValue (o, null);\n\nConsole.WriteLine (text);             // Good emissions!\n```", "```cs\nclass Widget\n{\n  int _capacity = 4000;\n}\n```", "```cs\nFieldBuilder field = tb.DefineField (\"_capacity\", typeof (int),\n                                      FieldAttributes.Private);\nConstructorBuilder c = tb.DefineConstructor (\n  MethodAttributes.Public,\n  CallingConventions.Standard,\n  new Type[0]);                  // Constructor parameters\n\nILGenerator gen = c.GetILGenerator();\n\ngen.Emit (OpCodes.Ldarg_0);             // Load \"this\" onto eval stack\ngen.Emit (OpCodes.Ldc_I4, 4000);        // Load 4000 onto eval stack\ngen.Emit (OpCodes.Stfld, field);        // Store it to our field\ngen.Emit (OpCodes.Ret);\n```", "```cs\nclass A     { public A() { Console.Write (\"A\"); } }\nclass B : A { public B() {} }\n```", "```cs\nclass B : A { public B() : base() {} }\n```", "```cs\ngen.Emit (OpCodes.Ldarg_0);\nConstructorInfo baseConstr = typeof (A).GetConstructor (new Type[0]);\ngen.Emit (OpCodes.Call, baseConstr);\n```", "```cs\n[XmlElement (\"FirstName\", Namespace=\"http://test/\", Order=3)]\n```", "```cs\nType attType = typeof (XmlElementAttribute);\n\nConstructorInfo attConstructor = attType.GetConstructor (\n  new Type[] { typeof (string) } );\n\nvar att = new CustomAttributeBuilder (\n  attConstructor,                        // Constructor\n  new object[] { \"FirstName\" },          // Constructor arguments\n  new PropertyInfo[] \n  {\n    attType.GetProperty (\"Namespace\"),   // Properties\n    attType.GetProperty (\"Order\")\n  },\n  new object[] { \"http://test/\", 3 }     // Property values\n);\n\nmyFieldBuilder.SetCustomAttribute (att);\n// or propBuilder.SetCustomAttribute (att);\n// or typeBuilder.SetCustomAttribute (att);  etc\n```", "```cs\nAssemblyName aname = new AssemblyName (\"MyEmissions\");\n\nAssemblyBuilder assemBuilder = AssemblyBuilder.DefineDynamicAssembly (\n  aname, AssemblyBuilderAccess.Run);\n\nModuleBuilder modBuilder = assemBuilder.DefineDynamicModule (\"MainModule\");\n```", "```cs\npublic static T Echo<T> (T value)\n{\n  return value;\n}\n```", "```cs\nTypeBuilder tb = modBuilder.DefineType (\"Widget\", TypeAttributes.Public);\n\nMethodBuilder mb = tb.DefineMethod (\"Echo\", MethodAttributes.Public |\n                                            MethodAttributes.Static);\nGenericTypeParameterBuilder[] genericParams\n  = mb.DefineGenericParameters (\"T\");\n\nmb.SetSignature (genericParams[0],     // Return type\n                 null, null,\n                 genericParams,        // Parameter types\n                 null, null);\n\nmb.DefineParameter (1, ParameterAttributes.None, \"value\");   // Optional\n\nILGenerator gen = mb.GetILGenerator();\ngen.Emit (OpCodes.Ldarg_0);\ngen.Emit (OpCodes.Ret);\n```", "```cs\ngenericParams[0].SetBaseTypeConstraint (typeof (Foo));\n```", "```cs\ngenericParams[0].SetInterfaceConstraints (typeof (IComparable));\n```", "```cs\npublic static T Echo<T> (T value) where T : IComparable<T>\n```", "```cs\ngenericParams[0].SetInterfaceConstraints (\n  typeof (IComparable<>).MakeGenericType (genericParams[0]) );\n```", "```cs\nDefaultConstructorConstraint\nNotNullableValueTypeConstraint\nReferenceTypeConstraint\nCovariant\nContravariant\n```", "```cs\npublic class Widget<T>\n{\n  public T Value;\n}\n```", "```cs\nTypeBuilder tb = modBuilder.DefineType (\"Widget\", TypeAttributes.Public);\n\nGenericTypeParameterBuilder[] genericParams\n  = tb.DefineGenericParameters (\"T\");\n\ntb.DefineField (\"Value\", genericParams[0], FieldAttributes.Public);\n```", "```cs\npublic class Widget\n{\n  public static void Test() { var list = new List<int>(); }\n}\n```", "```cs\nTypeBuilder tb = modBuilder.DefineType (\"Widget\", TypeAttributes.Public);\n\nMethodBuilder mb = tb.DefineMethod (\"Test\", MethodAttributes.Public |\n                                            MethodAttributes.Static);\nILGenerator gen = mb.GetILGenerator();\n\nType variableType = typeof (List<int>);\n\nConstructorInfo ci = variableType.GetConstructor (new Type[0]);\n\nLocalBuilder listVar = gen.DeclareLocal (variableType);\ngen.Emit (OpCodes.Newobj, ci);\ngen.Emit (OpCodes.Stloc, listVar);\ngen.Emit (OpCodes.Ret);\n```", "```cs\npublic class Widget\n{\n  public static void Test() { var list = new List<Widget>(); }\n}\n```", "```cs\nType variableType = typeof (List<int>);\n```", "```cs\nType variableType = typeof (List<>).MakeGenericType (tb);\n```", "```cs\npublic static ConstructorInfo GetConstructor (Type, ConstructorInfo);\npublic static FieldInfo       GetField       (Type, FieldInfo);\npublic static MethodInfo      GetMethod      (Type, MethodInfo);\n```", "```cs\nMethodBuilder mb = tb.DefineMethod (\"Test\", MethodAttributes.Public |\n                                            MethodAttributes.Static);\nILGenerator gen = mb.GetILGenerator();\n\nType variableType = typeof (List<>).MakeGenericType (tb);\n\nConstructorInfo unbound = typeof (List<>).GetConstructor (new Type[0]);\nConstructorInfo ci = TypeBuilder.GetConstructor (variableType, unbound);\n\nLocalBuilder listVar = gen.DeclareLocal (variableType);\ngen.Emit (OpCodes.Newobj, ci);\ngen.Emit (OpCodes.Stloc, listVar);\ngen.Emit (OpCodes.Ret);\n```", "```cs\nclass A { public B Bee; }\nclass B { public A Aye; }\n```", "```cs\nvar publicAtt = FieldAttributes.Public;\n\nTypeBuilder aBuilder = modBuilder.DefineType (\"A\");\nTypeBuilder bBuilder = modBuilder.DefineType (\"B\");\n\nFieldBuilder bee = aBuilder.DefineField (\"Bee\", bBuilder, publicAtt);\nFieldBuilder aye = bBuilder.DefineField (\"Aye\", aBuilder, publicAtt);\n\nType realA = aBuilder.CreateType();\nType realB = bBuilder.CreateType();\n```", "```cs\nstruct A { public B Bee; }\nstruct B {               }\n```", "```cs\nstruct A { public B Bee; }\nstruct B { public A Aye; }\n```", "```cs\npublic struct S<T> { ... }    // S can be empty and this demo will work.\n\nclass A { S<B> Bee; }\nclass B { S<A> Aye; }\n```", "```cs\nvar pub = FieldAttributes.Public;\n\nTypeBuilder aBuilder = modBuilder.DefineType (\"A\");\nTypeBuilder bBuilder = modBuilder.DefineType (\"B\");\n\naBuilder.DefineField (\"Bee\", typeof(S<>).MakeGenericType (bBuilder), pub);\nbBuilder.DefineField (\"Aye\", typeof(S<>).MakeGenericType (aBuilder), pub);\n\nType realA = aBuilder.CreateType();    // Error: cannot load type B\nType realB = bBuilder.CreateType();\n```", "```cs\nTypeBuilder[] uncreatedTypes = { aBuilder, bBuilder };\n\nResolveEventHandler handler = delegate (object o, ResolveEventArgs args)\n{\n  var type = uncreatedTypes.FirstOrDefault (t => t.FullName == args.Name);\n  return type == null ? null : type.CreateType().Assembly;\n};\n\nAppDomain.CurrentDomain.TypeResolve += handler;\n\nType realA = aBuilder.CreateType();\nType realB = bBuilder.CreateType();\n\nAppDomain.CurrentDomain.TypeResolve -= handler;\n```", "```cs\nIL_00EB:  ldfld        Disassembler._pos\nIL_00F0:  ldloc.2\nIL_00F1:  add\nIL_00F2:  ldelema      System.Byte\nIL_00F7:  ldstr        \"Hello world\"\nIL_00FC:  call         System.Byte.ToString\nIL_0101:  ldstr        \" \"\nIL_0106:  call         System.String.Concat\n```", "```cs\npublic class Disassembler\n{\n  public static string Disassemble (MethodBase method)\n    => new Disassembler (method).Dis();\n\n  StringBuilder _output;    // The result to which we'll keep appending\n  Module _module;           // This will come in handy later\n  byte[] _il;               // The raw byte code\n  int _pos;                 // The position we're up to in the byte code\n\n  Disassembler (MethodBase method)\n  {\n    _module = method.DeclaringType.Module;\n    _il = method.GetMethodBody().GetILAsByteArray();\n  }\n\n  string Dis()\n  {\n    _output = new StringBuilder();\n    while (_pos < _il.Length) DisassembleNextInstruction();\n    return _output.ToString();\n  }\n}\n```", "```cs\nstatic Dictionary<short,OpCode> _opcodes = new Dictionary<short,OpCode>();\n\nstatic Disassembler()\n{\n  Dictionary<short, OpCode> opcodes = new Dictionary<short, OpCode>();\n    foreach (FieldInfo fi in typeof (OpCodes).GetFields\n                             (BindingFlags.Public | BindingFlags.Static))\n      if (typeof (OpCode).IsAssignableFrom (fi.FieldType))\n      {\n        OpCode code = (OpCode) fi.GetValue (null);   // Get field's value\n        if (code.OpCodeType != OpCodeType.Nternal)\n          _opcodes.Add (code.Value, code);\n      }\n}\n```", "```cs\nvoid DisassembleNextInstruction()\n{\n  int opStart = _pos;\n\n  OpCode code = ReadOpCode();\n  string operand = ReadOperand (code);\n\n  _output.AppendFormat (\"IL_{0:X4}:  {1,-12} {2}\",\n                        opStart, code.Name, operand);\n  _output.AppendLine();\n}\n```", "```cs\nOpCode ReadOpCode()\n{\n  byte byteCode = _il [_pos++];\n  if (_opcodes.ContainsKey (byteCode)) return _opcodes [byteCode];\n\n  if (_pos == _il.Length)  throw new Exception (\"Unexpected end of IL\");\n\n  short shortCode = (short) (byteCode * 256 + _il [_pos++]);\n\n  if (!_opcodes.ContainsKey (shortCode))\n    throw new Exception (\"Cannot find opcode \" + shortCode);\n\n  return _opcodes [shortCode];\n}\n```", "```cs\nstring ReadOperand (OpCode c)\n{\n  int operandLength =\n    c.OperandType == OperandType.InlineNone\n      ? 0 :\n    c.OperandType == OperandType.ShortInlineBrTarget ||\n    c.OperandType == OperandType.ShortInlineI ||\n    c.OperandType == OperandType.ShortInlineVar\n      ? 1 :\n    c.OperandType == OperandType.InlineVar\n      ? 2 :\n    c.OperandType == OperandType.InlineI8 ||\n    c.OperandType == OperandType.InlineR\n      ? 8 :\n    c.OperandType == OperandType.InlineSwitch\n      ? 4 * (BitConverter.ToInt32 (_il, _pos) + 1) :\n      4;  // All others are 4 bytes\n\n  if (_pos + operandLength > _il.Length)\n    throw new Exception (\"Unexpected end of IL\");\n\n  string result = FormatOperand (c, operandLength);\n  if (result == null)\n  {                        // Write out operand bytes in hex\n    result = \"\";\n    for (int i = 0; i < operandLength; i++)\n      result += _il [_pos + i].ToString (\"X2\") + \" \";\n  }\n  _pos += operandLength;\n  return result;\n}\n```", "```cs\nIL_00A8:  ldfld        98 00 00 04\nIL_00AD:  ldloc.2\nIL_00AE:  add\nIL_00AF:  ldelema      64 00 00 01\nIL_00B4:  ldstr        26 04 00 70\nIL_00B9:  call         B6 00 00 0A\nIL_00BE:  ldstr        11 01 00 70\nIL_00C3:  call         91 00 00 0A\n...\n```", "```cs\nstring FormatOperand (OpCode c, int operandLength)\n{\n  if (operandLength == 0) return \"\";\n\n  if (operandLength == 4)\n    return Get4ByteOperand (c);\n  else if (c.OperandType == OperandType.ShortInlineBrTarget)\n    return GetShortRelativeTarget();\n  else if (c.OperandType == OperandType.InlineSwitch)\n    return GetSwitchTarget (operandLength);\n  else\n    return null;\n}\n```", "```cs\nstring Get4ByteOperand (OpCode c)\n{\n  int intOp = BitConverter.ToInt32 (_il, _pos);\n\n  switch (c.OperandType)\n  {\n    case OperandType.InlineTok:\n    case OperandType.InlineMethod:\n    case OperandType.InlineField:\n    case OperandType.InlineType:\n      MemberInfo mi;\n      try   { mi = _module.ResolveMember (intOp); }\n      catch { return null; }\n      if (mi == null) return null;\n\n      if (mi.ReflectedType != null)\n        return mi.ReflectedType.FullName + \".\" + mi.Name;\n      else if (mi is Type)\n        return ((Type)mi).FullName;\n      else\n        return mi.Name;\n\n    case OperandType.InlineString:\n      string s = _module.ResolveString (intOp);\n      if (s != null) s = \"'\" + s + \"'\";\n      return s;\n\n    case OperandType.InlineBrTarget:\n      return \"IL_\" + (_pos + intOp + 4).ToString (\"X4\");\n\n    default:\n      return null;\n  }\n}\n```", "```cs\nstring GetShortRelativeTarget()\n{\n  int absoluteTarget = _pos + (sbyte) _il [_pos] + 1;\n  return \"IL_\" + absoluteTarget.ToString (\"X4\");\n}\n\nstring GetSwitchTarget (int operandLength)\n{\n  int targetCount = BitConverter.ToInt32 (_il, _pos);\n  string [] targets = new string [targetCount];\n  for (int i = 0; i < targetCount; i++)\n  {\n    int ilTarget = BitConverter.ToInt32 (_il, _pos + (i + 1) * 4);\n    targets [i] = \"IL_\" + (_pos + ilTarget + operandLength).ToString (\"X4\");\n  }\n  return \"(\" + string.Join (\", \", targets) + \")\";\n}\n```", "```cs\nMethodInfo mi = typeof (Disassembler).GetMethod (\n  \"ReadOperand\", BindingFlags.Instance | BindingFlags.NonPublic);\n\nConsole.WriteLine (Disassembler.Disassemble (mi));\n```"]