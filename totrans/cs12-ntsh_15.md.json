["```cs\nusing System;\nusing System.IO;\n\n// Create a file called test.txt in the current directory:\nusing (Stream s = new FileStream (\"test.txt\", FileMode.Create))\n{\n  Console.WriteLine (s.CanRead);       // True\n  Console.WriteLine (s.CanWrite);      // True\n  Console.WriteLine (s.CanSeek);       // True\n\n  s.WriteByte (101);\n  s.WriteByte (102);\n  byte[] block = { 1, 2, 3, 4, 5 };\n  s.Write (block, 0, block.Length);     // Write block of 5 bytes\n\n  Console.WriteLine (s.Length);         // 7\n  Console.WriteLine (s.Position);       // 7\n  s.Position = 0;                       // Move back to the start\n\n  Console.WriteLine (s.ReadByte());     // 101\n  Console.WriteLine (s.ReadByte());     // 102\n\n  // Read from the stream back into the block array:\n  Console.WriteLine (s.Read (block, 0, block.Length));   // 5\n\n  // Assuming the last Read returned 5, we'll be at\n  // the end of the file, so Read will now return 0:\n  Console.WriteLine (s.Read (block, 0, block.Length));   // 0\n}\n```", "```cs\nasync static void AsyncDemo()\n{\n  using (Stream s = new FileStream (\"test.txt\", FileMode.Create))\n  {\n    byte[] block = { 1, 2, 3, 4, 5 };\n    await s.WriteAsync (block, 0, block.Length);    // Write asychronously\n\n    s.Position = 0;                       // Move back to the start\n\n    // Read from the stream back into the block array:\n    Console.WriteLine (await s.ReadAsync (block, 0, block.Length));   // 5\n  }\n}\n```", "```cs\n// Assuming s is a stream:\nbyte[] data = new byte [1000];\ns.Read (data, 0, data.Length);\n```", "```cs\nbyte[] data = new byte [1000];\n\n// bytesRead will always end up at 1000, unless the stream is\n// itself smaller in length:\n\nint bytesRead = 0;\nint chunkSize = 1;\nwhile (bytesRead < data.Length && chunkSize > 0)\n  bytesRead +=\n    chunkSize = s.Read (data, bytesRead, data.Length - bytesRead);\n```", "```cs\nbyte[] data = new byte [1000];\ns.ReadExactly (data);   // Reads exactly 1000 bytes\n```", "```cs\ns.ReadExactly (data, offset:0, count:1000);\n```", "```cs\nbyte[] data = new BinaryReader (s).ReadBytes (1000);\n```", "```cs\ns.Flush(); s.Close();\n```", "```cs\nFileStream fs1 = File.OpenRead  (\"readme.bin\");            // Read-only\nFileStream fs2 = File.OpenWrite (\"writeme.tmp\");           // Write-only\nFileStream fs3 = File.Create    (\"readwrite.tmp\");         // Read/write\n```", "```cs\nusing var fs = new FileStream (\"readwrite.tmp\", FileMode.Open);\n```", "```cs\nstring baseFolder = AppDomain.CurrentDomain.BaseDirectory;\nstring logoPath = Path.Combine (baseFolder, \"logo.jpg\");\nConsole.WriteLine (File.Exists (logoPath));\n```", "```cs\nFile.Delete (\"hidden.txt\");\nusing var file = File.Create (\"hidden.txt\");\n...\n```", "```cs\n[Flags]\npublic enum FileAccess { Read = 1, Write = 2, ReadWrite = 3 }\n```", "```cs\nusing var fs = new FileStream (\"x.bin\", FileMode.Open, FileAccess.Read);\n...\n```", "```cs\nusing var fs = new FileStream (\"myFile.bin\", FileMode.Open);\n\nfs.Seek (0, SeekOrigin.End);\n...\n```", "```cs\n// Defined on the FileStream class:\npublic virtual void Lock   (long position, long length);\npublic virtual void Unlock (long position, long length);\n```", "```cs\nvar ms = new MemoryStream();\nsourceStream.CopyTo (ms);\n```", "```cs\nusing var s = new NamedPipeServerStream (\"pipedream\");\n\ns.WaitForConnection();\ns.WriteByte (100);                // Send the value 100.\nConsole.WriteLine (s.ReadByte());\n```", "```cs\nusing var s = new NamedPipeClientStream (\"pipedream\");\n\ns.Connect();\nConsole.WriteLine (s.ReadByte());\ns.WriteByte (200);                 // Send the value 200 back.\n```", "```cs\nstatic byte[] ReadMessage (PipeStream s)\n{\n  MemoryStream ms = new MemoryStream();\n  byte[] buffer = new byte [0x1000];      // Read in 4 KB blocks\n\n  do    { ms.Write (buffer, 0, s.Read (buffer, 0, buffer.Length)); }\n  while (!s.IsMessageComplete);\n\n  return ms.ToArray();\n}\n```", "```cs\nusing var s = new NamedPipeServerStream (\"pipedream\", PipeDirection.InOut,\n                                          1, PipeTransmissionMode.Message);\n\ns.WaitForConnection();\n\nbyte[] msg = Encoding.UTF8.GetBytes (\"Hello\");\ns.Write (msg, 0, msg.Length);\n\nConsole.WriteLine (Encoding.UTF8.GetString (ReadMessage (s)));\n```", "```cs\nusing var s = new NamedPipeClientStream (\"pipedream\");\n\ns.Connect();\ns.ReadMode = PipeTransmissionMode.Message;\n\nConsole.WriteLine (Encoding.UTF8.GetString (ReadMessage (s)));\n\nbyte[] msg = Encoding.UTF8.GetBytes (\"Hello right back!\");\ns.Write (msg, 0, msg.Length);\n```", "```cs\nclass Program\n{\n  static void Main (string[] args)\n  {\n    if (args.Length == 0)\n      // No arguments signals server mode\n      AnonymousPipeServer();\n    else\n      // We pass in the pipe handle IDs as arguments to signal client mode\n      AnonymousPipeClient (args [0], args [1]);\n  }\n\n  static void AnonymousPipeClient (string rxID, string txID)\n  {\n    using var rx = new AnonymousPipeClientStream (PipeDirection.In, rxID);\n    using var tx = new AnonymousPipeClientStream (PipeDirection.Out, txID);\n\n    Console.WriteLine (\"Client received: \" + rx.ReadByte ());\n    tx.WriteByte (200);\n  }\n\n  static void AnonymousPipeServer ()\n  {\n    using var tx = new AnonymousPipeServerStream (\n                     PipeDirection.Out, HandleInheritability.Inheritable);\n    using var rx = new AnonymousPipeServerStream (\n                     PipeDirection.In, HandleInheritability.Inheritable);\n\n    string txID = tx.GetClientHandleAsString ();\n    string rxID = rx.GetClientHandleAsString ();\n\n    // Create and start up a child process.\n    // We'll use the same Console executable, but pass in arguments:\n    string thisAssembly = Assembly.GetEntryAssembly().Location;\n    string thisExe = Path.ChangeExtension (thisAssembly, \".exe\");\n    var args = $\"{txID} {rxID}\";\n    var startInfo = new ProcessStartInfo (thisExe, args);\n\n    startInfo.UseShellExecute = false;       // Required for child process\n    Process p = Process.Start (startInfo);\n\n    tx.DisposeLocalCopyOfClientHandle ();    // Release unmanaged\n    rx.DisposeLocalCopyOfClientHandle ();    // handle resources.\n\n    tx.WriteByte (100);    // Send a byte to the child process\n\n    Console.WriteLine (\"Server received: \" + rx.ReadByte ());\n\n    p.WaitForExit ();\n  }\n}\n```", "```cs\n// Write 100K to a file:\nFile.WriteAllBytes (\"myFile.bin\", new byte [100000]);\n\nusing FileStream fs = File.OpenRead (\"myFile.bin\");\nusing BufferedStream bs = new BufferedStream (fs, 20000);  //20K buffer\n\nbs.ReadByte();\nConsole.WriteLine (fs.Position);         // 20000\n```", "```cs\nusing (FileStream fs = File.Create (\"test.txt\"))\nusing (TextWriter writer = new StreamWriter (fs))\n{\n  writer.WriteLine (\"Line1\");\n  writer.WriteLine (\"Line2\");\n}\n\nusing (FileStream fs = File.OpenRead (\"test.txt\"))\nusing (TextReader reader = new StreamReader (fs))\n{\n  Console.WriteLine (reader.ReadLine());       // Line1\n  Console.WriteLine (reader.ReadLine());       // Line2\n}\n```", "```cs\nusing (TextWriter writer = File.CreateText (\"test.txt\"))\n{\n  writer.WriteLine (\"Line1\");\n  writer.WriteLine (\"Line2\");\n}\n\nusing (TextWriter writer = File.AppendText (\"test.txt\"))\n  writer.WriteLine (\"Line3\");\n\nusing (TextReader reader = File.OpenText (\"test.txt\"))\n  while (reader.Peek() > -1)\n    Console.WriteLine (reader.ReadLine());     // Line1\n                                               // Line2\n                                               // Line3\n```", "```cs\nusing (TextWriter w = File.CreateText (\"data.txt\"))\n{\n  w.WriteLine (123);          // Writes \"123\"\n  w.WriteLine (true);         // Writes the word \"true\"\n}\n\nusing (TextReader r = File.OpenText (\"data.txt\"))\n{\n  int myInt = int.Parse (r.ReadLine());     // myInt == 123\n  bool yes = bool.Parse (r.ReadLine());     // yes == true\n}\n```", "```cs\nvar encoding = new UTF8Encoding (\n  encoderShouldEmitUTF8Identifier:false,\n  throwOnInvalidBytes:true);\n```", "```cs\nusing (TextWriter w = File.CreateText (\"but.txt\"))    // Use default UTF-8\n  w.WriteLine (\"but-\");                               // encoding.\n\nusing (Stream s = File.OpenRead (\"but.txt\"))\n  for (int b; (b = s.ReadByte()) > -1;)\n    Console.WriteLine (b);\n```", "```cs\n98     // b\n117    // u\n116    // t\n226    // em dash byte 1       Note that the byte values\n128    // em dash byte 2       are >= 128 for each part\n148    // em dash byte 3       of the multibyte sequence.\n13     // <CR>\n10     // <LF>\n```", "```cs\nusing (Stream s = File.Create (\"but.txt\"))\nusing (TextWriter w = new StreamWriter (s, Encoding.Unicode))\n  w.WriteLine (\"but-\");\n\nforeach (byte b in File.ReadAllBytes (\"but.txt\"))\n  Console.WriteLine (b);\n```", "```cs\n255    // Byte-order mark 1\n254    // Byte-order mark 2\n98     // 'b' byte 1\n0      // 'b' byte 2\n117    // 'u' byte 1\n0      // 'u' byte 2\n116    // 't' byte 1\n0      // 't' byte 2\n20     // '--' byte 1\n32     // '--' byte 2\n13     // <CR> byte 1\n0      // <CR> byte 2\n10     // <LF> byte 1\n0      // <LF> byte 2\n```", "```cs\nXmlReader r = XmlReader.Create (new StringReader (myString));\n```", "```cs\npublic class Person\n{\n  public string Name;\n  public int    Age;\n  public double Height;\n}\n```", "```cs\npublic void SaveData (Stream s)\n{\n  var w = new BinaryWriter (s);\n  w.Write (Name);\n  w.Write (Age);\n  w.Write (Height);\n  w.Flush();         // Ensure the BinaryWriter buffer is cleared.\n                     // We won't dispose/close it, so more data\n}                    // can be written to the stream.\n\npublic void LoadData (Stream s)\n{\n  var r = new BinaryReader (s);\n  Name   = r.ReadString();\n  Age    = r.ReadInt32();\n  Height = r.ReadDouble();\n}\n```", "```cs\nbyte[] data = new BinaryReader (s).ReadBytes ((int) s.Length);\n```", "```cs\nusing (FileStream fs = File.Create (\"test.txt\"))\nusing (TextWriter writer = new StreamWriter (fs))\n  writer.WriteLine (\"Line\");\n```", "```cs\nusing (FileStream fs = new FileStream (\"test.txt\", FileMode.Create))\n{\n  StreamWriter writer = new StreamWriter (fs);\n  writer.WriteLine (\"Hello\");\n  writer.Flush();\n\n  fs.Position = 0;\n  Console.WriteLine (fs.ReadByte());\n}\n```", "```cs\nusing (var fs = new FileStream (\"test.txt\", FileMode.Create))\n{\n  using (var writer = new StreamWriter (fs, new UTF8Encoding (false, true),\n                                       0x400, true))\n    writer.WriteLine (\"Hello\");\n\n  fs.Position = 0;\n  Console.WriteLine (fs.ReadByte());\n  Console.WriteLine (fs.Length);\n}\n```", "```cs\nusing (Stream s = File.Create (\"compressed.bin\"))\nusing (Stream ds = new DeflateStream (s, CompressionMode.Compress))\n  for (byte i = 0; i < 100; i++)\n    ds.WriteByte (i);\n\nusing (Stream s = File.OpenRead (\"compressed.bin\"))\nusing (Stream ds = new DeflateStream (s, CompressionMode.Decompress))\n  for (byte i = 0; i < 100; i++)\n    Console.WriteLine (ds.ReadByte());     // Writes 0 to 99\n```", "```cs\nstring[] words = \"The quick brown fox jumps over the lazy dog\".Split();\nRandom rand = new Random (0);   // Give it a seed for consistency\n\nusing (Stream s = File.Create (\"compressed.bin\"))\nusing (Stream ds = new BrotliStream (s, CompressionMode.Compress))\nusing (TextWriter w = new StreamWriter (ds))\n  for (int i = 0; i < 1000; i++)\n    await w.WriteAsync (words [rand.Next (words.Length)] + \" \");\n\nConsole.WriteLine (new FileInfo (\"compressed.bin\").Length);      // 808\n\nusing (Stream s = File.OpenRead (\"compressed.bin\"))\nusing (Stream ds = new BrotliStream (s, CompressionMode.Decompress))\nusing (TextReader r = new StreamReader (ds))\n  Console.Write (await r.ReadToEndAsync());  // Output below:\n\nlazy lazy the fox the quick The brown fox jumps over fox over fox The\nbrown brown brown over brown quick fox brown dog dog lazy fox dog brown\nover fox jumps lazy lazy quick The jumps fox jumps The over jumps dog...\n```", "```cs\nbyte[] data = new byte[1000];          // We can expect a good compression\n                                       // ratio from an empty array!\nvar ms = new MemoryStream();\nusing (Stream ds = new DeflateStream (ms, CompressionMode.Compress))\n  ds.Write (data, 0, data.Length);\n\nbyte[] compressed = ms.ToArray();\nConsole.WriteLine (compressed.Length);       // 11\n\n// Decompress back to the data array:\nms = new MemoryStream (compressed);\nusing (Stream ds = new DeflateStream (ms, CompressionMode.Decompress))\n  for (int i = 0; i < 1000; i += ds.Read (data, i, 1000 - i));\n```", "```cs\nbyte[] data = new byte[1000];\n\nMemoryStream ms = new MemoryStream();\nusing (Stream ds = new DeflateStream (ms, CompressionMode.Compress, true))\n  await ds.WriteAsync (data, 0, data.Length);\n\nConsole.WriteLine (ms.Length);             // 113\nms.Position = 0;\nusing (Stream ds = new DeflateStream (ms, CompressionMode.Decompress))\n  for (int i = 0; i < 1000; i += await ds.ReadAsync (data, i, 1000 - i));\n```", "```cs\nasync Task GZip (string sourcefile, bool deleteSource = true)\n{\n  var gzip = $\"{sourcefile}.gz\";\n  if (File.Exists (gzip))\n    throw new Exception (\"Gzip file already exists\");\n\n  // Compress\n  using (FileStream inStream = File.Open (sourcefile, FileMode.Open))\n  using (FileStream outStream = new FileStream (gzip, FileMode.CreateNew))\n  using (GZipStream gzipStream = \n    new GZipStream (outStream, CompressionMode.Compress))\n    await inStream.CopyToAsync (gzipStream); \n\n  if (deleteSource) File.Delete(sourcefile);\n}\n\nasync Task GUnzip (string gzipfile, bool deleteGzip = true)\n{\n  if (Path.GetExtension (gzipfile) != \".gz\") \n    throw new Exception (\"Not a gzip file\");\n\n  var uncompressedFile = gzipfile.Substring (0, gzipfile.Length - 3);\n  if (File.Exists (uncompressedFile)) \n    throw new Exception (\"Destination file already exists\");\n\n  // Uncompress\n  using (FileStream uncompressToStream = \n         File.Open (uncompressedFile, FileMode.Create))\n  using (FileStream zipfileStream = File.Open (gzipfile, FileMode.Open))\n  using (var unzipStream = \n         new GZipStream (zipfileStream, CompressionMode.Decompress))\n    await unzipStream.CopyToAsync (uncompressToStream);\n\n  if (deleteGzip) File.Delete (gzipfile);\n}\n```", "```cs\nawait GZip (\"/tmp/myfile.txt\");      // Creates /tmp/myfile.txt.gz\n```", "```cs\nawait GUnzip (\"/tmp/myfile.txt.gz\")  // Creates /tmp/myfile.txt\n```", "```cs\nZipFile.CreateFromDirectory (@\"d:\\MyFolder\", @\"d:\\archive.zip\");\n```", "```cs\nZipFile.ExtractToDirectory (@\"d:\\archive.zip\", @\"d:\\MyFolder\");\n```", "```cs\nusing (ZipArchive zip = ZipFile.Open (@\"d:\\zz.zip\", ZipArchiveMode.Read))\n\n  foreach (ZipArchiveEntry entry in zip.Entries)\n    Console.WriteLine (entry.FullName + \" \" + entry.Length);\n```", "```cs\nbyte[] data = File.ReadAllBytes (@\"d:\\foo.dll\"); \nusing (ZipArchive zip = ZipFile.Open (@\"d:\\zz.zip\", ZipArchiveMode.Update))\n  zip.CreateEntry (@\"bin\\X64\\foo.dll\").Open().Write (data, 0, data.Length);\n```", "```cs\nTarFile.CreateFromDirectory (\"/tmp/testfolder\", \"/tmp/test.tar\", false);\n```", "```cs\nTarFile.ExtractToDirectory (\"/tmp/test.tar\", \"/tmp/testfolder\", true);\n```", "```cs\nvar ms = new MemoryStream();\nTarFile.CreateFromDirectory (\"/tmp/testfolder\", ms, false);\nms.Position = 0;    // So that we can re-use the stream for reading.\nusing (var fs = File.Create (\"/tmp/test.tar.gz\"))\nusing (var gz = new GZipStream (fs, CompressionMode.Compress))\n  ms.CopyTo (gz);\n```", "```cs\nusing (var fs = File.OpenRead (\"/tmp/test.tar.gz\"))\nusing (var gz = new GZipStream (fs, CompressionMode.Decompress))\n  TarFile.ExtractToDirectory (gz, \"/tmp/testfolder\", true);\n```", "```cs\nusing (FileStream archiveStream = File.OpenRead (\"/tmp/test.tar \"))\nusing (TarReader reader = new (archiveStream))\n  while (true)\n  {\n    TarEntry entry = reader.GetNextEntry();\n    if (entry == null) break;   // No more entries\n    Console.WriteLine (\n      $\"Entry {entry.Name} is {entry.DataStream.Length} bytes long\");\n    entry.ExtractToFile (\n      Path.Combine (\"/tmp/testfolder\", entry.Name), true);\n  }\n```", "```cs\nbool Exists (string path);      // Returns true if the file is present\n\nvoid Delete  (string path);\nvoid Copy    (string sourceFileName, string destFileName);\nvoid Move    (string sourceFileName, string destFileName);\nvoid Replace (string sourceFileName, string destinationFileName,\n                                     string destinationBackupFileName);\n\nFileAttributes GetAttributes (string path);\nvoid SetAttributes           (string path, FileAttributes fileAttributes);\n\nvoid Decrypt (string path);\nvoid Encrypt (string path);\n\nDateTime GetCreationTime   (string path);      // UTC versions are\nDateTime GetLastAccessTime (string path);      // also provided.\nDateTime GetLastWriteTime  (string path);\n\nvoid SetCreationTime   (string path, DateTime creationTime);\nvoid SetLastAccessTime (string path, DateTime lastAccessTime);\nvoid SetLastWriteTime  (string path, DateTime lastWriteTime);\n\nFileSecurity GetAccessControl (string path);\nFileSecurity GetAccessControl (string path,\n                               AccessControlSections includeSections);\nvoid SetAccessControl (string path, FileSecurity fileSecurity);\n```", "```cs\nArchive, Compressed, Device, Directory, Encrypted,\nHidden, IntegritySystem, Normal, NoScrubData, NotContentIndexed, \nOffline, ReadOnly, ReparsePoint, SparseFile, System, Temporary\n```", "```cs\nstring filePath = \"test.txt\";\n\nFileAttributes fa = File.GetAttributes (filePath);\nif ((fa & FileAttributes.ReadOnly) != 0)\n{\n    // Use the exclusive-or operator (^) to toggle the ReadOnly flag\n    fa ^= FileAttributes.ReadOnly;\n    File.SetAttributes (filePath, fa);\n}\n\n// Now we can delete the file, for instance:\nFile.Delete (filePath);\n```", "```cs\nnew FileInfo (\"test.txt\").IsReadOnly = false;\n```", "```cs\nstatic uint CompressFolder (string folder, bool recursive)\n{\n  string path = \"Win32_Directory.Name='\" + folder + \"'\";\n  using (ManagementObject dir = new ManagementObject (path))\n  using (ManagementBaseObject p = dir.GetMethodParameters (\"CompressEx\"))\n  {\n    p [\"Recursive\"] = recursive;\n    using (ManagementBaseObject result = dir.InvokeMethod (\"CompressEx\",\n                                                             p, null))\n      return (uint) result.Properties [\"ReturnValue\"].Value;\n  }\n}\n```", "```cs\nusing System;\nusing System.IO;\nusing System.Text;\nusing System.ComponentModel;\nusing System.Runtime.InteropServices;\n\nclass SupportsCompressionEncryption\n{\n  const int SupportsCompression = 0x10;\n  const int SupportsEncryption = 0x20000;\n\n  [DllImport (\"Kernel32.dll\", SetLastError = true)]\n  extern static bool GetVolumeInformation (string vol, StringBuilder name,\n    int nameSize, out uint serialNum, out uint maxNameLen, out uint flags,\n    StringBuilder fileSysName, int fileSysNameSize);\n\n  static void Main()\n  {\n    uint serialNum, maxNameLen, flags;\n    bool ok = GetVolumeInformation (@\"C:\\\", null, 0, out serialNum,\n                                    out maxNameLen, out flags, null, 0);\n    if (!ok)\n      throw new Win32Exception();\n\n    bool canCompress = (flags & SupportsCompression) != 0;\n    bool canEncrypt = (flags & SupportsEncryption) != 0;\n  }\n}\n```", "```cs\nusing System;\nusing System.IO;\nusing System.Security.AccessControl;\nusing System.Security.Principal;\n\nvoid ShowSecurity (FileSecurity sec)\n{\n  AuthorizationRuleCollection rules = sec.GetAccessRules (true, true,\n                                                       typeof (NTAccount));\n  foreach (FileSystemAccessRule r in rules.Cast<FileSystemAccessRule>()\n    .OrderBy (rule => rule.IdentityReference.Value))\n  {\n    // e.g., MyDomain/Joe\n    Console.WriteLine ($\"  {r.IdentityReference.Value}\");\n    // Allow or Deny: e.g., FullControl\n    Console.WriteLine ($\"    {r.FileSystemRights}: {r.AccessControlType}\");\n  }\n}\n\nvar file = \"sectest.txt\";\nFile.WriteAllText (file, \"File security test.\");\n\nvar sid = new SecurityIdentifier (WellKnownSidType.BuiltinUsersSid, null);\nstring usersAccount = sid.Translate (typeof (NTAccount)).ToString();\n\nConsole.WriteLine ($\"User: {usersAccount}\");\n\nFileSecurity sec = new FileSecurity (file,\n                          AccessControlSections.Owner |\n                          AccessControlSections.Group |\n                          AccessControlSections.Access);\n\nConsole.WriteLine (\"AFTER CREATE:\");\nShowSecurity(sec); // BUILTIN\\Users doesn't have Write permission\n\nsec.ModifyAccessRule (AccessControlModification.Add,\n    new FileSystemAccessRule (usersAccount, FileSystemRights.Write, \n                              AccessControlType.Allow),\n    out bool modified);\n\nConsole.WriteLine (\"AFTER MODIFY:\");\nShowSecurity (sec); // BUILTIN\\Users has Write permission\n```", "```cs\nvar fs = new FileStream (\"test.txt\",\n  new FileStreamOptions\n  {\n    Mode = FileMode.Create,\n    UnixCreateMode = UnixFileMode.UserRead | UnixFileMode.UserWrite\n  });\n```", "```cs\nstring GetCurrentDirectory ();\nvoid   SetCurrentDirectory (string path);\n\nDirectoryInfo CreateDirectory  (string path);\nDirectoryInfo GetParent        (string path);\nstring        GetDirectoryRoot (string path);\n\nstring[] GetLogicalDrives(); // Gets mount points on Unix\n\n// The following methods all return full paths:\n\nstring[] GetFiles             (string path);\nstring[] GetDirectories       (string path);\nstring[] GetFileSystemEntries (string path);\n\nIEnumerable<string> EnumerateFiles             (string path);\nIEnumerable<string> EnumerateDirectories       (string path);\nIEnumerable<string> EnumerateFileSystemEntries (string path);\n```", "```cs\nif (!Directory.Exists (@\"d:\\test\"))\n  Directory.CreateDirectory (@\"d:\\test\");\n```", "```cs\nstatic string TestDirectory => \n  RuntimeInformation.IsOSPlatform (OSPlatform.Windows)\n    ? @\"C:\\Temp\" \n    : \"/tmp\"; \n\nDirectory.CreateDirectory (TestDirectory);\n\nFileInfo fi = new FileInfo (Path.Combine (TestDirectory, \"FileInfo.txt\"));\n\nConsole.WriteLine (fi.Exists);         // false\n\nusing (TextWriter w = fi.CreateText())\n  w.Write (\"Some text\");\n\nConsole.WriteLine (fi.Exists);         // false (still)\nfi.Refresh();\nConsole.WriteLine (fi.Exists);         // true\n\nConsole.WriteLine (fi.Name);           // FileInfo.txt\nConsole.WriteLine (fi.FullName);       // c:\\temp\\FileInfo.txt (Windows)\n                                       // /tmp/FileInfo.txt (Unix)\nConsole.WriteLine (fi.DirectoryName);  // c:\\temp (Windows)\n                                       // /tmp (Unix)\nConsole.WriteLine (fi.Directory.Name); // temp\nConsole.WriteLine (fi.Extension);      // .txt\nConsole.WriteLine (fi.Length);         // 9\n\nfi.Encrypt();\nfi.Attributes ^= FileAttributes.Hidden;   // (Toggle hidden flag)\nfi.IsReadOnly = true;\n\nConsole.WriteLine (fi.Attributes);    // ReadOnly,Archive,Hidden,Encrypted\nConsole.WriteLine (fi.CreationTime);  // 3/09/2019 1:24:05 PM\n\nfi.MoveTo (Path.Combine (TestDirectory, \"FileInfoX.txt\")); \n\nDirectoryInfo di = fi.Directory;\nConsole.WriteLine (di.Name);             // temp or tmp\nConsole.WriteLine (di.FullName);         // c:\\temp or /tmp\nConsole.WriteLine (di.Parent.FullName);  // c:\\ or /\ndi.CreateSubdirectory (\"SubFolder\");\n```", "```cs\nDirectoryInfo di = new DirectoryInfo (@\"e:\\photos\");\n\nforeach (FileInfo fi in di.GetFiles (\"*.jpg\"))\n  Console.WriteLine (fi.Name);\n\nforeach (DirectoryInfo subDir in di.GetDirectories())\n  Console.WriteLine (subDir.FullName);\n```", "```cs\nstring dir  = @\"c:\\mydir\";    // or /mydir\nstring file = \"myfile.txt\";\nstring path = @\"c:\\mydir\\myfile.txt\";    // or /mydir/myfile.txt\n\nDirectory.SetCurrentDirectory (@\"k:\\demo\");    // or /demo\n```", "```cs\nstring myDocPath = Environment.GetFolderPath\n  (Environment.SpecialFolder.MyDocuments);\n```", "```cs\nSystem.Runtime.InteropServices.RuntimeEnvironment.GetRuntimeDirectory()\n```", "```cs\nstring localAppDataPath = Path.Combine (\n  Environment.GetFolderPath (Environment.SpecialFolder.ApplicationData),\n  \"MyCoolApplication\");\n\nif (!Directory.Exists (localAppDataPath))\n  Directory.CreateDirectory (localAppDataPath);\n```", "```cs\nDriveInfo c = new DriveInfo (\"C\");       // Query the C: drive.\n                                         // On Unix: /\n\nlong totalSize = c.TotalSize;            // Size in bytes.\nlong freeBytes = c.TotalFreeSpace;       // Ignores disk quotas.\nlong freeToMe  = c.AvailableFreeSpace;   // Takes quotas into account.\n\nforeach (DriveInfo d in DriveInfo.GetDrives())  // All defined drives.\n                                                // On Unix: mount points\n{\n  Console.WriteLine (d.Name);             // C:\\\n  Console.WriteLine (d.DriveType);        // Fixed\n  Console.WriteLine (d.RootDirectory);    // C:\\\n\n  if (d.IsReady)   // If the drive is not ready, the following two\n                   // properties will throw exceptions:\n  {\n    Console.WriteLine (d.VolumeLabel);    // The Sea Drive\n    Console.WriteLine (d.DriveFormat);    // NTFS\n  }\n}\n```", "```cs\nUnknown, NoRootDirectory, Removable, Fixed, Network, CDRom, Ram\n```", "```cs\nWatch (GetTestDirectory(), \"*.txt\", true);\n\nvoid Watch (string path, string filter, bool includeSubDirs)\n{\n  using (var watcher = new FileSystemWatcher (path, filter))\n  {\n    watcher.Created += FileCreatedChangedDeleted;\n    watcher.Changed += FileCreatedChangedDeleted;\n    watcher.Deleted += FileCreatedChangedDeleted;\n    watcher.Renamed += FileRenamed;\n    watcher.Error   += FileError;\n\n    watcher.IncludeSubdirectories = includeSubDirs;\n    watcher.EnableRaisingEvents = true;\n\n    Console.WriteLine (\"Listening for events - press <enter> to end\");\n    Console.ReadLine();\n  }\n  // Disposing the FileSystemWatcher stops further events from firing.\n}\n\nvoid FileCreatedChangedDeleted (object o, FileSystemEventArgs e)\n  => Console.WriteLine (\"File {0} has been {1}\", e.FullPath, e.ChangeType);\n\nvoid FileRenamed (object o, RenamedEventArgs e)\n  => Console.WriteLine (\"Renamed: {0}->{1}\", e.OldFullPath, e.FullPath);\n\nvoid FileError (object o, ErrorEventArgs e)\n  => Console.WriteLine (\"Error: \" + e.GetException().Message);\n\nstring GetTestDirectory() =>\n  RuntimeInformation.IsOSPlatform (OSPlatform.Windows)\n    ? @\"C:\\Temp\"\n    : \"/tmp\";\n```", "```cs\n[DllImport(\"libc\")]\npublic static extern uint getuid();\n\nstatic bool IsRunningAsAdmin()\n{\n  if (RuntimeInformation.IsOSPlatform (OSPlatform.Windows))\n  {\n    using var identity = WindowsIdentity.GetCurrent();\n    var principal = new WindowsPrincipal (identity);\n    return principal.IsInRole (WindowsBuiltInRole.Administrator);\n  }\n  return getuid() == 0;\n}\n```", "```cs\nstring docsFolder = Environment.GetFolderPath\n                    (Environment.SpecialFolder.MyDocuments);\n\nstring path = Path.Combine (docsFolder, \"test.txt\");\n```", "```cs\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<assembly manifestVersion=\"1.0\" >\n  <trustInfo >\n    <security>\n      <requestedPrivileges>\n        <requestedExecutionLevel level=\"requireAdministrator\" />\n      </requestedPrivileges>\n    </security>\n  </trustInfo>\n</assembly>\n```", "```cs\nFile.WriteAllBytes (\"long.bin\", new byte [1000000]);\n\nusing MemoryMappedFile mmf = MemoryMappedFile.CreateFromFile (\"long.bin\");\nusing MemoryMappedViewAccessor accessor = mmf.CreateViewAccessor();\n\naccessor.Write (500000, (byte) 77);\nConsole.WriteLine (accessor.ReadByte (500000));   // 77\n```", "```cs\nFile.WriteAllBytes (\"short.bin\", new byte [1]);\nusing (var mmf = MemoryMappedFile.CreateFromFile\n                 (\"short.bin\", FileMode.Create, null, 1000))\n  ...\n```", "```cs\nusing (MemoryMappedFile mmFile = MemoryMappedFile.CreateNew (\"Demo\", 500))\nusing (MemoryMappedViewAccessor accessor = mmFile.CreateViewAccessor())\n{\n  accessor.Write (0, 12345);\n  Console.ReadLine();   // Keep shared memory alive until user hits Enter.\n}\n```", "```cs\n// This can run in a separate executable:\nusing (MemoryMappedFile mmFile = MemoryMappedFile.OpenExisting (\"Demo\"))\nusing (MemoryMappedViewAccessor accessor = mmFile.CreateViewAccessor())\n  Console.WriteLine (accessor.ReadInt32 (0));   // 12345\n```", "```cs\nstatic void Writer()\n{\n  var file = Path.Combine (TestDirectory, \"interprocess.bin\");\n  File.WriteAllBytes (file, new byte [100]);\n\n  using FileStream fs = \n    new FileStream (file, FileMode.Open, FileAccess.ReadWrite, \n                    FileShare.ReadWrite);\n\n  using MemoryMappedFile mmf = MemoryMappedFile\n    .CreateFromFile (fs, null, fs.Length, MemoryMappedFileAccess.ReadWrite,\n                     HandleInheritability.None, true);\n  using MemoryMappedViewAccessor accessor = mmf.CreateViewAccessor();\n\n  accessor.Write (0, 12345);\n\n  Console.ReadLine();   // Keep shared memory alive until user hits Enter.\n\n  File.Delete (file);\n}\n\nstatic void Reader()\n{\n  // This can run in a separate executable:\n  var file = Path.Combine (TestDirectory, \"interprocess.bin\");\n  using FileStream fs = \n    new FileStream (file, FileMode.Open, FileAccess.ReadWrite, \n                    FileShare.ReadWrite);\n  using MemoryMappedFile mmf = MemoryMappedFile\n    .CreateFromFile (fs, null, fs.Length, MemoryMappedFileAccess.ReadWrite, \n                      HandleInheritability.None, true);\n  using MemoryMappedViewAccessor accessor = mmf.CreateViewAccessor();\n\n  Console.WriteLine (accessor.ReadInt32 (0));   // 12345\n}\n\nstatic string TestDirectory =>\n  RuntimeInformation.IsOSPlatform (OSPlatform.Windows)\n    ?  @\"C:\\Test\"\n    : \"/tmp\";\n```", "```cs\nbyte[] data = Encoding.UTF8.GetBytes (\"This is a test\");\naccessor.Write (0, data.Length);\naccessor.WriteArray (4, data, 0, data.Length);\n```", "```cs\nbyte[] data = new byte [accessor.ReadInt32 (0)];\naccessor.ReadArray (4, data, 0, data.Length);\nConsole.WriteLine (Encoding.UTF8.GetString (data));   // This is a test\n```", "```cs\nstruct Data { public int X, Y; }\n...\nvar data = new Data { X = 123, Y = 456 };\naccessor.Write (0, ref data);\naccessor.Read (0, out data);\nConsole.WriteLine (data.X + \" \" + data.Y);   // 123 456\n```", "```cs\nunsafe\n{\n  byte* pointer = null;\n  try\n  {\n    accessor.SafeMemoryMappedViewHandle.AcquirePointer (ref pointer);\n    int* intPointer = (int*) pointer;\n    Console.WriteLine (*intPointer);               // 123\n  }\n  finally\n  {\n    if (pointer != null)\n      accessor.SafeMemoryMappedViewHandle.ReleasePointer();\n  }\n}\n```", "```cs\n  <PropertyGroup>\n    <AllowUnsafeBlocks>true</AllowUnsafeBlocks>\n  </PropertyGroup>\n```"]