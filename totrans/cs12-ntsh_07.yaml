- en: Chapter 7\. Collections
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章. 集合
- en: .NET provides a standard set of types for storing and managing collections of
    objects. These include resizable lists, linked lists, and sorted and unsorted
    dictionaries, as well as arrays. Of these, only arrays form part of the C# language;
    the remaining collections are just classes you instantiate like any other.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 提供了一套标准类型，用于存储和管理对象集合。这些包括可调整大小的列表，链表，排序和未排序的字典，以及数组。其中，只有数组是 C# 语言的一部分；其余的集合只是像其他类一样实例化的类。
- en: 'We can divide the types in the .NET BCL for collections into the following
    categories:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将.NET BCL中用于集合的类型分为以下几类：
- en: Interfaces that define standard collection protocols
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义标准集合协议的接口
- en: Ready-to-use collection classes (lists, dictionaries, etc.)
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可直接使用的集合类（列表，字典等）
- en: Base classes for writing application-specific collections
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于编写特定于应用程序的集合的基类
- en: This chapter covers each of these categories, with an additional section on
    the types used in determining element equality and order.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了这些类别的每一个，另外还有一个关于用于确定元素相等性和顺序的类型的部分。
- en: 'The collection namespaces are as follows:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 集合命名空间如下：
- en: '| Namespace | Contains |'
  id: totrans-8
  prefs: []
  type: TYPE_TB
  zh: '| 命名空间 | 包含 |'
- en: '| --- | --- |'
  id: totrans-9
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `System.Collections` | Nongeneric collection classes and interfaces |'
  id: totrans-10
  prefs: []
  type: TYPE_TB
  zh: '| `System.Collections` | 非泛型集合类和接口 |'
- en: '| `System.Collections.Specialized` | Strongly typed nongeneric collection classes
    |'
  id: totrans-11
  prefs: []
  type: TYPE_TB
  zh: '| `System.Collections.Specialized` | 强类型的非泛型集合类 |'
- en: '| `System.Collections.Generic` | Generic collection classes and interfaces
    |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '| `System.Collections.Generic` | 泛型集合类和接口 |'
- en: '| `System.Collections.ObjectModel` | Proxies and bases for custom collections
    |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '| `System.Collections.ObjectModel` | 自定义集合的代理和基类 |'
- en: '| `System.Collections.Concurrent` | Thread-safe collections (see [Chapter 23](ch23.html#spanless_thantgreater_than_and-id00089))
    |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| `System.Collections.Concurrent` | 线程安全的集合（参见[第23章](ch23.html#spanless_thantgreater_than_and-id00089)）
    |'
- en: Enumeration
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 枚举
- en: In computing, there are many different kinds of collections, ranging from simple
    data structures such as arrays or linked lists, to more complex ones such as red/black
    trees and hashtables. Although the internal implementation and external characteristics
    of these data structures vary widely, the ability to traverse the contents of
    the collection is an almost universal need. The .NET BCL supports this need via
    a pair of interfaces (`IEnumerable`, `IEnumerator`, and their generic counterparts)
    that allow different data structures to expose a common traversal API. These are
    part of a larger set of collection interfaces illustrated in [Figure 7-1](#collection_interfaces).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算中，有许多不同类型的集合，从简单的数据结构（如数组或链表）到更复杂的数据结构（如红黑树和哈希表）。尽管这些数据结构的内部实现和外部特征各不相同，但遍历集合内容的能力几乎是普遍需求。.NET
    BCL通过一对接口（`IEnumerable`，`IEnumerator`及其泛型对应项）支持这种需求，这些接口允许不同的数据结构公开一个通用的遍历API。这些接口是[图7-1](#collection_interfaces)中所示的一组更大的集合接口的一部分。
- en: '![Collection interfaces](assets/cn10_0701.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![集合接口](assets/cn10_0701.png)'
- en: Figure 7-1\. Collection interfaces
  id: totrans-18
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7-1. 集合接口
- en: IEnumerable and IEnumerator
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: IEnumerable 和 IEnumerator
- en: 'The `IEnumerator` interface defines the basic low-level protocol by which elements
    in a collection are traversed—or enumerated—in a forward-only manner. Its declaration
    is as follows:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`IEnumerator` 接口定义了集合中元素以仅向前方式遍历或枚举的基本低级协议。其声明如下：'
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '`MoveNext` advances the current element or “cursor” to the next position, returning
    `false` if there are no more elements in the collection. `Current` returns the
    element at the current position (usually cast from `object` to a more specific
    type). `MoveNext` must be called before retrieving the first element—this is to
    allow for an empty collection. The `Reset` method, if implemented, moves back
    to the start, allowing the collection to be enumerated again. `Reset` exists mainly
    for Component Object Model (COM) interoperability; calling it directly is generally
    avoided because it’s not universally supported (and is unnecessary in that it’s
    usually just as easy to instantiate a new enumerator).'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`MoveNext` 将当前元素或“光标”移动到下一个位置，如果集合中没有更多元素，则返回`false`。`Current` 返回当前位置的元素（通常从`object`转换为更具体的类型）。在检索第一个元素之前必须调用`MoveNext`
    —— 这是为了允许空集合。如果实现了`Reset` 方法，则可以将其移回起始位置，从而允许重新枚举集合。`Reset` 主要用于组件对象模型（COM）互操作性；直接调用它通常是避免的，因为它不是普遍支持的（而且通常只需实例化一个新的枚举器就可以了）。'
- en: 'Collections do not usually *implement* enumerators; instead, they *provide*
    enumerators, via the interface `IEnumerable`:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 集合通常不会 *实现* 枚举器；相反，它们通过接口 `IEnumerable` *提供* 枚举器：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: By defining a single method retuning an enumerator, `IEnumerable` provides flexibility
    in that the iteration logic can be farmed out to another class. Moreover, it means
    that several consumers can enumerate the collection at once without interfering
    with one another. You can think of `IEnumerable` as “IEnumeratorProvider,” and
    it is the most basic interface that collection classes implement.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 通过定义一个返回枚举器的单个方法，`IEnumerable` 提供了灵活性，使得迭代逻辑可以委托给另一个类。此外，这意味着多个消费者可以同时枚举集合而互不干扰。你可以将
    `IEnumerable` 看作是“IEnumeratorProvider”，它是集合类实现的最基本接口。
- en: 'The following example illustrates low-level use of `IEnumerable` and `IEnumerator`:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例说明了 `IEnumerable` 和 `IEnumerator` 的低级使用：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'However, it’s rare to call methods on enumerators directly in this manner because
    C# provides a syntactic shortcut: the `foreach` statement. Here’s the same example
    rewritten using `foreach`:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 不过，以这种方式直接调用枚举器的方法是很少见的，因为 C# 提供了一种语法快捷方式：`foreach` 语句。以下是使用 `foreach` 重新编写的相同示例：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: IEnumerable<T> and IEnumerator<T>
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`IEnumerable<T>` 和 `IEnumerator<T>`'
- en: '`IEnumerator` and `IEnumerable` are nearly always implemented in conjunction
    with their extended generic versions:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`IEnumerator` 和 `IEnumerable` 几乎总是与它们的扩展泛型版本一起实现：'
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: By defining a typed version of `Current` and `GetEnumerator`, these interfaces
    strengthen static type safety, avoid the overhead of boxing with value-type elements,
    and are more convenient to the consumer. Arrays automatically implement `IEnumerable<T>`
    (where `T` is the member type of the array).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 通过定义 `Current` 和 `GetEnumerator` 的类型化版本，这些接口增强了静态类型安全性，避免了对值类型元素的装箱开销，并且对消费者更加方便。数组会自动实现
    `IEnumerable<T>`（其中 `T` 是数组的成员类型）。
- en: 'Thanks to the improved static type safety, calling the following method with
    an array of characters will generate a compile-time error:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 由于改进了静态类型安全性，使用字符数组调用以下方法将生成编译时错误：
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'It’s a standard practice for collection classes to publicly expose `IEnumerable<T>`
    while “hiding” the nongeneric `IEnumerable` through explicit interface implementation.
    This is so that if you directly call `GetEnumerator()`, you get back the type-safe
    generic `IEnumerator<T>`. There are times, though, when this rule is broken for
    reasons of backward compatibility (generics did not exist prior to C# 2.0). A
    good example is arrays—these must return the nongeneric (the nice way of putting
    it is “classic”) `IEnumerator` to avoid breaking earlier code. To get a generic
    `IEnumerator<T>`, you must cast to expose the explicit interface:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 集合类的标准做法是公开 `IEnumerable<T>`，同时通过显式接口实现“隐藏”非泛型的 `IEnumerable`。这样，如果直接调用 `GetEnumerator()`，你会得到类型安全的泛型
    `IEnumerator<T>`。不过，出于向后兼容性的考虑（在 C# 2.0 之前没有泛型），有时会违反这个规则。一个很好的例子是数组 —— 它们必须返回非泛型（委婉的说法是“经典”）的
    `IEnumerator`，以避免破坏早期的代码。要获得泛型的 `IEnumerator<T>`，你必须进行类型转换来公开显式接口：
- en: '[PRE6]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Fortunately, you rarely need to write this sort of code, thanks to the `foreach`
    statement.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，由于 `foreach` 语句的存在，你很少需要编写这种类型的代码。
- en: IEnumerable<T> and IDisposable
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`IEnumerable<T>` 和 `IDisposable`'
- en: '`IEnumerator<T>` inherits from `IDisposable`. This allows enumerators to hold
    references to resources such as database connections—and ensure that those resources
    are released when enumeration is complete (or abandoned partway through). The
    `foreach` statement recognizes this detail and translates the following:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`IEnumerator<T>` 继承自 `IDisposable`。这使得枚举器可以持有诸如数据库连接之类的资源引用，并确保这些资源在枚举完成（或中途放弃）时被释放。`foreach`
    语句能够识别这一细节，并将以下内容进行转换：'
- en: '[PRE7]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'into the logical equivalent of this:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 转换成以下的逻辑等效：
- en: '[PRE8]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `using` block ensures disposal—more on `IDisposable` in [Chapter 12](ch12.html#disposal_and_garbage_collection).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`using` 块确保释放资源 —— 关于 `IDisposable` 的更多信息详见[第12章](ch12.html#disposal_and_garbage_collection)。'
- en: Implementing the Enumeration Interfaces
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现枚举接口
- en: 'You might want to implement `IEnumerable` or `IEnumerable<T>` for one or more
    of the following reasons:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能希望为以下一个或多个原因之一实现 `IEnumerable` 或 `IEnumerable<T>`：
- en: To support the `foreach` statement
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了支持 `foreach` 语句
- en: To interoperate with anything expecting a standard collection
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了与期望标准集合的任何东西进行互操作
- en: To meet the requirements of a more sophisticated collection interface
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以满足更复杂的集合接口的要求
- en: To support collection initializers
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了支持集合初始化器
- en: 'To implement `IEnumerable`/`IEnumerable<T>`, you must provide an enumerator.
    You can do this in one of three ways:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现`IEnumerable`/`IEnumerable<T>`，你必须提供一个枚举器。你可以通过以下三种方式之一实现：
- en: If the class is “wrapping” another collection, by returning the wrapped collection’s
    enumerator
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果类“包装”另一个集合，则通过返回包装集合的枚举器
- en: Via an iterator using `yield return`
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用`yield return`创建迭代器
- en: By instantiating your own `IEnumerator`/`IEnumerator<T>` implementation
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过实例化自己的`IEnumerator`/`IEnumerator<T>`实现
- en: Note
  id: totrans-55
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can also subclass an existing collection: `Collection<T>` is designed just
    for this purpose (see [“Customizable Collections and Proxies”](#customizable_collections_and_proxies)).
    Yet another approach is to use the LINQ query operators, which we cover in [Chapter 8](ch08.html#linq_queries).'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以从现有集合派生子类：`Collection<T>`专门设计用于此目的（参见[“可自定义集合和代理”](#customizable_collections_and_proxies)）。另一种方法是使用LINQ查询运算符，我们将在[第8章](ch08.html#linq_queries)中介绍。
- en: 'Returning another collection’s enumerator is just a matter of calling `GetEnumerator`
    on the inner collection. However, this is viable only in the simplest scenarios
    in which the items in the inner collection are exactly what are required. A more
    flexible approach is to write an iterator, using C#’s `yield return` statement.
    An *iterator* is a C# language feature that assists in writing collections, in
    the same way the `foreach` statement assists in consuming collections. An iterator
    automatically handles the implementation of `IEnumerable` and `IEnumerator`—or
    their generic versions. Here’s a simple example:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 返回另一个集合的枚举器只是在内部集合上调用`GetEnumerator`的问题。然而，这只在内部集合的项目恰好符合所需项目的最简单场景中有效。更灵活的方法是使用C#的`yield
    return`语句编写一个迭代器。*迭代器*是C#语言的一种特性，它有助于编写集合，就像`foreach`语句有助于消费集合一样。迭代器自动处理`IEnumerable`和`IEnumerator`（或它们的泛型版本）的实现。以下是一个简单的示例：
- en: '[PRE9]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Notice the “black magic”: `GetEnumerator` doesn’t appear to return an enumerator
    at all! Upon parsing the `yield return` statement, the compiler writes a hidden
    nested enumerator class behind the scenes and then refactors `GetEnumerator` to
    instantiate and return that class. Iterators are powerful and simple (and are
    used extensively in the implementation of LINQ-to-Object’s standard query operators).'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这种“黑魔法”：`GetEnumerator`似乎根本不返回枚举器！在解析`yield return`语句时，编译器在幕后编写一个隐藏的嵌套枚举器类，然后重构`GetEnumerator`以实例化并返回该类。迭代器功能强大且简单（在LINQ-to-Object标准查询操作的实现中广泛使用）。
- en: 'Keeping with this approach, we can also implement the generic interface `IEnumerable<T>`:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 按照这种方法，我们也可以实现泛型接口`IEnumerable<T>`：
- en: '[PRE10]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Because `IEnumerable<T>` inherits from `IEnumerable`, we must implement both
    the generic and the nongeneric versions of `GetEnumerator`. In accordance with
    standard practice, we’ve implemented the nongeneric version explicitly. It can
    simply call the generic `GetEnumerator` because `IEnumerator<T>` inherits from
    `IEnumerator`.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`IEnumerable<T>`继承自`IEnumerable`，所以我们必须同时实现泛型和非泛型版本的`GetEnumerator`。根据标准实践，我们已经显式实现了非泛型版本，它只需调用泛型的`GetEnumerator`，因为`IEnumerator<T>`继承自`IEnumerator`。
- en: 'The class we’ve just written would be suitable as a basis from which to write
    a more sophisticated collection. However, if we need nothing above a simple `IEnumerable<T>`
    implementation, the `yield return` statement allows for an easier variation. Rather
    than writing a class, you can move the iteration logic into a method returning
    a generic `IEnumerable<T>` and let the compiler take care of the rest. Here’s
    an example:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚编写的类将适合作为编写更复杂集合的基础。但是，如果我们只需要简单的`IEnumerable<T>`实现，`yield return`语句允许更简单的变体。而不是编写一个类，你可以将迭代逻辑移入一个返回泛型`IEnumerable<T>`的方法中，让编译器来处理其余部分。以下是一个示例：
- en: '[PRE11]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Here’s our method in use:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们方法的使用：
- en: '[PRE12]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The final approach in writing `GetEnumerator` is to write a class that implements
    `IEnumerator` directly. This is exactly what the compiler does behind the scenes,
    in resolving iterators. (Fortunately, it’s rare that you’ll need to go this far
    yourself.) The following example defines a collection that’s hardcoded to contain
    the integers 1, 2, and 3:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 写`GetEnumerator`的最终方法是编写一个直接实现`IEnumerator`接口的类。这恰恰是编译器在幕后解析迭代器时所做的。（幸运的是，你自己很少需要走到这一步。）以下示例定义了一个硬编码为整数1、2和3的集合：
- en: '[PRE13]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Note
  id: totrans-69
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Implementing `Reset` is optional—you can instead throw a `NotSupportedException`.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 实现`Reset`是可选的 —— 你可以选择抛出`NotSupportedException`异常。
- en: Note that the first call to `MoveNext` should move to the first (and not the
    second) item in the list.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，第一次调用 `MoveNext` 应该移动到列表中的第一个（而不是第二个）项目。
- en: 'To get on par with an iterator in functionality, we must also implement `IEnumerator<T>`.
    Here’s an example with bounds checking omitted for brevity:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 要与迭代器的功能相匹配，我们还必须实现 `IEnumerator<T>`。以下是省略边界检查的示例：
- en: '[PRE14]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The example with generics is faster because `IEnumerator<int>.Current` doesn’t
    require casting from `int` to `object` and so avoids the overhead of boxing.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型示例更快，因为 `IEnumerator<int>.Current` 不需要从 `int` 转换为 `object`，因此避免了装箱的开销。
- en: The ICollection and IList Interfaces
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ICollection 和 IList 接口
- en: Although the enumeration interfaces provide a protocol for forward-only iteration
    over a collection, they don’t provide a mechanism to determine the size of the
    collection, access a member by index, or modify the collection. For such functionality,
    .NET defines the `ICollection`, `IList`, and `IDictionary` interfaces. Each comes
    in both generic and nongeneric versions; however, the nongeneric versions exist
    mostly for legacy support.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然枚举接口提供了一种在集合上进行单向迭代的协议，但它们并没有提供确定集合大小、按索引访问成员或修改集合的机制。为此，.NET 定义了 `ICollection`、`IList`
    和 `IDictionary` 接口。每种接口都有泛型和非泛型版本；然而，非泛型版本主要是为了向后兼容。
- en: '[Figure 7-1](#collection_interfaces) showed the inheritance hierarchy for these
    interfaces. The easiest way to summarize them is as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 7-1](#collection_interfaces) 显示了这些接口的继承层次结构。总结它们的最简单方法如下：'
- en: '`IEnumerable<T>` (and `IEnumerable`)'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`IEnumerable<T>`（以及 `IEnumerable`）'
- en: Provides minimum functionality (enumeration only)
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 提供最小的功能性（仅枚举）
- en: '`ICollection<T>` (and `ICollection`)'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`ICollection<T>`（以及 `ICollection`）'
- en: Provides medium functionality (e.g., the `Count` property)
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 提供中等功能性（例如，`Count` 属性）
- en: '`IList<T>`*/*`IDictionary<K,V>` and their nongeneric versions'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`IList<T>`/*`IDictionary<K,V>` 及其非泛型版本'
- en: Provide maximum functionality (including “random” access by index/key)
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 提供最大的功能性（包括按索引/键“随机”访问）
- en: Note
  id: totrans-84
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: It’s rare that you’ll need to *implement* any of these interfaces. In nearly
    all cases when you need to write a collection class, you can instead subclass
    `Collection<T>` (see [“Customizable Collections and Proxies”](#customizable_collections_and_proxies)).
    LINQ provides yet another option that covers many scenarios.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎不需要*实现*这些接口。几乎在所有需要编写集合类的情况下，您都可以选择子类化 `Collection<T>`（参见[“可自定义的集合和代理”](#customizable_collections_and_proxies)）。LINQ
    提供了另一种覆盖多种情况的选项。
- en: 'The generic and nongeneric versions differ in ways over and above what you
    might expect, particularly in the case of `ICollection`. The reasons for this
    are mostly historical: because generics came later, the generic interfaces were
    developed with the benefit of hindsight, leading to a different (and better) choice
    of members. For this reason, `ICollection<T>` does not extend `ICollection`, `IList<T>`
    does not extend `IList`, and `IDictionary<TKey, TValue>` does not extend `IDictionary`.
    Of course, a collection class itself is free to implement both versions of an
    interface if beneficial (which it often is).'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型和非泛型版本在某些方面有所不同，尤其是在 `ICollection` 的情况下。这主要是因为历史原因：泛型是后来引入的，因此泛型接口在开发时可以借鉴先前的经验，从而做出了不同（更好）的成员选择。因此，`ICollection<T>`
    不扩展 `ICollection`，`IList<T>` 不扩展 `IList`，`IDictionary<TKey, TValue>` 也不扩展 `IDictionary`。当然，如果有益的话，集合类本身可以自由地实现接口的两个版本（通常情况下确实如此）。
- en: Note
  id: totrans-87
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Another, subtler reason for `IList<T>` not extending `IList` is that casting
    to `IList<T>` would then return an interface with both `Add(T)` and `Add(object)`
    members. This would effectively defeat static type safety because you could call
    `Add` with an object of any type.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个更微妙的原因是 `IList<T>` 没有扩展 `IList` 的原因是，将 `IList<T>` 强制转换为 `IList` 将会返回一个同时具有
    `Add(T)` 和 `Add(object)` 成员的接口。这实际上会破坏静态类型安全，因为您可以使用任何类型的对象调用 `Add`。
- en: This section covers `ICollection<T>` and `IList<T>` and their nongeneric versions;
    [“Dictionaries”](#dictionaries) covers the dictionary interfaces.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 本节涵盖了 `ICollection<T>` 和 `IList<T>` 及其非泛型版本；[“字典”](#dictionaries) 则涵盖了字典接口。
- en: Note
  id: totrans-90
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: There is no *consistent* rationale in the way the words “collection” and “list”
    are applied throughout the .NET libraries. For instance, because `IList<T>` is
    a more functional version of `ICollection<T>`, you might expect the class `List<T>`
    to be correspondingly more functional than the class `Collection<T>`. This is
    not the case. It’s best to consider the terms “collection” and “list” as broadly
    synonymous, except when a specific type is involved.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在 .NET 库中，并没有一致的方法来应用“集合”和“列表”这两个词。例如，因为 `IList<T>` 是 `ICollection<T>` 的更功能化版本，您可能会期望
    `List<T>` 类相应地比 `Collection<T>` 类更具功能性。但实际情况并非如此。最好将术语“集合”和“列表”视为广义上的同义词，除非涉及特定类型。
- en: ICollection<T> and ICollection
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`ICollection<T>` 和 `ICollection`'
- en: '`ICollection<T>` is the standard interface for countable collections of objects.
    It provides the ability to determine the size of a collection (`Count`), determine
    whether an item exists in the collection (`Contains`), copy the collection into
    an array (`ToArray`), and determine whether the collection is read-only (`IsReadOnly`).
    For writable collections, you can also `Add`, `Remove`, and `Clear` items from
    the collection. And because it extends `IEnumerable<T>`, it can also be traversed
    via the `foreach` statement:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`ICollection<T>` 是可计数对象集合的标准接口。它提供了确定集合大小（`Count`）、确定集合中是否存在项（`Contains`）、将集合复制到数组中（`ToArray`）以及确定集合是否为只读（`IsReadOnly`）的能力。对于可写集合，还可以添加、移除和清除集合中的项。由于它扩展了
    `IEnumerable<T>`，因此也可以通过 `foreach` 语句进行遍历：'
- en: '[PRE15]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The nongeneric `ICollection` is similar in providing a countable collection,
    but it doesn’t provide functionality for altering the list or checking for element
    membership:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 非泛型的 `ICollection` 类似地提供了可计数集合，但不提供更改列表或检查元素成员的功能：
- en: '[PRE16]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The nongeneric interface also defines properties to assist with synchronization
    ([Chapter 14](ch14.html#concurrency_and_asynchron))—these were dumped in the generic
    version because thread safety is no longer considered intrinsic to the collection.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 非泛型接口还定义了用于同步的属性（[第14章](ch14.html#concurrency_and_asynchron)）——这些在泛型版本中被舍弃，因为集合的线程安全性不再被视为固有的。
- en: Both interfaces are fairly straightforward to implement. If implementing a read-only
    `ICollection<T>`, the `Add`, `Remove`, and `Clear` methods should throw a `NotSupportedException`.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个接口都相对简单易实现。如果实现只读的 `ICollection<T>`，则 `Add`、`Remove` 和 `Clear` 方法应该抛出 `NotSupportedException`。
- en: These interfaces are usually implemented in conjunction with either the `IList`
    or the `IDictionary` interface.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这些接口通常与 `IList` 或 `IDictionary` 接口一起实现。
- en: IList<T> and IList
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`IList<T>` 和 `IList`'
- en: '`IList<T>` is the standard interface for collections indexable by position.
    In addition to the functionality inherited from `ICollection<T>` and `IEnumerable<T>`,
    it provides the ability to read or write an element by position (via an indexer)
    and insert/remove by position:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`IList<T>` 是通过位置索引访问的标准集合接口。除了从 `ICollection<T>` 和 `IEnumerable<T>` 继承的功能外，它还提供了通过位置（通过索引器）读取或写入元素以及插入/删除元素的能力：'
- en: '[PRE17]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `IndexOf` methods perform a linear search on the list, returning `−1` if
    the specified item is not found.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`IndexOf` 方法在列表上执行线性搜索，如果未找到指定项，则返回 `-1`。'
- en: 'The nongeneric version of `IList` has more members because it inherits less
    from `ICollection`:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`IList` 的非泛型版本因为从 `ICollection` 继承较少的原因而具有更多的成员：'
- en: '[PRE18]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `Add` method on the nongeneric `IList` interface returns an integer—this
    is the index of the newly added item. In contrast, the `Add` method on `ICollection<T>`
    has a `void` return type.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在非泛型的 `IList` 接口上，`Add` 方法返回一个整数，这是新添加项的索引。相比之下，`ICollection<T>` 上的 `Add` 方法返回类型为
    `void`。
- en: The general-purpose `List<T>` class is the quintessential implementation of
    both `IList<T>` and `IList`. C# arrays also implement both the generic and nongeneric
    `IList`s (although the methods that add or remove elements are hidden via explicit
    interface implementation and throw a `NotSupportedException` if called).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 通用的 `List<T>` 类是 `IList<T>` 和 `IList` 的典型实现。C# 数组也同时实现了泛型和非泛型的 `IList`（尽管添加或移除元素的方法通过显式接口实现被隐藏，并且如果调用会抛出
    `NotSupportedException`）。
- en: Warning
  id: totrans-108
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: 'An `ArgumentException` is thrown if you try to access a multidimensional array
    via `IList`’s indexer. This is a trap when writing methods such as the following:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果尝试通过 `IList` 的索引器访问多维数组，则会抛出 `ArgumentException`。编写如下方法时需要注意这一点：
- en: '[PRE19]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This might appear bulletproof, but it will throw an exception if called with
    a multidimensional array. You can test for a multidimensional array at runtime
    with this expression (more on this in [Chapter 19](ch19.html#dynamic_programming)):'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来可能十分完美，但如果使用多维数组调用，将会抛出异常。你可以在运行时使用以下表达式测试是否为多维数组（更多信息请参见 [第 19 章](ch19.html#dynamic_programming)）：
- en: '[PRE20]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: IReadOnlyCollection<T> and IReadOnlyList<T>
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`IReadOnlyCollection<T>` 和 `IReadOnlyList<T>`'
- en: '.NET also defines collection and list interfaces that expose just the members
    required for read-only operations:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 还定义了仅公开只读操作所需成员的集合和列表接口：
- en: '[PRE21]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Because the type parameter for these interfaces is used only in output positions,
    it’s marked as *covariant*. This allows a list of cats, for instance, to be treated
    as a read-only list of animals. In contrast, `T` is not marked as covariant with
    `ICollection<T>` and `IList<T>`, because `T` is used in both input and output
    positions.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这些接口的类型参数仅在输出位置使用，所以被标记为*协变*。这使得一个猫的列表，例如，可以被视为动物的只读列表。相反，`T` 在 `ICollection<T>`
    和 `IList<T>` 中没有标记为协变，因为 `T` 在输入和输出位置都有使用。
- en: Note
  id: totrans-117
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: These interfaces represent a read-only *view* of a collection or list; the underlying
    implementation might still be writable. Most of the writable (*mutable*) collections
    implement both the read-only and read/write interfaces.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这些接口表示集合或列表的只读*视图*；底层实现可能仍然可写。大多数可写（*可变*）集合都同时实现只读和读写接口。
- en: In addition to letting you work with collections covariantly, the read-only
    interfaces allow a class to publicly expose a read-only view of a private writable
    collection. We demonstrate this—along with a better solution—in [“ReadOnlyCollection<T>”](#readonlycollectionless_thantgreater_tha).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 除了让你协变地处理集合外，只读接口还允许类公开对私有可写集合的只读视图。我们在 [“ReadOnlyCollection<T>”](#readonlycollectionless_thantgreater_tha)
    中演示了这一点，并提供了更好的解决方案。
- en: '`IReadOnlyList<T>` maps to the Windows Runtime type `IVectorView<T>`.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`IReadOnlyList<T>` 映射到 Windows Runtime 类型 `IVectorView<T>`。'
- en: The Array Class
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数组类
- en: The `Array` class is the implicit base class for all single and multidimensional
    arrays, and it is one of the most fundamental types implementing the standard
    collection interfaces. The `Array` class provides type unification, so a common
    set of methods is available to all arrays, regardless of their declaration or
    underlying element type.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`Array` 类是所有单维和多维数组的隐式基类之一，它是实现标准集合接口的最基础类型之一。`Array` 类提供类型统一化，因此所有数组都可以使用一组通用方法，无论其声明或底层元素类型如何。'
- en: Because arrays are so fundamental, C# provides explicit syntax for their declaration
    and initialization, which we described in Chapters [2](ch02.html#chash_language_basics)
    and [3](ch03.html#creating_types_in_chash). When an array is declared using C#’s
    syntax, the CLR implicitly subtypes the `Array` class—synthesizing a *pseudotype*
    appropriate to the array’s dimensions and element types. This pseudotype implements
    the typed generic collection interfaces, such as `IList<string>`.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 由于数组非常基础，C# 提供了声明和初始化它们的显式语法，我们在第 [2](ch02.html#chash_language_basics) 章和第 [3](ch03.html#creating_types_in_chash)
    章中有所描述。当使用 C# 的语法声明数组时，CLR 隐式地为 `Array` 类创建子类型，合成适合数组维度和元素类型的*伪类型*。这个伪类型实现了类型化的通用集合接口，比如
    `IList<string>`。
- en: The CLR also treats array types specially upon construction, assigning them
    a contiguous space in memory. This makes indexing into arrays highly efficient,
    but prevents them from being resized later on.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造时，CLR 也会特殊处理数组类型，为其分配连续的内存空间。这使得数组的索引操作非常高效，但同时阻止它们在稍后进行调整大小。
- en: '`Array` implements the collection interfaces up to `IList<T>` in both their
    generic and nongeneric forms. `IList<T>` itself is implemented explicitly, though,
    to keep `Array`’s public interface clean of methods such as `Add` or `Remove`,
    which throw an exception on fixed-length collections such as arrays. The `Array`
    class does actually offer a static `Resize` method, although this works by creating
    a new array and then copying over each element. As well as being inefficient,
    references to the array elsewhere in the program will still point to the original
    version. A better solution for resizable collections is to use the `List<T>` class
    (described in the following section).'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`Array` 实现了集合接口，包括它们的泛型和非泛型形式，直至 `IList<T>`。但 `IList<T>` 本身是显式实现的，以保持 `Array`
    的公共接口干净，不包含诸如 `Add` 或 `Remove` 的方法，这些方法在固定长度集合（如数组）上抛出异常。`Array` 类确实提供了一个静态的 `Resize`
    方法，但这通过创建一个新数组然后复制每个元素来实现。除了效率低下外，在程序的其他位置引用数组仍将指向原始版本。对于可调整大小的集合，更好的解决方案是使用 `List<T>`
    类（在下一节中描述）。'
- en: 'An array can contain value-type or reference-type elements. Value-type elements
    are stored in place in the array, so an array of three long integers (each 8 bytes)
    will occupy 24 bytes of contiguous memory. A reference type element, however,
    occupies only as much space in the array as a reference (4 bytes in a 32-bit environment
    or 8 bytes in a 64-bit environment). [Figure 7-2](#arrays_in_memory) illustrates
    the effect, in memory, of the following program:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 数组可以包含值类型或引用类型元素。值类型元素在数组中原地存储，因此三个长整数的数组（每个8字节）将占用24字节的连续内存。但引用类型元素仅占用一个引用的空间（在32位环境中为4字节，在64位环境中为8字节）。[图 7-2](#arrays_in_memory)
    在内存中展示了以下程序的效果：
- en: '[PRE22]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '![Arrays in memory](assets/cn10_0702.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![内存中的数组](assets/cn10_0702.png)'
- en: Figure 7-2\. Arrays in memory
  id: totrans-129
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 7-2\. 数组在内存中的表现
- en: 'Because `Array` is a class, arrays are always (themselves) reference types—regardless
    of the array’s element type. This means that the statement `arrayB = arrayA` results
    in two variables that reference the same array. Similarly, two distinct arrays
    will always fail an equality test, unless you employ a *structural equality comparer*,
    which compares every element of the array:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 `Array` 是一个类，所以数组始终是（它们自己）引用类型——无论数组的元素类型如何。这意味着语句 `arrayB = arrayA` 导致两个变量引用同一个数组。同样，除非使用*结构相等比较器*比较数组的每个元素，否则两个不同的数组总是无法通过相等性测试：
- en: '[PRE23]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Arrays can be duplicated by calling the `Clone` method: `arrayB = arrayA.Clone()`.
    However, this results in a shallow clone, meaning that only the memory represented
    by the array itself is copied. If the array contains value-type objects, the values
    themselves are copied; if the array contains reference type objects, just the
    references are copied (resulting in two arrays whose members reference the same
    objects). [Figure 7-3](#shallow_cloning_an_array) demonstrates the effect of adding
    the following code to our example:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 数组可以通过调用 `Clone` 方法进行复制：`arrayB = arrayA.Clone()`。然而，这将导致浅克隆，意味着只有数组本身表示的内存被复制。如果数组包含值类型对象，则值本身被复制；如果数组包含引用类型对象，则只复制引用（导致两个数组的成员引用相同的对象）。[图 7-3](#shallow_cloning_an_array)
    展示了向我们的示例添加以下代码的效果：
- en: '[PRE24]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '![Shallow-cloning an array](assets/cn10_0703.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![浅克隆一个数组](assets/cn10_0703.png)'
- en: Figure 7-3\. Shallow-cloning an array
  id: totrans-135
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 7-3\. 浅克隆一个数组
- en: To create a deep copy—for which reference type subobjects are duplicated—you
    must loop through the array and clone each element manually. The same rules apply
    to other .NET collection types.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建深复制——即复制引用类型子对象——您必须循环遍历数组并手动克隆每个元素。其他 .NET 集合类型也适用相同规则。
- en: Although `Array` is designed primarily for use with 32-bit indexers, it also
    has limited support for 64-bit indexers (allowing an array to theoretically address
    up to 2^(64) elements) via several methods that accept both `Int32` and `Int64`
    parameters. These overloads are useless in practice because the CLR does not permit
    any object—including arrays—to exceed two gigabytes in size (whether running on
    a 32- or 64-bit environment).
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `Array` 主要设计用于32位索引器，但它也对64位索引器有限支持（允许数组理论上寻址至多2^(64)个元素），通过几种方法接受 `Int32`
    和 `Int64` 参数。但实际上这些重载方法是无用的，因为CLR不允许任何对象——包括数组——超过两吉字节的大小（无论在32位还是64位环境中运行）。
- en: Warning
  id: totrans-138
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: Many of the methods on the `Array` class that you expect to be instance methods
    are in fact static methods. This is an odd design decision, and means that you
    should check for both static and instance methods when looking for a method on
    `Array`.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`Array`类上许多您期望是实例方法的方法实际上是静态方法。这是一个奇怪的设计决定，这意味着在寻找`Array`上的方法时，您应该检查静态方法和实例方法两者。'
- en: Construction and Indexing
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构造和索引
- en: 'The easiest way to create and index arrays is through C#’s language constructs:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 通过C#语言结构创建和索引数组的最简单方法是：
- en: '[PRE25]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Alternatively, you can instantiate an array dynamically by calling `Array.CreateInstance`.
    This allows you to specify element type and rank (number of dimensions) at runtime
    as well as allowing nonzero-based arrays through specifying a lower bound. Nonzero-based
    arrays are not compatible with the .NET Common Language Specification (CLS), and
    should not be exposed as public members in a library that might be consumed by
    a program written in F# or Visual Basic.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以通过调用`Array.CreateInstance`动态实例化一个数组。这允许您在运行时指定元素类型和秩（维数），并通过指定较低边界来允许非零基础的数组。非零基础的数组与.NET公共语言规范（CLS）不兼容，并且不应在可能被F#或Visual
    Basic编写的程序消费的库中作为公共成员暴露出去。
- en: 'The `GetValue` and `SetValue` methods let you access elements in a dynamically
    created array (they also work on ordinary arrays):'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetValue`和`SetValue`方法允许您访问动态创建数组中的元素（它们也适用于普通数组）：'
- en: '[PRE26]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Zero-indexed arrays created dynamically can be cast to a C# array of a matching
    or compatible type (compatible by standard array-variance rules). For example,
    if `Apple` subclasses `Fruit`, `Apple[]` can be cast to `Fruit[]`. This leads
    to the issue of why `object[]` was not used as the unifying array type rather
    than the `Array` class. The answer is that `object[]` is incompatible with both
    multidimensional and value-type arrays (and non-zero-based arrays). An `int[]`
    array cannot be cast to `object[]`. Hence, we require the `Array` class for full
    type unification.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 动态创建的零索引数组可以转换为匹配或兼容类型的C#数组（通过标准数组协变规则兼容）。例如，如果`Apple`是`Fruit`的子类，则`Apple[]`可以转换为`Fruit[]`。这引出了为什么没有使用`object[]`作为统一的数组类型而是使用`Array`类的问题。答案是，`object[]`与多维和值类型数组（以及非零基础数组）都不兼容。`int[]`数组无法转换为`object[]`。因此，我们需要`Array`类进行完整的类型统一。
- en: '`GetValue` and `SetValue` also work on compiler-created arrays, and they are
    useful when writing methods that can deal with an array of any type and rank.
    For multidimensional arrays, they accept an *array* of indexers:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetValue`和`SetValue`也适用于编译器创建的数组，在编写可以处理任何类型和秩的数组的方法时非常有用。对于多维数组，它们接受一个*索引器的数组*：'
- en: '[PRE27]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The following method prints the first element of any array, regardless of rank:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 以下方法打印任何数组的第一个元素，无论其秩如何：
- en: '[PRE28]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Note
  id: totrans-151
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'For working with arrays of unknown type but known rank, generics provide an
    easier and more efficient solution:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 对于处理未知类型但已知秩的数组，泛型提供了更简单和更高效的解决方案：
- en: '[PRE29]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '`SetValue` throws an exception if the element is of an incompatible type for
    the array.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如果元素与数组不兼容的类型，则`SetValue`会抛出异常。
- en: 'When an array is instantiated, whether via language syntax or `Array.Create​In⁠stance`,
    its elements are automatically initialized to their default values. For arrays
    with reference type elements, this means writing nulls; for arrays with value-type
    elements, this means bitwise “zeroing” the members. The `Array` class also provides
    this functionality on demand via the `Clear` method:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 当实例化数组时，无论是通过语言语法还是`Array.Create​In⁠stance`，其元素都会自动初始化为它们的默认值。对于具有引用类型元素的数组，这意味着写入null；对于具有值类型元素的数组，这意味着“零化”成员的位。`Array`类还通过`Clear`方法按需提供此功能：
- en: '[PRE30]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This method doesn’t affect the size of the array. This is in contrast to the
    usual use of `Clear` (such as in `ICollection<T>.Clear`) whereby the collection
    is reduced to zero elements.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法不会影响数组的大小。这与通常使用的`Clear`（例如在`ICollection<T>.Clear`中）形成对比，后者会将集合减少到零个元素。
- en: Enumeration
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 枚举
- en: 'Arrays are easily enumerated with a `foreach` statement:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`foreach`语句可以轻松枚举数组：
- en: '[PRE31]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'You can also enumerate using the static `Array.ForEach` method, defined as
    follows:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用静态的`Array.ForEach`方法进行枚举，其定义如下：
- en: '[PRE32]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This uses an `Action` delegate, with this signature:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这使用了一个带有如下签名的`Action`委托：
- en: '[PRE33]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Here’s the first example rewritten with `Array.ForEach`:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这是使用`Array.ForEach`重写的第一个示例：
- en: '[PRE34]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We can further simplify this with a *collection expression* (from C# 12):'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过*C# 12*中的*集合表达式*进一步简化这一过程：
- en: '[PRE35]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Length and Rank
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 长度和秩
- en: '`Array` provides the following methods and properties for querying length and
    rank:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`Array`提供了以下用于查询长度和秩的方法和属性：'
- en: '[PRE36]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '`GetLength` and `GetLongLength` return the length for a given dimension (`0`
    for a single-dimensional array), and `Length` and `LongLength` return the total
    number of elements in the array—all dimensions included.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetLength`和`GetLongLength`返回给定维度的长度（对于单维数组为`0`），`Length`和`LongLength`返回数组中的总元素数，包括所有维度。'
- en: '`GetLowerBound` and `GetUpperBound` are useful with nonzero indexed arrays.
    `Get​Up⁠perBound` returns the same result as adding `GetLowerBound` to `GetLength`
    for any given dimension.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetLowerBound`和`GetUpperBound`对于非零索引的数组很有用。`Get​Up⁠perBound`返回与给定维度的`GetLowerBound`加上`GetLength`相同的结果。'
- en: Searching
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 搜索
- en: 'The `Array` class offers a range of methods for finding elements within a one-dimensional
    array:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`Array`类提供了一系列方法，用于在一维数组中查找元素：'
- en: '`BinarySearch` methods'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`BinarySearch`方法'
- en: For rapidly searching a sorted array for a particular item
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 用于在排序的数组中快速搜索特定项
- en: '`IndexOf`/`LastIndex` methods'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`IndexOf`/`LastIndex`方法'
- en: For searching unsorted arrays for a particular item
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 用于在未排序的数组中搜索特定项
- en: '`Find`/`FindLast`/`FindIndex`/`FindLastIndex`/`FindAll`/`Exists`/`TrueForAll`'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '`Find`/`FindLast`/`FindIndex`/`FindLastIndex`/`FindAll`/`Exists`/`TrueForAll`'
- en: For searching unsorted arrays for item(s) that satisfy a given `Predicate<T>`
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 用于在未排序的数组中搜索满足给定`Predicate<T>`条件的项
- en: None of the array-searching methods throws an exception if the specified value
    is not found. Instead, if an item is not found, methods returning an integer return
    `−1` (assuming a zero-indexed array), and methods returning a generic type return
    the type’s default value (e.g., `0` for an `int`, or `null` for a `string` ).
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 如果指定的值未找到，数组搜索方法都不会抛出异常。相反，如果未找到项，则返回整数的方法返回`−1`（假设是从零开始索引的数组），返回泛型类型的方法返回类型的默认值（例如，对于`int`返回`0`，对于`string`返回`null`）。
- en: The binary search methods are fast, but they work only on sorted arrays and
    require that the elements be compared for *order* rather than simply *equality*.
    To this effect, the binary search methods can accept an `IComparer` or `IComparer<T>`
    object to arbitrate on ordering decisions (see [“Plugging in Equality and Order”](#plugging_in_equality_and_order)”).
    This must be consistent with any comparer used in originally sorting the array.
    If no comparer is provided, the type’s default ordering algorithm will be applied
    based on its implementation of `IComparable` / `IComparable<T>`.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 二分搜索方法速度快，但仅适用于排序的数组，并要求元素按*顺序*而不仅仅是*相等性*比较。为此，二分搜索方法可以接受`IComparer`或`IComparer<T>`对象来处理排序决策（见[“插入相等性和顺序”](#plugging_in_equality_and_order)）。这必须与最初用于排序数组的任何比较器一致。如果未提供比较器，则将基于其实现的`IComparable`
    / `IComparable<T>`应用类型的默认排序算法。
- en: The `IndexOf` and `LastIndexOf` methods perform a simple enumeration over the
    array, returning the position of the first (or last) element that matches the
    given value.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`IndexOf`和`LastIndexOf`方法在数组上执行简单的枚举，返回与给定值匹配的第一个（或最后一个）元素的位置。'
- en: 'The predicate-based searching methods allow a method delegate or lambda expression
    to arbitrate on whether a given element is a “match.” A predicate is simply a
    delegate accepting an object and returning `true` or `false`:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 基于谓词的搜索方法允许方法委托或lambda表达式来判断给定元素是否“匹配”。谓词只是接受对象并返回`true`或`false`的委托：
- en: '[PRE37]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'In the following example, we search an array of strings for a name containing
    the letter “a”:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们搜索一个字符串数组，以找到包含字母“a”的名称：
- en: '[PRE38]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Here’s the same code shortened with a lambda expression:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这是使用lambda表达式缩短的相同代码：
- en: '[PRE39]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '`FindAll` returns an array of all items satisfying the predicate. In fact,
    it’s equivalent to `Enumerable.Where` in the `System.Linq` namespace, except that
    `FindAll` returns an array of matching items rather than an `IEnumerable<T>` of
    the same.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`FindAll`返回满足谓词条件的所有项的数组。事实上，它等同于`System.Linq`命名空间中的`Enumerable.Where`，但`FindAll`返回匹配项的数组，而不是相同的`IEnumerable<T>`。'
- en: '`Exists` returns `true` if any array member satisfies the given predicate,
    and is equivalent to `Any` in `System.Linq.Enumerable`.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '`Exists`在任何数组成员满足给定谓词时返回`true`，等同于`System.Linq.Enumerable`中的`Any`。'
- en: '`TrueForAll` returns `true` if all items satisfy the predicate, and is equivalent
    to `All` in `System.Linq.Enumerable`.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '`TrueForAll`在所有项满足谓词条件时返回`true`，等同于`System.Linq.Enumerable`中的`All`。'
- en: Sorting
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 排序
- en: '`Array` has the following built-in sorting methods:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`Array`具有以下内置排序方法：'
- en: '[PRE40]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Each of these methods is additionally overloaded to also accept the following:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法还可以接受以下内容的重载：
- en: '[PRE41]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The following illustrates the simplest use of `Sort`:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 以下演示了 `Sort` 的最简单用法：
- en: '[PRE42]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The methods accepting a pair of arrays work by rearranging the items of each
    array in tandem, basing the ordering decisions on the first array. In the next
    example, both the numbers and their corresponding words are sorted into numerical
    order:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 接受一对数组的方法通过将每个数组的项配对重新排列来工作，并基于第一个数组进行排序决策。在下一个示例中，数字及其对应的单词都按数字顺序排序：
- en: '[PRE43]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '`Array.Sort` requires that the elements in the array implement `IComparable`
    (see [“Order Comparison”](ch06.html#order_comparison)). This means that most built-in
    C# types (such as integers, as in the preceding example) can be sorted. If the
    elements are not intrinsically comparable or you want to override the default
    ordering, you must provide `Sort` with a custom `comparison` provider that reports
    on the relative position of two elements. There are ways to do this:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '`Array.Sort` 要求数组中的元素实现 `IComparable`（参见 [“排序比较”](ch06.html#order_comparison)）。这意味着大多数内置的
    C# 类型（例如前面示例中的整数）可以被排序。如果元素不是本质上可比较的，或者你想要覆盖默认的排序顺序，你必须提供一个自定义的 `comparison` 提供者给
    `Sort`，用于报告两个元素的相对位置。有多种方法可以实现这一点：'
- en: Via a helper object that implements `IComparer` /`IComparer<T>` (see [“Plugging
    in Equality and Order”](#plugging_in_equality_and_order))
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过实现 `IComparer` / `IComparer<T>` 的辅助对象（见 [“插入相等性和顺序”](#plugging_in_equality_and_order)）
- en: 'Via a `Comparison` delegate:'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过 `Comparison` 委托：
- en: '[PRE44]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The `Comparison` delegate follows the same semantics as `IComparer<T>.CompareTo`:
    if `x` comes before `y`, a negative integer is returned; if `x` comes after `y`,
    a positive integer is returned; if `x` and `y` have the same sorting position,
    `0` is returned.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '`Comparison` 委托遵循与 `IComparer<T>.CompareTo` 相同的语义：如果 `x` 在 `y` 之前，则返回负整数；如果
    `x` 在 `y` 之后，则返回正整数；如果 `x` 和 `y` 的排序位置相同，则返回 `0`。'
- en: 'In the following example, we sort an array of integers such that the odd numbers
    come first:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例中，我们对整数数组进行排序，使奇数首先出现：
- en: '[PRE45]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Note
  id: totrans-210
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: As an alternative to calling `Sort`, you can use LINQ’s `OrderBy` and `ThenBy`
    operators. Unlike `Array.Sort`, the LINQ operators don’t alter the original array,
    instead emitting the sorted result in a fresh `IEnumerable<T>` sequence.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 作为调用 `Sort` 的替代方案，你可以使用 LINQ 的 `OrderBy` 和 `ThenBy` 操作符。与 `Array.Sort` 不同，LINQ
    操作符不会改变原始数组，而是在一个新的 `IEnumerable<T>` 序列中输出排序后的结果。
- en: Reversing Elements
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 颠倒元素
- en: 'The following `Array` methods reverse the order of all—or a portion of—elements
    in an array:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 以下 `Array` 方法颠倒数组中所有或部分元素的顺序：
- en: '[PRE46]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Copying
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 复制
- en: '`Array` provides four methods to perform shallow copying: `Clone`, `CopyTo`,
    `Copy`, and `ConstrainedCopy`. The former two are instance methods; the latter
    two are static methods.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '`Array` 提供了四种方法来执行浅复制：`Clone`、`CopyTo`、`Copy` 和 `ConstrainedCopy`。前两者是实例方法，后两者是静态方法。'
- en: 'The `Clone` method returns a whole new (shallow-copied) array. The `CopyTo`
    and `Copy` methods copy a contiguous subset of the array. Copying a multidimensional
    rectangular array requires you to map the multidimensional index to a linear index.
    For example, the middle square (`position[1,1]`) in a 3 × 3 array is represented
    with the index 4, from the calculation: 1 * 3 + 1\. The source and destination
    ranges can overlap without causing a problem.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '`Clone` 方法返回一个全新的（浅复制的）数组。`CopyTo` 和 `Copy` 方法复制数组的连续子集。复制多维矩形数组需要将多维索引映射到线性索引。例如，3
    × 3 数组中的中间方块（`position[1,1]`）用索引 4 表示，计算方法为：1 * 3 + 1。源范围和目标范围可以重叠而不会造成问题。'
- en: '`ConstrainedCopy` performs an *atomic* operation: if all of the requested elements
    cannot be successfully copied (due to a type error, for instance), the operation
    is rolled back.'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '`ConstrainedCopy` 执行一个 *原子* 操作：如果无法成功复制所有请求的元素（例如由于类型错误），则操作将回滚。'
- en: '`Array` also provides an `AsReadOnly` method that returns a wrapper that prevents
    elements from being reassigned.'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '`Array` 还提供了一个 `AsReadOnly` 方法，返回一个包装器，防止元素被重新赋值。'
- en: Converting and Resizing
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 转换和调整大小
- en: '`Array.ConvertAll` creates and returns a new array of element type `TOutput`,
    calling the supplied `Converter` delegate to copy over the elements. `Converter`
    is defined as follows:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '`Array.ConvertAll` 创建并返回一个新的 `TOutput` 元素类型的数组，调用提供的 `Converter` 委托来复制元素。`Converter`
    的定义如下：'
- en: '[PRE47]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The following converts an array of floats to an array of integers:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例将一个浮点数数组转换为整数数组：
- en: '[PRE48]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The `Resize` method works by creating a new array and copying over the elements,
    returning the new array via the reference parameter. However, any references to
    the original array in other objects will remain unchanged.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '`Resize`方法通过创建一个新数组并复制元素来工作，通过引用参数返回新数组。然而，其他对象中对原始数组的引用将保持不变。'
- en: Note
  id: totrans-226
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The `System.Linq` namespace offers an additional buffet of extension methods
    suitable for array conversion. These methods return an `IEnumerable<T>`, which
    you can convert back to an array via `Enumerable` ’s `ToArray` method.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '`System.Linq`命名空间提供了一系列适用于数组转换的扩展方法。这些方法返回一个`IEnumerable<T>`，你可以通过`Enumerable`的`ToArray`方法将其转换回数组。'
- en: Lists, Queues, Stacks, and Sets
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 列表、队列、堆栈和集合
- en: .NET provides a basic set of concrete collection classes that implement the
    interfaces described in this chapter. This section concentrates on the *list-like*
    collections (versus the *dictionary-like* collections, which we cover in [“Dictionaries”](#dictionaries)).
    As with the interfaces we discussed previously, you usually have a choice of generic
    or nongeneric versions of each type. In terms of flexibility and performance,
    the generic classes win, making their nongeneric counterparts redundant except
    for backward compatibility. This differs from the situation with collection interfaces,
    for which the nongeneric versions are still occasionally useful.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: .NET提供了一组基本的具体集合类，实现了本章描述的接口。本节集中讨论*类似于列表*的集合（而不是*类似于字典*的集合，我们将在[“字典”](#dictionaries)中讨论）。与我们之前讨论的接口一样，你通常可以选择每种类型的泛型或非泛型版本。在灵活性和性能方面，泛型类胜出，使它们的非泛型对应物除了向后兼容性之外都显得多余。这与集合接口的情况不同，对于集合接口，非泛型版本偶尔还是有用的。
- en: Of the classes described in this section, the generic `List` class is the most
    commonly used.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节描述的类中，泛型`List`类是最常用的。
- en: List<T> and ArrayList
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: List<T>和ArrayList
- en: The generic `List` and nongeneric `ArrayList` classes provide a dynamically
    sized array of objects and are among the most commonly used of the collection
    classes. `ArrayList` implements `IList`, whereas `List<T>` implements both `IList`
    and `IList<T>` (and the read-only version, `IReadOnlyList<T>`). Unlike with arrays,
    all interfaces are implemented publicly, and methods such as `Add` and `Remove`
    are exposed and work as you would expect.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型`List`和非泛型`ArrayList`类提供了一个动态大小的对象数组，是集合类中最常用的之一。`ArrayList`实现了`IList`接口，而`List<T>`则实现了`IList`和`IList<T>`（以及只读版本`IReadOnlyList<T>`）。与数组不同的是，所有接口都是公开实现的，诸如`Add`和`Remove`等方法都被暴露出来，并且按预期工作。
- en: Internally, `List<T>` and `ArrayList` work by maintaining an internal array
    of objects, replaced with a larger array upon reaching capacity. Appending elements
    is efficient (because there is usually a free slot at the end), but inserting
    elements can be slow (because all elements after the insertion point must be shifted
    to make a free slot), as can removing elements (especially near the start). As
    with arrays, searching is efficient if the `BinarySearch` method is used on a
    list that has been sorted, but it is otherwise inefficient because each item must
    be individually checked.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 内部，`List<T>`和`ArrayList`通过维护一个对象的内部数组来工作，在达到容量时会被替换为一个更大的数组。附加元素是高效的（因为通常在末尾有空闲槽位），但插入元素可能很慢（因为必须将插入点之后的所有元素移动以创建空闲槽位），删除元素也可能很慢（特别是在接近开始位置时）。与数组一样，如果在已排序的列表上使用`BinarySearch`方法，搜索是高效的，但在其他情况下效率较低，因为必须逐个检查每个项目。
- en: Note
  id: totrans-234
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: '`List<T>` is up to several times faster than `ArrayList` if `T` is a value
    type, because `List<T>` avoids the overhead of boxing and unboxing elements.'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 如果T是值类型，`List<T>`比`ArrayList`快几倍，因为`List<T>`避免了元素装箱和拆箱的开销。
- en: '`List<T>` and `ArrayList` provide constructors that accept an existing collection
    of elements: these copy each element from the existing collection into the new
    `List<T>` or `ArrayList`:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '`List<T>`和`ArrayList`提供了接受现有元素集合的构造函数：这些函数将现有集合中的每个元素复制到新的`List<T>`或`ArrayList`中：'
- en: '[PRE49]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: In addition to these members, `List<T>` provides instance versions of all of
    `Array`’s searching and sorting methods.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些成员外，`List<T>`还提供了所有`Array`的搜索和排序方法的实例版本。
- en: 'The following code demonstrates `List`’s properties and methods (for examples
    on searching and sorting, see [“The Array Class”](#the_array_class)):'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码演示了`List`的属性和方法（有关搜索和排序的示例，请参见[“数组类”](#the_array_class)）：
- en: '[PRE50]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The nongeneric `ArrayList` class requires clumsy casts—as the following example
    demonstrates:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 非泛型`ArrayList`类需要笨拙的类型转换，正如下面的示例所示：
- en: '[PRE51]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Such casts cannot be verified by the compiler; the following compiles successfully
    but then fails at runtime:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 此类转换无法通过编译器验证；以下代码编译成功，但在运行时失败：
- en: '[PRE52]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Note
  id: totrans-245
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: An `ArrayList` is functionally similar to `List<object>`. Both are useful when
    you need a list of mixed-type elements that share no common base type (other than
    `object`). A possible advantage of choosing an `ArrayList`, in this case, would
    be if you need to deal with the list using reflection ([Chapter 19](ch19.html#dynamic_programming)).
    Reflection is easier with a nongeneric `ArrayList` than a `List<object>`.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '`ArrayList`在功能上类似于`List<object>`。当您需要一个包含没有共同基类型（除`object`外）的混合类型元素列表时，这两者都非常有用。在这种情况下选择`ArrayList`的一个可能优势是，如果需要使用反射处理列表（见[第19章](ch19.html#dynamic_programming)），则使用非泛型的`ArrayList`比`List<object>`更容易。反射在非泛型`ArrayList`上比`List<object>`更容易。'
- en: 'If you import the `System.Linq` namespace, you can convert an `ArrayList` to
    a generic `List` by calling `Cast` and then `ToList`:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 如果导入`System.Linq`命名空间，可以通过调用`Cast`然后`ToList`将`ArrayList`转换为泛型`List`：
- en: '[PRE53]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '`Cast` and `ToList` are extension methods in the `System.Linq.Enumerable` class.'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '`Cast`和`ToList`是`System.Linq.Enumerable`类中的扩展方法。'
- en: LinkedList<T>
  id: totrans-250
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: LinkedList<T>
- en: '`LinkedList<T>` is a generic doubly linked list (see [Figure 7-4](#linkedlistless_thantgreater-id00075)).
    A doubly linked list is a chain of nodes in which each references the node before,
    the node after, and the actual element. Its main benefit is that an element can
    always be inserted efficiently anywhere in the list because it just involves creating
    a new node and updating a few references. However, finding where to insert the
    node in the first place can be slow because there’s no intrinsic mechanism to
    index directly into a linked list; each node must be traversed, and binary-chop
    searches are not possible.'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '`LinkedList<T>`是泛型双向链表（见[图 7-4](#linkedlistless_thantgreater-id00075)）。双向链表是一系列节点，每个节点分别引用其前后节点和实际元素。其主要优势在于可以高效地在列表中的任何位置插入元素，只需创建一个新节点并更新少数引用即可。但是，首先找到要插入节点的位置可能会很慢，因为没有内在机制直接索引到链表；每个节点必须遍历，且无法进行二分查找。'
- en: '![LinkedList<T>](assets/cn10_0704.png)'
  id: totrans-252
  prefs: []
  type: TYPE_IMG
  zh: '![LinkedList<T>](assets/cn10_0704.png)'
- en: Figure 7-4\. LinkedList<T>
  id: totrans-253
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 7-4\. LinkedList<T>
- en: '`LinkedList<T>` implements `IEnumerable<T>` and `ICollection<T>` (and their
    nongeneric versions), but not `IList<T>` because access by index is not supported.
    List nodes are implemented via the following class:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '`LinkedList<T>`实现了`IEnumerable<T>`和`ICollection<T>`（以及它们的非泛型版本），但不支持`IList<T>`，因为不支持按索引访问。列表节点是通过以下类实现的：'
- en: '[PRE54]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'When adding a node, you can specify its position either relative to another
    node or at the start/end of the list. `LinkedList<T>` provides the following methods
    for this:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加节点时，可以指定其相对于另一个节点的位置或位于列表的起始/末尾。`LinkedList<T>`提供了以下方法：
- en: '[PRE55]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Similar methods are provided to remove elements:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 还提供了类似的方法来删除元素：
- en: '[PRE56]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '`LinkedList<T>` has internal fields to keep track of the number of elements
    in the list as well as the head and tail of the list. These are exposed in the
    following public properties:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '`LinkedList<T>`具有内部字段来跟踪列表中的元素数量以及列表的头部和尾部。这些在以下公共属性中公开：'
- en: '[PRE57]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '`LinkedList<T>` also supports the following searching methods (each requiring
    that the list be internally enumerated):'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '`LinkedList<T>`也支持以下搜索方法（每种方法都要求列表在内部枚举）：'
- en: '[PRE58]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Finally, `LinkedList<T>` supports copying to an array for indexed processing
    and obtaining an enumerator to support the `foreach` statement:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`LinkedList<T>`支持将元素复制到数组以进行索引处理，并获取枚举器以支持`foreach`语句：
- en: '[PRE59]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Here’s a demonstration on the use of `LinkedList<string>`:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 下面演示了`LinkedList<string>`的使用：
- en: '[PRE60]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Queue<T> and Queue
  id: totrans-268
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Queue<T>和Queue
- en: '`Queue<T>` and `Queue` are first-in, first-out (FIFO) data structures, providing
    methods to `Enqueue` (add an item to the tail of the queue) and `Dequeue` (retrieve
    and remove the item at the head of the queue). A `Peek` method is also provided
    to return the element at the head of the queue without removing it, and a `Count`
    property (useful in checking that elements are present before dequeuing).'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '`Queue<T>`和`Queue`是先进先出（FIFO）的数据结构，提供了`Enqueue`（将项目添加到队列的尾部）和`Dequeue`（检索并移除队列头部的项目）方法。还提供了一个`Peek`方法，在不移除元素的情况下返回队列头部的元素，并提供了一个`Count`属性（在出队之前检查元素是否存在时非常有用）。'
- en: 'Although queues are enumerable, they do not implement `IList<T>`/`IList`, because
    members cannot be accessed directly by index. A `ToArray` method is provided,
    however, for copying the elements to an array from which they can be randomly
    accessed:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管队列是可枚举的，但它们不实现`IList<T>`/`IList`，因为无法直接通过索引访问成员。但是，提供了一个`ToArray`方法，可以将元素复制到数组中，从而可以随机访问它们：
- en: '[PRE61]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The following is an example of using `Queue<int>`:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是使用`Queue<int>`的示例：
- en: '[PRE62]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Queues are implemented internally using an array that’s resized as required—much
    like the generic `List` class. The queue maintains indexes that point directly
    to the head and tail elements; therefore, enqueuing and dequeuing are extremely
    quick operations (except when an internal resize is required).
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 队列使用内部调整大小的数组实现，与泛型`List`类似。队列维护直接指向头部和尾部元素的索引；因此，入队和出队操作非常快（除非需要内部调整大小）。
- en: Stack<T> and Stack
  id: totrans-275
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`Stack<T>` 和 `Stack`'
- en: '`Stack<T>` and `Stack` are last-in, first-out (LIFO) data structures, providing
    methods to `Push` (add an item to the top of the stack) and `Pop` (retrieve and
    remove an element from the top of the stack). A nondestructive `Peek` method is
    also provided, as is a `Count` property and a `ToArray` method for exporting the
    data for random access:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '`Stack<T>` 和 `Stack` 是后进先出（LIFO）的数据结构，提供`Push`（将项目添加到堆栈顶部）和`Pop`（检索并移除堆栈顶部的元素）方法。还提供了非破坏性的`Peek`方法，以及`Count`属性和`ToArray`方法用于导出数据进行随机访问：'
- en: '[PRE63]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'The following example demonstrates `Stack<int>`:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的示例演示了`Stack<int>`：
- en: '[PRE64]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Stacks are implemented internally with an array that’s resized as required,
    as with `Queue<T>` and `List<T>`.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 栈使用内部调整大小的数组实现，与`Queue<T>`和`List<T>`类似。
- en: BitArray
  id: totrans-281
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: BitArray
- en: A `BitArray` is a dynamically sized collection of compacted `bool` values. It
    is more memory efficient than both a simple array of `bool` and a generic `List`
    of `bool` because it uses only one bit for each value, whereas the `bool` type
    otherwise occupies one byte for each value.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '`BitArray`是一种动态大小的压缩布尔值集合。它比简单的`bool`数组和泛型`List<bool>`更节省内存，因为每个值仅使用一位，而`bool`类型通常为每个值占用一个字节。'
- en: '`BitArray`’s indexer reads and writes individual bits:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '`BitArray`的索引器可以读取和写入单个位：'
- en: '[PRE65]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'There are four bitwise operator methods (`And`, `Or`, `Xor`, and `Not`). All
    but the last accept another `BitArray`:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 有四个位操作方法（`And`、`Or`、`Xor`和`Not`）。除了最后一个外，所有方法都接受另一个`BitArray`：
- en: '[PRE66]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: HashSet<T> and SortedSet<T>
  id: totrans-287
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: HashSet<T> 和 SortedSet<T>
- en: '`HashSet<T>` and `SortedSet<T>` have the following distinguishing features:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '`HashSet<T>` 和 `SortedSet<T>` 具有以下显著特点：'
- en: Their `Contains` methods execute quickly using a hash-based lookup.
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们的`Contains`方法使用基于哈希的快速查找。
- en: They do not store duplicate elements and silently ignore requests to add duplicates.
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们不存储重复的元素，并且会默默地忽略添加重复元素的请求。
- en: You cannot access an element by position.
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你不能通过位置访问元素。
- en: '`SortedSet<T>` keeps elements in order, whereas `HashSet<T>` does not.'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '`SortedSet<T>`保持元素有序，而`HashSet<T>`则不是。'
- en: The commonality of the `HashSet<T>` and `SortedSet<T>` types is captured by
    the interface `ISet<T>`. From .NET 5, these classes also implement an interface
    called `IReadOnlySet<T>`, which is also implemented by the immutable set types
    (see [“Immutable Collections”](#immutable_collections)).
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '`HashSet<T>` 和 `SortedSet<T>` 类型的共同点由接口`ISet<T>`捕获。从.NET 5开始，这些类还实现了一个名为`IReadOnlySet<T>`的接口，这个接口也被不可变集合类型实现（参见[“不可变集合”](#immutable_collections)）。'
- en: '`HashSet<T>` is implemented with a hashtable that stores just keys; `SortedSet<T>`
    is implemented with a red/black tree.'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '`HashSet<T>`使用哈希表实现，仅存储键；`SortedSet<T>`使用红黑树实现。'
- en: Both collections implement `ICollection<T>` and offer methods that you would
    expect, such as `Contains`, `Add`, and `Remove`. In addition, there’s a predicate-based
    removal method called `RemoveWhere`.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个集合都实现了`ICollection<T>`接口，并提供了如`Contains`、`Add`和`Remove`等你预期的方法。此外，还提供了基于谓词的移除方法`RemoveWhere`。
- en: 'The following constructs a `HashSet<char>` from an existing collection, tests
    for membership, and then enumerates the collection (notice the absence of duplicates):'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码从现有集合构造了一个`HashSet<char>`，测试了成员资格，然后枚举了集合（注意没有重复项）：
- en: '[PRE67]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: (The reason we can pass a `string` into `HashSet<char>`’s constructor is because
    `string` implements `IEnumerable<char>`.)
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: （我们可以将`string`传递给`HashSet<char>`的构造函数的原因是因为`string`实现了`IEnumerable<char>`接口。）
- en: 'The really interesting methods are the set operations. The following set operations
    are *destructive* in that they modify the set:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 真正有趣的方法是集合操作。以下集合操作是*破坏性*的，因为它们修改了集合：
- en: '[PRE68]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'whereas the following methods simply query the set and so are nondestructive:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 而以下方法仅查询集合，因此是非破坏性的：
- en: '[PRE69]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '`UnionWith` adds all the elements in the second set to the original set (excluding
    duplicates). `IntersectWith` removes the elements that are not in both sets. We
    can extract all of the vowels from our set of characters as follows:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '`UnionWith` 将第二个集合中的所有元素添加到原始集合（不包括重复项）。 `IntersectWith` 删除不在两个集合中的元素。我们可以如下提取字符集中的所有元音字母：'
- en: '[PRE70]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '`ExceptWith` removes the specified elements from the source set. Here, we strip
    all vowels from the set:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '`ExceptWith` 从源集合中移除指定的元素。在这里，我们从集合中剔除所有元音字母：'
- en: '[PRE71]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '`SymmetricExceptWith` removes all but the elements that are unique to one set
    or the other:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '`SymmetricExceptWith` 会删除除了两个集合中唯一的元素之外的所有元素：'
- en: '[PRE72]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Note that because `HashSet<T>` and `SortedSet<T>` implement `IEnumerable<T>`,
    you can use another type of set (or collection) as the argument to any of the
    set operation methods.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，因为 `HashSet<T>` 和 `SortedSet<T>` 实现了 `IEnumerable<T>`，所以您可以将另一种类型的集合（或集合）用作任何集合操作方法的参数。
- en: '`SortedSet<T>` offers all the members of `HashSet<T>`, plus the following:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '`SortedSet<T>` 提供 `HashSet<T>` 的所有成员，以及以下内容：'
- en: '[PRE73]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '`SortedSet<T>` also accepts an optional `IComparer<T>` in its constructor (rather
    than an *equality comparer*).'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '`SortedSet<T>` 在其构造函数中还接受一个可选的 `IComparer<T>`（而不是*相等比较器*）。'
- en: 'Here’s an example of loading the same letters into a `SortedSet<char>`:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个将相同字母加载到 `SortedSet<char>` 的示例：
- en: '[PRE74]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Following on from this, we can obtain the letters in the set between *f* and
    *i* as follows:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 继续之前，我们可以如下获取集合中 *f* 和 *i* 之间的字母：
- en: '[PRE75]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Dictionaries
  id: totrans-317
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字典
- en: A dictionary is a collection in which each element is a key/value pair. Dictionaries
    are most commonly used for lookups and sorted lists.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 字典是一种每个元素都是键/值对的集合。字典最常用于查找和排序列表。
- en: '.NET defines a standard protocol for dictionaries, via the interfaces `IDictionary`
    and `IDictionary <TKey, TValue>`, as well as a set of general-purpose dictionary
    classes. The classes each differ in the following regard:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 定义了字典的标准协议，通过接口 `IDictionary` 和 `IDictionary <TKey, TValue>`，以及一组通用的字典类。这些类在以下方面各不相同：
- en: Whether or not items are stored in sorted sequence
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是否按排序顺序存储项
- en: Whether or not items can be accessed by position (index) as well as by key
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是否可以通过位置（索引）和键访问项
- en: Whether it’s generic or nongeneric
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是否为泛型或非泛型
- en: Whether it’s fast or slow to retrieve items by key from a large dictionary
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是否从大字典中通过键快速或慢速检索项
- en: '[Table 7-1](#dictionary_classes) summarizes each of the dictionary classes
    and how they differ in these respects. The performance times are in milliseconds
    and based on performing 50,000 operations on a dictionary with integer keys and
    values on a 1.5 GHz PC. (The differences in performance between generic and nongeneric
    counterparts using the same underlying collection structure are due to boxing,
    and show up only with value-type elements.)'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 7-1](#dictionary_classes) 总结了每个字典类及其在这些方面的不同之处。性能时间以毫秒为单位，并基于在1.5 GHz PC上对整数键和值的字典执行
    50,000 次操作。（相同底层集合结构使用泛型和非泛型对应体现出来的性能差异，是由于装箱而产生的。）'
- en: Table 7-1\. Dictionary classes
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 表 7-1\. 字典类
- en: '| Type | Internal structure | Retrieve by index? | Memory overhead (avg. bytes
    per item) | Speed: random insertion | Speed: sequential insertion | Speed: retrieval
    by key |'
  id: totrans-326
  prefs: []
  type: TYPE_TB
  zh: '| 类型 | 内部结构 | 是否按索引检索？ | 内存开销（平均每项字节） | 随机插入速度 | 顺序插入速度 | 按键检索速度 |'
- en: '| --- | --- | --- | --- | --- | --- | --- |'
  id: totrans-327
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- | --- |'
- en: '| **Unsorted** |  |  |  |  |  |  |'
  id: totrans-328
  prefs: []
  type: TYPE_TB
  zh: '| **未排序** |  |  |  |  |  |  |'
- en: '| `Dictionary <K,V>` | Hashtable | No | 22 | 30 | 30 | 20 |'
  id: totrans-329
  prefs: []
  type: TYPE_TB
  zh: '| `Dictionary <K,V>` | 哈希表 | 否 | 22 | 30 | 30 | 20 |'
- en: '| `Hashtable` | Hashtable | No | 38 | 50 | 50 | 30 |'
  id: totrans-330
  prefs: []
  type: TYPE_TB
  zh: '| `Hashtable` | 哈希表 | 否 | 38 | 50 | 50 | 30 |'
- en: '| `ListDictionary` | Linked list | No | 36 | 50,000 | 50,000 | 50,000 |'
  id: totrans-331
  prefs: []
  type: TYPE_TB
  zh: '| `ListDictionary` | 链表 | 否 | 36 | 50,000 | 50,000 | 50,000 |'
- en: '| `OrderedDictionary` | Hashtable + array | Yes | 59 | 70 | 70 | 40 |'
  id: totrans-332
  prefs: []
  type: TYPE_TB
  zh: '| `OrderedDictionary` | 哈希表 + 数组 | 是 | 59 | 70 | 70 | 40 |'
- en: '| **Sorted** |  |  |  |  |  |  |'
  id: totrans-333
  prefs: []
  type: TYPE_TB
  zh: '| **已排序** |  |  |  |  |  |  |'
- en: '| `SortedDictionary <K,V>` | Red/black tree | No | 20 | 130 | 100 | 120 |'
  id: totrans-334
  prefs: []
  type: TYPE_TB
  zh: '| `SortedDictionary <K,V>` | 红黑树 | 否 | 20 | 130 | 100 | 120 |'
- en: '| `SortedList <K,V>` | 2xArray | Yes | 2 | 3,300 | 30 | 40 |'
  id: totrans-335
  prefs: []
  type: TYPE_TB
  zh: '| `SortedList <K,V>` | 2xArray | 是 | 2 | 3,300 | 30 | 40 |'
- en: '| `SortedList` | 2xArray | Yes | 27 | 4,500 | 100 | 180 |'
  id: totrans-336
  prefs: []
  type: TYPE_TB
  zh: '| `SortedList` | 2xArray | 是 | 27 | 4,500 | 100 | 180 |'
- en: 'In Big-O notation, retrieval time by key is as follows:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 用大O表示法，按键检索时间如下：
- en: O(1) for `Hashtable`, `Dictionary`, and `OrderedDictionary`
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Hashtable`、`Dictionary` 和 `OrderedDictionary` 的大O为O(1)'
- en: O(log *n*) for `SortedDictionary` and `SortedList`
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于`SortedDictionary`和`SortedList`，为O(log *n*)。
- en: O(*n*) for `ListDictionary` (and nondictionary types such as `List<T>`)
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于`ListDictionary`（以及`List<T>`等非字典类型），为O(*n*)
- en: '*n* is the number of elements in the collection.'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: '*n*代表集合中的元素数量。'
- en: IDictionary<TKey,TValue>
  id: totrans-342
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: IDictionary<TKey,TValue>
- en: '`IDictionary<TKey,TValue>` defines the standard protocol for all key/value-based
    collections. It extends `ICollection<T>` by adding methods and properties to access
    elements based on a key of arbitrary type:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: '`IDictionary<TKey,TValue>`定义了所有基于键/值的集合的标准协议。它通过添加方法和属性来扩展`ICollection<T>`，以根据任意类型的键访问元素。'
- en: '[PRE76]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Note
  id: totrans-345
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: There’s also an interface called `IReadOnlyDictionary<TKey,TValue>` that defines
    the read-only subset of dictionary members.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个名为`IReadOnlyDictionary<TKey,TValue>`的接口，定义了字典成员的只读子集。
- en: To add an item to a dictionary, you either call `Add` or use the index’s set
    accessor—the latter adds an item to the dictionary if the key is not already present
    (or updates the item if it is present). Duplicate keys are forbidden in all dictionary
    implementations, so calling `Add` twice with the same key throws an exception.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 要向字典中添加项目，可以调用`Add`或使用索引器的设置访问器——后者将项目添加到字典中（如果键尚不存在）或更新项目（如果已存在）。所有字典实现都禁止重复键，因此如果使用相同键两次调用`Add`会抛出异常。
- en: To retrieve an item from a dictionary, use either the indexer or the `TryGetValue`
    method. If the key doesn’t exist, the indexer throws an exception, whereas `TryGetValue`
    returns `false`. You can test for membership explicitly by calling `Contain⁠s​Key`;
    however, this incurs the cost of two lookups if you then subsequently retrieve
    the item.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 要从字典中检索项目，请使用索引器或`TryGetValue`方法。如果键不存在，索引器会抛出异常，而`TryGetValue`会返回`false`。你可以通过调用`Contain⁠s​Key`显式测试成员资格；然而，如果你随后检索项目，则会产生两次查找的成本。
- en: 'Enumerating directly over an `IDictionary<TKey,TValue>` returns a sequence
    of `KeyValuePair` structs:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 直接枚举`IDictionary<TKey,TValue>`会返回一个`KeyValuePair`结构的序列：
- en: '[PRE77]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: You can enumerate over just the keys or values via the dictionary’s `Keys`/`Values`
    properties.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过字典的`Keys`/`Values`属性仅枚举键或值。
- en: We demonstrate the use of this interface with the generic `Dictionary` class
    in the following section.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在下一节中演示如何使用这个接口与泛型`Dictionary`类。
- en: IDictionary
  id: totrans-353
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: IDictionary
- en: 'The nongeneric `IDictionary` interface is the same in principle as `IDictionary<TKey,TValue>`,
    apart from two important functional differences. It’s important to be aware of
    these differences, because `IDictionary` appears in legacy code (including the
    .NET BCL itself in places):'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 非泛型的`IDictionary`接口在原则上与`IDictionary<TKey,TValue>`相同，除了两个重要的功能差异。了解这些差异很重要，因为`IDictionary`在遗留代码中（包括.NET
    BCL本身的某些位置）中出现：
- en: Retrieving a nonexistent key via the indexer returns null (rather than throwing
    an exception).
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过索引器检索不存在的键会返回null（而不是抛出异常）。
- en: '`Contains` tests for membership rather than `ContainsKey`.'
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Contains`用于测试成员资格，而不是`ContainsKey`。'
- en: 'Enumerating over a nongeneric `IDictionary` returns a sequence of `Dictionary​En⁠try`
    structs:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 枚举非泛型`IDictionary`会返回一个`Dictionary​En⁠try`结构的序列：
- en: '[PRE78]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Dictionary<TKey,TValue> and Hashtable
  id: totrans-359
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Dictionary<TKey,TValue>和Hashtable
- en: The generic `Dictionary` class is one of the most commonly used collections
    (along with the `List<T>` collection). It uses a hashtable data structure to store
    keys and values, and it is fast and efficient.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型`Dictionary`类是最常用的集合之一（与`List<T>`集合一样）。它使用哈希表数据结构存储键和值，速度快且高效。
- en: Note
  id: totrans-361
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The nongeneric version of `Dictionary<TKey,TValue>` is called `Hashtable`; there
    is no nongeneric class called `Dictionary`. When we refer simply to `Dictionary`,
    we mean the generic `Dictionary<TKey,TValue>` class.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 非泛型的`Dictionary<TKey,TValue>`版本称为`Hashtable`；没有称为`Dictionary`的非泛型类。当我们简称`Dictionary`时，指的是泛型`Dictionary<TKey,TValue>`类。
- en: '`Dictionary` implements both the generic and nongeneric `IDictionary` interfaces,
    the generic `IDictionary` being exposed publicly. `Dictionary` is, in fact, a
    “textbook” implementation of the generic `IDictionary`.'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: '`Dictionary`实现了泛型和非泛型的`IDictionary`接口，泛型的`IDictionary`是公开的。实际上，`Dictionary`是泛型`IDictionary`的“教科书”实现。'
- en: 'Here’s how to use it:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 使用方法如下：
- en: '[PRE79]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Its underlying hashtable works by converting each element’s key into an integer
    hashcode—a pseudo-unique value—and then applying an algorithm to convert the hashcode
    into a hash key. This hash key is used internally to determine which “bucket”
    an entry belongs to. If the bucket contains more than one value, a linear search
    is performed on the bucket. A good hash function does not strive to return strictly
    unique hashcodes (which would usually be impossible); it strives to return hashcodes
    that are evenly distributed across the 32-bit integer space. This avoids the scenario
    of ending up with a few very large (and inefficient) buckets.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 其底层的哈希表通过将每个元素的键转换为整数哈希码（一种伪唯一的值），然后应用算法将哈希码转换为哈希键。这个哈希键在内部用于确定条目属于哪个“桶”。如果桶中包含多个值，则在桶上执行线性搜索。一个好的哈希函数不会力求返回严格唯一的哈希码（通常是不可能的），它力求返回均匀分布在32位整数空间中的哈希码。这避免了最终出现少数非常大（且低效）的桶的情况。
- en: 'A dictionary can work with keys of any type, providing it’s able to determine
    equality between keys and obtain hashcodes. By default, equality is determined
    via the key’s `object.Equals` method, and the pseudo-unique hashcode is obtained
    via the key’s `GetHashCode` method. You can change this behavior either by overriding
    these methods or by providing an `IEqualityComparer` object when constructing
    the dictionary. A common application of this is to specify a case-insensitive
    equality comparer when using string keys:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 字典可以使用任何类型的键工作，只要能够确定键之间的相等性并获取哈希码。默认情况下，通过键的`object.Equals`方法确定相等性，并通过键的`GetHashCode`方法获取伪唯一的哈希码。可以通过覆盖这些方法或在构建字典时提供`IEqualityComparer`对象来更改此行为。在使用字符串键时，常见的应用是指定一个不区分大小写的相等性比较器：
- en: '[PRE80]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: We discuss this further in [“Plugging in Equality and Order”](#plugging_in_equality_and_order).
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[“插入相等性和顺序”](#plugging_in_equality_and_order)中进一步讨论这一点。
- en: As with many other types of collections, you can improve the performance of
    a dictionary slightly by specifying the collection’s expected size in the constructor,
    avoiding or lessening the need for internal resizing operations.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 与许多其他类型的集合一样，可以通过在构造函数中指定集合的预期大小来略微提高字典的性能，从而避免或减少内部调整大小操作的需求。
- en: The nongeneric version is named `Hashtable` and is functionally similar apart
    from differences stemming from it exposing the nongeneric `IDictionary` interface
    discussed previously.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 非泛型版本命名为`Hashtable`，在功能上类似，除了因其公开了先前讨论过的非泛型`IDictionary`接口而产生的差异。
- en: The downside to `Dictionary` and `Hashtable` is that the items are not sorted.
    Furthermore, the original order in which the items were added is not retained.
    As with all dictionaries, duplicate keys are not allowed.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: '`Dictionary`和`Hashtable`的缺点是项目不会排序。此外，不会保留项目添加的原始顺序。与所有字典一样，不允许重复键。'
- en: Note
  id: totrans-373
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: When the generic collections were introduced back in 2005, the CLR team chose
    to name them according to what they represent (`Dictionary`, `List`) rather than
    how they are internally implemented (`Hashtable`, `ArrayList`). Although this
    is good because it gives them the freedom to later change the implementation,
    it also means that the *performance contract* (often the most important criteria
    in choosing one kind of collection over another) is no longer captured in the
    name.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 当泛型集合在2005年引入时，CLR团队选择根据它们的表示方式（`Dictionary`、`List`）而不是它们的内部实现方式（`Hashtable`、`ArrayList`）来命名它们。尽管这样做是好的，因为它给了他们后来更改实现的自由，但这也意味着*性能约定*（通常是选择一种集合类型的最重要标准）不再在名称中体现。
- en: OrderedDictionary
  id: totrans-375
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: OrderedDictionary
- en: An `OrderedDictionary` is a nongeneric dictionary that maintains elements in
    the same order that they were added. With an `OrderedDictionary`, you can access
    elements both by index and by key.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 一个`OrderedDictionary`是一个非泛型字典，它以元素添加的顺序维护元素。使用`OrderedDictionary`，你可以通过索引和键访问元素。
- en: Note
  id: totrans-377
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: An `OrderedDictionary` is not a *sorted* dictionary.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 一个`OrderedDictionary`不是*排序*字典。
- en: An `OrderedDictionary` is a combination of a `Hashtable` and an `ArrayList`.
    This means that it has all the functionality of a `Hashtable`, plus functions
    such as `RemoveAt`, and an integer indexer. It also exposes `Keys` and `Values`
    properties that return elements in their original order.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 一个`OrderedDictionary`是`Hashtable`和`ArrayList`的组合。这意味着它具有`Hashtable`的所有功能，还具有诸如`RemoveAt`和整数索引器等功能。它还公开了`Keys`和`Values`属性，以原始顺序返回元素。
- en: This class was introduced in .NET 2.0; yet, peculiarly, there’s no generic version.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类在 .NET 2.0 中引入；然而，奇怪的是，没有泛型版本。
- en: ListDictionary and HybridDictionary
  id: totrans-381
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ListDictionary 和 HybridDictionary
- en: '`ListDictionary` uses a singly linked list to store the underlying data. It
    doesn’t provide sorting, although it does preserve the original entry order of
    the items. `ListDictionary` is extremely slow with large lists. Its only real
    “claim to fame” is its efficiency with very small lists (fewer than 10 items).'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: '`ListDictionary` 使用单向链表存储底层数据。它不提供排序，尽管它保留了项目的原始输入顺序。对于大型列表，`ListDictionary`
    速度非常慢。它唯一真正的“成就”是在非常小的列表（少于 10 项）中的效率。'
- en: '`HybridDictionary` is a `ListDictionary` that automatically converts to a `Hashtable`
    upon reaching a certain size, to address `ListDictionary`’s problems with performance.
    The idea is to get a low memory footprint when the dictionary is small, and good
    performance when the dictionary is large. However, given the overhead in converting
    from one to the other—and the fact that a `Dictionary` is not excessively heavy
    or slow in either scenario—you wouldn’t suffer unreasonably by using a `Dictionary`
    to begin with.'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: '`HybridDictionary` 是 `ListDictionary`，在达到一定大小时会自动转换为 `Hashtable`，以解决 `ListDictionary`
    在性能上的问题。其思想是在字典较小时获得较低的内存占用，并在字典较大时获得良好的性能。然而，考虑到从一个转换到另一个的开销——而且 `Dictionary`
    在任何情况下都不会过于笨重或缓慢——因此，一开始使用 `Dictionary` 不会带来不合理的困扰。'
- en: Both classes come only in nongeneric form.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个类仅以非泛型形式存在。
- en: Sorted Dictionaries
  id: totrans-385
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 排序字典
- en: 'The .NET BCL provides two dictionary classes internally structured such that
    their content is always sorted by key:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: .NET BCL 提供了两个字典类，其内部结构使其内容始终按键排序：
- en: '`SortedDictionary<TKey,TValue>`'
  id: totrans-387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SortedDictionary<TKey,TValue>`'
- en: '`SortedList<TKey,TValue>`^([1](ch07.html#ch01fn6))'
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SortedList<TKey,TValue>`^([1](ch07.html#ch01fn6))'
- en: (In this section, we abbreviate `<TKey,TValue>` to `<,>`.)
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: （在本节中，我们将 `<TKey,TValue>` 缩写为 `<,>`。）
- en: '`SortedDictionary<,>` uses a red/black tree: a data structure designed to perform
    consistently well in any insertion or retrieval scenario.'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: '`SortedDictionary<,>` 使用红黑树：一种设计成在任何插入或检索场景中表现一致良好的数据结构。'
- en: '`SortedList<,>` is implemented internally with an ordered array pair, providing
    fast retrieval (via a binary-chop search) but poor insertion performance (because
    existing values need to be shifted to make room for a new entry).'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: '`SortedList<,>` 在内部实现中使用有序数组对，通过二分查找提供快速检索，但插入性能较差（因为需要移动现有值以腾出空间来放置新条目）。'
- en: '`SortedDictionary<,>` is much faster than `SortedList<,>` at inserting elements
    in a random sequence (particularly with large lists). `SortedList<,>`, however,
    has an extra ability: to access items by index as well as by key. With a sorted
    list, you can go directly to the *n*th element in the sorting sequence (via the
    indexer on the `Keys`/`Values` properties). To do the same with a `SortedDictionary<,>`,
    you must manually enumerate over *n* items. (Alternatively, you could write a
    class that combines a sorted dictionary with a list class.)'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: '`SortedDictionary<,>` 在随机顺序插入元素时比 `SortedList<,>` 快得多（特别是对于大型列表）。然而，`SortedList<,>`
    有一个额外的能力：可以通过索引以及键访问项目。通过排序列表，您可以直接访问排序序列中的第 *n* 个元素（通过 `Keys`/`Values` 属性的索引器）。要在
    `SortedDictionary<,>` 中做同样的事情，您必须手动枚举 *n* 个项目。（或者，您可以编写一个将排序字典与列表类结合的类。）'
- en: None of the three collections allows duplicate keys (as is the case with all
    dictionaries).
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个集合都不允许重复键（就像所有字典一样）。
- en: 'The following example uses reflection to load all of the methods defined in
    `System.Object` into a sorted list keyed by name and then enumerates their keys
    and values:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的示例使用反射将 `System.Object` 中定义的所有方法加载到按名称排序的排序列表中，然后枚举它们的键和值：
- en: '[PRE81]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Here’s the result of the first enumeration:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是第一次枚举的结果：
- en: '[PRE82]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Here’s the result of the second enumeration:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是第二次枚举的结果：
- en: '[PRE83]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: Notice that we populated the dictionary through its indexer. If we instead used
    the `Add` method, it would throw an exception because the `object` class upon
    which we’re reflecting overloads the `Equals` method, and you can’t add the same
    key twice to a dictionary. By using the indexer, the later entry overwrites the
    earlier entry, preventing this error.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们通过其索引器填充了字典。如果我们使用 `Add` 方法，它将抛出异常，因为我们反射的 `object` 类重载了 `Equals` 方法，并且不能将相同的键两次添加到字典中。通过使用索引器，后续条目将覆盖较早的条目，从而防止此错误。
- en: Note
  id: totrans-401
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can store multiple members of the same key by making each value element
    a list:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过将每个值元素设置为列表来存储相同键的多个成员：
- en: '[PRE84]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Extending our example, the following retrieves the `MethodInfo` whose key is
    `"GetHashCode"`, just as with an ordinary dictionary:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展我们的示例，以下代码检索其键为 `"GetHashCode"` 的 `MethodInfo`，就像普通字典一样：
- en: '[PRE85]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'So far, everything we’ve done would also work with a `SortedDictionary<,>`.
    The following two lines, however, which retrieve the last key and value, work
    only with a sorted list:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们所做的一切也适用于 `SortedDictionary<,>`。然而，以下两行代码，用于检索最后一个键和值，仅适用于排序列表：
- en: '[PRE86]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: Customizable Collections and Proxies
  id: totrans-408
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可定制的集合和代理
- en: 'The collection classes discussed in previous sections are convenient in that
    you can directly instantiate them, but they don’t allow you to control what happens
    when an item is added to or removed from the collection. With strongly typed collections
    in an application, you sometimes need this control; for instance:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面部分讨论的集合类非常方便，因为可以直接实例化它们，但是它们不允许控制将项添加到集合或从集合中移除时发生的情况。在应用程序中的强类型集合中，有时需要这种控制；例如：
- en: To fire an event when an item is added or removed
  id: totrans-410
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当添加或删除项时触发事件
- en: To update properties because of the added or removed item
  id: totrans-411
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因为添加或删除项而更新属性
- en: To detect an “illegal” add/remove operation and throw an exception (for example,
    if the operation violates a business rule)
  id: totrans-412
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检测“非法”添加/删除操作并抛出异常（例如，如果操作违反业务规则）
- en: The .NET BCL provides collection classes for this exact purpose, in the `System​.Col⁠lections.ObjectModel`
    namespace. These are essentially proxies or wrappers that implement `IList<T>`
    or `IDictionary<,>` by forwarding the methods through to an underlying collection.
    Each `Add`, `Remove`, or `Clear` operation is routed via a virtual method that
    acts as a “gateway” when overridden.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: .NET BCL 提供了专门用于此目的的集合类，位于 `System​.Col⁠lections.ObjectModel` 命名空间中。这些实质上是通过将方法转发到底层集合来实现
    `IList<T>` 或 `IDictionary<,>` 的代理或包装器。每个 `Add`、`Remove` 或 `Clear` 操作都通过一个虚拟方法路由，该方法在重写时充当“网关”。
- en: Customizable collection classes are commonly used for publicly exposed collections;
    for instance, a collection of controls exposed publicly on a `System​.Win⁠dows.Form`
    class.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 可定制的集合类通常用于公开的集合，例如，在 `System​.Win⁠dows.Form` 类上公开的控件集合。
- en: Collection<T> and CollectionBase
  id: totrans-415
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Collection<T> 和 CollectionBase
- en: The `Collection<T>` class is a customizable wrapper for `List<T>`.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: '`Collection<T>` 类是 `List<T>` 的可定制包装器。'
- en: 'As well as implementing `IList<T>` and `IList`, it defines four additional
    virtual methods and a protected property as follows:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 除了实现 `IList<T>` 和 `IList` 外，它还定义了四个额外的虚拟方法和一个受保护的属性，如下所示：
- en: '[PRE87]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: The virtual methods provide the gateway by which you can “hook in” to change
    or enhance the list’s normal behavior. The protected `Items` property allows the
    implementer to directly access the “inner list”—this is used to make changes internally
    without the virtual methods firing.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟方法提供了一种网关，通过它可以“挂接”以更改或增强列表的正常行为。受保护的 `Items` 属性允许实现者直接访问“内部列表”——这用于在不触发虚拟方法的情况下进行内部更改。
- en: 'The virtual methods need not be overridden; they can be left alone until there’s
    a requirement to alter the list’s default behavior. The following example demonstrates
    the typical “skeleton” use of `Collection<T>`:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 不需要重写虚拟方法；它们可以保持不变，直到需要更改列表的默认行为。以下示例演示了 `Collection<T>` 的典型“骨架”用法：
- en: '[PRE88]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'As it stands, `AnimalCollection` is no more functional than a simple `List<Animal>`;
    its role is to provide a base for future extension. To illustrate, let’s now add
    a `Zoo` property to `Animal` so that it can reference the `Zoo` in which it lives
    and override each of the virtual methods in `Collection<Animal>` to maintain that
    property automatically:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: '`AnimalCollection` 现在不再仅仅是一个简单的 `List<Animal>`；它的作用是为将来的扩展提供一个基础。为了说明这一点，现在让我们为
    `Animal` 添加一个 `Zoo` 属性，以便它可以引用它所居住的 `Zoo`，并且重写 `Collection<Animal>` 中的每个虚拟方法以自动维护该属性：'
- en: '[PRE89]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '`Collection<T>` also has a constructor accepting an existing `IList<T>`. Unlike
    with other collection classes, the supplied list is *proxied* rather than *copied*,
    meaning that subsequent changes will be reflected in the wrapping `Collection<T>`
    (although *without* `Collection<T>`’s virtual methods firing). Conversely, changes
    made via the `Collection<T>` will change the underlying list.'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: '`Collection<T>` 还具有接受现有 `IList<T>` 的构造函数。与其他集合类不同，所提供的列表是*代理*而非*复制*，这意味着后续更改将反映在包装的
    `Collection<T>` 中（尽管*不会*触发 `Collection<T>` 的虚拟方法）。反之，通过 `Collection<T>` 进行的更改将改变底层列表。'
- en: CollectionBase
  id: totrans-425
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: CollectionBase
- en: '`CollectionBase` is the nongeneric version of `Collection<T>`. This provides
    most of the same features as `Collection<T>` but is clumsier to use. Instead of
    the template methods `InsertItem`, `RemoveItem`, `SetItem`, and `ClearItem`, `CollectionBase`
    has “hook” methods that double the number of methods required: `OnInsert`, `OnInsertComplete`,
    `OnSet`, `OnSetComplete`, `OnRemove`, `OnRemoveComplete`, `OnClear`, and `OnClearComplete`.
    Because `CollectionBase` is nongeneric, you must also implement typed methods
    when subclassing it—at a minimum, a typed indexer and `Add` method.'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: '`CollectionBase`是`Collection<T>`的非泛型版本。它提供了大部分与`Collection<T>`相同的功能，但使用起来更加笨拙。与模板方法`InsertItem`、`RemoveItem`、`SetItem`和`ClearItem`不同，`CollectionBase`具有“挂钩”方法，这使得所需的方法数量翻倍：`OnInsert`、`OnInsertComplete`、`OnSet`、`OnSetComplete`、`OnRemove`、`OnRemoveComplete`、`OnClear`和`OnClearComplete`。由于`CollectionBase`是非泛型的，当子类化它时，您还必须实现类型化的方法——至少是一个类型化的索引器和`Add`方法。'
- en: KeyedCollection<TKey,TItem> and DictionaryBase
  id: totrans-427
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`KeyedCollection<TKey,TItem>`和DictionaryBase'
- en: '`KeyedCollection<TKey,TItem>` subclasses `Collection<TItem>`. It both adds
    and subtracts functionality. What it adds is the ability to access items by key,
    much like with a dictionary. What it subtracts is the ability to proxy your own
    inner list.'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: '`KeyedCollection<TKey,TItem>`是`Collection<TItem>`的子类。它既增加了功能，即通过键访问项目（类似于字典），又减少了能力，即无法代理自己的内部列表。'
- en: 'A keyed collection has some resemblance to an `OrderedDictionary` in that it
    combines a linear list with a hashtable. However, unlike `OrderedDictionary`,
    it doesn’t implement `IDictionary` and doesn’t support the concept of a key/value
    *pair*. Keys are obtained instead from the items themselves: via the abstract
    `GetKeyForItem` method. This means enumerating a keyed collection is just like
    enumerating an ordinary list.'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 键控集合在某种程度上类似于`OrderedDictionary`，因为它将线性列表与哈希表结合在一起。但与`OrderedDictionary`不同的是，它不实现`IDictionary`，也不支持键/值对的概念。相反，键是通过抽象的`GetKeyForItem`方法从项目本身获取的。这意味着枚举键控集合与枚举普通列表完全相同。
- en: You can best think of `KeyedCollection<TKey,TItem>` as `Collection<TItem>` plus
    fast lookup by key.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: '`KeyedCollection<TKey,TItem>`可以理解为`Collection<TItem>`加上按键快速查找的功能。'
- en: 'Because it subclasses `Collection<>`, a keyed collection inherits all of `Collection<>`’s
    functionality, except for the ability to specify an existing list in construction.
    The additional members it defines are as follows:'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 因为它是`Collection<>`的子类，所以键控集合继承了`Collection<>`的所有功能，除了在构造时指定现有列表的能力。它定义的附加成员如下：
- en: '[PRE90]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '`GetKeyForItem` is what the implementer overrides to obtain an item’s key from
    the underlying object. The `ChangeItemKey` method must be called if the item’s
    key property changes, in order to update the internal dictionary. The `Dictionary`
    property returns the internal dictionary used to implement the lookup, which is
    created when the first item is added. This behavior can be changed by specifying
    a creation threshold in the constructor, delaying the internal dictionary from
    being created until the threshold is reached (in the interim, a linear search
    is performed if an item is requested by key). A good reason not to specify a creation
    threshold is that having a valid dictionary can be useful in obtaining an `ICollection<>`
    of keys, via the `Dictionary`’s `Keys` property. This collection can then be passed
    on to a public property.'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetKeyForItem`是实现者从基础对象获取项键的方法。如果项的键属性发生更改，则必须调用`ChangeItemKey`方法以更新内部字典。`Dictionary`属性返回用于实现查找的内部字典，该字典在添加第一项时创建。可以通过在构造函数中指定创建阈值来更改此行为，延迟内部字典的创建直到达到阈值（在此期间，如果按键请求项，则执行线性搜索）。不指定创建阈值的一个很好的理由是，拥有有效的字典对于通过`Dictionary`的`Keys`属性获取键的`ICollection<>`是有用的。然后可以将此集合传递给公共属性。'
- en: 'The most common use for `KeyedCollection<,>` is in providing a collection of
    items accessible both by index and by name. To demonstrate this, let’s revisit
    the zoo, this time implementing `AnimalCollection` as a `KeyedCollection<string,​Ani⁠mal>`:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: '`KeyedCollection<,>`最常见的用途是提供一组可通过索引和名称访问的项目。为了演示这一点，让我们重新访问动物园，这次将`AnimalCollection`实现为`KeyedCollection<string,​Ani⁠mal>`：'
- en: '[PRE91]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'The following code demonstrates its use:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码演示了它的使用：
- en: '[PRE92]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: DictionaryBase
  id: totrans-438
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: DictionaryBase
- en: 'The nongeneric version of `KeyedCollection` is called `DictionaryBase`. This
    legacy class takes a very different approach in that it implements `IDictionary`
    and uses clumsy hook methods like `CollectionBase`: `OnInsert`, `OnInsertComplete`,
    `OnSet`, `OnSetComplete`, `OnRemove`, `OnRemoveComplete`, `OnClear`, and `OnClearComplete`
    (and additionally, `OnGet`). The primary advantage of implementing `IDictionary`
    over taking the `KeyedCollection` approach is that you don’t need to subclass
    it in order to obtain keys. But since the very purpose of `DictionaryBase` is
    to be subclassed, it’s no advantage at all. The improved model in `KeyedCollection`
    is almost certainly due to the fact that it was written some years later, with
    the benefit of hindsight. `DictionaryBase` is best considered useful for backward
    compatibility.'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: '`KeyedCollection`的非泛型版本称为`DictionaryBase`。这个传统类采用非常不同的方法，它实现了`IDictionary`并使用笨拙的挂钩方法，比如`CollectionBase`：`OnInsert`、`OnInsertComplete`、`OnSet`、`OnSetComplete`、`OnRemove`、`OnRemoveComplete`、`OnClear`和`OnClearComplete`（另外还有`OnGet`）。实现`IDictionary`而不是采用`KeyedCollection`方法的主要优势在于，您无需对其进行子类化即可获取键。但由于`DictionaryBase`的主要目的是被子类化，所以这并不是优势。`KeyedCollection`中改进的模型几乎肯定是由于它是在几年后编写的，并且具有事后诸葛亮的好处。`DictionaryBase`最好被认为是用于向后兼容性。'
- en: ReadOnlyCollection<T>
  id: totrans-440
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ReadOnlyCollection<T>
- en: '`ReadOnlyCollection<T>` is a wrapper, or *proxy*, that provides a read-only
    view of a collection. This is useful in allowing a class to publicly expose read-only
    access to a collection that the class can still update internally.'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: '`ReadOnlyCollection<T>`是一个提供集合只读视图的包装器或*代理*。这在允许类公开对其内部仍可更新的集合进行只读访问时非常有用。'
- en: A read-only collection accepts the input collection in its constructor, to which
    it maintains a permanent reference. It doesn’t take a static copy of the input
    collection, so subsequent changes to the input collection are visible through
    the read-only wrapper.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 只读集合在其构造函数中接受输入集合，并保持对输入集合的永久引用。它不会静态复制输入集合，因此对输入集合的后续更改将通过只读包装器可见。
- en: 'To illustrate, suppose that your class wants to provide read-only public access
    to a list of strings called `Names`. We could do this as follows:'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 举例来说，假设你的班级想要向名为`Names`的字符串列表提供只读的公共访问权限。我们可以这样做：
- en: '[PRE93]'
  id: totrans-444
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Although `Names` returns a read-only interface, the consumer can still downcast
    at runtime to `List<string>` or `IList<string>` and then call `Add`, `Remove`,
    or `Clear` on the list. `ReadOnlyCollection<T>` provides a more robust solution:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`Names`返回一个只读接口，消费者仍然可以在运行时向`List<string>`或`IList<string>`进行降级，然后在列表上调用`Add`、`Remove`或`Clear`。`ReadOnlyCollection<T>`提供了更健壮的解决方案：
- en: '[PRE94]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'Now, only members within the `Test` class can alter the list of names:'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，只有`Test`类中的成员才能更改名称列表：
- en: '[PRE95]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: Immutable Collections
  id: totrans-449
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不可变集合
- en: We just described how `ReadOnlyCollection<T>` creates a read-only view of a
    collection. Restricting the ability to write (*mutate*) a collection—or any other
    object—simplifies software and reduces bugs.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚描述了`ReadOnlyCollection<T>`如何创建集合的只读视图。限制对集合或任何其他对象的写入（*突变*）能力简化了软件并减少了错误。
- en: The *immutable collections* extend this principle, by providing collections
    that cannot be modified at all after initialization. Should you need to add an
    item to an immutable collection, you must instantiate a new collection, leaving
    the old one untouched.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: '*不可变集合*扩展了这一原则，通过提供在初始化后无法修改的集合来实现。如果需要向不可变集合添加项，必须实例化一个新集合，保持旧集合不变。'
- en: 'Immutability is a hallmark of *functional programming* and has the following
    benefits:'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 不可变性是*函数式编程*的标志，并具有以下好处：
- en: It eliminates a large class of bugs associated with changing state.
  id: totrans-453
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它消除了与更改状态相关的一大类错误。
- en: It vastly simplifies parallelism and multithreading, by avoiding most of the
    thread-safety problems that we describe in Chapters [14](ch14.html#concurrency_and_asynchron),
    [22](ch22.html#parallel_programming-id00071), and [23](ch23.html#spanless_thantgreater_than_and-id00089).
  id: totrans-454
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它极大地简化了并行和多线程，通过避免我们在第[14章](ch14.html#concurrency_and_asynchron)、[22章](ch22.html#parallel_programming-id00071)和[23章](ch23.html#spanless_thantgreater_than_and-id00089)中描述的大多数线程安全问题。
- en: It makes code easier to reason about.
  id: totrans-455
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它使得代码更容易理解。
- en: The disadvantage of immutability is that when you need to make a change, you
    must create a whole new object. This incurs a performance hit, although there
    are mitigating strategies that we discuss in this section, including the ability
    to reuse portions of the original structure.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 不可变性的缺点是当你需要进行更改时，你必须创建一个全新的对象。尽管有减少性能损耗的策略，我们在本节中讨论了一些缓解策略，包括能够重用原始结构的部分。
- en: 'The immutable collections are part of .NET (in .NET Framework, they are available
    via the *System.Collections.Immutable* NuGet package). All collections are defined
    in the `System.Collections.Immutable` namespace:'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 不可变集合是 .NET 的一部分（在 .NET Framework 中，它们通过 *System.Collections.Immutable* NuGet
    包提供）。所有集合都定义在 `System.Collections.Immutable` 命名空间中：
- en: '| Type | Internal structure |'
  id: totrans-458
  prefs: []
  type: TYPE_TB
  zh: '| 类型 | 内部结构 |'
- en: '| --- | --- |'
  id: totrans-459
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `ImmutableArray<T>` | Array |'
  id: totrans-460
  prefs: []
  type: TYPE_TB
  zh: '| `ImmutableArray<T>` | 数组 |'
- en: '| `ImmutableList<T>` | AVL tree |'
  id: totrans-461
  prefs: []
  type: TYPE_TB
  zh: '| `ImmutableList<T>` | AVL 树 |'
- en: '| `ImmutableDictionary<K,V>` | AVL tree |'
  id: totrans-462
  prefs: []
  type: TYPE_TB
  zh: '| `ImmutableDictionary<K,V>` | AVL 树 |'
- en: '| `ImmutableHashSet<T>` | AVL tree |'
  id: totrans-463
  prefs: []
  type: TYPE_TB
  zh: '| `ImmutableHashSet<T>` | AVL 树 |'
- en: '| `ImmutableSortedDictionary<K,V>` | AVL tree |'
  id: totrans-464
  prefs: []
  type: TYPE_TB
  zh: '| `ImmutableSortedDictionary<K,V>` | AVL 树 |'
- en: '| `ImmutableSortedSet<T>` | AVL tree |'
  id: totrans-465
  prefs: []
  type: TYPE_TB
  zh: '| `ImmutableSortedSet<T>` | AVL 树 |'
- en: '| `ImmutableStack<T>` | Linked list |'
  id: totrans-466
  prefs: []
  type: TYPE_TB
  zh: '| `ImmutableStack<T>` | 链表 |'
- en: '| `ImmutableQueue<T>` | Linked list |'
  id: totrans-467
  prefs: []
  type: TYPE_TB
  zh: '| `ImmutableQueue<T>` | 链表 |'
- en: The `ImmutableArray<T>` and `ImmutableList<T>` types are both immutable versions
    of `List<T>`. Both do the same job but with different performance characteristics
    that we discuss in [“Immutable Collections and Performance”](#immutable_collections_and_performance).
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: '`ImmutableArray<T>` 和 `ImmutableList<T>` 类型都是 `List<T>` 的不可变版本。它们的功能相同，但性能特性不同，我们在
    [“不可变集合和性能”](#immutable_collections_and_performance) 中讨论。'
- en: The immutable collections expose a public interface similar to their mutable
    counterparts. The key difference is that the methods that appear to alter the
    collection (such as `Add` or `Remove`) don’t alter the original collection; instead
    they return a new collection with the requested item added or removed. This is
    called *nondestructive mutation*.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 不可变集合公开了与其可变对应物类似的公共接口。主要区别在于看似会修改集合（如 `Add` 或 `Remove`）的方法并不会修改原始集合；相反，它们会返回一个包含请求添加或移除项的新集合。这被称为
    *非破坏性变异*。
- en: Note
  id: totrans-470
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Immutable collections prevent the adding and removing of items; they don’t prevent
    the items *themselves* from being mutated. To get the full benefits of immutability,
    you need to ensure that only immutable items end up in an immutable collection.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 不可变集合防止添加和移除项；它们不阻止 *项本身* 被突变。要充分利用不可变性的优势，需要确保只有不可变的项最终进入不可变集合。
- en: Creating Immutable Collections
  id: totrans-472
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建不可变集合
- en: 'Each immutable collection type offers a `Create<T>()` method, which accepts
    optional initial values and returns an initialized immutable collection:'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 每种不可变集合类型都提供一个 `Create<T>()` 方法，该方法接受可选的初始值并返回一个初始化的不可变集合：
- en: '[PRE96]'
  id: totrans-474
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: Each collection also offers a `CreateRange<T>` method, which does the same job
    as `Create<T>`; the difference is that its parameter type is `IEnumerable<T>`
    instead of `params T[]`.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 每个集合还提供一个 `CreateRange<T>` 方法，其功能与 `Create<T>` 相同；区别在于它的参数类型是 `IEnumerable<T>`
    而不是 `params T[]`。
- en: 'You can also create an immutable collection from an existing `IEnumerable<T>`,
    using appropriately extension methods (`ToImmutableArray`, `ToImmutableList`,
    `ToImmutableDictionary`, and so on):'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用适当的扩展方法（`ToImmutableArray`、`ToImmutableList`、`ToImmutableDictionary` 等）从现有的
    `IEnumerable<T>` 创建不可变集合：
- en: '[PRE97]'
  id: totrans-477
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: Manipulating Immutable Collections
  id: totrans-478
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作不可变集合
- en: 'The `Add` method returns a new collection containing the existing elements
    plus the new one:'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: '`Add` 方法返回一个包含现有元素和新元素的新集合：'
- en: '[PRE98]'
  id: totrans-480
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: The `Remove` method operates in the same fashion, returning a new collection
    with the item removed.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: '`Remove` 方法的操作方式相同，返回一个移除了指定项的新集合。'
- en: 'Repeatedly adding or removing elements in this manner is inefficient, because
    a new immutable collection is created for each add or remove operation. A better
    solution is to call `AddRange` (or `RemoveRange`), which accepts an `IEnumerable<T>`
    of items, which are all added or removed in one go:'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 反复添加或移除元素这种方式效率低下，因为每次添加或移除操作都会创建一个新的不可变集合。更好的解决方案是调用 `AddRange`（或 `RemoveRange`），它接受一个
    `IEnumerable<T>` 的项，在一次操作中添加或移除所有项：
- en: '[PRE99]'
  id: totrans-483
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: The immutable list and array also defines `Insert` and `InsertRange` methods
    to insert elements at a particular index, a `RemoveAt` method to remove at an
    index, and `RemoveAll`, which removes based on a predicate.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 不可变列表和数组还定义了`Insert`和`InsertRange`方法，用于在特定索引处插入元素，`RemoveAt`方法用于按索引移除元素，以及`RemoveAll`方法，根据谓词条件移除元素。
- en: Builders
  id: totrans-485
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建器
- en: For more complex initialization needs, each immutable collection class defines
    a *builder* counterpart. Builders are classes that are functionally equivalent
    to a mutable collection, with similar performance characteristics. After the data
    is initialized, calling `.ToImmutable()` on a builder returns an immutable collection.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 对于更复杂的初始化需求，每个不可变集合类都定义了一个*构建器*对应物。构建器是与可变集合功能上等效的类，具有类似的性能特征。在数据初始化后，对构建器调用`.ToImmutable()`将返回一个不可变集合。
- en: '[PRE100]'
  id: totrans-487
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'You also can use builders to *batch* multiple updates to an existing immutable
    collection:'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以使用构建器批量对现有的不可变集合进行多次更新：
- en: '[PRE101]'
  id: totrans-489
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: Immutable Collections and Performance
  id: totrans-490
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不可变集合与性能
- en: Most of the immutable collections use an *AVL tree* internally, which allows
    the add/remove operations to reuse portions of the original internal structure
    rather than having to re-create the entire thing from scratch. This reduces the
    overhead of add/remove operations from potentially *huge* (with large collections)
    to just *moderately large*, but it comes at the cost of making read operations
    slower. The end result is that most immutable collections are slower than their
    mutable counterparts for both reading and writing.
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数不可变集合在内部使用*AVL树*，这允许添加/移除操作重用原始内部结构的部分，而不必从头开始重新创建整个结构。这减少了添加/移除操作的开销，从可能是*巨大的*（对于大集合）降低到只是*适度大*，但这也使得读取操作变慢。最终结果是，大多数不可变集合在读取和写入方面都比其可变对应物慢。
- en: 'The most seriously affected is `ImmutableList<T>`, which for both read and
    add operations, is 10 to 200 times slower than `List<T>` (depending on the size
    of the list). This is why `ImmutableArray<T>` exists: by using an array inside,
    it avoids the overhead for read operations (for which it’s comparable in performance
    to an ordinary mutable array). The flipside is that it’s *much* slower than (even)
    `ImmutableList<T>` for add operations because none of the original structure can
    be reused.'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 受影响最严重的是`ImmutableList<T>`，在读取和添加操作方面，其速度比`List<T>`慢10到200倍（取决于列表的大小）。这就是为什么存在`ImmutableArray<T>`：通过在内部使用数组，它避免了读取操作的开销（在这方面，它的性能与普通可变数组相当）。但其反面是，在添加操作方面比（甚至）`ImmutableList<T>`慢得多，因为原始结构的任何部分都无法重用。
- en: Hence, `ImmutableArray<T>` is desirable when you want unimpeded *read*-performance
    and don’t expect many subsequent calls to `Add` or `Remove` (without using a builder).
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当您希望不受阻碍的*读取*性能，并且不希望频繁调用`Add`或`Remove`（而不使用构建器）时，`ImmutableArray<T>`是理想的选择。
- en: '| Type | Read performance | Add performance |'
  id: totrans-494
  prefs: []
  type: TYPE_TB
  zh: '| 类型 | 读取性能 | 添加性能 |'
- en: '| --- | --- | --- |'
  id: totrans-495
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `ImmutableList<T>` | Slow | Slow |'
  id: totrans-496
  prefs: []
  type: TYPE_TB
  zh: '| `ImmutableList<T>` | 慢 | 慢 |'
- en: '| `ImmutableArray<T>` | Very fast | Very slow |'
  id: totrans-497
  prefs: []
  type: TYPE_TB
  zh: '| `ImmutableArray<T>` | 非常快 | 非常慢 |'
- en: Note
  id: totrans-498
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Calling `Remove` on an `ImmutableArray` is more expensive than calling `Remove`
    on a `List<T>`—even in the worst-case scenario of removing the first element—because
    allocating the new collection places additional load on the garbage collector.
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`ImmutableArray`上的`Remove`比在`List<T>`上调用`Remove`更昂贵——即使在移除第一个元素的最坏情况下——因为分配新集合会给垃圾收集器增加额外负载。
- en: Although the immutable collections as a whole incur a potentially significant
    performance cost, it’s important to keep the overall magnitude in perspective.
    An `Add` operation on an `ImmutableList` with a million elements is still likely
    to occur in less than a microsecond on a typical laptop, and a read operation,
    in less than 100 nanoseconds. And, if you need to perform write-operations in
    a loop, you can avoid the accumulated cost with a builder.
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管整体上不可变集合可能会产生显著的性能成本，但保持总体量的透视是很重要的。在典型的笔记本电脑上，对具有百万个元素的`ImmutableList`执行`Add`操作仍然可能发生在小于一微秒的时间内，读取操作则在100纳秒以下。而且，如果需要在循环中执行写操作，可以使用构建器来避免累积的成本。
- en: 'The following factors also work to mitigate the costs:'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 以下因素也有助于减轻成本：
- en: Immutability allows for easy concurrency and parallelization ([Chapter 23](ch23.html#spanless_thantgreater_than_and-id00089)),
    so you can employ all available cores. Parallelizing with mutable state easily
    leads to errors and requires the use of locks or concurrent collections, both
    of which hurt performance.
  id: totrans-502
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不可变性允许轻松进行并发和并行处理（[第23章](ch23.html#spanless_thantgreater_than_and-id00089)），因此您可以利用所有可用的核心。使用可变状态进行并行处理很容易导致错误，并且需要使用锁或并发集合，这两者都会影响性能。
- en: With immutability, you don’t need to “defensively copy” collections or data
    structures to guard against unexpected change. This was a factor in favoring the
    use of immutable collections in writing recent portions of Visual Studio.
  id: totrans-503
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用不可变性，您无需“防御性地复制”集合或数据结构以防止意外更改。这是在编写Visual Studio的最新部分时倾向于使用不可变集合的一个因素。
- en: In most typical programs, few collections have enough items for the difference
    to matter.
  id: totrans-504
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在大多数典型程序中，很少有足够多的项使得这些差异有影响。
- en: In addition to Visual Studio, the well-performing Microsoft Roslyn toolchain
    was built with immutable collections, demonstrating how the benefits can outweigh
    the costs.
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 除了Visual Studio外，性能良好的Microsoft Roslyn工具链也使用不可变集合构建，显示了其益处大于成本的情况。
- en: Frozen Collections
  id: totrans-506
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 冻结集合
- en: 'From .NET 8, the `System.Collections.Frozen` namespace contains the following
    two read-only collection classes:'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 从.NET 8开始，`System.Collections.Frozen`命名空间包含以下两个只读集合类：
- en: '[PRE102]'
  id: totrans-508
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'These are similar to `ImmutableDictionary<K,V>` and `ImmutableHashSet<T>`,
    but lack methods for nondestructive mutation (such as `Add` or `Remove`), allowing
    for highly optimized read performance. To create a frozen collection, you start
    with another collection or sequence and then call the `ToFrozenDictionary` or
    `ToFrozenSet` extension method:'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类似于`ImmutableDictionary<K,V>`和`ImmutableHashSet<T>`，但缺少非破坏性变异（例如`Add`或`Remove`）的方法，从而实现了高度优化的读取性能。要创建冻结集合，您可以从另一个集合或序列开始，然后调用`ToFrozenDictionary`或`ToFrozenSet`扩展方法：
- en: '[PRE103]'
  id: totrans-510
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'Frozen collections are great for lookups that are initialized at the start
    of a program and then used throughout the life of the application:'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 冻结集合非常适合在程序开始时初始化并在应用程序的整个生命周期中使用的查找操作：
- en: '[PRE104]'
  id: totrans-512
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: The frozen collections implement the standard dictionary/set interfaces, including
    their read-only versions. In this example, we exposed our `FrozenDictionary<string,string>`
    as a field of type `IReadOnlyDictionary<string,string>`.
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 冻结集合实现了标准的字典/集合接口，包括它们的只读版本。在本例中，我们将我们的`FrozenDictionary<string,string>`作为`IReadOnlyDictionary<string,string>`类型的字段公开。
- en: Plugging in Equality and Order
  id: totrans-514
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 插入相等性和顺序
- en: 'In the sections [“Equality Comparison”](ch04.html#equality_comparison-id00016)
    and [“Order Comparison”](ch06.html#order_comparison), we described the standard
    .NET protocols that make a type equatable, hashable, and comparable. A type that
    implements these protocols can function correctly in a dictionary or sorted list
    “out of the box.” More specifically:'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 在部分章节[“相等比较”](ch04.html#equality_comparison-id00016)和[“顺序比较”](ch06.html#order_comparison)中，我们描述了标准的.NET协议，使得类型可以在字典或排序列表中“开箱即用”地正确运行。更具体地说：
- en: A type for which `Equals` and `GetHashCode` return meaningful results can be
    used as a key in a `Dictionary` or `Hashtable`.
  id: totrans-516
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个类型的`Equals`和`GetHashCode`返回有意义的结果，则可以将其用作`Dictionary`或`Hashtable`中的键。
- en: A type that implements `IComparable` /`IComparable<T>` can be used as a key
    in any of the *sorted* dictionaries or lists.
  id: totrans-517
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现`IComparable` / `IComparable<T>`的类型可以用作*排序*字典或列表中的键。
- en: 'A type’s default equating or comparison implementation typically reflects what
    is most “natural” for that type. Sometimes, however, the default behavior is not
    what you want. You might need a dictionary whose `string` type key is treated
    without respect to case. Or you might want a sorted list of customers, sorted
    by each customer’s postcode. For this reason, .NET also defines a matching set
    of “plug-in” protocols. The plug-in protocols achieve two things:'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 类型的默认相等或比较实现通常反映了对该类型最“自然”的内容。然而，有时默认行为并非您想要的。您可能需要一个字典，其中`string`类型的键不考虑大小写。或者您可能希望按照每个客户的邮政编码对客户进行排序的排序列表。因此，.NET还定义了一组匹配的“插件”协议。插件协议实现了两个目标：
- en: They allow you to switch in alternative equating or comparison behavior.
  id: totrans-519
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们允许您切换到替代的相等或比较行为。
- en: They allow you to use a dictionary or sorted collection with a key type that’s
    not intrinsically equatable or comparable.
  id: totrans-520
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们允许您使用键类型不本质上可相等或可比较的字典或排序集合。
- en: 'The plug-in protocols consist of the following interfaces:'
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 插件协议包括以下接口：
- en: '`IEqualityComparer` and `IEqualityComparer<T>`'
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: '`IEqualityComparer` 和 `IEqualityComparer<T>`'
- en: Performs plug-in *equality comparison and hashing*
  id: totrans-523
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行插件 *相等比较和哈希*
- en: Recognized by `Hashtable` and `Dictionary`
  id: totrans-524
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 被 `Hashtable` 和 `Dictionary` 所识别
- en: '`IComparer` and `IComparer<T>`'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: '`IComparer` 和 `IComparer<T>`'
- en: Performs plug-in *order comparison*
  id: totrans-526
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行插件 *顺序比较*
- en: Recognized by the sorted dictionaries and collections; also, `Array.Sort`
  id: totrans-527
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 被排序字典和集合识别；同时也被 `Array.Sort` 所识别
- en: Each interface comes in both generic and nongeneric forms. The `IEquality​Com⁠parer`
    interfaces also have a default implementation in a class called `Equality​Comparer`.
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 每个接口都有通用和非通用形式。`IEquality​Com⁠parer` 接口也在名为 `Equality​Comparer` 的类中有默认实现。
- en: In addition, there are interfaces called `IStructuralEquatable` and `IStructuralComparable`
    which allow for the option of structural comparisons on classes and arrays.
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有名为 `IStructuralEquatable` 和 `IStructuralComparable` 的接口，允许在类和数组上进行结构比较选项。
- en: IEqualityComparer and EqualityComparer
  id: totrans-530
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: IEqualityComparer 和 EqualityComparer
- en: An equality comparer switches in nondefault equality and hashing behavior, primarily
    for the `Dictionary` and `Hashtable` classes.
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 一个相等比较器在非默认的相等和哈希行为上切换，主要用于 `Dictionary` 和 `Hashtable` 类。
- en: 'Recall the requirements of a hashtable-based dictionary. It needs answers to
    two questions for any given key:'
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下基于哈希表的字典的要求。对于任何给定的键，它需要回答两个问题：
- en: Is it the same as another?
  id: totrans-533
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是否与另一个相同？
- en: What is its integer hashcode?
  id: totrans-534
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它的整数哈希码是多少？
- en: 'An equality comparer answers these questions by implementing the `IEquality​Com⁠parer`
    interfaces:'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 一个相等比较器通过实现 `IEquality​Com⁠parer` 接口来回答这些问题：
- en: '[PRE105]'
  id: totrans-536
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'To write a custom comparer, you implement one or both of these interfaces (implementing
    both gives maximum interoperability). Because this is somewhat tedious, an alternative
    is to subclass the abstract `EqualityComparer` class, defined as follows:'
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 要编写自定义比较器，您可以实现其中一个或两个接口（同时实现两个可以获得最大的互操作性）。由于这有些繁琐，一个替代方法是继承抽象类 `EqualityComparer`，定义如下：
- en: '[PRE106]'
  id: totrans-538
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: '`EqualityComparer` implements both interfaces; your job is simply to override
    the two abstract methods.'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: '`EqualityComparer` 实现了这两个接口；您的任务只是覆盖这两个抽象方法。'
- en: 'The semantics for `Equals` and `GetHashCode` follow the same rules for `object.Equals`
    and `object.GetHashCode`, described in [Chapter 6](ch06.html#dotnet_fundamentals).
    In the following example, we define a `Customer` class with two fields and then
    write an equality comparer that matches both the first and last names:'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: '`Equals` 和 `GetHashCode` 的语义遵循 `object.Equals` 和 `object.GetHashCode` 的相同规则，详见[第六章](ch06.html#dotnet_fundamentals)。在以下示例中，我们定义一个
    `Customer` 类，包含两个字段，然后编写一个相等比较器，匹配第一个和最后一个名字：'
- en: '[PRE107]'
  id: totrans-541
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'To illustrate how this works, let’s create two customers:'
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这是如何工作的，让我们创建两个客户：
- en: '[PRE108]'
  id: totrans-543
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'Because we’ve not overridden `object.Equals`, normal reference type equality
    semantics apply:'
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们没有重写 `object.Equals`，所以正常的引用类型相等语义适用：
- en: '[PRE109]'
  id: totrans-545
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'The same default equality semantics apply when using these customers in a `Dictionary`
    without specifying an equality comparer:'
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 当在 `Dictionary` 中使用这些客户时，没有指定相等比较器时也适用相同的默认相等语义：
- en: '[PRE110]'
  id: totrans-547
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'Now, with the custom equality comparer:'
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用自定义的相等比较器：
- en: '[PRE111]'
  id: totrans-549
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: In this example, we would have to be careful not to change the customer’s `FirstName`
    or `LastName` while it was in use in the dictionary; otherwise, its hashcode would
    change and the `Dictionary` would break.
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，我们必须小心，不要在字典中使用客户的 `FirstName` 或 `LastName` 发生变化；否则，它的哈希码将会改变，字典将会出现问题。
- en: EqualityComparer<T>.Default
  id: totrans-551
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: EqualityComparer<T>.Default
- en: 'Calling `EqualityComparer<T>.Default` returns a general-purpose equality comparer
    that you can use as an alternative to the static `object.Equals` method. The advantage
    is that it first checks whether `T` implements `IEquatable<T>`, and if so, it
    calls that implementation instead, avoiding the boxing overhead. This is particularly
    useful in generic methods:'
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 调用 `EqualityComparer<T>.Default` 返回一个通用的相等比较器，您可以将其用作替代静态的 `object.Equals` 方法。优势在于它首先检查
    `T` 是否实现了 `IEquatable<T>`，如果是，则调用该实现，避免装箱开销。这在泛型方法中特别有用：
- en: '[PRE112]'
  id: totrans-553
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: ReferenceEqualityComparer.Instance (.NET 5+)
  id: totrans-554
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`ReferenceEqualityComparer.Instance`（.NET 5+）'
- en: From .NET 5, `ReferenceEqualityComparer.Instance` returns an equality comparer
    that always applies referential equality. In the case of value types, its `Equals`
    method always returns false.
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 从 .NET 5 开始，`ReferenceEqualityComparer.Instance` 返回一个总是应用引用相等的相等比较器。对于值类型，其
    `Equals` 方法总是返回 false。
- en: IComparer and Comparer
  id: totrans-556
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: IComparer 和 Comparer
- en: Comparers are used to switch in custom ordering logic for sorted dictionaries
    and collections.
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 比较器用于为排序的字典和集合切换自定义排序逻辑。
- en: Note that a comparer is useless to the unsorted dictionaries such as `Dictionary`
    and `Hashtable`—these require an `IEqualityComparer` to get hashcodes. Similarly,
    an equality comparer is useless for sorted dictionaries and collections.
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，对于像`Dictionary`和`Hashtable`这样的未排序字典，比较器是无用的——这些需要一个`IEqualityComparer`来获取哈希码。同样，对于排序字典和集合，相等比较器也是无用的。
- en: 'Here are the `IComparer` interface definitions:'
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是`IComparer`接口的定义：
- en: '[PRE113]'
  id: totrans-560
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'As with equality comparers, there’s an abstract class that you can subtype
    instead of implementing the interfaces:'
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 与相等比较器一样，有一个抽象类，您可以对其进行子类型化，而不是实现接口：
- en: '[PRE114]'
  id: totrans-562
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'The following example illustrates a class that describes a wish as well as
    a comparer that sorts wishes by priority:'
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了描述愿望的类以及按优先级排序愿望的比较器：
- en: '[PRE115]'
  id: totrans-564
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: The `object.Equals` check ensures that we can never contradict the `Equals`
    method. Calling the static `object.Equals` method in this case is better than
    calling `x.Equals` because it still works if `x` is null!
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: '`object.Equals`检查确保我们永远不会违反`Equals`方法。在这种情况下调用静态的`object.Equals`方法比调用`x.Equals`更好，因为如果`x`为空，它仍然有效！'
- en: 'Here’s how our `PriorityComparer` is used to sort a `List`:'
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 这里展示了我们的`PriorityComparer`如何用于对`List`进行排序：
- en: '[PRE116]'
  id: totrans-567
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'In the next example, `SurnameComparer` allows you to sort surname strings in
    an order suitable for a phonebook listing:'
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个示例中，`SurnameComparer`允许您按适合电话簿列表的顺序对姓氏字符串进行排序：
- en: '[PRE117]'
  id: totrans-569
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'Here’s `SurnameComparer` in use in a sorted dictionary:'
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 这里展示了`SurnameComparer`在排序字典中的使用：
- en: '[PRE118]'
  id: totrans-571
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: StringComparer
  id: totrans-572
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: StringComparer
- en: '`StringComparer` is a predefined plug-in class for equating and comparing strings,
    allowing you to specify language and case sensitivity. `StringComparer` implements
    both `IEqualityComparer` and `IComparer` (and their generic versions), so you
    can use it with any type of dictionary or sorted collection.'
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: '`StringComparer`是一个预定义的插件类，用于等同和比较字符串，允许您指定语言和大小写敏感性。`StringComparer`实现了`IEqualityComparer`和`IComparer`（以及它们的泛型版本），因此您可以将其与任何类型的字典或排序集合一起使用。'
- en: 'Because `StringComparer` is abstract, you obtain instances via its static properties.
    `StringComparer.Ordinal` mirrors the default behavior for string equality comparison
    and `StringComparer.CurrentCulture` for order comparison. Here are all of its
    static members:'
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`StringComparer`是抽象的，您可以通过其静态属性获取实例。`StringComparer.Ordinal`反映了字符串相等比较的默认行为，`StringComparer.CurrentCulture`用于顺序比较。以下是它的所有静态成员：
- en: '[PRE119]'
  id: totrans-575
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'In the following example, an ordinal case-insensitive dictionary is created
    such that `dict["Joe"]` and `dict["JOE"]` mean the same thing:'
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例中，创建了一个按序大小写不敏感的字典，使得`dict["Joe"]`和`dict["JOE"]`意思相同：
- en: '[PRE120]'
  id: totrans-577
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'In the next example, an array of names is sorted, using Australian English:'
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个示例中，一个名字数组按澳大利亚英语排序：
- en: '[PRE121]'
  id: totrans-579
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'The final example is a culture-aware version of the `SurnameComparer` we wrote
    in the previous section (to compare names suitable for a phonebook listing):'
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个示例是我们在上一节中编写的适用于电话簿列表的`SurnameComparer`的文化感知版本：
- en: '[PRE122]'
  id: totrans-581
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: IStructuralEquatable and IStructuralComparable
  id: totrans-582
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: IStructuralEquatable和IStructuralComparable
- en: 'As we discussed in [Chapter 6](ch06.html#dotnet_fundamentals), structs implement
    *structural comparison* by default: two structs are equal if all of their fields
    are equal. Sometimes, however, structural equality and order comparison are useful
    as plug-in options on other types, as well—such as arrays. The following interfaces
    help with this:'
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[第6章](ch06.html#dotnet_fundamentals)中讨论的那样，结构体默认实现*结构比较*：如果它们的所有字段都相等，则两个结构体相等。然而，有时候，结构相等性和顺序比较也可以作为插件选项应用于其他类型，比如数组。以下接口有助于实现这一点：
- en: '[PRE123]'
  id: totrans-584
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'The `IEqualityComparer`/`IComparer` that you pass in are applied to each individual
    element in the composite object. We can demonstrate this by using arrays. In the
    following example, we compare two arrays for equality, first using the default
    `Equals` method, then using `IStructuralEquatable`’s version:'
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: 你传入的`IEqualityComparer`/`IComparer`会应用于复合对象中的每个单独元素。我们可以通过使用数组来演示这一点。在下面的示例中，我们首先使用默认的`Equals`方法，然后使用`IStructuralEquatable`的版本来比较两个数组是否相等：
- en: '[PRE124]'
  id: totrans-586
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'Here’s another example:'
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是另一个示例：
- en: '[PRE125]'
  id: totrans-588
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: ^([1](ch07.html#ch01fn6-marker)) There’s also a functionally identical nongeneric
    version of this called `SortedList`.
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch07.html#ch01fn6-marker)) 还有一个功能上相同的非泛型版本称为`SortedList`。
