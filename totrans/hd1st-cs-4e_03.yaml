- en: 'Chapter 2\. Dive into C#: *Statements, Classes, and Code*'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Chapter 2\. 深入 C#：*语句、类和代码*
- en: '![Images](assets/049fig01.png)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/049fig01.png)'
- en: '**You’re not just an IDE user. You’re a **developer**.**'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**你不只是一个 IDE 用户。你是一个**开发者**。**'
- en: 'You can get a lot of work done using the IDE, but there’s only so far it can
    take you. Visual Studio is one of the most advanced software development tools
    ever made, but a **powerful IDE** is only the beginning. It’s time to **dig in
    to C# code**: how it’s structured, how it works, and how you can take control
    of it…because there’s no limit to what you can get your apps to do.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 IDE 可以完成大量工作，但它的能力有限。Visual Studio 是有史以来最先进的软件开发工具之一，但**强大的集成开发环境**仅仅是一个开始。现在是时候**深入研究
    C# 代码**了：它的结构是怎样的，它如何工作，以及如何掌控它……因为你可以让你的应用程序做任何事情，没有限制。
- en: (And for the record, you can be a **real developer** no matter what kind of
    keyboard you prefer. The only thing you need to do is **write code**!)
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: （顺便说一句，无论你喜欢哪种键盘，你都可以成为**真正的开发者**。唯一需要做的就是**编写代码**！）
- en: Let’s take a closer look at the files for a console app
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 让我们仔细查看控制台应用程序的文件。
- en: In the last chapter, you created a new .NET Core Console App project and named
    it MyFirstConsoleApp. When you did that, Visual Studio created two folders and
    three files.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，你创建了一个名为 MyFirstConsoleApp 的新 .NET Core 控制台应用程序项目。这样做时，Visual Studio 创建了两个文件夹和三个文件。
- en: '![Images](assets/050fig01.png)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/050fig01.png)'
- en: 'Let’s take a closer look at the Program.cs file that it created. Open it up
    in Visual Studio:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们仔细看看它创建的 Program.cs 文件。在 Visual Studio 中打开它：
- en: '![Images](assets/050fig02.png)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/050fig02.png)'
- en: At the top of the file is a `**using directive**`. You’ll see `using` lines
    like this in all of your C# code files.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件顶部是一个 `**using 指令**`。在所有的 C# 代码文件中，你都会看到类似这样的 `using` 行。
- en: Right after the `using` directives comes the `namespace` **keyword**. Your code
    is in a namespace called MyFirstConsoleApp. Right after it is an opening curly
    bracket `**{**`, and at the end of the file is the closing bracket `**}**`. Everything
    between those brackets is in the namespace.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `using` 指令之后就是 `namespace` **关键字**。你的代码位于 MyFirstConsoleApp 命名空间中。紧接着是一个左花括号
    `**{**`，文件的末尾是右花括号 `**}**`。在这些花括号之间的所有内容都属于这个命名空间。
- en: Inside the namespace is a **class**. Your program has one class called Program.
    Right after the class declaration is an opening curly bracket, with its pair in
    the second-to-last line of the file.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在命名空间内部是一个**类**。你的程序有一个名为 Program 的类。在类声明之后是一个左花括号，与文件倒数第二行的右花括号成对出现。
- en: Inside your class is a **method** called Main—again, followed by a pair of brackets
    with its contents.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在你的类内部是一个名为 Main 的**方法**——同样是一对括号及其内容。
- en: 'Your method has one **statement**: `Console.WriteLine("Hello World!");`'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你的方法只有一个**语句**：`Console.WriteLine("Hello World!");`
- en: A statement performs one single action
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个语句执行一个单一动作。
- en: Every method is made up of **statements** like your Console.WriteLine statement.
    When your program calls a method, it executes the first statement, then the next,
    then the next, etc. When the method runs out of statements—or hits a `**return**`
    statement—it ends, and the program execution resumes after the statement that
    originally called the method.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 每个方法都由像你的 Console.WriteLine 语句那样的**语句**组成。当程序调用一个方法时，它会依次执行每个语句，直到语句用完或者遇到一个
    `**return**` 语句时结束，程序的执行会恢复到最初调用该方法的语句之后。
- en: Two classes can be in the same namespace (and file!)
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 两个类可以在同一个命名空间（和文件）中。
- en: 'Take a look at these two C# code files from a program called PetFiler2\. They
    contain three classes: a Dog class, a Cat class, and a Fish class. Since they’re
    all in the same PetFiler2 namespace, statements in the Dog.Bark method can call
    Cat.Meow and Fish.Swim ***without adding a*** `using` ***directive***.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 看看 PetFiler2 程序的这两个 C# 代码文件。它们包含三个类：Dog 类、Cat 类和 Fish 类。由于它们都在同一个 PetFiler2
    命名空间中，所以在 Dog.Bark 方法中可以调用 Cat.Meow 和 Fish.Swim ***而无需添加*** `using` ***指令***。
- en: '![Images](assets/052fig01.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/052fig01.png)'
- en: A class can span multiple files too, but you need to use the `partial` keyword
    when you declare it. It doesn’t matter how the various namespaces and classes
    are divided up between files. They still act the same when they’re run.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 一个类也可以跨多个文件，但在声明时需要使用 `partial` 关键字。不管不同的命名空间和类如何分布在文件中，它们在运行时的行为都是相同的。
- en: '![Images](assets/052fig02.png)![Images](assets/053fig01.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/052fig02.png)![图片](assets/053fig01.png)'
- en: '**The IDE helps you build your code right.**'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '**IDE 帮助你正确构建代码。**'
- en: A long, long, LONG time ago, programmers had to use simple text editors like
    Windows Notepad or macOS TextEdit to edit their code. In fact, some their features
    would have been cutting-edge (like search and replace, or Notepad’s Ctrl+G for
    “go to line number” ). We had to use a lot of complex command-line applications
    to build, run, debug, and deploy our code.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 很久以前，程序员们不得不使用简单的文本编辑器，如Windows记事本或macOS TextEdit来编辑他们的代码。事实上，一些他们的功能当时可能是尖端的（比如搜索和替换，或者记事本的Ctrl+G用于“转到行号”）。我们不得不使用许多复杂的命令行应用程序来构建、运行、调试和部署我们的代码。
- en: Over the years, Microsoft (and, let’s be fair, a lot of other companies, and
    a lot of individual developers) figured out how to add *`many`* helpful things
    like error highlighting, IntelliSense, WYSIWYG click-and-drag window UI editing,
    automatic code generation, and many other features.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 多年来，微软（以及许多其他公司和许多个人开发者）找到了如何添加*`许多`*有用功能，如错误高亮显示、智能感知、所见即所得的点击拖放窗口UI编辑、自动生成代码等等。
- en: After years of evolution, Visual Studio is now one of the most advanced code-editing
    tools ever built. And lucky for you, it’s also a ***great tool for learning and
    exploring C# and app development***.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 经过多年的发展，Visual Studio 现在是有史以来最先进的代码编辑工具之一。幸运的是，它也是一个***学习和探索C#和应用开发的绝佳工具***。
- en: Statements are the building blocks for your apps
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 语句是你的应用程序的构建块
- en: 'Your app is made up of classes, and those classes contain methods, and those
    methods contain statements. So if we want to build apps that do a lot of things,
    we’ll need a few **different kinds of statements** to make them work. You’ve already
    seen one kind of statement:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 你的应用由类组成，这些类包含方法，方法包含语句。所以，如果我们想要构建能做很多事情的应用程序，我们将需要一些**不同类型的语句**来使它们运行。你已经看到了一种类型的语句：
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This is a **statement that calls a method**—specifically, the Console.WriteLine
    method, which prints a line of text to the console. We’ll also use a few other
    kinds of statements in this chapter and throughout the book. For example:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个调用方法的**语句**，具体来说是Console.WriteLine方法，它将一行文本打印到控制台。我们还将在本章和整本书中使用几种其他类型的语句。例如：
- en: '| ![Images](assets/055fig01.png) | We use variables and variable declarations
    to let our app store and work with data. |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| ![图片](assets/055fig01.png) | 我们使用变量和变量声明让我们的应用存储和处理数据。 |'
- en: '| ![Images](assets/055fig02.png) | Lots of programs use math, so we use mathematical
    operators to add, subtract, multiply, divide, and more. |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| ![图片](assets/055fig02.png) | 许多程序使用数学，所以我们使用数学运算符来加法、减法、乘法、除法等等。 |'
- en: '| ![Images](assets/055fig03.png) | Conditionals let our code choose between
    options, either executing one block of code or another. |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| ![图片](assets/055fig03.png) | 条件语句让我们的代码在选择选项时执行一个代码块或另一个代码块。 |'
- en: '| ![Images](assets/055fig04.png) | Loops let our code run the same block over
    and over again until a condition is satisfied. |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| ![图片](assets/055fig04.png) | 循环让我们的代码重复执行相同的块，直到满足条件为止。 |'
- en: Your programs use variables to work with data
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你的程序使用变量来处理数据
- en: Every program, no matter how big or how small, works with data. Sometimes the
    data is in the form of a document, or an image in a video game, or a social media
    update—but it’s all just data. That’s where **variables** come in. A variable
    is what your program uses to store data.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 每个程序，无论大小，都与数据一起工作。有时数据是文档的形式，或者是视频游戏中的图像，或者是社交媒体更新，但它们都只是数据。这就是**变量**的用武之地。变量是程序用来存储数据的工具。
- en: '![Images](assets/056fig01.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/056fig01.png)'
- en: Declare your variables
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 声明你的变量
- en: 'Whenever you **declare** a variable, you tell your program its *`type`* and
    its *`name`*. Once C# knows your variable’s type, it will generate errors that
    stop your program from building if you try to do something that doesn’t make sense,
    like subtract `"Fido"` from `48353`. Here’s how to declare variables:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 每当你**声明**一个变量时，你告诉你的程序它的*`类型`*和它的*`名称`*。一旦C#知道你的变量类型，如果你尝试做一些毫无意义的事情，比如从`48353`中减去`"Fido"`，它将生成错误并阻止你的程序构建。以下是声明变量的方式：
- en: '![Images](assets/056fig02.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/056fig02.png)'
- en: '**Whenever your program needs to work with numbers, text, true/false values,
    or any other kind of data, you’ll use variables to keep track of them.**'
  id: totrans-40
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**每当你的程序需要处理数字、文本、真/假值或任何其他类型的数据时，你将使用变量来跟踪它们。**'
- en: Variables vary
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 变量是可变的
- en: 'A variable is equal to different values at different times while your program
    runs. In other words, a variable’s value ***varies***. (Which is why “variable”
    is such a good name.) This is really important, because that idea is at the core
    of every program you’ll write. Say your program sets the variable `myHeight` equal
    to 63:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 一个变量在程序运行时会在不同的时间点等于不同的值。换句话说，变量的值***变化***。（这就是为什么“变量”是个好名字的原因。）这非常重要，因为这个想法是你将写的每个程序的核心。假设你的程序将变量`myHeight`设置为63：
- en: '[PRE1]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Any time `myHeight` appears in the code, C# will replace it with its value,
    63\. Then, later on, if you change its value to 12:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码中出现`myHeight`时，C#将把它替换为它的值63。然后，稍后，如果你将其值更改为12：
- en: '[PRE2]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: C# will replace `myHeight` with 12 from that point onwards (until it gets set
    again)—but the variable is still called `myHeight`.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: C#将从那时起用12替换`myHeight`（直到再次设置）——但变量仍然称为`myHeight`。
- en: You need to assign values to variables before you use them
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在使用变量之前，你需要为它们赋值。
- en: 'Try typing these statements just below the “Hello World” statement in your
    new console app:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试在你的新控制台应用程序的“Hello World”语句下方输入这些语句：
- en: '[PRE3]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '***Do this!***'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '***快点！***'
- en: 'Go ahead, try it right now. You’ll get an error, and the IDE will refuse to
    build your code. That’s because it checks each variable to make sure that you’ve
    assigned it a value before you use it. The easiest way to make sure you don’t
    forget to assign your variables values is to combine the statement that declares
    a variable with a statement that assigns its value:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在就试试看。你会收到一个错误，IDE将拒绝构建你的代码。这是因为它检查每个变量，确保在使用之前你已经为它赋了值。确保你不会忘记为变量赋值的最简单方法是将声明变量和赋值的语句结合起来：
- en: '![Images](assets/057fig01.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/057fig01.png)'
- en: A few useful types
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 几个有用的类型
- en: Every variable has a type that tells C# what kind of data it can hold. We’ll
    go into a lot of detail about the many different types in C# in [#types_and_references_getting_the_referen](ch04.html#types_and_references_getting_the_referen).
    In the meantime, we’ll concentrate on the three most popular types. `int` holds
    integers (or whole numbers), `string` holds text, and `bool` holds **Boolean**
    true/false values.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 每个变量都有一个类型，告诉C#它可以保存什么类型的数据。我们将详细讨论C#中许多不同的类型，暂时我们将集中讨论三种最流行的类型。`int`保存整数（或整数），`string`保存文本，`bool`保存**布尔值**true/false。
- en: Note
  id: totrans-55
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: var-i-a-ble, noun.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 变量，名词。
- en: an element or feature likely to change. *Predicting the weather would be a whole
    lot easier if meteorologists didn’t have to take so many **variables** into account.*
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 一个很可能改变的元素或特征。*如果气象学家不必考虑那么多**变量**，预测天气会容易得多。*
- en: If you write code that uses a variable that hasn’t been assigned a value, your
    code won’t build. It’s easy to avoid that error by combining your variable declaration
    and assignment into a single statement.
  id: totrans-58
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果你写了一个使用未赋值的变量的代码，你的代码将无法构建。通过将变量声明和赋值合并为一个语句，可以轻松避免此错误。
- en: Note
  id: totrans-59
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Once you’ve assigned a value to your variable, that value can change. So there’s
    no disadvantage to assigning a variable an initial value when you declare it.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦为变量赋了一个值，该值可以更改。因此，在声明变量时赋予一个初始值没有任何不利之处。
- en: Generate a new method to work with variables
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成一个新的方法来处理变量
- en: In the last chapter, you learned that Visual Studio will **generate code for
    you**. This is quite useful when you’re writing code and ***it’s also a really
    valuable learning tool***. Let’s build on what you learned and take a closer look
    at generating methods.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，你学到了Visual Studio将**为你生成代码**。当你编写代码时，这是非常有用的，***它也是一个非常宝贵的学习工具***。让我们在你学到的基础上进一步学习并仔细看看生成方法。
- en: '***Do this!***'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '***快点！***'
- en: '**Add a method to your new MyFirstConsoleApp project.**'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**在你的新的MyFirstConsoleApp项目中添加一个方法。**'
- en: '**Open the Console App project** that you created in the last chapter. The
    IDE created your app with a Main method that has exactly one statement:'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**打开上一章创建的控制台应用程序项目**。IDE创建了一个只有一个语句的Main方法：'
- en: '[PRE4]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Replace this with a statement that calls a method:'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 替换这个语句来调用一个方法：
- en: '[PRE5]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '**Let Visual Studio tell you what’s wrong.**'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**让Visual Studio告诉你哪里出错了。**'
- en: 'As soon as you finish replacing the statement, Visual Studio will draw a red
    squiggly underline beneath your method call. Hover your mouse cursor over it.
    The IDE will display a pop-up window:'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一旦你完成替换语句，Visual Studio会在你的方法调用下绘制一条红色波浪线。将鼠标悬停在其上。IDE将显示一个弹出窗口：
- en: '![Images](assets/058fig01.png)'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](assets/058fig01.png)'
- en: 'Visual Studio is telling you two things: that there’s a problem—you’re trying
    to call a method that doesn’t exist (which will prevent your code from building)—and
    that it has a potential fix.'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Visual Studio 告诉您两件事情：有一个问题——您正在尝试调用一个不存在的方法（这将阻止您的代码构建）——以及它有一个潜在的修复方法。
- en: '**Generate the OperatorExamples method**.'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**生成 OperatorExamples 方法**。'
- en: On **Windows**, the pop-up window tells you to press Alt+Enter or Ctrl+. to
    see the potential fixes. On **macOS**, it has a “Show potential fixes” link—press
    Option+Return to see the potential fixes. So go ahead and press either of those
    key combinations (or click on the dropdown to the left of the pop-up).
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在 **Windows** 上，弹出窗口告诉您按下 Alt+Enter 或 Ctrl+. 来查看潜在的修复方法。在 **macOS** 上，它有一个 “显示潜在修复”
    的链接——按 Option+Return 来查看潜在修复方法。所以，请继续按下其中任何一个键组合（或点击弹出窗口左侧的下拉菜单）。
- en: '![Images](assets/058fig02.png)'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图像](assets/058fig02.png)'
- en: 'The IDE has a solution: it will generate a method called OperatorExamples in
    your Program class. **Click “Preview changes”** to display a window that has the
    IDE’s potential fix—adding a new method. Then **click Apply** to add the method
    to your code.'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个 IDE 提供了一个解决方案：它会在您的程序类中生成一个名为 OperatorExamples 的方法。点击“预览更改”显示一个窗口，其中包含 IDE
    的潜在修复方案——添加一个新方法。然后点击“应用”将该方法添加到您的代码中。
- en: Add code that uses operators to your method
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加使用运算符的代码到您的方法中
- en: Once you’ve got some data stored in a variable, what can you do with it? Well,
    if it’s a number, you might want to add or multiply it. If it’s a string, you
    might join it together with other strings. That’s where **operators** come in.
    Here’s the method body for your new OperatorExamples method. **Add this code to
    your program**, and read the `**comments**` to learn about the operators it uses.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您在变量中存储了一些数据，您可以做什么？如果它是一个数字，您可能想要添加或乘以它。如果它是一个字符串，您可能想要将它与其他字符串一起连接。这就是运算符发挥作用的地方。这里是您的新
    OperatorExamples 方法的方法体。**将此代码添加到您的程序**，并阅读 `**注释**` 以了解它使用的运算符。
- en: '![Images](assets/059fig01.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![图像](assets/059fig01.png)'
- en: '[PRE6]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Note
  id: totrans-81
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: String variables hold text. When you use the + operator with strings it joins
    them together, so adding “abc” + “def” results in a single string, “abcdef” .
    When you join strings like that it’s called concatenation.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串变量用于保存文本。当您使用 + 运算符连接字符串时，它们会被合并在一起，所以添加 “abc” + “def” 的结果是一个字符串 “abcdef”
    。当您像这样连接字符串时，它被称为串联。
- en: Use the debugger to watch your variables change
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用调试器观察您的变量变化
- en: 'When you ran your program earlier, it was executing in the **debugger**—and
    that’s an incredibly useful tool for understanding how your programs work. You
    can use **breakpoints** to pause your program when it hits certain statements
    and add **watches** to look at the value of your variables. Let’s use the debugger
    to see your code in action. We’ll use these three features of the debugger, which
    you’ll find in the toolbar:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 当您之前运行程序时，它是在 **调试器** 中执行的——这是一个非常有用的工具，用于理解您的程序如何工作。您可以使用 **断点** 在程序执行到达某些语句时暂停，并添加
    **监视** 来查看变量的值。让我们使用调试器来看看您的代码运行情况。我们将使用调试器的这三个特性，您将在工具栏中找到：
- en: '![Images](assets/060fig01.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![图像](assets/060fig01.png)'
- en: If you end up in a state you don’t expect, just use the Restart button (![Images](assets/060fig02.png))
    to restart the debugger.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您进入一个您不期望的状态，只需使用重新启动按钮 (![图像](assets/060fig02.png)) 重新启动调试器。
- en: '***Do this!***'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '***就这样！***'
- en: '**Add a breakpoint and run your program.**'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**添加断点并运行您的程序。**'
- en: 'Place your mouse cursor on the method call that you added to your program’s
    Main method and **choose Toggle Breakpoint (F9) from the Debug menu**. The line
    should now look like this:'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将鼠标光标放在您添加到程序 Main 方法中的方法调用上，并从调试菜单中选择 **切换断点 (F9)**。现在该行应该看起来像这样：
- en: '![Images](assets/060fig03.png)'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图像](assets/060fig03.png)'
- en: Note
  id: totrans-91
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: '**The debugging shortcut keys for Mac are Step Over (![Images](assets/060fig03b.png)),
    Step In (![Images](assets/060fig03c.png)), and Step Out (![Images](assets/060fig03d.png)).
    The screens will look a little different, but the debugger operates exactly the
    same, as you saw in [#start_building_with_chash_build_somethin](ch01.html#start_building_with_chash_build_somethin)
    in the *Mac Learner’s Guide*.**'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**Mac 上的调试快捷键是 Step Over (![图像](assets/060fig03b.png)), Step In (![图像](assets/060fig03c.png)),
    和 Step Out (![图像](assets/060fig03d.png))。屏幕看起来可能有点不同，但调试器的操作方式完全相同，就像您在 *Mac 学习指南*
    的 [#start_building_with_chash_build_somethin](ch01.html#start_building_with_chash_build_somethin)
    中看到的那样。**'
- en: Then press the ![Images](assets/060fig03a.png) button to run your program in
    the debugger, just like you did earlier.
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后按下 ![图像](assets/060fig03a.png) 按钮在调试器中运行程序，就像您之前所做的那样。
- en: '**Step into the method.**'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**进入该方法。**'
- en: Your debugger is stopped at the breakpoint on the statement that calls the OperatorExamples
    method.
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 调试器在调用 OperatorExamples 方法的语句处停止。
- en: '![Images](assets/060fig04.png)'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](assets/060fig04.png)'
- en: '**Press *Step Into (F11)***—the debugger will jump into the method, then stop
    before it runs the first statement.'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**按下 *Step Into (F11)* ——调试器会跳进方法，然后在执行第一条语句之前停下来。'
- en: '**Examine the value of the width variable.**'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**检查 width 变量的值。**'
- en: When you’re **stepping through your code**, the debugger pauses after each statement
    that it executes. This gives you the opportunity to examine the values of your
    variables. Hover over the `width` variable.
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当你 **逐步执行代码** 时，调试器在执行每条语句后会暂停。这使你有机会检查变量的值。将鼠标悬停在 `width` 变量上。
- en: '![Images](assets/060fig05.png)'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](assets/060fig05.png)'
- en: The IDE displays a pop-up that shows the current value of the variable—it’s
    currently 0\. Now **press Step Over (F10)**—the execution jumps over the comment
    to the first statement, which is now highlighted. We want to execute it, so **press
    Step Over (F10) again**. Hover over `width` again. It now has a value of 3.
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: IDE 显示一个弹出窗口，显示变量的当前值 ——目前为 0。现在 **按下 Step Over (F10)** ——执行跳过注释到第一个语句，该语句现在已突出显示。我们希望执行它，所以
    **再次按下 Step Over (F10)**。再次悬停在 `width` 上。现在它的值为 3。
- en: '**The Locals window shows the values of your variables.**'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Locals 窗口显示变量的值。**'
- en: The variables that you declared are **local** to your OperatorExamples method—which
    just means that they exist only inside that method, and can only be used by statements
    in the method. Visual Studio displays their values in the Locals window at the
    bottom of the IDE when it’s debugging.
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你声明的变量是 **局部** 的，即它们只存在于该方法内部，并且只能被方法中的语句使用。当 Visual Studio 调试时，在底部的 IDE 中的
    Locals 窗口显示它们的值。
- en: '![Images](assets/061fig01.png)'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](assets/061fig01.png)'
- en: '**Add a watch for the height variable.**'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**为 height 变量添加 Watch。**'
- en: A really useful feature of the debugger is the **Watch window**, which is typically
    in the same panel as the Locals window at the bottom of the IDE. When you hover
    over a variable, you can add a watch by right-clicking on the variable name in
    the pop-up window and choosing Add Watch. Hover over the `height` variable, then
    right-click and choose **Add Watch** from the menu.
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 调试器的一个非常有用的功能是 **Watch 窗口**，通常与底部的 Locals 窗口在同一面板中。当你将鼠标悬停在变量上时，可以通过右键单击弹出窗口中的变量名称并选择添加
    Watch 来添加 Watch。将鼠标悬停在 `height` 变量上，然后右键单击并选择 **Add Watch** 菜单。
- en: '![Images](assets/061fig02.png)'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](assets/061fig02.png)'
- en: Now you can see the `height` variable in the Watch window.
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在你可以在 Watch 窗口中看到 `height` 变量。
- en: '![Images](assets/061fig03.png)'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](assets/061fig03.png)'
- en: '**The debugger is one of the most important features in Visual Studio, and
    it’s a great tool for understanding how your programs work.**'
  id: totrans-110
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**调试器是 Visual Studio 中最重要的功能之一，它是理解程序运行方式的强大工具。**'
- en: '**Step through the rest of the method.**'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**逐步执行方法的其余部分。**'
- en: Step over each statement in OperatorExamples. As you step through the method,
    keep an eye on the Locals or Watch window and watch the values as they change.
    On **Windows,** press **Alt+Tab** before and after the Console.WriteLine statements
    to switch back and forth to the Debug Console to see the output. On **macOS**,
    you’ll see the output in the Terminal window so you don’t need to switch windows.
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 逐步执行 OperatorExamples 中的每个语句。当你逐步执行方法时，注意 Locals 或 Watch 窗口，并观察值随着变化而变化。在 **Windows**
    上，在 Console.WriteLine 语句之前和之后按下 **Alt+Tab** 切换到调试控制台查看输出。在 **macOS** 上，你会在终端窗口中看到输出，所以不需要切换窗口。
- en: Use operators to work with variables
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用运算符处理变量
- en: 'Once you have data in a variable, what do you do with it? Well, most of the
    time you’ll want your code to do something based on the value. That’s where **equality
    operators**, **relational operators**, and **logical operators** become important:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你有了变量中的数据，你要怎么处理它？嗯，大多数时候你会希望你的代码根据这些值执行某些操作。这就是 **等式运算符**、**关系运算符** 和 **逻辑运算符**
    变得重要的地方：
- en: '**Equality Operators**'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '**等式运算符**'
- en: The == operator compares two things and is true if they’re equal.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: == 运算符比较两个值，如果它们相等则返回 true。
- en: The != operator works a lot like ==, except it’s true if the two things you’re
    comparing are not equal.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '!= 运算符与 == 非常类似，不同之处在于比较的两个值不相等时返回 true。'
- en: '**Relational Operators**'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '**关系运算符**'
- en: Use > and < to compare numbers and see if a number in one variable one is bigger
    or smaller than another.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 > 和 < 比较数字，查看一个变量中的数字是大于还是小于另一个变量中的数字。
- en: You can also use >= to check if one value is greater than or equal to another,
    and <= to check if it’s less than or equal.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用`>=`来检查一个值是否大于或等于另一个，使用`<=`来检查它是否小于或等于另一个。
- en: '**Logical Operators**'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '**逻辑运算符**'
- en: You can combine individual conditional tests into one long test using the &&
    operator for ***and*** and the || operator for ***or***.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用&&运算符进行***和***和||运算符进行***或***将个别条件测试组合成一个长测试。
- en: Here’s how you’d check if `i` equals 3 ***or*** `j` is less than 5:`(i == 3)
    || (j < 5)`
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是如何检查`i`是否等于3***或者***`j`是否小于5的方式：`(i == 3) || (j < 5)`
- en: Note
  id: totrans-124
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: '**Use operators to compare two int variables**'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用运算符比较两个int变量**'
- en: 'You can do simple tests by checking the value of a variable using a comparison
    operator. Here’s how you compare two ints, x and y:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用比较运算符来检查变量的值进行简单测试。这是如何比较两个int变量x和y的方式：
- en: '[PRE7]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: These are the ones you’ll use most often.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是你最常使用的。
- en: “if” statements make decisions
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: “if”语句做出决策
- en: Use `**if**` **statements** to tell your program to do certain things only when
    the **conditions** you set up are (or aren’t) true. The `if` statement ***tests
    the condition*** and executes code if the test passed. A lot of `if` statements
    check if two things are equal. That’s when you use the `==` operator. That’s different
    from the single equals sign (=) operator, which you use to set a value.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`**if**` **语句**告诉你的程序只有当你设置的**条件**（或不是）为真时才执行某些操作。`if`语句***测试条件***并在测试通过时执行代码。许多`if`语句检查两个事物是否相等。这时你使用`==`运算符。这与单等号（=）运算符不同，后者用于设置值。
- en: '![Images](assets/063fig01.png)![Images](assets/063fig02.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/063fig01.png)![图片](assets/063fig02.png)'
- en: if/else statements also do something if a condition isn’t true
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如果/否则语句在条件不为真时也会执行某些操作。
- en: '`**if/else**` **statements** are just what they sound like: if a condition
    is true they do one thing ***or else*** they do the other. An `if/else` statement
    is an `if` statement followed by the `**else**` **keyword** followed by a second
    set of statements to execute. If the test is true, the program executes the statements
    between the first set of brackets. Otherwise, it executes the statements between
    the second set.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`**if/else**` **语句**就像它听起来的那样：如果条件为真，则执行一件事情***否则***执行另一件事情。一个`if/else`语句是一个`if`语句，后面跟着`**else**`
    **关键字**，然后是第二组要执行的语句。如果测试为真，则程序执行第一组大括号之间的语句。否则，它执行第二组大括号之间的语句。'
- en: '![Images](assets/063fig03.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/063fig03.png)'
- en: Loops perform an action over and over
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 循环一遍又一遍地执行一个操作
- en: 'Here’s a peculiar thing about most programs (*`especially`* games!): they almost
    always involve doing certain things over and over again. That’s what **loops**
    are for—they tell your program to keep executing a certain set of statements as
    long as some condition is true or false.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有大多数程序（*`尤其是`* 游戏！）的一个奇特之处：它们几乎总是涉及重复执行某些操作。这就是**循环**的用途——它告诉你的程序在某个条件为真或假时继续执行某一组语句。
- en: '![Images](assets/064fig01.png)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/064fig01.png)'
- en: while loops keep looping statements while a condition is true
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: while循环在条件为真时不断地执行循环语句
- en: In a **while loop**, all of the statements inside the curly brackets get executed
    as long as the condition in the parentheses is true.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在**while循环**中，只要括号内的条件为真，大括号内的所有语句都会执行。
- en: '[PRE8]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: do/while loops run the statements then check the condition
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: do/while循环运行语句，然后检查条件
- en: A **do/while** loop is just like a while loop, with one difference. The while
    loop does its test first, then runs its statements only if that test is true.
    The do/while loop runs the statements first, ***then*** runs the test. So if you
    need to make sure your loop always runs at least once, a do/while loop is a good
    choice.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '**do/while** 循环与while循环几乎一样，只有一个区别。while循环首先进行测试，然后仅在测试为真时运行其语句。do/while循环先运行语句，***然后***进行测试。因此，如果需要确保循环至少运行一次，do/while循环是一个不错的选择。'
- en: '[PRE9]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: for loops run a statement after each loop
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: for循环在每次循环后运行一个语句。
- en: A **for loop** runs a statement after each time it executes a loop.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '**for循环**在每次执行循环后运行一个语句。'
- en: '![Images](assets/064fig04.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/064fig04.png)'
- en: Note
  id: totrans-147
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: '**The parts of the for statement are called the** initializer **(int i = 0),
    the** conditional test **(i < 8), and the** iterator **(i = i + 2). Each time
    through a for loop (or any loop) is called an** iteration.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '**for语句的各个部分称为** 初始化器 **（int i = 0），条件测试 **（i < 8），和** 迭代器 **（i = i + 2）。每次通过一个for循环（或任何循环）都称为**
    迭代。'
- en: '**The conditional test always runs at the beginning of each iteration, and
    the iterator always runs at the end of the iteration.**'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '**条件测试始终在每次迭代开始时运行，并且迭代器始终在迭代结束时运行。**'
- en: Note
  id: totrans-150
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: When you use the for snippet, press Tab to switch between i and length. If you
    change the name of the variable i, the snippet will automatically change the other
    two occurrences of it.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用for片段时，按Tab键可以在i和length之间切换。如果你改变变量i的名称，片段会自动更改另外两次出现的名称。
- en: Note
  id: totrans-152
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: When we give you pencil-and-paper exercises, we’ll usually give you the solution
    on the next page.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们给你提供纸和笔的练习时，通常会在下一页给出答案。
- en: Use code snippets to help write loops
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用代码片段来帮助编写循环
- en: '**Do this!**'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '**这样做！**'
- en: You’ll be writing a lot of loops throughout this book, and Visual Studio can
    help speed things up for you with **snippets**, or simple templates that you can
    use to add code. Let’s use snippets to add a few loops to your OperatorExamples
    method.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在本书中编写大量的循环，Visual Studio可以通过**片段**或简单的代码模板来帮助提高效率。让我们使用片段向你的OperatorExamples方法中添加一些循环。
- en: 'If your code is still running, choose **Stop Debugging (Shift+F5)** from the
    Debug menu (or press the square Stop button ![Images](assets/067fig02.png) in
    the toolbar). Then find the line `Console.WriteLine(area);` in your OperatorExamples
    method. Click at the end of that line so your cursor is after the semicolon, then
    press Enter a few times to add some extra space. Now start your snippet. **Type**
    `**while**` **and press the Tab key twice.** The IDE will add a template for a
    while loop to your code, with the conditional test highlighted:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的代码仍在运行，请从调试菜单中选择**停止调试（Shift+F5）**（或者点击工具栏上的停止按钮 ![Images](assets/067fig02.png)）。然后找到`Console.WriteLine(area);`这一行，在分号后面点击，然后按几次Enter添加额外的空格。现在开始你的片段。**输入**
    `**while**` **并按两次Tab键**。IDE会向你的代码添加一个while循环的模板，条件测试被突出显示：
- en: '![Images](assets/067fig03.png)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![Images](assets/067fig03.png)'
- en: 'Type `**area < 50**`—the IDE will replace `true` with the text. **Press Enter**
    to finish the snippet. Then add two statements between the brackets:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 输入`**area < 50**` ——IDE将用文本替换`true`。按Enter完成片段。然后在括号之间添加两个语句：
- en: '[PRE10]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note
  id: totrans-161
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'IDE Tip: Brackets'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: IDE提示：括号
- en: If your brackets (or braces, either name will do) don’t match up, your program
    won’t build, which leads to frustrating bugs. Luckily, the IDE can help with this!
    Put your cursor on a bracket, and the IDE highlights its match.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的括号不匹配，你的程序将无法构建，这会导致令人沮丧的错误。幸运的是，IDE可以帮助解决这个问题！将光标放在括号上，IDE会突出显示其匹配项。
- en: 'Next, use the `**do/while**` **loop snippet** to add another loop immediately
    after the while loop you just added. Type `**do**` **and press Tab twice**. The
    IDE will add this snippet:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，使用`**do/while**` **循环片段**在你刚刚添加的while循环后立即添加另一个循环。输入`**do**` **并按两次Tab键**。IDE会添加此片段：
- en: '![Images](assets/067fig04.png)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![Images](assets/067fig04.png)'
- en: 'Type `area > 25` and press Enter to finish the snippet. Then add two statements
    between the brackets:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 输入`area > 25`并按Enter完成片段。然后在括号之间添加两个语句：
- en: '[PRE11]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now **use the debugger** to really get a good sense of how these loops work:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，**使用调试器**真正了解这些循环的工作方式：
- en: Click on the line just above the first loop and choose **Toggle Breakpoint (F9)**
    from the Debug menu to add a breakpoint. Then run your code and **press F5** to
    skip to the new breakpoint.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击循环体上方的一行，并从调试菜单中选择**切换断点（F9）**以添加断点。然后运行你的代码，按下**F5**跳转到新的断点。
- en: Use **Step Over (F10)** to step through the two loops. Watch the Locals window
    as the values for `height`, `width`, and `area` change.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用**逐步执行（F10）**来逐步执行这两个循环。观察局部窗口中`height`、`width`和`area`值的变化。
- en: Stop the program, then change the while loop test to `**area < 20**` so both
    loops have conditions that are false. Debug the program again. The while checks
    the condition first and skips the loop, but the do/while executes it once and
    then checks the condition.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 停止程序，然后将while循环测试更改为`**area < 20**`，以使两个循环的条件都为假。再次调试程序。while先检查条件并跳过循环，但do/while会执行一次后再检查条件。
- en: Some useful things to keep in mind about C# code
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 一些关于C#代码有用的事项
- en: '**Don’t forget that all your statements need to end in a semicolon.**'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不要忘记，你所有的语句都需要以分号结束。**'
- en: '[PRE12]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '**Add comments to your code by starting a line with two slashes.**'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**通过在代码行前加两个斜杠来为你的代码添加注释。**'
- en: '[PRE13]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '**Use /* and */ to start and end comments that can include line breaks.**'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用 /* 和 */ 来开始和结束包含换行符的注释。**'
- en: '[PRE14]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '**Variables are declared with a *type* followed by a *name*.**'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**变量是由*类型*后跟*名称*声明的。**'
- en: '[PRE15]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '**Most of the time, extra whitespace is fine.**'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**大多数时候，额外的空白是可以接受的。**'
- en: '[PRE16]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '**If/else, while, do, and for are all about testing conditions.**'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**If/else, while, do, and for are all about testing conditions.**'
- en: Every loop we’ve seen so far keeps running as long as a condition is true.
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 到目前为止，我们看到的每个循环只要条件为真就会继续运行。
- en: '![Images](assets/069fig01.png)'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](assets/069fig01.png)'
- en: '**Then your loop runs forever.**'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '**然后你的循环就会永远运行下去。**'
- en: Every time your program runs a conditional test, the result is either `**true**`
    or `**false**`. If it’s `**true**`, then your program goes through the loop one
    more time. Every loop should have code that, if it’s run enough times, should
    cause the conditional test to eventually return `**false**`. If it doesn’t, then
    the loop will keep running until you kill the program or turn the computer off!
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 每次程序运行条件测试时，结果要么是`**true**`，要么是`**false**`。如果是`**true**`，那么程序将再次通过循环。每个循环都应该有一些代码，如果运行足够多次，应该会导致条件测试最终返回`**false**`。如果没有，那么循环将一直运行，直到您关闭程序或关闭计算机！
- en: Note
  id: totrans-188
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: This is sometimes called an **infinite loop**, and there are definitely times
    when you’ll want to use one in your code.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 有时这被称为**无限循环**，在编写代码时肯定会有使用它的时候。
- en: '![Images](assets/070fig01.png)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/070fig01.png)'
- en: '**Definitely! Every program has its own kind of mechanics.**'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '**当然！每个程序都有其自身的机制。**'
- en: There are mechanics at every level of software design. They’re easier to talk
    about and understand in the context of video games. We’ll take advantage of that
    to help give you a deeper understanding of mechanics, which is valuable for designing
    and building any kind of project.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件设计的每个层次都存在着机制。在视频游戏的背景下讨论和理解它们会更容易。我们将利用这一点来帮助您更深入地理解机制，这对于设计和构建任何类型的项目都是非常有价值的。
- en: Here’s an example. The mechanics of a game determine how hard or easy it is
    to play. Make Pac Man faster or the ghosts slower and the game gets easier. That
    doesn’t necessarily make it better or worse—just different. And guess what? The
    same exact idea applies to how you design your classes! You can think of ***how
    you design your methods and fields*** as the mechanics of the class. The choices
    you make about how to break up your code into methods or when to use fields make
    them easier or more difficult to use.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例子。游戏的机制决定了游戏的难易程度。使Pac Man更快或鬼魂更慢，游戏会变得更容易。这并不一定使游戏变得更好或更糟——只是不同而已。猜猜？同样的想法也适用于您如何设计您的类！您可以将***您如何设计方法和字段***看作是类的机制。关于如何将代码分解为方法或何时使用字段的选择会使它们更易于使用或更难以使用。
- en: Controls drive the mechanics of your user interfaces
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控件驱动您的用户界面的机制
- en: 'In the last chapter, you built a game using TextBlock and Grid **controls**.
    But there are a lot of different ways that you can use controls, and the choices
    you make about what controls to use can really change your app. Does that sound
    weird? It’s actually really similar to the way we make choices in game design.
    If you’re designing a tabletop game that needs a random number generator, you
    can choose to use dice, a spinner, or cards. If you’re designing a platformer,
    you can choose to have your player jump, double jump, wall jump, or fly (or do
    different things at different times). The same goes for apps: if you’re designing
    an app where the user needs to enter a number, you can choose from different controls
    to let them do that—***and that choice affects how your user experiences the app***.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，您使用了TextBlock和Grid **控件**来构建一个游戏。但是有很多不同的控件可以使用，您选择使用哪些控件会真正改变您的应用程序。听起来奇怪吗？实际上与我们在游戏设计中做选择的方式非常相似。如果您设计一个需要随机数生成器的桌面游戏，您可以选择使用骰子、旋转器或卡片。如果您设计一个平台游戏，您可以选择让您的玩家跳跃、双重跳跃、墙壁跳跃或飞行（或在不同时间做不同的事情）。对于应用程序也是如此：如果您设计一个需要用户输入数字的应用程序，您可以从不同的控件中选择让他们这样做——***而这种选择会影响用户体验应用程序的方式***。
- en: '![Images](assets/071fig01.png)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/071fig01.png)'
- en: A **text box** lets a user enter any text they want. But we need a way to make
    sure they’re only entering numbers and not just any text.
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文本框允许用户输入任何想要的文本。但我们需要一种方法来确保他们只输入数字，而不是任意文本。
- en: '![Images](assets/071fig04.png)'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](assets/071fig04.png)'
- en: '**Radio buttons** let you restrict the user’s choice. You can use them for
    numbers if you want, and you can choose how you want to lay them out.'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单选按钮**允许您限制用户的选择。如果需要，您可以将其用于数字，并且可以选择如何布局它们。'
- en: '![Images](assets/071fig05.png)'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](assets/071fig05.png)'
- en: The other controls on this page can be used for other types of data, but **sliders**
    are used exclusively to choose a number. Phone numbers are just numbers, too.
    So *`technically`* you could use a slider to choose a phone number. Do you think
    that’s a good choice?
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此页面上的其他控件可以用于其他类型的数据，但**滑块**专门用于选择数字。电话号码也只是数字而已，所以*`从技术上讲`*，你可以使用滑块来选择电话号码。你觉得这是个好选择吗？
- en: '![Images](assets/071fig02.png)'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](assets/071fig02.png)'
- en: A **list box** gives users a way to choose from a list of items. If the list
    is long, it will show a scroll bar to make it easier for the user to find an item.
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**列表框**为用户提供了从项目列表中选择的方式。如果列表很长，它会显示滚动条，以便用户更容易找到项目。'
- en: '![Images](assets/071fig03.png)'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](assets/071fig03.png)'
- en: A **combo box** combines the behavior of a list box and a text box. It looks
    like a normal text box, but when the user clicks it a list box pops up underneath
    it.
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**组合框**结合了列表框和文本框的行为。它看起来像一个普通的文本框，但当用户点击它时，会在其下弹出一个列表框。'
- en: '![Images](assets/071fig06.png)'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](assets/071fig06.png)'
- en: Note
  id: totrans-207
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: '**Controls are common user interface (UI) components, the building blocks of
    your UI. The choices you make about what controls to use change the mechanics
    of your app.**'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '**控件是常见的用户界面（UI）组件，是您的 UI 的构建块。您所做的有关使用哪些控件的选择会改变应用程序的机制。**'
- en: Note
  id: totrans-209
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: We can borrow the idea of mechanics from video games to understand our options,
    so we can make great choices for any of our own apps—not just games.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以借鉴视频游戏中的机制概念来了解我们的选择，这样我们可以为任何我们自己的应用程序做出出色的选择——不仅仅是游戏。
- en: '![Images](assets/071fig07.png)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/071fig07.png)'
- en: '**The rest of this chapter contains a project to build a WPF desktop app for
    Windows. Go to the Visual Studio for Mac Learner’s Guide for the corresponding
    macOS project.**'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '**本章的其余部分包含了一个为 Windows 构建 WPF 桌面应用程序的项目。前往 Visual Studio for Mac 学习指南获取相应的
    macOS 项目。**'
- en: Create a WPF app to experiment with controls
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个 WPF 应用程序以实验控件
- en: If you’ve filled out a form on a web page, you’ve seen the controls we just
    showed you (even if you didn’t know all of their official names). Now let’s **create
    a WPF app** to get some practice using those controls. The app will be really
    simple—the only thing it will do is let the user pick a number, and display the
    number that was picked.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你填写了网页上的表单，你就会看到我们刚才展示的这些控件（即使你不知道它们的官方名称）。现在让我们**创建一个 WPF 应用程序**来练习使用这些控件。这个应用程序非常简单——它唯一的功能就是让用户选择一个数字，并显示所选择的数字。
- en: '***Do this!***'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '***一定要这样做！***'
- en: '![Images](assets/072fig01.png)![Images](assets/074fig02.png)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/072fig01.png)![图片](assets/074fig02.png)'
- en: '**“Save early, save often.”**'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '**“早存，多存。”**'
- en: That’s an old saying from a time before video games had an autosave feature,
    and when you had to stick one of these in your computer to back up your projects…but
    it’s still great advice! Visual Studio makes it easy to add your project to source
    control and keep it up to date—so you’ll always be able to go back and see all
    the progress you’ve made.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个旧说法，来自视频游戏没有自动保存功能的时代，当时您必须将这些东西插入计算机以备份项目……但这仍然是个好建议！Visual Studio 使得将项目添加到源代码控制并保持更新变得轻松——所以您始终可以回顾您所取得的所有进展。
- en: '![Images](assets/074fig03.png)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/074fig03.png)'
- en: Add a TextBox control to your app
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向您的应用程序添加一个 TextBox 控件
- en: A **TextBox control** gives your user a box to type text into, so let’s add
    one to your app. But we don’t just want a TextBox sitting there without a label,
    so first we’ll add a **Label control** (which is a lot like a TextBlock, except
    it’s specifically used to add labels to other controls).
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '**TextBox 控件**为用户提供了一个输入文本的框，所以让我们将其添加到您的应用程序中。但我们不只是想要一个没有标签的 TextBox，所以我们首先会添加一个**Label
    控件**（它与 TextBlock 很相似，但专门用于为其他控件添加标签）。'
- en: '**Drag a Label out of the Toolbox into the top-left cell of the grid.**'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**从工具箱拖动一个 Label 到网格的左上角单元格。**'
- en: This is exactly how you added TextBlock controls to your animal matching game
    in [#start_building_with_chash_build_somethin](ch01.html#start_building_with_chash_build_somethin),
    except this time you’re doing it with a Label control. It doesn’t matter where
    in the cell you drag it, as long as it’s in the upper-left cell.
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这与你在 [#start_building_with_chash_build_somethin](ch01.html#start_building_with_chash_build_somethin)
    中向你的动物匹配游戏添加 TextBlock 控件的方法完全相同，只是这次你要用 Label 控件来做。无论你把它拖到单元格的哪个位置，只要它在左上角的单元格里就行了。
- en: '**Set the text size and content of the Label.**'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**设置 Label 的文本大小和内容。**'
- en: While the Label control is selected, go to the Properties window, expand the
    Text section, and set the font size to `**18px**`. Then expand the Common section
    and set the Content to the text `Enter a number`.
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当选中标签控件时，转到属性窗口，展开文本部分，并将字体大小设置为`**18px**`。然后展开常规部分，并将内容设置为文本`输入一个数字`。
- en: '![Images](assets/075fig01.png)![Images](assets/075fig02.png)'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](assets/075fig01.png)![图片](assets/075fig02.png)'
- en: '**Drag the Label to the upper-left corner of the cell.**'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**将标签拖到单元格的左上角。**'
- en: Click on the Label in the designer and drag it to the upper-left corner. When
    it’s 10 pixels away from the left or top cell wall, you’ll see gray bars appear
    and it will snap to a 10px margin.
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在设计师中单击标签并将其拖动到左上角。当距左侧或顶部单元格墙壁10像素时，您将看到灰色条出现，并且它将捕捉到10像素的边距。
- en: 'The XAML for your window should now contain a Label control:'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，您窗口的XAML应包含一个标签控件：
- en: '[PRE17]'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '![Images](assets/075fig03.png)'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](assets/075fig03.png)'
- en: '**Drag a TextBox into the top-left cell of the grid.**'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**将一个文本框拖到网格的左上角单元格中。**'
- en: Your app will have a TextBox positioned just underneath the Label so the user
    can type in numbers. Drag it so it’s on the left side and below the Label—the
    same gray bars will appear to position it just underneath the Label with a 10px
    left margin. Set its name to `**numberTextBox**`, font size to `**18px**`, and
    text to `**0**`.
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您的应用程序将拥有一个文本框，位于标签的正下方，以便用户可以输入数字。将其拖动到左侧并放置在标签的下方 - 相同的灰色条将出现以使其在标签的下方具有10像素的左边距。将其名称设置为`**numberTextBox**`，字体大小设置为`**18px**`，文本设置为`**0**`。
- en: '![Images](assets/076fig01.png)'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](assets/076fig01.png)'
- en: Now run your app. Oops! Something went wrong—it threw an exception.
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在运行您的应用程序。糟糕！出了点问题 — 它抛出了一个异常。
- en: '![Images](assets/077fig01.png)'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](assets/077fig01.png)'
- en: Take a look at the bottom of the IDE. It has an Autos window that shows you
    any defined variables.
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 查看IDE底部。它有一个自动窗口，显示您定义的任何变量。
- en: So what’s going on—***and, more importantly, how do we fix it?***
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 所以到底发生了什么 — ***更重要的是，我们如何修复它？***
- en: Note
  id: totrans-239
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Moving the TextBlock tag in the XAML so it’s above the TextBox, causes the TextBlock
    to get initialized first.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 将XAML中的TextBlock标签移动到文本框上方，使TextBlock首先初始化。
- en: Add C# code to update the TextBlock
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加C#代码来更新TextBlock
- en: In [#start_building_with_chash_build_somethin](ch01.html#start_building_with_chash_build_somethin)
    you added **event handlers**—methods that are called when a certain event is **raised**
    (sometimes we say the event is **triggered** or **fired**)—to handle mouse clicks
    in your animal matching game. Now we’ll add an event handler to the code-behind
    that’s called any time the user enters text into the TextBox and copies that text
    to the TextBlock that you added to the upper-right cell in the mini-exercise.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在[#start_building_with_chash_build_somethin](ch01.html#start_building_with_chash_build_somethin)中，您添加了**事件处理程序**
    — 当某个事件**触发**时调用的方法（有时我们称事件为**触发**或**激发**）— 来处理动物匹配游戏中的鼠标点击。现在我们将向代码后台添加一个事件处理程序，每当用户在文本框中输入文本并将该文本复制到您添加到小练习中的右上角单元格中的TextBlock时调用。
- en: Note
  id: totrans-243
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: '**When you double-click on a TextBox control, the IDE adds an event handler
    for the TextChanged event that’s called any time the user changes its text. Double-clicking
    on other types of controls might add other event handlers—and in some cases (like
    with TextBlock) doesn’t add any event handlers at all.**'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '**当您双击文本框控件时，IDE会添加一个处理TextChanged事件的事件处理程序，每当用户更改其文本时调用此事件处理程序。双击其他类型的控件可能会添加其他事件处理程序
    — 而在某些情况下（例如TextBlock），则根本不会添加任何事件处理程序。**'
- en: '**Double-click on the TextBox control to add the method.**'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**双击文本框控件以添加方法。**'
- en: 'As soon as you double-click on the TextBox, the IDE will **automatically add
    a C# event handler method** hooked up to its TextChanged event. It generates an
    empty method and gives it a name that consists of the name of the control (`numberTextBox`)
    followed by an underscore and the name of the event being handled—numberTextBox_TextChanged:'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 双击文本框后，IDE会**自动添加一个C#事件处理方法**，连接到其TextChanged事件。它会生成一个空方法，并赋予一个名称，该名称由控件名称（`numberTextBox`）后跟下划线和所处理事件的名称组成
    — `numberTextBox_TextChanged`：
- en: '[PRE18]'
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '**Add code to the new TextChanged event handler.**'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**添加代码到新的TextChanged事件处理程序中。**'
- en: 'Any time the user enters text into the TextBox, we want the app to copy it
    into the TextBlock that you added to the upper-right cell of the grid. Since you
    gave the TextBlock a name (`number`) and you also gave the TextBox a name (`numberTextBox`),
    you just need one line of code to copy its contents:'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 任何时候用户在文本框中输入文本，我们希望应用程序将其复制到你添加到网格右上角单元格中的文本块中。因为你给文本块命名为 `number`，并且你还给文本框命名为
    `numberTextBox`，你只需要一行代码来复制其内容：
- en: '[PRE19]'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Note
  id: totrans-251
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: This line of code sets the text in the TextBlock so it’s the same as the text
    in the TextBox, and it gets called any time the user changes the text in the TextBox.
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这行代码将文本块中的文本设置为与文本框中的文本相同，任何时候用户改变文本框中的文本，它都会被调用。
- en: '**Run your app and try out the TextBox.**'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**运行你的应用程序并尝试文本框。**'
- en: Use the Start Debugging button (or choose Start Debugging (F5) from the Debug
    menu) to start your app, just like you did with the animal matching game in [#start_building_with_chash_build_somethin](ch01.html#start_building_with_chash_build_somethin).
    (If the runtime tools appear, you can disable them just like you did in [#start_building_with_chash_build_somethin](ch01.html#start_building_with_chash_build_somethin).)
    Type any number into the TextBox and it will get copied.
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用“开始调试”按钮（或从调试菜单中选择“开始调试（F5）”）启动你的应用程序，就像你在 [#start_building_with_chash_build_somethin](ch01.html#start_building_with_chash_build_somethin)
    中做动物匹配游戏一样。（如果运行时工具出现，你可以像在 [#start_building_with_chash_build_somethin](ch01.html#start_building_with_chash_build_somethin)
    中那样禁用它们。）在文本框中输入任何数字，它都会被复制。
- en: '![Images](assets/078fig02.png)'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](assets/078fig02.png)'
- en: But something’s wrong—you can enter any text into the TextBox, not just numbers!
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 但是有些问题 —— 你可以输入任何文本到文本框中，而不仅仅是数字！
- en: '![Images](assets/078fig03.png)'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](assets/078fig03.png)'
- en: Add an event handler that only allows number input
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加一个只允许数字输入的事件处理程序
- en: When you added the MouseDown event to your TextBlock in [#start_building_with_chash_build_somethin](ch01.html#start_building_with_chash_build_somethin),
    you used the buttons in the upper-right corner of the Properties window to switch
    between properties and events. Now you’ll do the same thing, except this time
    you’ll use the **PreviewTextInput event** to only accept input that’s made up
    of numbers, and reject any input that isn’t a number.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在 [#start_building_with_chash_build_somethin](ch01.html#start_building_with_chash_build_somethin)
    中给你的文本块添加了鼠标按下事件时，你使用了属性窗口右上角的按钮在属性和事件之间切换。现在你会做同样的事情，但这次你会使用**预览文本输入事件**只接受由数字组成的输入，并拒绝任何不是数字的输入。
- en: If your app is currently running, stop it. Then go to the designer, click on
    the TextBox to select it, and switch the Properties window to show you its events.
    Scroll down and **double-click inside the box next to PreviewTextInput** to make
    the IDE generate an event handler method.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的应用程序当前正在运行，请停止它。然后进入设计器，点击文本框选择它，切换到属性窗口以显示其事件。向下滚动并**双击预览文本输入旁边的框**，让 IDE
    生成一个事件处理程序方法。
- en: '![Images](assets/079fig01.png)![Images](assets/079fig02.png)'
  id: totrans-261
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/079fig01.png)![图片](assets/079fig02.png)'
- en: 'Your new event handler method will have one statement in it:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 你的新事件处理程序方法将有一个语句：
- en: '[PRE20]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Note
  id: totrans-264
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: You’ll learn all about int.TryParse later in the book—for now, just enter the
    code exactly as it appears here.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 你会在书后面详细了解 `int.TryParse`，现在只需按照这里显示的方式输入代码。
- en: 'Here’s how this event handler works:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 这是这个事件处理程序的工作原理：
- en: The event handler is called when the user enters text into the TextBox, but
    ***before*** the TextBox is updated.
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当用户输入文本到文本框中时，事件处理程序会被调用，但在文本框更新之前。
- en: It uses a special method called `int.TryParse` to check if the text that the
    user entered is a number.
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它使用了一个特殊的方法叫做 `int.TryParse` 来检查用户输入的文本是否为数字。
- en: If the user entered a number, it sets `e.Handled` to `true`, which tells WPF
    to ignore the input.
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果用户输入了一个数字，它会将 `e.Handled` 设置为 `true`，这告诉 WPF 忽略该输入。
- en: 'Before you run your code, go back and look at the XAML tag for the TextBox:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行代码之前，请回到 XAML 标签查看文本框：
- en: '[PRE21]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now it’s hooked up to two event handlers: the TextChange event is hooked up
    to an event handler method called numberTextBox_TextChanged, and right below it
    the PreviewTextInput event is hooked up to a method called numberTextBox_PreviewTextInput.'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 现在它连接了两个事件处理程序：文本更改事件连接到一个名为 `numberTextBox_TextChanged` 的事件处理程序方法，紧接着下面的预览文本输入事件连接到一个名为
    `numberTextBox_PreviewTextInput` 的方法。
- en: Add sliders to the bottom row of the grid
  id: totrans-273
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在网格的底部行添加滑块
- en: Let’s add two sliders to the bottom row and then hook up their event handlers
    so they update the TextBlock in the upper-right corner.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在底部行添加两个滑块，然后连接它们的事件处理程序以更新右上角的文本块。
- en: '**Add a slider to your app.**'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**向你的应用程序添加一个滑块。**'
- en: Drag a Slider out of the Toolbox and into the lower-right cell. Drag it to the
    upper-left corner of the cell and use the gray bars to give it left and top margins
    of 10.
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 从工具箱中拖动一个滑块到右下角的单元格中。将其拖动到单元格的左上角，并使用灰色条形调整其左侧和顶部边距为10。
- en: '![Images](assets/083fig01.png)![Images](assets/083fig02.png)'
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](assets/083fig01.png)![图片](assets/083fig02.png)'
- en: 'Use the Common section of the Properties window to set AutoToolTipPlacement
    to `**TopLeft**`, Maximum to `**5**`, and Minimum to `**1**`. Give it the name
    `**smallSlider**`. Then double-click on the slider to add this event handler:'
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用属性窗口的常用部分将AutoToolTipPlacement设置为`**TopLeft**`，将Maximum设置为`**5**`，将Minimum设置为`**1**`。给它命名为`**smallSlider**`。然后双击滑块，添加这个事件处理程序：
- en: '[PRE22]'
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Note
  id: totrans-280
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The value of the Slider control is a fractional number with a decimal point.
    This “0” converts it to a whole number.
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Slider控件的值是带有小数点的分数。这个“0”将其转换为整数。
- en: '**Add a ridiculous slider to choose phone numbers.**'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**添加一个荒谬的滑块以选择电话号码。**'
- en: 'There’s an old saying: *`“Just because an idea is terrible and also maybe stupid,
    that doesn’t mean you shouldn’t do it.”`* So let’s do something that’s just a
    bit stupid: add a slider to select phone numbers.'
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 有句老话说：*“只是因为一个想法很糟糕，也许还很愚蠢，并不意味着你不应该去做它。”* 所以让我们做一些有点愚蠢的事情：添加一个滑块以选择电话号码。
- en: '![Images](assets/083fig04.png)![Images](assets/083fig05.png)'
  id: totrans-284
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](assets/083fig04.png)![图片](assets/083fig05.png)'
- en: 'Drag another slider into the bottom row. Use the Layout section of the Properties
    window to **reset its width**, set its ColumnSpan to `**2**`, set all of its margins
    to `**10**`, and set its vertical alignment to `**Center**` and horizontal alignment
    to `**Stretch**`. Then use the Common section to set AutoToolTipPlacement to `**TopLeft**`,
    Minimum to `**1111111111**`, Maximum to `**9999999999**`, and Value to `**7183876962**`.
    Give it the name `**bigSlider**`. Then double-click on it and add this ValueChanged
    event handler:'
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将另一个滑块拖入底行。使用属性窗口的布局部分**重置其宽度**，将其ColumnSpan设置为`**2**`，将所有边距设置为`**10**`，将其垂直对齐设置为`**Center**`，水平对齐设置为`**Stretch**`。然后使用常用部分将AutoToolTipPlacement设置为`**TopLeft**`，Minimum设置为`**1111111111**`，Maximum设置为`**9999999999**`，Value设置为`**7183876962**`。给它命名为`**bigSlider**`。然后双击它，添加这个ValueChanged事件处理程序：
- en: '![Images](assets/083fig06.png)'
  id: totrans-286
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](assets/083fig06.png)'
- en: Add C# code to make the rest of the controls work
  id: totrans-287
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加C#代码以使其余控件工作
- en: 'You want each of the controls in your app to do the same thing: update the
    TextBlock in the upper-right cell with a number, so when you check one of the
    radio buttons or pick an item from a ListBox or ComboBox, the TextBlock is updated
    with whatever value you chose.'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 你希望应用程序中的每个控件都执行相同的操作：更新右上角单元格中的TextBlock，以显示所选数字。因此，当你选中单选按钮或从ListBox或ComboBox中选择项目时，TextBlock会更新为你选择的值。
- en: '**Add a Checked event handler to the first RadioButton control.**'
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**为第一个RadioButton控件添加一个Checked事件处理程序。**'
- en: 'Double-click on the first RadioButton. The IDE will add a new event handler
    method called RadioButton_Checked (since you never gave the control a name, it
    just uses the type of control to generate the method). Add this line of code:'
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 双击第一个RadioButton。IDE将添加一个名为RadioButton_Checked的新事件处理程序方法（因为你从未给控件命名，它只是使用控件类型生成方法）。添加以下代码行：
- en: '[PRE23]'
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '**Make the other RadioButtons use the same event handler.**'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**使其他RadioButton使用相同的事件处理程序。**'
- en: Look closely at the XAML for the RadioButton that you just modified. The IDE
    added the property `Checked="RadioButton_Checked"`—this is exactly like how the
    other event handlers were hooked up. **Copy this property to the other RadioButton
    tags** so they all have identical Checked properties—and ***now they’re all connected
    to the same Checked event handler***. You can use the Events view in the Properties
    window to check that each RadioButton is hooked up correctly.
  id: totrans-293
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 仔细查看你刚修改的RadioButton的XAML。IDE添加了属性`Checked="RadioButton_Checked"` ——这与其他事件处理程序的连接方式完全相同。**将此属性复制到其他RadioButton标签**，使它们都具有相同的Checked属性——***现在它们都连接到同一个Checked事件处理程序***。你可以使用属性窗口中的事件视图来检查每个RadioButton是否正确连接。
- en: '![Images](assets/084fig02.png)'
  id: totrans-294
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](assets/084fig02.png)'
- en: '**Make the ListBox update the TextBlock in the upper-right cell.**'
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**使ListBox更新右上角单元格中的TextBlock。**'
- en: When you did the exercise, you named your ListBox `myListBox`. Now you’ll add
    an event handler that fires any time the user selects an item and uses the name
    to get the number that the user selected.
  id: totrans-296
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在你进行练习时，你将ListBox命名为`myListBox`。现在，你将添加一个事件处理程序，每当用户选择项目时都会触发该处理程序，并使用该名称获取用户选择的数字。
- en: 'Double-click inside the **empty** space in the ListBox **below** the items
    to make the IDE add an event handler method for the SelectionChanged event. Add
    this statement to it:'
  id: totrans-297
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 双击 ListBox **下方**的空白处，使 IDE 添加一个 SelectionChanged 事件的事件处理程序方法。在其中添加以下语句：
- en: Note
  id: totrans-298
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Make sure you click on the empty space below the list items. If you click on
    an item, it will add an event handler for that item and not for the entire ListBox.
  id: totrans-299
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 确保您点击列表项下方的空白处。如果您点击一个项目，它将为该项目添加一个事件处理程序，而不是为整个 ListBox 添加。
- en: '[PRE24]'
  id: totrans-300
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '**Make the read-only combo box update the TextBlock.**'
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**使只读组合框更新 TextBlock。**'
- en: 'Double-click on the read-only ComboBox to make Visual Studio add an event handler
    for the SelectionChanged event, which is raised any time a new item is selected
    in the ComboBox. Here’s the code—it’s really similar to the code for the ListBox:'
  id: totrans-302
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 双击只读 ComboBox 以使 Visual Studio 添加一个 SelectionChanged 事件的事件处理程序，每当在 ComboBox
    中选择一个新项目时，该事件都会触发。这里的代码——与 ListBox 的代码非常相似：
- en: '[PRE25]'
  id: totrans-303
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Note
  id: totrans-304
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: You can also use the Properties window to add a SelectionChanged event. If you
    accidentally do this, you can hit “undo” (but make sure you do it in both files).
  id: totrans-305
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您还可以使用属性窗口添加 SelectionChanged 事件。如果您意外地这样做了，您可以点击“撤销”（但确保您在两个文件中都这样做）。
- en: '**Make the editable combo box update the TextBlock.**'
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**使可编辑的组合框更新 TextBlock。**'
- en: An editable combo box is like a cross between a ComboBox and a TextBox. You
    can choose items from a list, but you can also type in your own text. Since it
    works like a TextBox, we can add a PreviewTextInput event handler to make sure
    the user can only type numbers, just like we did with the TextBox. In fact, you
    can **reuse the same event handler** that you already added for the TextBox.
  id: totrans-307
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 可编辑的组合框类似于 ComboBox 和 TextBox 的混合体。您可以从列表中选择项目，但也可以输入自己的文本。因为它像一个 TextBox 一样工作，我们可以添加一个
    PreviewTextInput 事件处理程序，以确保用户只能输入数字，就像我们对 TextBox 做的那样。事实上，您可以**重用您已经为 TextBox
    添加的相同事件处理程序**。
- en: Go to the XAML for the editable ComboBox, put your cursor just before the closing
    caret `**>**` and **start typing *PreviewTextInput***. An IntelliSense window
    will pop up to help you complete the event name. Then **add an equals sign**—as
    soon as you do, the IDE will prompt you to either choose a new event handler or
    select the one you already added. Choose the existing event handler.
  id: totrans-308
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 转到可编辑 ComboBox 的 XAML，在闭合角标 `**>**` 前面放置光标，**开始输入 *PreviewTextInput***。 IntelliSense
    窗口将弹出以帮助您完成事件名称。然后 **添加一个等号**—一旦您这样做，IDE 将提示您选择一个新的事件处理程序或选择您已添加的一个。选择现有的事件处理程序。
- en: '![Images](assets/085fig02.png)'
  id: totrans-309
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](assets/085fig02.png)'
- en: The previous event handlers used the list items to update the TextBlock. But
    users can enter any text they want into an editable ComboBox, so this time you’ll
    **add a different kind of event handler**.
  id: totrans-310
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 之前的事件处理程序使用列表项来更新 TextBlock。但用户可以在可编辑的 ComboBox 中输入任何文本，所以这次您将**添加一种不同类型的事件处理程序**。
- en: Edit the XAML again to add a new tag below `ComboBox`. This time, **type** `**TextBoxBase**`.—as
    soon as you type the period, the autocomplete will give suggestions. Choose **TextBoxBase.TextChanged**
    and type an equals sign. Now choose <New Event Handler> from the dropdown.
  id: totrans-311
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 再次编辑 XAML，在 `ComboBox` 下方添加一个新的标签。这次，**输入** `**TextBoxBase**`。—一旦你输入句点，自动完成将会给出建议。选择
    **TextBoxBase.TextChanged** 并输入一个等号。现在从下拉菜单中选择 <新事件处理程序>。
- en: '![Images](assets/085fig03.png)'
  id: totrans-312
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](assets/085fig03.png)'
- en: 'The IDE will add a new event handler to the code-behind. Here’s the code for
    it:'
  id: totrans-313
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: IDE 将在代码后台添加一个新的事件处理程序。这是它的代码：
- en: '[PRE26]'
  id: totrans-314
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '***Now run your program. All of the controls should work. Great job!***'
  id: totrans-315
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '***现在运行你的程序。所有控件都应该工作。干得好！***'
- en: '![Images](assets/086fig01.png)'
  id: totrans-316
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/086fig01.png)'
- en: '**Controls give you the flexibility to make things easy for your users.**'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '**控件为您的用户提供了灵活性，使事情变得更加简单。**'
- en: 'When you’re building the UI for an app, there are so many choices that you
    make: what controls to use, where to put each one, what to do with their input.
    Picking one control instead of another gives your users an *`implicit`* message
    about how to use your app. For example, when you see a set of radio buttons, you
    know that you need to pick from a small set of choices, while an editable combo
    box tells you that there your choices are nearly unlimited. So don’t think of
    UI design as a matter of making “right” or “wrong” choices. Instead, think of
    it as your way to make things as easy as possible for your users.'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建应用程序的用户界面（UI）时，你需要做出很多选择：使用哪些控件，每个控件放置在哪里，如何处理它们的输入。选择一个控件而不是另一个会向用户传达关于如何使用你的应用程序的*`隐含`*信息。例如，当你看到一组单选按钮时，你知道你需要从一个有限的选择集中选择一个，而可编辑的组合框则告诉你几乎没有限制的选择。因此，不要把UI设计看作是做出“对”或“错”的选择。相反，把它看作是让用户尽可能轻松使用你的途径。
