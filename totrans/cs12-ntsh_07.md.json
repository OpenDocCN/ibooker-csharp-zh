["```cs\npublic interface IEnumerator\n{\n  bool MoveNext();\n  object Current { get; }\n  void Reset();\n}\n```", "```cs\npublic interface IEnumerable\n{\n  IEnumerator GetEnumerator();\n}\n```", "```cs\nstring s = \"Hello\";\n\n// Because string implements IEnumerable, we can call GetEnumerator():\nIEnumerator rator = s.GetEnumerator();\n\nwhile (rator.MoveNext())\n{\n  char c = (char) rator.Current;\n  Console.Write (c + \".\");\n}\n\n// Output:  H.e.l.l.o.\n```", "```cs\nstring s = \"Hello\";      // The String class implements IEnumerable\n\nforeach (char c in s)\n  Console.Write (c + \".\");\n```", "```cs\npublic interface IEnumerator<T> : IEnumerator, IDisposable\n{\n  T Current { get; }\n}\n\npublic interface IEnumerable<T> : IEnumerable\n{\n  IEnumerator<T> GetEnumerator();\n}\n```", "```cs\nvoid Test (IEnumerable<int> numbers) { ... }\n```", "```cs\nint[] data = { 1, 2, 3 };\nvar rator = ((IEnumerable <int>)data).GetEnumerator();\n```", "```cs\nforeach (var element in somethingEnumerable) { ... }\n```", "```cs\nusing (var rator = somethingEnumerable.GetEnumerator())\n  while (rator.MoveNext())\n  {\n    var element = rator.Current;\n    ...\n  }\n```", "```cs\npublic class MyCollection : IEnumerable\n{\n  int[] data = { 1, 2, 3 };\n\n  public IEnumerator GetEnumerator()\n  {\n    foreach (int i in data)\n      yield return i;\n  }\n}\n```", "```cs\npublic class MyGenCollection : IEnumerable<int>\n{\n  int[] data = { 1, 2, 3 };\n\n  public IEnumerator<int> GetEnumerator()\n  {\n    foreach (int i in data)\n      yield return i;\n  }\n\n  // Explicit implementation keeps it hidden:\n  IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();\n}\n```", "```cs\npublic static IEnumerable <int> GetSomeIntegers()\n{\n  yield return 1;\n  yield return 2;\n  yield return 3;\n}\n```", "```cs\nforeach (int i in Test.GetSomeIntegers())\n  Console.WriteLine (i);\n```", "```cs\npublic class MyIntList : IEnumerable\n{\n  int[] data = { 1, 2, 3 };\n\n  public IEnumerator GetEnumerator() => new Enumerator (this);\n\n  class Enumerator : IEnumerator       // Define an inner class\n  {                                    // for the enumerator.\n    MyIntList collection;\n    int currentIndex = -1;\n\n    public Enumerator (MyIntList items) => this.collection = items;\n\n    public object Current\n    {\n      get\n      {\n        if (currentIndex == -1)\n          throw new InvalidOperationException (\"Enumeration not started!\");\n        if (currentIndex == collection.data.Length)\n          throw new InvalidOperationException (\"Past end of list!\");\n        return collection.data [currentIndex];\n      }\n    }\n\n    public bool MoveNext()\n    {\n      if (currentIndex >= collection.data.Length - 1) return false;\n      return ++currentIndex < collection.data.Length;\n    }\n\n    public void Reset() => currentIndex = -1;\n  }\n}\n```", "```cs\nclass MyIntList : IEnumerable<int>\n{\n  int[] data = { 1, 2, 3 };\n\n  // The generic enumerator is compatible with both IEnumerable and\n  // IEnumerable<T>. We implement the nongeneric GetEnumerator method\n  // explicitly to avoid a naming conflict.\n\n  public IEnumerator<int> GetEnumerator() => new Enumerator(this);\n  IEnumerator IEnumerable.GetEnumerator() => new Enumerator(this);\n\n  class Enumerator : IEnumerator<int>\n  {\n    int currentIndex = -1;\n    MyIntList collection;\n\n    public Enumerator (MyIntList items) => collection = items;\n\n    public int Current => collection.data [currentIndex];\n    object IEnumerator.Current => Current;\n\n    public bool MoveNext() => ++currentIndex < collection.data.Length;\n\n    public void Reset() => currentIndex = -1;\n\n    // Given we don't need a Dispose method, it's good practice to\n    // implement it explicitly, so it's hidden from the public interface.\n    void IDisposable.Dispose() {}\n  }\n}\n```", "```cs\npublic interface ICollection<T> : IEnumerable<T>, IEnumerable\n{\n  int Count { get; }\n\n  bool Contains (T item);\n  void CopyTo (T[] array, int arrayIndex);\n  bool IsReadOnly { get; }\n\n  void Add(T item);\n  bool Remove (T item);\n  void Clear();\n}\n```", "```cs\npublic interface ICollection : IEnumerable\n{\n   int Count { get; }\n   bool IsSynchronized { get; }\n   object SyncRoot { get; }\n   void CopyTo (Array array, int index);\n}\n```", "```cs\npublic interface IList<T> : ICollection<T>, IEnumerable<T>, IEnumerable\n{\n  T this [int index] { get; set; }\n  int IndexOf (T item);\n  void Insert (int index, T item);\n  void RemoveAt (int index);\n}\n```", "```cs\npublic interface IList : ICollection, IEnumerable\n{\n  object this [int index] { get; set }\n  bool IsFixedSize { get; }\n  bool IsReadOnly  { get; }\n  int  Add      (object value);\n  void Clear();\n  bool Contains (object value);\n  int  IndexOf  (object value);\n  void Insert   (int index, object value);\n  void Remove   (object value);\n  void RemoveAt (int index);\n}\n```", "```cs\npublic object FirstOrNull (IList list)\n{\n  if (list == null || list.Count == 0) return null;\n  return list[0];\n}\n```", "```cs\nlist.GetType().IsArray && list.GetType().GetArrayRank()>1\n```", "```cs\npublic interface IReadOnlyCollection<out T> : IEnumerable<T>, IEnumerable\n{\n  int Count { get; }\n}\n\npublic interface IReadOnlyList<out T> : IReadOnlyCollection<T>,\n                                        IEnumerable<T>, IEnumerable\n{\n  T this[int index] { get; }\n}\n```", "```cs\nStringBuilder[] builders = new StringBuilder [5];\nbuilders [0] = new StringBuilder (\"builder1\");\nbuilders [1] = new StringBuilder (\"builder2\");\nbuilders [2] = new StringBuilder (\"builder3\");\n\nlong[] numbers = new long [3];\nnumbers [0] = 12345;\nnumbers [1] = 54321;\n```", "```cs\nobject[] a1 = { \"string\", 123, true };\nobject[] a2 = { \"string\", 123, true };\n\nConsole.WriteLine (a1 == a2);                          // False\nConsole.WriteLine (a1.Equals (a2));                    // False\n\nIStructuralEquatable se1 = a1;\nConsole.WriteLine (se1.Equals (a2,\n StructuralComparisons.StructuralEqualityComparer));   // True\n```", "```cs\nStringBuilder[] builders2 = builders;\nStringBuilder[] shallowClone = (StringBuilder[]) builders.Clone();\n```", "```cs\nint[] myArray = { 1, 2, 3 };\nint first = myArray [0];\nint last = myArray [myArray.Length - 1];\n```", "```cs\n // Create a string array 2 elements in length:\n Array a = Array.CreateInstance (typeof(string), 2);\n a.SetValue (\"hi\", 0);                             //  → a[0] = \"hi\";\n a.SetValue (\"there\", 1);                          //  → a[1] = \"there\";\n string s = (string) a.GetValue (0);               //  → s = a[0];\n\n // We can also cast to a C# array as follows:\n string[] cSharpArray = (string[]) a;\n string s2 = cSharpArray [0];\n```", "```cs\npublic object GetValue (params int[] indices)\npublic void   SetValue (object value, params int[] indices)\n```", "```cs\n void WriteFirstValue (Array a)\n {\n   Console.Write (a.Rank + \"-dimensional; \");\n\n   // The indexers array will automatically initialize to all zeros, so\n   // passing it into GetValue or SetValue will get/set the zero-based\n   // (i.e., first) element in the array.\n\n   int[] indexers = new int[a.Rank];\n   Console.WriteLine (\"First value is \" +  a.GetValue (indexers));\n }\n\n void Demo()\n {\n   int[]  oneD = { 1, 2, 3 };\n   int[,] twoD = { {5,6}, {8,9} };\n\n   WriteFirstValue (oneD);   // 1-dimensional; first value is 1\n   WriteFirstValue (twoD);   // 2-dimensional; first value is 5\n }\n```", "```cs\nvoid WriteFirstValue<T> (T[] array)\n{\n  Console.WriteLine (array[0]);\n}\n```", "```cs\npublic static void Clear (Array array, int index, int length);\n```", "```cs\nint[] myArray = { 1, 2, 3};\nforeach (int val in myArray)\n  Console.WriteLine (val);\n```", "```cs\npublic static void ForEach<T> (T[] array, Action<T> action);\n```", "```cs\npublic delegate void Action<T> (T obj);\n```", "```cs\nArray.ForEach (new[] { 1, 2, 3 }, Console.WriteLine);\n```", "```cs\nArray.ForEach ([ 1, 2, 3 ], Console.WriteLine);\n```", "```cs\npublic int  GetLength      (int dimension);\npublic long GetLongLength  (int dimension);\n\npublic int  Length       { get; }\npublic long LongLength   { get; }\n\npublic int GetLowerBound (int dimension);\npublic int GetUpperBound (int dimension);\n\npublic int Rank { get; }    // Returns number of dimensions in array\n```", "```cs\npublic delegate bool Predicate<T> (T object);\n```", "```cs\nstring[] names = { \"Rodney\", \"Jack\", \"Jill\" };\nstring match = Array.Find (names, ContainsA);\nConsole.WriteLine (match);     // Jack\n\nContainsA (string name) { return name.Contains (\"a\"); }\n```", "```cs\nstring[] names = { \"Rodney\", \"Jack\", \"Jill\" };\nstring match = Array.Find (names, n => n.Contains (\"a\"));     // Jack\n```", "```cs\n// For sorting a single array:\n\npublic static void Sort<T> (T[] array);\npublic static void Sort    (Array array);\n\n// For sorting a pair of arrays:\n\npublic static void Sort<TKey,TValue> (TKey[] keys, TValue[] items);\npublic static void Sort              (Array keys, Array items);\n```", "```cs\nint index                 // Starting index at which to begin sorting\nint length                // Number of elements to sort\nIComparer<T> comparer     // Object making ordering decisions\nComparison<T> comparison  // Delegate making ordering decisions\n```", "```cs\nint[] numbers = { 3, 2, 1 };\nArray.Sort (numbers);                     // Array is now { 1, 2, 3 }\n```", "```cs\nint[] numbers = { 3, 2, 1 };\nstring[] words = { \"three\", \"two\", \"one\" };\nArray.Sort (numbers, words);\n\n// numbers array is now { 1, 2, 3 }\n// words   array is now { \"one\", \"two\", \"three\" }\n```", "```cs\npublic delegate int Comparison<T> (T x, T y);\n```", "```cs\nint[] numbers = { 1, 2, 3, 4, 5 };\nArray.Sort (numbers, (x, y) => x % 2 == y % 2 ? 0 : x % 2 == 1 ? -1 : 1);\n\n// numbers array is now { 1, 3, 5, 2, 4 }\n```", "```cs\npublic static void Reverse (Array array);\npublic static void Reverse (Array array, int index, int length);\n```", "```cs\npublic delegate TOutput Converter<TInput,TOutput> (TInput input)\n```", "```cs\nfloat[] reals = { 1.3f, 1.5f, 1.8f };\nint[] wholes = Array.ConvertAll (reals, r => Convert.ToInt32 (r));\n\n// wholes array is { 1, 2, 2 }\n```", "```cs\npublic class List<T> : IList<T>, IReadOnlyList<T>\n{\n  public List ();\n  public List (IEnumerable<T> collection);\n  public List (int capacity);\n\n  // Add+Insert\n  public void Add         (T item);\n  public void AddRange    (IEnumerable<T> collection);\n  public void Insert      (int index, T item);\n  public void InsertRange (int index, IEnumerable<T> collection);\n\n  // Remove\n  public bool Remove      (T item);\n  public void RemoveAt    (int index);\n  public void RemoveRange (int index, int count);\n  public int  RemoveAll   (Predicate<T> match);\n\n  // Indexing\n  public T this [int index] { get; set; }\n  public List<T> GetRange (int index, int count);\n  public Enumerator<T> GetEnumerator();\n\n  // Exporting, copying and converting:\n  public T[] ToArray();\n  public void CopyTo (T[] array);\n  public void CopyTo (T[] array, int arrayIndex);\n  public void CopyTo (int index, T[] array, int arrayIndex, int count);\n  public ReadOnlyCollection<T> AsReadOnly();\n  public List<TOutput> ConvertAll<TOutput> (Converter <T,TOutput>\n                                            converter);\n  // Other:\n  public void Reverse();            // Reverses order of elements in list.\n  public int Capacity { get;set; }  // Forces expansion of internal array.\n  public void TrimExcess();         // Trims internal array back to size.\n  public void Clear();              // Removes all elements, so Count=0.\n}\n\npublic delegate TOutput Converter <TInput, TOutput> (TInput input);\n```", "```cs\nvar words = new List<string>();    // New string-typed list\n\nwords.Add (\"melon\");\nwords.Add (\"avocado\");\nwords.AddRange ([\"banana\", \"plum\"]);\nwords.Insert (0, \"lemon\");                   // Insert at start\nwords.InsertRange (0, [\"peach\", \"nashi\"]);   // Insert at start\n\nwords.Remove (\"melon\");\nwords.RemoveAt (3);                         // Remove the 4th element\nwords.RemoveRange (0, 2);                   // Remove first 2 elements\n\n// Remove all strings starting in 'n':\nwords.RemoveAll (s => s.StartsWith (\"n\"));\n\nConsole.WriteLine (words [0]);                          // first word\nConsole.WriteLine (words [words.Count - 1]);            // last word\nforeach (string s in words) Console.WriteLine (s);      // all words\nList<string> subset = words.GetRange (1, 2);            // 2nd->3rd words\n\nstring[] wordsArray = words.ToArray();    // Creates a new typed array\n\n// Copy first two elements to the end of an existing array:\nstring[] existing = new string [1000];\nwords.CopyTo (0, existing, 998, 2);\n\nList<string> upperCaseWords = words.ConvertAll (s => s.ToUpper());\nList<int> lengths = words.ConvertAll (s => s.Length);\n```", "```cs\nArrayList al = new ArrayList();\nal.Add (\"hello\");\nstring first = (string) al [0];\nstring[] strArr = (string[]) al.ToArray (typeof (string));\n```", "```cs\nint first = (int) al [0];    // Runtime exception\n```", "```cs\nArrayList al = new ArrayList();\nal.AddRange (new[] { 1, 5, 9 } );\nList<int> list = al.Cast<int>().ToList();\n```", "```cs\npublic sealed class LinkedListNode<T>\n{\n  public LinkedList<T> List { get; }\n  public LinkedListNode<T> Next { get; }\n  public LinkedListNode<T> Previous { get; }\n  public T Value { get; set; }\n}\n```", "```cs\npublic void AddFirst(LinkedListNode<T> node);\npublic LinkedListNode<T> AddFirst (T value);\n\npublic void AddLast (LinkedListNode<T> node);\npublic LinkedListNode<T> AddLast (T value);\n\npublic void AddAfter (LinkedListNode<T> node, LinkedListNode<T> newNode);\npublic LinkedListNode<T> AddAfter (LinkedListNode<T> node, T value);\n\npublic void AddBefore (LinkedListNode<T> node, LinkedListNode<T> newNode);\npublic LinkedListNode<T> AddBefore (LinkedListNode<T> node, T value);\n```", "```cs\npublic void Clear();\n\npublic void RemoveFirst();\npublic void RemoveLast();\n\npublic bool Remove (T value);\npublic void Remove (LinkedListNode<T> node);\n```", "```cs\npublic int Count { get; }                      // Fast\npublic LinkedListNode<T> First { get; }        // Fast\npublic LinkedListNode<T> Last { get; }         // Fast\n```", "```cs\npublic bool Contains (T value);\npublic LinkedListNode<T> Find (T value);\npublic LinkedListNode<T> FindLast (T value);\n```", "```cs\npublic void CopyTo (T[] array, int index);\npublic Enumerator<T> GetEnumerator();\n```", "```cs\nvar tune = new LinkedList<string>();\ntune.AddFirst (\"do\");                           // do\ntune.AddLast (\"so\");                            // do - so\n\ntune.AddAfter (tune.First, \"re\");               // do - re- so\ntune.AddAfter (tune.First.Next, \"mi\");          // do - re - mi- so\ntune.AddBefore (tune.Last, \"fa\");               // do - re - mi - fa- so\n\ntune.RemoveFirst();                             // re - mi - fa - so\ntune.RemoveLast();                              // re - mi - fa\n\nLinkedListNode<string> miNode = tune.Find (\"mi\");\ntune.Remove (miNode);                           // re - fa\ntune.AddFirst (miNode);                         // mi- re - fa\n\nforeach (string s in tune) Console.WriteLine (s);\n```", "```cs\npublic class Queue<T> : IEnumerable<T>, ICollection, IEnumerable\n{\n  public Queue();\n  public Queue (IEnumerable<T> collection);   // Copies existing elements\n  public Queue (int capacity);                // To lessen auto-resizing\n  public void Clear();\n  public bool Contains (T item);\n  public void CopyTo (T[] array, int arrayIndex);\n  public int Count { get; }\n  public T Dequeue();\n  public void Enqueue (T item);\n  public Enumerator<T> GetEnumerator();       // To support foreach\n  public T Peek();\n  public T[] ToArray();\n  public void TrimExcess();\n}\n```", "```cs\nvar q = new Queue<int>();\nq.Enqueue (10);\nq.Enqueue (20);\nint[] data = q.ToArray();         // Exports to an array\nConsole.WriteLine (q.Count);      // \"2\"\nConsole.WriteLine (q.Peek());     // \"10\"\nConsole.WriteLine (q.Dequeue());  // \"10\"\nConsole.WriteLine (q.Dequeue());  // \"20\"\nConsole.WriteLine (q.Dequeue());  // throws an exception (queue empty)\n```", "```cs\npublic class Stack<T> : IEnumerable<T>, ICollection, IEnumerable\n{\n  public Stack();\n  public Stack (IEnumerable<T> collection);   // Copies existing elements\n  public Stack (int capacity);                // Lessens auto-resizing\n  public void Clear();\n  public bool Contains (T item);\n  public void CopyTo (T[] array, int arrayIndex);\n  public int Count { get; }\n  public Enumerator<T> GetEnumerator();       // To support foreach\n  public T Peek();\n  public T Pop();\n  public void Push (T item);\n  public T[] ToArray();\n  public void TrimExcess();\n}\n```", "```cs\nvar s = new Stack<int>();\ns.Push (1);                      //            Stack = 1\ns.Push (2);                      //            Stack = 1,2\ns.Push (3);                      //            Stack = 1,2,3\nConsole.WriteLine (s.Count);     // Prints 3\nConsole.WriteLine (s.Peek());    // Prints 3,  Stack = 1,2,3\nConsole.WriteLine (s.Pop());     // Prints 3,  Stack = 1,2\nConsole.WriteLine (s.Pop());     // Prints 2,  Stack = 1\nConsole.WriteLine (s.Pop());     // Prints 1,  Stack = <empty>\nConsole.WriteLine (s.Pop());     // throws exception\n```", "```cs\nvar bits = new BitArray(2);\nbits[1] = true;\n```", "```cs\nbits.Xor (bits);               // Bitwise exclusive-OR bits with itself\nConsole.WriteLine (bits[1]);   // False\n```", "```cs\nvar letters = new HashSet<char> (\"the quick brown fox\");\n\nConsole.WriteLine (letters.Contains ('t'));      // true\nConsole.WriteLine (letters.Contains ('j'));      // false\n\nforeach (char c in letters) Console.Write (c);   // the quickbrownfx\n```", "```cs\npublic void UnionWith           (IEnumerable<T> other);   // Adds\npublic void IntersectWith       (IEnumerable<T> other);   // Removes\npublic void ExceptWith          (IEnumerable<T> other);   // Removes\npublic void SymmetricExceptWith (IEnumerable<T> other);   // Removes\n```", "```cs\npublic bool IsSubsetOf         (IEnumerable<T> other);\npublic bool IsProperSubsetOf   (IEnumerable<T> other);\npublic bool IsSupersetOf       (IEnumerable<T> other);\npublic bool IsProperSupersetOf (IEnumerable<T> other);\npublic bool Overlaps           (IEnumerable<T> other);\npublic bool SetEquals          (IEnumerable<T> other);\n```", "```cs\nvar letters = new HashSet<char> (\"the quick brown fox\");\nletters.IntersectWith (\"aeiou\");\nforeach (char c in letters) Console.Write (c);     // euio\n```", "```cs\nvar letters = new HashSet<char> (\"the quick brown fox\");\nletters.ExceptWith (\"aeiou\");\nforeach (char c in letters) Console.Write (c);     // th qckbrwnfx\n```", "```cs\nvar letters = new HashSet<char> (\"the quick brown fox\");\nletters.SymmetricExceptWith (\"the lazy brown fox\");\nforeach (char c in letters) Console.Write (c);     // quicklazy\n```", "```cs\npublic virtual SortedSet<T> GetViewBetween (T lowerValue, T upperValue)\npublic IEnumerable<T> Reverse()\npublic T Min { get; }\npublic T Max { get; }\n```", "```cs\nvar letters = new SortedSet<char> (\"the quick brown fox\");\nforeach (char c in letters) Console.Write (c);   //  bcefhiknoqrtuwx\n```", "```cs\nforeach (char c in letters.GetViewBetween ('f', 'i'))\n  Console.Write (c);                                    //  fhi\n```", "```cs\npublic interface IDictionary <TKey, TValue> :\n  ICollection <KeyValuePair <TKey, TValue>>, IEnumerable\n{\n   bool ContainsKey (TKey key);\n   bool TryGetValue (TKey key, out TValue value);\n   void Add         (TKey key, TValue value);\n   bool Remove      (TKey key);\n\n   TValue this [TKey key]      { get; set; }  // Main indexer - by key\n   ICollection <TKey> Keys     { get; }       // Returns just keys\n   ICollection <TValue> Values { get; }       // Returns just values\n}\n```", "```cs\npublic struct KeyValuePair <TKey, TValue>\n{\n  public TKey Key     { get; }\n  public TValue Value { get; }\n}\n```", "```cs\npublic struct DictionaryEntry\n{\n  public object Key   { get; set; }\n  public object Value { get; set; }\n}\n```", "```cs\nvar d = new Dictionary<string, int>();\n\nd.Add(\"One\", 1);\nd[\"Two\"] = 2;     // adds to dictionary because \"two\" isn't already present\nd[\"Two\"] = 22;    // updates dictionary because \"two\" is now present\nd[\"Three\"] = 3;\n\nConsole.WriteLine (d[\"Two\"]);                // Prints \"22\"\nConsole.WriteLine (d.ContainsKey (\"One\"));   // true (fast operation)\nConsole.WriteLine (d.ContainsValue (3));     // true (slow operation)\nint val = 0;\nif (!d.TryGetValue (\"onE\", out val))\n  Console.WriteLine (\"No val\");              // \"No val\" (case sensitive)\n\n// Three different ways to enumerate the dictionary:\n\nforeach (KeyValuePair<string, int> kv in d)          //  One; 1\n  Console.WriteLine (kv.Key + \"; \" + kv.Value);      //  Two; 22\n                                                     //  Three; 3\n\nforeach (string s in d.Keys) Console.Write (s);      // OneTwoThree\nConsole.WriteLine();\nforeach (int i in d.Values) Console.Write (i);       // 1223\n```", "```cs\nvar d = new Dictionary<string, int> (StringComparer.OrdinalIgnoreCase);\n```", "```cs\n// MethodInfo is in the System.Reflection namespace\n\nvar sorted = new SortedList <string, MethodInfo>();\n\nforeach (MethodInfo m in typeof (object).GetMethods())\n  sorted [m.Name] = m;\n\nforeach (string name in sorted.Keys)\n  Console.WriteLine (name);\n\nforeach (MethodInfo m in sorted.Values)\n  Console.WriteLine (m.Name + \" returns a \" + m.ReturnType);\n```", "```cs\nEquals\nGetHashCode\nGetType\nReferenceEquals\nToString\n```", "```cs\nEquals returns a System.Boolean\nGetHashCode returns a System.Int32\nGetType returns a System.Type\nReferenceEquals returns a System.Boolean\nToString returns a System.String\n```", "```cs\nSortedList <string, List<MethodInfo>>\n```", "```cs\nConsole.WriteLine (sorted [\"GetHashCode\"]);      // Int32 GetHashCode()\n```", "```cs\nConsole.WriteLine (sorted.Keys  [sorted.Count - 1]);            // ToString\nConsole.WriteLine (sorted.Values[sorted.Count - 1].IsVirtual);  // True\n```", "```cs\npublic class Collection<T> :\n  IList<T>, ICollection<T>, IEnumerable<T>, IList, ICollection, IEnumerable\n{\n   // ...\n\n   protected virtual void ClearItems();\n   protected virtual void InsertItem (int index, T item);\n   protected virtual void RemoveItem (int index);\n   protected virtual void SetItem (int index, T item);\n\n   protected IList<T> Items { get; }\n}\n```", "```cs\nZoo zoo = new Zoo();\nzoo.Animals.Add (new Animal (\"Kangaroo\", 10));\nzoo.Animals.Add (new Animal (\"Mr Sea Lion\", 20));\nforeach (Animal a in zoo.Animals) Console.WriteLine (a.Name);\n\npublic class Animal\n{\n  public string Name;\n  public int Popularity;\n\n  public Animal (string name, int popularity)\n  {\n    Name = name; Popularity = popularity;\n  }\n}\n\npublic class AnimalCollection : Collection <Animal>\n{\n  // AnimalCollection is already a fully functioning list of animals.\n  // No extra code is required.\n}\n\npublic class Zoo   // The class that will expose AnimalCollection.\n{                  // This would typically have additional members.\n\n  public readonly AnimalCollection Animals = new AnimalCollection();\n}\n```", "```cs\npublic class Animal\n{\n  public string Name;\n  public int Popularity;\n  public Zoo Zoo { get; internal set; }\n  public Animal(string name, int popularity)\n  {\n    Name = name; Popularity = popularity;\n  }\n}\n\npublic class AnimalCollection : Collection <Animal>\n{\n  Zoo zoo;\n  public AnimalCollection (Zoo zoo) { this.zoo = zoo; }\n\n  protected override void InsertItem (int index, Animal item)\n  {\n    base.InsertItem (index, item);\n    item.Zoo = zoo;\n  }\n  protected override void SetItem (int index, Animal item)\n  {\n    base.SetItem (index, item);\n    item.Zoo = zoo;\n  }\n  protected override void RemoveItem (int index)\n  {\n    this [index].Zoo = null;\n    base.RemoveItem (index);\n  }\n  protected override void ClearItems()\n  {\n    foreach (Animal a in this) a.Zoo = null;\n    base.ClearItems();\n  }\n}\n\npublic class Zoo\n{\n  public readonly AnimalCollection Animals;\n  public Zoo() { Animals = new AnimalCollection (this); }\n}\n```", "```cs\npublic abstract class KeyedCollection <TKey, TItem> : Collection <TItem>\n\n  // ...\n\n  protected abstract TKey GetKeyForItem(TItem item);\n  protected void ChangeItemKey(TItem item, TKey newKey);\n\n  // Fast lookup by key - this is in addition to lookup by index.\n  public TItem this[TKey key] { get; }\n\n  protected IDictionary<TKey, TItem> Dictionary { get; }\n}\n```", "```cs\npublic class Animal\n{\n  string name;\n  public string Name\n  {\n    get { return name; }\n    set {\n      if (Zoo != null) Zoo.Animals.NotifyNameChange (this, value);\n      name = value;\n    }\n  }\n  public int Popularity;\n  public Zoo Zoo { get; internal set; }\n\n  public Animal (string name, int popularity)\n  {\n    Name = name; Popularity = popularity;\n  }\n}\n\npublic class AnimalCollection : KeyedCollection <string, Animal>\n{\n  Zoo zoo;\n  public AnimalCollection (Zoo zoo) { this.zoo = zoo; }\n\n  internal void NotifyNameChange (Animal a, string newName) =>\n    this.ChangeItemKey (a, newName);\n\n  protected override string GetKeyForItem (Animal item) => item.Name;\n\n  // The following methods would be implemented as in the previous example\n  protected override void InsertItem (int index, Animal item)...\n  protected override void SetItem (int index, Animal item)...\n  protected override void RemoveItem (int index)...\n  protected override void ClearItems()...\n}\n\npublic class Zoo\n{\n  public readonly AnimalCollection Animals;\n  public Zoo() { Animals = new AnimalCollection (this); }\n}\n```", "```cs\nZoo zoo = new Zoo();\nzoo.Animals.Add (new Animal (\"Kangaroo\", 10));\nzoo.Animals.Add (new Animal (\"Mr Sea Lion\", 20));\nConsole.WriteLine (zoo.Animals [0].Popularity);               // 10\nConsole.WriteLine (zoo.Animals [\"Mr Sea Lion\"].Popularity);   // 20\nzoo.Animals [\"Kangaroo\"].Name = \"Mr Roo\";\nConsole.WriteLine (zoo.Animals [\"Mr Roo\"].Popularity);        // 10\n```", "```cs\npublic class Test\n{\n  List<string> names = new List<string>();\n  public IReadOnlyList<string> Names => names;\n}\n```", "```cs\npublic class Test\n{\n  List<string> names = new List<string>();\n  public ReadOnlyCollection<string> Names { get; private set; }\n\n  public Test() => Names = new ReadOnlyCollection<string> (names);\n\n  public void AddInternally() => names.Add (\"test\");\n}\n```", "```cs\nTest t = new Test();\n\nConsole.WriteLine (t.Names.Count);       // 0\nt.AddInternally();\nConsole.WriteLine (t.Names.Count);       // 1\n\nt.Names.Add (\"test\");                    // Compiler error\n((IList<string>) t.Names).Add (\"test\");  // NotSupportedException\n```", "```cs\nImmutableArray<int> array = ImmutableArray.Create<int> (1, 2, 3);\n```", "```cs\nvar list = new[] { 1, 2, 3 }.ToImmutableList();\n```", "```cs\nvar oldList = ImmutableList.Create<int> (1, 2, 3);\n\nImmutableList<int> newList = oldList.Add (4);\n\nConsole.WriteLine (oldList.Count);     // 3  (unaltered)\nConsole.WriteLine (newList.Count);     // 4\n```", "```cs\nvar anotherList = oldList.AddRange ([4, 5, 6]);\n```", "```cs\nImmutableArray<int>.Builder builder = ImmutableArray.CreateBuilder<int>();\nbuilder.Add (1);\nbuilder.Add (2);\nbuilder.Add (3);\nbuilder.RemoveAt (0);\nImmutableArray<int> myImmutable = builder.ToImmutable();\n```", "```cs\nvar builder2 = myImmutable.ToBuilder();\nbuilder2.Add (4);      // Efficient\nbuilder2.Remove (2);   // Efficient\n...                    // More changes to builder...\n// Return a new immutable collection with all the changes applied:\nImmutableArray<int> myImmutable2 = builder2.ToImmutable();\n```", "```cs\nFrozenDictionary<TKey,TValue>\nFrozenSet<T>\n```", "```cs\nint[] numbers = { 10, 20, 30 };\nFrozenSet<int> frozen = numbers.ToFrozenSet();\nConsole.WriteLine (frozen.Contains (10));   // True\n```", "```cs\nclass Disassembler\n{\n  public readonly static IReadOnlyDictionary<string,string> OpCodeLookup =\n    new Dictionary<string, string>()\n    {\n      { \"ADC\", \"Add with Carry\" },\n      { \"ADD\", \"Add\" },\n      { \"AND\", \"Logical AND\" },\n      { \"ANDN\", \"Logical AND NOT\" },\n      ...\n    }\n    .ToFrozenDictionary();\n\n  ...\n}\n```", "```cs\npublic interface IEqualityComparer<T>\n{\n   bool Equals (T x, T y);\n   int GetHashCode (T obj);\n}\n\npublic interface IEqualityComparer     // Nongeneric version\n{\n   bool Equals (object x, object y);\n   int GetHashCode (object obj);\n}\n```", "```cs\npublic abstract class EqualityComparer<T> : IEqualityComparer,\n                                            IEqualityComparer<T>\n{\n  public abstract bool Equals (T x, T y);\n  public abstract int GetHashCode (T obj);\n\n  bool IEqualityComparer.Equals (object x, object y);\n  int IEqualityComparer.GetHashCode (object obj);\n\n  public static EqualityComparer<T> Default { get; }\n}\n```", "```cs\npublic class Customer\n{\n  public string LastName;\n  public string FirstName;\n\n  public Customer (string last, string first)\n  {\n    LastName = last;\n    FirstName = first;\n  }\n}\npublic class LastFirstEqComparer : EqualityComparer <Customer>\n{\n  public override bool Equals (Customer x, Customer y)\n    => x.LastName == y.LastName && x.FirstName == y.FirstName;\n\n  public override int GetHashCode (Customer obj)\n    => (obj.LastName + \";\" + obj.FirstName).GetHashCode();\n}\n```", "```cs\nCustomer c1 = new Customer (\"Bloggs\", \"Joe\");\nCustomer c2 = new Customer (\"Bloggs\", \"Joe\");\n```", "```cs\nConsole.WriteLine (c1 == c2);               // False\nConsole.WriteLine (c1.Equals (c2));         // False\n```", "```cs\nvar d = new Dictionary<Customer, string>();\nd [c1] = \"Joe\";\nConsole.WriteLine (d.ContainsKey (c2));         // False\n```", "```cs\nvar eqComparer = new LastFirstEqComparer();\nvar d = new Dictionary<Customer, string> (eqComparer);\nd [c1] = \"Joe\";\nConsole.WriteLine (d.ContainsKey (c2));         // True\n```", "```cs\nstatic bool Foo<T> (T x, T y)\n{\n  bool same = EqualityComparer<T>.Default.Equals (x, y);\n  ...\n```", "```cs\npublic interface IComparer\n{\n  int Compare(object x, object y);\n}\npublic interface IComparer <in T>\n{\n  int Compare(T x, T y);\n}\n```", "```cs\npublic abstract class Comparer<T> : IComparer, IComparer<T>\n{\n   public static Comparer<T> Default { get; }\n\n   public abstract int Compare (T x, T y);       // Implemented *by* you\n   int IComparer.Compare (object x, object y);   // Implemented *for* you\n}\n```", "```cs\nclass Wish\n{\n  public string Name;\n  public int Priority;\n\n  public Wish (string name, int priority)\n  {\n    Name = name;\n    Priority = priority;\n  }\n}\n\nclass PriorityComparer : Comparer<Wish>\n{\n  public override int Compare (Wish x, Wish y)\n  {\n    if (object.Equals (x, y)) return 0;    // Optimization\n    if (x == null) return -1;\n    if (y == null) return 1;\n    return x.Priority.CompareTo (y.Priority);\n  }\n}\n```", "```cs\nvar wishList = new List<Wish>();\nwishList.Add (new Wish (\"Peace\", 2));\nwishList.Add (new Wish (\"Wealth\", 3));\nwishList.Add (new Wish (\"Love\", 2));\nwishList.Add (new Wish (\"3 more wishes\", 1));\n\nwishList.Sort (new PriorityComparer());\nforeach (Wish w in wishList) Console.Write (w.Name + \" | \");\n\n// OUTPUT: 3 more wishes | Love | Peace | Wealth |\n```", "```cs\nclass SurnameComparer : Comparer <string>\n{\n  string Normalize (string s)\n  {\n    s = s.Trim().ToUpper();\n    if (s.StartsWith (\"MC\")) s = \"MAC\" + s.Substring (2);\n    return s;\n  }\n\n  public override int Compare (string x, string y)\n    => Normalize (x).CompareTo (Normalize (y));\n}\n```", "```cs\nvar dic = new SortedDictionary<string,string> (new SurnameComparer());\ndic.Add (\"MacPhail\", \"second!\");\ndic.Add (\"MacWilliam\", \"third!\");\ndic.Add (\"McDonald\", \"first!\");\n\nforeach (string s in dic.Values)\n  Console.Write (s + \" \");              // first! second! third!\n```", "```cs\npublic static StringComparer CurrentCulture { get; }\npublic static StringComparer CurrentCultureIgnoreCase { get; }\npublic static StringComparer InvariantCulture { get; }\npublic static StringComparer InvariantCultureIgnoreCase { get; }\npublic static StringComparer Ordinal { get; }\npublic static StringComparer OrdinalIgnoreCase { get; }\npublic static StringComparer Create (CultureInfo culture,\n                                       bool ignoreCase);\n```", "```cs\nvar dict = new Dictionary<string, int> (StringComparer.OrdinalIgnoreCase);\n```", "```cs\nstring[] names = { \"Tom\", \"HARRY\", \"sheila\" };\nCultureInfo ci = new CultureInfo (\"en-AU\");\nArray.Sort<string> (names, StringComparer.Create (ci, false));\n```", "```cs\nclass SurnameComparer : Comparer<string>\n{\n  StringComparer strCmp;\n\n  public SurnameComparer (CultureInfo ci)\n  {\n    // Create a case-sensitive, culture-sensitive string comparer\n    strCmp = StringComparer.Create (ci, false);\n  }\n\n  string Normalize (string s)\n  {\n    s = s.Trim();\n    if (s.ToUpper().StartsWith (\"MC\")) s = \"MAC\" + s.Substring (2);\n    return s;\n  }\n\n  public override int Compare (string x, string y)\n  {\n    // Directly call Compare on our culture-aware StringComparer\n    return strCmp.Compare (Normalize (x), Normalize (y));\n  }\n}\n```", "```cs\npublic interface IStructuralEquatable\n{\n  bool Equals (object other, IEqualityComparer comparer);\n  int GetHashCode (IEqualityComparer comparer);\n}\n\npublic interface IStructuralComparable\n{\n  int CompareTo (object other, IComparer comparer);\n}\n```", "```cs\nint[] a1 = { 1, 2, 3 };\nint[] a2 = { 1, 2, 3 };\nIStructuralEquatable se1 = a1;\nConsole.Write (a1.Equals (a2));                                  // False\nConsole.Write (se1.Equals (a2, EqualityComparer<int>.Default));  // True\n```", "```cs\nstring[] a1 = \"the quick brown fox\".Split();\nstring[] a2 = \"THE QUICK BROWN FOX\".Split();\nIStructuralEquatable se1 = a1;\nbool isTrue = se1.Equals (a2, StringComparer.InvariantCultureIgnoreCase);\n```"]