["```cs\nint[] numbers = new int[10];\nstring[] strings = new string[numbers.Length];\n```", "```cs\n// Continued from Example 5-1\nnumbers[0] = 42;\nnumbers[1] = numbers.Length;\nnumbers[2] = numbers[0] + numbers[1];\nnumbers[numbers.Length - 1] = 99;\n```", "```cs\npublic static string GetCopyrightForType(object o)\n{\n    Assembly asm = o.GetType().Assembly;\n    var copyrightAttribute = (AssemblyCopyrightAttribute)\n        `asm``.``GetCustomAttributes``(``typeof``(``AssemblyCopyrightAttribute``)``,` `true``)``[``0``]``;`\n    return copyrightAttribute.Copyright;\n}\n```", "```cs\nvar values = new Complex[10];\n// These lines both cause compiler errors:\nvalues[0].Real = 10;\nvalues[0].Imaginary = 1;\n```", "```cs\nvar values = new Complex[10];\nvalues[0] = new Complex(10, 1);\n```", "```cs\nvar workingWeekDayNames = new string[5];\nworkingWeekDayNames[0] = \"Monday\";\nworkingWeekDayNames[1] = \"Tuesday\";\nworkingWeekDayNames[2] = \"Wednesday\";\nworkingWeekDayNames[3] = \"Thursday\";\nworkingWeekDayNames[4] = \"Friday\";\n```", "```cs\nvar workingWeekDayNames = new string[]\n    { \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\" };\n```", "```cs\nstring[] workingWeekDayNames =\n    { \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\" };\n```", "```cs\nvar workingWeekDayNames = new[]\n    { \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\" };\n```", "```cs\nSetHeaders(new[] { \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\" });\n```", "```cs\nint recentFileListIndex = Array.IndexOf(myRecentFiles, openedFile);\nif (recentFileListIndex < 0)\n{\n    AddNewRecentEntry(openedFile);\n}\nelse\n{\n    MoveExistingRecentEntryToTop(recentFileListIndex);\n}\n```", "```cs\npublic static int GetIndexOfFirstNonEmptyBin(int[] bins)\n    => Array.FindIndex(bins, IsNonZero);\n\nprivate static bool IsNonZero(int value) => value != 0;\n```", "```cs\npublic static int GetIndexOfFirstNonEmptyBin(int[] bins)\n    => Array.FindIndex(bins, value => value != 0);\n```", "```cs\npublic static T[] GetNonNullItems<T>(T[] items) where T : class\n    => Array.FindAll(items, value => value != null);\n```", "```cs\nvoid Sort(int[] numbers)\n{\n    Array.Sort(numbers);\n}\n\nint Find(int[] numbers, int searchFor)\n{\n    return Array.BinarySearch(numbers, searchFor);\n}\n```", "```cs\nint[][] arrays = new int[5][]\n{\n    new[] { 1, 2 },\n    new[] { 1, 2, 3, 4, 5, 6 },\n    new[] { 1, 2, 4 },\n    new[] { 1 },\n    new[] { 1, 2, 3, 4, 5 }\n};\n```", "```cs\nint[,] grid = new int[5, 10];\nvar smallerGrid = new int[,]\n{\n    { 1, 2, 3, 4 },\n    { 2, 3, 4, 5 },\n    { 3, 4, 5, 6 }\n};\n```", "```cs\nvar cuboid = new int[,,]\n{\n    {\n        { 1, 2, 3, 4, 5 },\n        { 2, 3, 4, 5, 6 },\n        { 3, 4, 5, 6, 7 }\n    },\n    {\n        { 2, 3, 4, 5, 6 },\n        { 3, 4, 5, 6, 7 },\n        { 4, 5, 6, 7, 8 }\n    }\n};\n```", "```cs\nvar numbers = new List<int>();\nnumbers.Add(123);\nnumbers.Add(99);\nnumbers.Add(42);\nConsole.WriteLine(numbers.Count);\nConsole.WriteLine($\"{numbers[0]}, {numbers[1]}, {numbers[2]}\");\n\nnumbers[1] += 1;\nConsole.WriteLine(numbers[1]);\n\nnumbers.RemoveAt(1);\nConsole.WriteLine(numbers.Count);\nConsole.WriteLine($\"{numbers[0]}, {numbers[1]}\");\n```", "```cs\nvar numbers = new List<int> { 123, 99, 42 };\n```", "```cs\nList<int> numbers = new() { 123, 99, 42 };\n```", "```cs\npublic interface IEnumerable<out T> : IEnumerable\n{\n    IEnumerator<T> GetEnumerator();\n}\n\npublic interface IEnumerable\n{\n    IEnumerator GetEnumerator();\n}\n```", "```cs\npublic interface IEnumerator<out T> : IDisposable, IEnumerator\n{\n    T Current { get; }\n}\n\npublic interface IEnumerator\n{\n    bool MoveNext();\n    object Current { get; }\n    void Reset();\n}\n```", "```cs\npublic interface IAsyncEnumerable<out T>\n{\n    IAsyncEnumerator<T> GetAsyncEnumerator(\n        CancellationToken cancellationToken = default);\n}\n\npublic interface IAsyncEnumerator<out T> : IAsyncDisposable\n{\n    T Current { get; }\n\n    ValueTask<bool> MoveNextAsync();\n}\n```", "```cs\npublic interface ICollection<T> : IEnumerable<T>, IEnumerable\n{\n    void Add(T item);\n    void Clear();\n    bool Contains(T item);\n    void CopyTo(T[] array, int arrayIndex);\n    bool Remove(T item);\n\n    int Count { get; }\n    bool IsReadOnly { get; }\n}\n```", "```cs\npublic interface IList<T> : ICollection<T>, IEnumerable<T>, IEnumerable\n{\n    int IndexOf(T item);\n    void Insert(int index, T item);\n    void RemoveAt(int index);\n\n    T this[int index] { get; set; }\n}\n```", "```cs\nIList<int> array = new[] { 1, 2, 3 };\narray.Add(4);  // Will throw an exception\n```", "```cs\npublic static IEnumerable<int> Countdown(int start, int end)\n{\n    for (int i = start; i >= end; --i)\n    {\n        yield return i;\n    }\n}\n\nprivate static void Main(string[] args)\n{\n    foreach (int i in Countdown(5, 1))\n    {\n        Console.WriteLine(i);\n    }\n}\n```", "```cs\npublic static IEnumerable<int> ThreeNumbers()\n{\n    yield return 1;\n    yield return 2;\n    yield return 3;\n}\n```", "```cs\npublic static IEnumerable<BigInteger> Fibonacci()\n{\n    BigInteger v1 = 1;\n    BigInteger v2 = 1;\n\n    while (true)\n    {\n        yield return v1;\n        var tmp = v2;\n        v2 = v1 + v2;\n        v1 = tmp;\n    }\n}\n```", "```cs\npublic class FibonacciEnumerable :\n    IEnumerable<BigInteger>, IEnumerator<BigInteger>\n{\n    private BigInteger v1;\n    private BigInteger v2;\n    private bool first = true;\n\n    public BigInteger Current => v1;\n\n    public void Dispose() { }\n\n    object IEnumerator.Current => Current;\n\n    public bool MoveNext()\n    {\n        if (first)\n        {\n            v1 = 1;\n            v2 = 1;\n            first = false;\n        }\n        else\n        {\n            var tmp = v2;\n            v2 = v1 + v2;\n            v1 = tmp;\n        }\n\n        return true;\n    }\n\n    public void Reset()\n    {\n        first = true;\n    }\n\n    public IEnumerator<BigInteger> GetEnumerator() =>\n        new FibonacciEnumerable();\n\n    IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();\n}\n```", "```cs\npublic static IEnumerable<BigInteger> Fibonacci(int count)\n{\n    if (count < 0)\n    {\n        throw new ArgumentOutOfRangeException(nameof(count));\n    }\n    return Core(count);\n\n    static IEnumerable<BigInteger> Core(int count)\n    {\n        BigInteger v1 = 1;\n        BigInteger v2 = 1;\n\n        for (int i = 0; i < count; ++i)\n        {\n            yield return v1;\n            var tmp = v2;\n            v2 = v1 + v2;\n            v1 = tmp;\n        }\n    }\n}\n```", "```cs\nchar[] letters = { 'a', 'b', 'c', 'd' };\nchar lastLetter = letters[^1];\n```", "```cs\nint[] numbers = { 1, 2, 3, 4, 5, 6, 7 };\n// Gets 4th and 5th (but not the 3rd or 6th, for reasons explained shortly) int[] theFourthTheFifth = `numbers``[``3..5``]``;`\n```", "```cs\nIndex first = 0;\nIndex second = 1;\nIndex third = 2;\nvar fourth = new Index(3, fromEnd: false);\n\nIndex antePenultimate = ^3;\nIndex penultimate = ^2;\nIndex last = ^1;\nIndex directlyAfterTheLast = ^0;\n```", "```cs\nint lastOld = numbers[numbers.Length - 1];\nint lastNew = numbers[^1];\n\nint penultimateOld = numbers[numbers.Length - 2];\nint penultimateNew = numbers[^2];\n```", "```cs\nRange everything = 0..^0;\nRange alsoEverything = 0..;\nRange everythingAgain = ..^0;\nRange everythingOneMoreTime = ..;\nvar yetAnotherWayToSayEverything = Range.All;\n\nRange firstThreeItems = 0..3;\nRange alsoFirstThreeItems = ..3;\n\nRange allButTheFirstThree = 3..^0;\nRange alsoAllButTheFirstThree = 3..;\n\nRange allButTheLastThree = 0..^3;\nRange alsoAllButTheLastThree = ..^3;\n\nRange lastThreeItems = ^3..^0;\nRange alsoLastThreeItems = ^3..;\n```", "```cs\nstring t1 = \"dysfunctional\";\nstring t2 = t1[3..6];\nConsole.WriteLine($\"Putting the {t2} in {t1}\");\n```", "```cs\nint[] numbers = { 1, 2, 3, 4, 5, 6, 7 };\nArraySegment<int> wholeArrayAsSegment = numbers;\nArraySegment<int> theFourthTheFifth = wholeArrayAsSegment[3..5];\n```", "```cs\nint[] numbers = { 1, 2, 3, 4, 5, 6, 7 };\nSpan<int> wholeArrayAsSpan = numbers;\nSpan<int> theFourthTheFifth = wholeArrayAsSpan[3..5];\nReadOnlySpan<char> textSpan = \"dysfunctional\".AsSpan();\nReadOnlySpan<char> such = textSpan[3..6];\n```", "```cs\npublic class Indexable\n{\n    public char this[int index] => (char)('0' + index);\n\n    public int Length => 10;\n}\n```", "```cs\npublic class Rangeable\n{\n    public int Length => 10;\n\n    public Rangeable Slice(int offset, int length) => this;\n}\n```", "```cs\nRangeable r1 = new();\nRange r = 2..^2;\n\nRangeable r2;\n\nr2 = r1[r];\n// is equivalent to\nint startIndex = r.Start.GetOffset(r1.Length);\nint endIndex = r.End.GetOffset(r1.Length);\nr2 = r1.Slice(startIndex, endIndex - startIndex);\n```", "```cs\npublic class UserCache\n{\n    private readonly Dictionary<string, UserInfo> _cachedUserInfo = new();\n\n    public UserInfo GetInfo(string userHandle)\n    {\n        RemoveStaleCacheEntries();\n        if (!_cachedUserInfo.TryGetValue(userHandle, out UserInfo? info))\n        {\n            info = FetchUserInfo(userHandle);\n            _cachedUserInfo.Add(userHandle, info);\n        }\n        return info;\n    }\n\n    private UserInfo FetchUserInfo(string userHandle)\n    {\n        // fetch info...\n    }\n\n    private void RemoveStaleCacheEntries()\n    {\n        // application-specific logic deciding when to remove old entries...\n    }\n}\n\npublic class UserInfo\n{\n    // application-specific user information...\n}\n```", "```cs\nUserInfo info = _cachedUserInfo[userHandle];\n```", "```cs\nvar textToNumber = new Dictionary<string, int>\n{\n    { \"One\", 1 },\n    { \"Two\", 2 },\n    { \"Three\", 3 },\n};\n```", "```cs\nvar textToNumber = new Dictionary<string, int>\n{\n [\"One\"] = 1,\n [\"Two\"] = 2,\n [\"Three\"] = 3\n};\n```", "```cs\nvar textToNumber =\n    new Dictionary<string, int>(StringComparer.InvariantCultureIgnoreCase)\n{\n    { \"One\", 1 },\n    { \"Two\", 2 },\n    { \"Three\", 3 },\n};\n```", "```cs\npublic static void ShowEachDistinctString(IEnumerable<string> strings)\n{\n    var shown = new HashSet<string>();  // Implements ISet<T>\n    foreach (string s in strings)\n    {\n        if (shown.Add(s))\n        {\n            Console.WriteLine(s);\n        }\n    }\n}\n```", "```cs\nIImmutableDictionary<int, string> d = ImmutableDictionary.Create<int, string>();\nd = d.Add(1, \"One\");\nd = d.Add(2, \"Two\");\nd = d.Add(3, \"Three\");\n```", "```cs\nImmutableDictionary<int, string>.Builder b =\n    ImmutableDictionary.CreateBuilder<int, string>();\nb.Add(1, \"One\");\nb.Add(2, \"Two\");\nb.Add(3, \"Three\");\nIImmutableDictionary<int, string> d = b.ToImmutable();\n```"]