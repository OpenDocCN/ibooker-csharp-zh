- en: 'Chapter 6\. Inheritance: *Your Object’s Family Tree*'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章。继承：*你的对象家族树*
- en: '![Images](assets/272fig01a.png)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
  zh: '![图像](assets/272fig01a.png)'
- en: '**Sometimes you *DO* want to be just like your parents.** Ever run across a
    class that ***almost*** does exactly what you want ***your*** class to do? Found
    yourself thinking that if you could just ***change a few things***, that class
    would be perfect? With **inheritance**, you can **extend** an existing class so
    your new class gets all of its behavior—with the **flexibility** to make changes
    to that behavior so you can tailor it however you want. Inheritance is one of
    the most powerful concepts and techniques in the C# language: with it you can
    **avoid duplicate code, model the real world** more closely, and end up with apps
    that are **easier to maintain** and **less prone to bugs**.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**有时候，你确实想要像你的父母一样。** 是否遇到过一个几乎完全符合你所需类的类？是否发现自己想着如果能稍微***改变一些东西***，那个类就完美了？通过**继承**，您可以**扩展**现有类，以便您的新类获得其所有行为——同时具备灵活性，可以对其行为进行更改，以便根据需要进行定制。继承是C#语言中最强大的概念和技术之一：借助它，您可以**避免重复的代码，更贴近模拟现实世界**，并最终获得**更易于维护**和**更少错误**的应用程序。'
- en: '***Do this!***'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '***这样做！***'
- en: '*THE BASE DAMAGE FOR AN ARROW IS THE 1D6 ROLL MULTIPLIED BY .35HP.*'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*箭头的基础伤害是1D6点数乘以0.35HP。*'
- en: '*FOR A MAGIC ARROW, THE BASE DAMAGE IS MULTIPLIED BY 2.5HP.*'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*对于魔法箭，基础伤害乘以2.5HP。*'
- en: '*A FLAMING ARROW ADDS AN EXTRA 1.25HP.*'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*火焰箭增加额外的1.25HP。*'
- en: '*THE RESULT IS ROUNDED **UP** TO THE NEAREST INTEGER HP.*'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*结果四舍五入**向上**取最近的整数HP。*'
- en: Calculate damage for MORE weapons
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计算更多武器的伤害
- en: The updated sword damage calculator was huge a hit on game night! Now Owen wants
    calculators for all of the weapons. Let’s start with the damage calculation for
    an arrow, which uses a 1d6 roll. Let’s **create a new ArrowDamage class** to calculate
    the arrow damage using the arrow formula in Owen’s game master notebook.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 更新后的剑伤害计算器在游戏之夜上大获成功！现在Owen想要所有武器的计算器。让我们从箭头的伤害计算开始，它使用1d6点数。让我们**创建一个新的ArrowDamage类**来使用Owen游戏大师笔记本中箭头公式计算箭头伤害。
- en: Most of the code in ArrowDamage will be ***identical to the code*** in the SwordDamage
    class. Here’s what we need to do to get started building the new app.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: ArrowDamage中的大部分代码与SwordDamage类中的代码***几乎相同***。这是我们启动新应用程序所需做的事情。
- en: '**Create a new .NET Console App project.** We want it to do both sword and
    arrow calculations, so **add the SwordDamage class** to the project.'
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**创建一个新的.NET控制台应用程序项目。** 我们希望它能够同时进行剑和箭的计算，因此**向项目中添加SwordDamage类**。'
- en: '**Create an ArrowDamage class that’s an exact copy of SwordDamage.** Create
    a new class called ArrowDamage, then **copy all of the code from SwordDamage and
    paste it** into the new ArrowDamage class. Then change the constructor name to
    ArrowDamage so the program builds.'
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**创建一个ArrowDamage类，完全复制SwordDamage的代码。** 创建一个名为ArrowDamage的新类，然后**复制所有代码从SwordDamage并粘贴**到新的ArrowDamage类。然后更改构造函数名称为ArrowDamage以便程序构建。'
- en: '**Refactor the constants.** The arrow damage formula has different values for
    the base and flame damage, so let’s rename the BASE_DAMAGE constant to BASE_MULTIPLIER
    and update the constant values. We think these constants make the code easier
    to read, so add a MAGIC_MULTIPLIER constant too:'
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**重构常量。** 箭头伤害公式的基础和火焰伤害有不同的值，因此让我们将BASE_DAMAGE常量重命名为BASE_MULTIPLIER，并更新常量值。我们认为这些常量使代码更易于阅读，因此也添加一个MAGIC_MULTIPLIER常量：'
- en: '![Images](assets/274fig01.png)'
  id: totrans-14
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图像](assets/274fig01.png)'
- en: Note
  id: totrans-15
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: ArrowDamage
  id: totrans-16
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ArrowDamage
- en: Roll
  id: totrans-17
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 掷
- en: Magic
  id: totrans-18
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 魔法
- en: Flaming
  id: totrans-19
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 火焰
- en: Damage
  id: totrans-20
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 伤害
- en: '**Modify the CalculateDamage method**. Now all you need to do to make your
    new ArrowDamage class work is to update the CalculateDamage method so it does
    the correct calculation:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**修改CalculateDamage方法**。现在，您唯一需要做的就是更新CalculateDamage方法，以便它执行正确的计算：'
- en: '![Images](assets/274fig02.png)'
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图像](assets/274fig02.png)'
- en: Use a switch statement to match several candidates
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用switch语句匹配多个候选人
- en: 'Let’s update our console app to prompt the user whether to calculate damage
    from an arrow or a sword. We’ll ask for a key, and use the static **Char.ToUpper**
    **method** to convert it to uppercase:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更新我们的控制台应用程序，询问用户是要计算箭头还是剑的伤害。我们将请求一个键，并使用静态的**Char.ToUpper** **方法**将其转换为大写：
- en: '![Images](assets/275fig001.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![图像](assets/275fig001.png)'
- en: 'We ***could*** use `if/else` statements for this:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们***可以***使用`if/else`语句来做这个：
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'That’s how we’ve handled input so far. Comparing one variable against many
    different values is a really common pattern that you’ll see over and over again.
    It’s so common that C# has a special kind of statement *designed specifically
    for this situation*. A `switch` **statement** lets you compare one variable against
    many values in a way that’s compact and easy to read. Here’s a `**switch**` **statement**
    that does exactly the same thing as the `if/else` statements above:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们到目前为止处理输入的方式。将一个变量与许多不同的值进行比较是一种非常常见的模式，你会一遍又一遍地看到它。这种情况非常普遍，以至于C#有一种专门为这种情况设计的特殊语句。`switch`
    **语句**让你以一种简洁易读的方式比较一个变量与许多值。下面是一个`**switch**` **语句**，它与上面的`if/else`语句完全相同：
- en: '![Images](assets/275fig01.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/275fig01.png)'
- en: One more thing...can we calculate damage for a dagger? and a mace? and a staff?
    and...
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有一件事...我们能计算匕首的伤害吗？还有狼牙棒？还有法杖？以及...
- en: We’ve made two classes for sword and arrow damage. But what happens if there
    are three other weapons? Or four? Or 12? And what if you had to maintain that
    code and make more changes later? What if you had to make the ***same exact change***
    to five or six ***closely related*** classes? What if you had to keep making changes?
    It’s inevitable that bugs would slip through—it’s way too easy to update five
    classes but forget to change the sixth.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为剑和箭伤害制作了两个类。但是如果有三种其他武器呢？还是四种？还是12种？如果你必须维护该代码并稍后进行更改呢？如果你必须对五个或六个***紧密相关的***类进行***完全相同的更改***会怎样呢？如果你不断进行更改会怎样呢？错误肯定会发生——更新五个类而忘记更改第六个太容易了。
- en: '![Images](assets/277fig01.png)![Images](assets/277fig02.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/277fig01.png)![图片](assets/277fig02.png)'
- en: '**You’re right! Having the same code repeated in different classes is inefficient
    and error-prone.**'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '**你是对的！在不同的类中重复相同的代码是低效且容易出错的。**'
- en: 'Lucky for us, C# gives us a better way to build classes that are related to
    each other and share behavior: ***inheritance***.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，C#给了我们一种更好的方式来构建彼此相关并共享行为的类：***继承***。
- en: When your classes use inheritance, you only need to write your code once
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 当你的类使用继承时，你只需要编写一次你的代码
- en: It’s no coincidence that your SwordDamage and ArrowDamage classes have a lot
    of the same code. When you write C# programs, you often create classes that represent
    things in the real world, and those things are usually related to each other.
    Your classes have **similar code** because the things they represent in the real
    world—two similar calculations from the same role-playing game—have **similar
    behaviors**.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 你的SwordDamage和ArrowDamage类有很多相同的代码并非巧合。当你编写C#程序时，通常会创建代表现实世界中事物的类，而这些事物通常彼此相关。你的类具有**相似的代码**，因为它们在现实世界中代表的事物——来自同一角色扮演游戏的两个相似计算——具有**相似的行为**。
- en: '![Images](assets/278fig01.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/278fig01.png)'
- en: When you have two classes that are specific cases of something more general,
    you can set them up to **inherit** from the same class. When you do that, each
    of them is a **subclass** of the same **base class**.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 当你有两个类是更一般的东西的具体情况时，你可以设置它们**继承**自相同的类。当你这样做时，它们中的每一个都是相同**基类**的**子类**。
- en: '![Images](assets/278fig02.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/278fig02.png)'
- en: Build up your class model by starting general and getting more specific
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过从一般开始并变得更具体来构建你的类模型
- en: When you build a set of classes that represent things (especially things in
    the real world), you’re building a **class model**. Real-world things are often
    in a **hierarchy** that goes from more general to more specific, and your programs
    have their own **class hierarchy** that does the same thing. In your class model,
    classes further down in the hierarchy **inherit** from those above them.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 当你   当你构建一组代表事物的类（特别是现实世界中的事物）时，你正在构建一个**类模型**。现实世界的事物通常处于从更一般到更具体的**层次结构**中，而你的程序也有自己的**类层次结构**，也是这样的。在你的类模型中，层次结构下面的类**继承**自上面的类。
- en: '![Images](assets/279fig01.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/279fig01.png)'
- en: How would you design a zoo simulator?
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你会如何设计一个动物园模拟器？
- en: Lions and tigers and bears...oh my! Also, hippos, wolves, and the occasional
    dog. Your job is to design an app that simulates a zoo. (Don’t get too excited—we’re
    not going to actually build the code, just design the classes to represent the
    animals. We bet you’re already thinking about how you’d do this in Unity!)
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 狮子、老虎和熊...哦，我的上帝！还有，河马、狼，偶尔也会有狗。你的工作是设计一个模拟动物园的应用程序。（不要太兴奋——我们不打算真的编写代码，只是设计代表动物的类。我们打赌你已经在考虑如何在Unity中完成这个任务了！）
- en: We’ve been given a list of some of the animals that will be in the program,
    but not all of them. We know that each animal will be represented by an object,
    and that the objects will move around in the simulator, doing whatever it is that
    each particular animal is programmed to do.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经得到了将在程序中出现的一些动物的列表，但不是所有动物。我们知道每个动物将由一个对象表示，并且这些对象将在模拟器中移动，执行每个特定动物编程的操作。
- en: More importantly, we want the program to be easy for other programmers to maintain,
    which means they’ll need to be able to add their own classes later on if they
    want to add new animals to the simulator.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 更重要的是，我们希望程序易于其他程序员维护，这意味着如果他们想要将新动物添加到模拟器中，他们需要能够稍后添加自己的类。
- en: '***Let’s start by building a class model for the animals we know about.***'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '***让我们从为我们所知道的动物建立一个类模型开始。***'
- en: So what’s the first step? Well, before we can talk about **specific** animals,
    we need to figure out the **general** things they have in common—the abstract
    characteristics that ***all*** animals have. Then we can build those characteristics
    into a base class that all animal classes can inherit from.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 那么第一步是什么呢？在我们谈论**具体**的动物之前，我们需要找出它们共同拥有的**普遍**特征——所有动物都具备的抽象特征。然后我们可以将这些特征构建成一个基类，所有动物类都可以从中继承。
- en: Note
  id: totrans-49
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: '**The terms parent, superclass, and base class are often used interchangeably.
    Also, the terms extend and inherit from mean the same thing. The terms child and
    subclass are also synonymous, but subclass can also be used as a verb.**'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '**术语“父类”、“超类”和“基类”通常可以互换使用。同样，“扩展”和“继承”这两个术语意思相同。“子类”也可以是一个动词。**'
- en: Note
  id: totrans-51
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Some people use the term “base class” to specifically mean the class at the
    top of the inheritance tree...but not the VERY top, because every class inherits
    from Object or a subclass of Object.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 有些人使用术语“基类”来特指继承树顶部的类...但不是最顶部，因为每个类都继承自 Object 或 Object 的子类。
- en: '**Look for things the animals have in common.**'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**寻找动物共有的特征。**'
- en: Take a look at these six animals. What do a lion, a hippo, a tiger, a bobcat,
    a wolf, and a dog have in common? How are they related? You’ll need to figure
    out their relationships so you can come up with a class model that includes all
    of them.
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 看看这六种动物。狮子、河马、老虎、猞猁、狼和狗有什么共同之处？它们如何相关联？您需要弄清它们的关系，以便能够提出包含它们所有的类模型。
- en: '![Images](assets/280fig02.png)'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](assets/280fig02.png)'
- en: '**Build a base class to give the animals everything they have in common.**'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**构建一个基类，为动物提供它们共同拥有的一切。**'
- en: The fields, properties, and methods in the base class will give all of the animals
    that inherit from it a common state and behavior. They’re all animals, so it makes
    sense to call the base class Animal.
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 基类中的字段、属性和方法将为所有继承它的动物提供一个共同的状态和行为。它们都是动物，因此将基类称为 Animal 是有道理的。
- en: 'You already know that we should avoid duplicate code: it’s hard to maintain,
    and always leads to headaches down the road. So let’s choose fields and methods
    for an Animal base class that you **only have to write once**, and each of the
    animal subclasses can inherit them. Let’s start with the public properties:'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您已经知道我们应该避免重复代码：这很难维护，并且总是会带来后续的头疼。因此，让我们为 Animal 基类选择您**只需编写一次**的字段和方法，并且每个动物子类都可以继承它们。让我们从公共属性开始：
- en: 'Picture: a path to an image file.'
  id: totrans-59
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图片：指向图像文件的路径。
- en: 'Food: the type of food this animal eats. Right now, there can be only two values:
    meat and grass.'
  id: totrans-60
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 食物：这种动物吃的食物类型。目前只能有两个值：肉和草。
- en: 'Hunger: an int representing the hunger level of the animal. It changes depending
    on when (and how much) the animal eats.'
  id: totrans-61
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 饥饿：表示动物饥饿水平的整数。它会随着动物吃饭的时间（和数量）而改变。
- en: 'Boundaries: a reference to a class that stores the height, width, and location
    of the pen that the animal will roam around in.'
  id: totrans-62
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 边界：指向一个存储了围栏高度、宽度和位置的类的引用。
- en: 'Location: the X and Y coordinates where the animal is standing.'
  id: totrans-63
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 位置：动物站立的 X 和 Y 坐标。
- en: 'In addition, the Animal class has four methods the animals can inherit:'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 另外，Animal 类还有四种动物可以继承的方法：
- en: 'MakeNoise: a method to let the animal make a sound.'
  id: totrans-65
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发出声音：让动物发出声音的方法。
- en: 'Eat: behavior for when the animal encounters its preferred food.'
  id: totrans-66
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进食：当动物遇到它们喜欢的食物时的行为。
- en: 'Sleep: a method to make the animal lie down and take a nap.'
  id: totrans-67
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 睡觉：让动物躺下来小睡的方法。
- en: 'Roam: a method to make animals wander around their pens.'
  id: totrans-68
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 游荡：使动物在它们的圈舍里四处游荡的方法。
- en: '![Images](assets/281fig01.png)'
  id: totrans-69
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](assets/281fig01.png)'
- en: Different animals have different behaviors
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不同的动物有不同的行为
- en: Lions roar, dogs bark, and as far as *we* know hippos don’t make any sound at
    all. All of the classes that inherit from Animal will have a MakeNoise method,
    but each of those methods will work a different way and will have different code.
    When a subclass changes the behavior of one of the methods that it inherited,
    we say that it **overrides** the method.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 狮子吼，狗叫，至于*我们*所知，河马根本不会发出任何声音。所有从Animal继承的类都将具有MakeNoise方法，但每个方法的工作方式都不同，并且具有不同的代码。当子类更改继承的方法的行为时，我们称其**覆盖**该方法。
- en: Note
  id: totrans-72
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Just because a property or a method is in the Animal base class, that doesn’t
    mean every subclass has to use it the same way...or at all!
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 仅因为一个属性或方法在Animal基类中，这并不意味着每个子类都必须以相同的方式使用它……或根本不使用！
- en: '**Figure out what each animal does that the Animal class does differently—or
    not at all.**'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**弄清楚每种动物在Animal类做得不同或根本不做的事情。**'
- en: Every animal needs to eat, but a dog might take small bites of meat while a
    hippo eats huge mouthfuls of grass. What would the code for that behavior look
    like? Both the dog and the hippo would override the Eat method. The hippo’s method
    would have it consume, say, 20 pounds of hay each time it was called. The dog’s
    Eat method, on the other hand, would reduce the zoo’s food supply by one 12-ounce
    can of dog food.
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 每种动物都需要进食，但狗可能会小口吃肉，而河马则会大口吃草。那种行为的代码会是什么样子呢？狗和河马都会覆盖Eat方法。河马的方法会让它每次调用时消耗大约20磅的干草。另一方面，狗的Eat方法会减少动物园的食物供应一罐12盎司的狗粮。
- en: Note
  id: totrans-76
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: '*So when you’ve got a subclass that inherits from a base class, it **must**
    inherit all of the base class’s behaviors... but you can **modify** them in the
    subclass so they’re not performed exactly the same way. That’s what overriding
    is all about.*'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*所以，当你有一个子类继承自一个基类时，它**必须**继承所有基类的行为……但是你可以**修改**它们在子类中的执行方式，所以它们不是完全相同的。这就是覆盖的意义。*'
- en: '![Images](assets/282fig01.png)'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](assets/282fig01.png)'
- en: '**Look for classes that have a lot in common.**'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**寻找有很多共同点的类。**'
- en: Don’t dogs and wolves seem pretty similar? They’re both canines, and it’s a
    good bet that if you look at their behavior they have a lot in common. They probably
    eat the same food and sleep the same way. What about bobcats, tigers, and lions?
    It turns out all three of them move around their habitats in exactly the same
    way. It’s a good bet that you’ll be able to have a general Feline class that lives
    between Animal and those three feline classes that can help prevent duplicate
    code between them.
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 狗和狼看起来不是很相似吗？它们都是食肉动物，可以肯定的是，如果你观察它们的行为，它们有很多共同点。它们可能吃同样的食物，以相同的方式睡觉。那么山猫、老虎和狮子呢？事实证明，它们三者在它们的栖息地中的移动方式完全相同。可以肯定的是，你可以创建一个通用的Feline类，位于Animal和这三个猫科动物类之间，有助于防止它们之间的重复代码。
- en: '![Images](assets/283fig01.png)'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](assets/283fig01.png)'
- en: '**Finish your class hierarchy.**'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**完成你的类层次结构。**'
- en: Now that you know how you’ll organize the animals, you can add the Feline and
    Canine classes.
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在你知道如何组织动物了，你可以添加Feline和Canine类。
- en: When you create your classes so that there’s a base class at the top with subclasses
    below it, and those subclasses have their own subclasses that inherit from them,
    what you’ve built is called a **class hierarchy**. This is about more than just
    avoiding duplicate code, although that is certainly a great benefit of a sensible
    hierarchy. One benefit of this is code that’s a lot easier to understand and maintain.
    When you’re looking at the zoo simulator code and you see a method or property
    defined in the Feline class, then you *immediately know* that you’re looking at
    something that all of the cats share. Your hierarchy becomes a map that helps
    you find your way through your program.
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当你创建类时，使得顶部有一个基类，下面有子类，而这些子类有它们自己的子类从它们那里继承时，你建立的就是一个**类层次结构**。这不仅仅是为了避免重复代码，尽管这显然是合理层次结构的一个很大好处。这种层次结构的一个好处是代码更容易理解和维护。当你查看动物园模拟器代码，看到在Feline类中定义了一个方法或属性，你就*立刻知道*这是所有猫共享的东西。你的层次结构成为了一张地图，帮助你在程序中找到方向。
- en: '![Images](assets/284fig01.png)'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](assets/284fig01.png)'
- en: Every subclass extends its base class
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 每个子类都扩展了它的基类
- en: You’re not limited to the methods that a subclass inherits from its base class...but
    you already know that! After all, you’ve been building your own classes all along.
    When you modify a class to make it inherit members—and we’ll see that in C# code
    soon!—what you’re doing is taking the class you’ve already built and ***extending***
    it by adding all of the fields, properties, and methods in the base class. So
    if you want to add a Fetch method to Dog, that’s perfectly normal. It won’t inherit
    or override anything—only the Dog class will have that method, and it won’t end
    up in Wolf, Canine, Animal, Hippo, or any other class.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 您不受限于子类从其基类继承的方法...但您已经知道了这一点！毕竟，您一直在构建自己的类。当您修改一个类以使其继承成员——我们很快就会在C#代码中看到！——您所做的就是获取您已经构建的类，并通过添加基类中的所有字段、属性和方法来***扩展***它。所以如果你想为Dog添加一个Fetch方法，那是很正常的。它不会继承或覆盖任何东西——只有Dog类会有该方法，并且它不会出现在Wolf、Canine、Animal、Hippo或任何其他类中。
- en: '![Images](assets/285fig01.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/285fig01.png)'
- en: C# always calls the most specific method
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C#总是调用最具体的方法
- en: If you tell your Dog object to roam, there’s only one method that can be called—the
    one in the Animal class. What about telling your Dog to make noise? Which MakeNoise
    is called?
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你告诉你的Dog对象漫游，只有一个方法可以调用——在Animal类中的方法。那么告诉你的Dog发出声音呢？调用哪个MakeNoise？
- en: Well, it’s not too hard to figure it out. A method in the Dog class tells you
    how dogs make noise. If it’s in the Canine class, it’s telling you how all canines
    do it. If it’s in Animal, then it’s a description of that behavior that’s so general
    that it applies to every single animal. So if you ask your Dog to make a noise,
    first C# will look inside the Dog class to find the behavior that applies specifically
    to dogs. If Dog didn’t have a MakeNoise method it’d check Canine, and after that
    it’d check Animal.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，弄清楚这个并不太难。Dog类中的方法告诉你狗怎么发出声音。如果它在Canine类中，它告诉你所有犬类动物如何做到这一点。如果它在Animal类中，那么它是一个描述行为的行为，非常普遍，适用于每一种动物。所以如果你让你的Dog发出声音，首先C#会查找Dog类中特别适用于狗的行为。如果Dog没有MakeNoise方法，它会检查Canine，然后检查Animal。
- en: Any place where you can use a base class, you can use one of its subclasses
    instead
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 任何地方可以使用基类，你可以使用它的子类之一代替
- en: 'One of the most useful things you can do with inheritance is to **extend**
    a class. So if your method takes a Bird object, then you can pass an instance
    of Woodpecker. All that method knows is that it has a bird. It doesn’t know what
    kind of bird it has, so it can only ask it to do things that all birds do: it
    can ask the bird to Walk and LayEggs, but it can’t ask it to HitWoodWithBeak,
    because only Woodpeckers have that behavior—and the method doesn’t know that it’s
    specifically a Woodpecker, just that it’s a more general Bird. It ***only has
    access to the fields, properties, and other methods that are part of the class
    it knows about***.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 继承中最有用的一件事情之一是**扩展**一个类。所以如果你的方法接受一个Bird对象，那么你可以传递一个Woodpecker的实例。该方法只知道它有一个鸟。它不知道它有什么种类的鸟，所以它只能要求它做所有鸟都能做的事情：它可以要求鸟走路和下蛋，但它不能要求它用嘴巴敲木头，因为只有啄木鸟有这种行为——而该方法不知道它具体是啄木鸟，只知道它是一个更一般的Bird。它***只能访问它知道的类中的字段、属性和其他方法***。
- en: '![Images](assets/286fig01.png)![Images](assets/286fig02.png)![Images](assets/289fig01.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/286fig01.png)![图片](assets/286fig02.png)![图片](assets/289fig01.png)'
- en: Use a colon to extend a base class
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用冒号扩展基类
- en: 'When you’re writing a class, you use a **colon (:)** to have it inherit from
    a base class. That makes it a subclass, and gives it **all of the fields, properties,
    and methods** of the class it inherits from. This Bird class is a subclass of
    Vertebrate:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 当你编写一个类时，你使用**冒号 (:)** 来让它继承自一个基类。这使得它成为一个子类，并给它**所有的字段、属性和方法**，来自于它继承的类。这个Bird类是Vertebrate的一个子类：
- en: '![Images](assets/290fig01.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/290fig01.png)'
- en: We know that inheritance adds the base class fields, properties, and methods
    to the subclass...
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们知道继承将基类的字段、属性和方法添加到子类中...
- en: We’ve seen inheritance when a subclass needs to inherit ***all*** of the base
    class’s methods, properties, and fields.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到，当一个子类需要继承基类的***所有***方法、属性和字段时。
- en: '![Images](assets/291fig01.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/291fig01.png)'
- en: '...but some birds don’t fly!'
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '...但有些鸟不会飞！'
- en: What do you do if your base class has a method that your subclass needs to ***modify***?
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的基类有一个方法，你的子类需要***修改***，你会怎么做？
- en: '![Images](assets/291fig02.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/291fig02.png)'
- en: Note
  id: totrans-104
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: '**Oops—we’ve got a problem. Penguins are birds, and the Bird class has a Fly
    method, but we don’t want our penguins to fly. It would be great if we could display
    a warning if a penguin tries to fly.**'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '**糟糕——我们有了一个问题。企鹅是鸟类，而鸟类有一个名为Fly的方法，但我们不希望我们的企鹅飞行。如果企鹅试图飞行，显示一个警告将是很好的。**'
- en: '![Images](assets/291fig03.png)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/291fig03.png)'
- en: A subclass can override methods to change or replace members it inherited
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 子类可以重写方法来更改或替换它继承的成员
- en: Sometimes you’ve got a subclass that you’d like to inherit *most* of the behaviors
    from the base class, but *not all of them*. When you want to change the behaviors
    that a class has inherited, you can **override methods or properties**, replacing
    them with new members with the same name.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 有时你有一个子类，你希望从基类继承*大多数*行为，但*不是全部*。当你想要改变类继承的行为时，你可以**重写方法或属性**，用同名的新成员替换它们。
- en: When you **override a method**, your new method needs to have exactly the same
    signature as the method in the base class it’s overriding. In the case of the
    penguin, that means it needs to be called Fly, return void, and have no parameters.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 当你**重写一个方法**时，你的新方法需要与它覆盖的基类方法具有完全相同的签名。对于企鹅来说，这意味着它需要被称为Fly，返回void，并且没有参数。
- en: Note
  id: totrans-110
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: o-ver-ride, verb.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 覆盖，动词。
- en: to use authority to replace, reject, or cancel. *Once she became president of
    Dynamco, she could **override** poor management decisions.*
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: to use authority to replace, reject, or cancel. *一旦她成为Dynamco的总裁，她可以**override**糟糕的管理决策。*
- en: '**Add the virtual keyword to the method in the base class.**'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**在基类方法中添加virtual关键字。**'
- en: A subclass can only override a method if it’s marked with the `virtual` keyword.
    Adding `virtual` to the Fly method declaration tells C# that a subclass of the
    Bird class is allowed to override the Fly method.
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 子类只能在一个标有`virtual`关键字的方法上重写它。在Fly方法声明中添加`virtual`告诉C#，Bird类的子类可以重写Fly方法。
- en: '![Images](assets/292fig01.png)'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](assets/292fig01.png)'
- en: '**Add the override keyword to a method with the same name in the subclass.**'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**在子类的同名方法上添加override关键字。**'
- en: The subclass’s method will need to have exactly the same signature—the same
    return type and parameters—and you’ll need to use the `**override**` keyword in
    the declaration. Now a Penguin object prints a warning when its Fly method is
    called.
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 子类的方法将需要与基类完全相同的签名——相同的返回类型和参数——并且你将需要在声明中使用`**override**`关键字。现在，当Penguin对象调用其Fly方法时，会打印警告。
- en: '![Images](assets/292fig02.png)'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](assets/292fig02.png)'
- en: '![Images](assets/296fig01.png)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/296fig01.png)'
- en: Some members are only implemented in a subclass
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一些成员只在子类中实现
- en: All the code we’ve seen so far that works with subclasses has accessed the members
    from outside the object—like how the Main method in the code you just wrote calls
    LayEggs. Inheritance really shines when the base class **uses a method or property
    that’s implemented in the subclass**. Here’s an example. Our zoo simulator has
    vending machines that let patrons buy soda, candy, and feed to give to the animals
    in the petting zoo area.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们所见过的所有代码都是从对象外部访问子类的成员——就像你刚刚编写的代码中Main方法调用LayEggs一样。继承真正发挥作用的地方是基类**使用子类中实现的方法或属性**。这里有一个例子。我们的动物园模拟器有自动售货机，让游客购买苏打水、糖果和饲料，以供宠物区的动物食用。
- en: '![Images](assets/297fig01.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/297fig01.png)'
- en: 'VendingMachine is the base class for all vending machines. It has code to dispense
    items, but those items aren’t defined. The method to check if the patron put in
    the right amount always returns false. Why? Because they **will be implemented
    in the subclass**. Here’s a subclass for dispensing animal feed in the petting
    zoo:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: VendingMachine是所有售货机的基类。它有分发物品的代码，但这些物品未定义。检查游客是否放入正确金额的方法始终返回false。为什么？因为它们**将在子类中实现**。以下是在宠物区分发动物饲料的子类：
- en: '![Images](assets/297fig02.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/297fig02.png)'
- en: Use the debugger to understand how overriding works
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用调试器来理解重写的工作原理
- en: Let’s use the debugger to see exactly what happens when we create an instance
    of AnimalFeedVendingMachine and ask it to dispense some feed. **Create a new Console
    App project**, then do this.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用调试器来看看当我们创建一个AnimalFeedVendingMachine的实例并要求它分发一些饲料时究竟会发生什么。**创建一个新的Console
    App项目**，然后按照以下步骤操作。
- en: '***Debug this!***'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '***调试一下这个！***'
- en: '**Add the Main method.** Here’s the code for the method:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**添加Main方法**。以下是该方法的代码：'
- en: '[PRE1]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '**Add the VendingMachine and AnimalFeedVendingMachine classes.** Once they’re
    added, try adding this line of code to the Main method:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**添加 VendingMachine 和 AnimalFeedVendingMachine 类。** 一旦它们被添加，尝试将这行代码添加到 Main
    方法中：'
- en: '[PRE2]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: You’ll get a compiler error because of the `protected` keyword, because only
    the VendingMachine class or subclasses of it can access its protected methods.
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于 `protected` 关键字，您将收到编译器错误，因为只有 VendingMachine 类或其子类可以访问其受保护的方法。
- en: '![Images](assets/298fig01.png)'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](assets/298fig01.png)'
- en: Delete the line so your code builds.
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 删除该行以使您的代码构建。
- en: '**Put a breakpoint on the first line of the Main method.** Run your program.
    When it hits the breakpoint, **use Step Into (F10) to execute every line of code
    one at a time**. Here’s what happens:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**在 Main 方法的第一行设置一个断点。** 运行程序。当它触发断点时，使用“逐行执行”（F10）逐行执行每行代码。以下是发生的情况：'
- en: It creates an instance of AnimalFeedVendingMachine and calls its Dispense method.
  id: totrans-136
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它创建 AnimalFeedVendingMachine 的实例并调用其 Dispense 方法。
- en: That method is only defined in the base class, so it calls VendingMachine.Dispense.
  id: totrans-137
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该方法仅在基类中定义，因此调用 VendingMachine.Dispense。
- en: The first line of VendingMachine.Dispense calls the protected CheckAmount method.
  id: totrans-138
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: VendingMachine.Dispense 的第一行调用受保护的 CheckAmount 方法。
- en: CheckAmount is overridden in the AnimalFeedVendingMachine subclass, which causes
    VendingMachine.Dispense to call the CheckAmount method defined in AnimalFeedVendingMachine.
  id: totrans-139
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: CheckAmount 在 AnimalFeedVendingMachine 子类中被覆盖，这导致 VendingMachine.Dispense 调用
    AnimalFeedVendingMachine 中定义的 CheckAmount 方法。
- en: This version of CheckAmount returns true, so Dispense returns the Item property.
    AnimalFeedVendingMachine also overrides this property, it returns “a handful of
    animal feed.”
  id: totrans-140
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个版本的 CheckAmount 返回 true，因此 Dispense 返回 Item 属性。AnimalFeedVendingMachine 也覆盖了此属性，它返回“一把动物饲料。”
- en: Note
  id: totrans-141
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: You’ve been using the Visual Studio debugger to sleuth out bugs in your code.
    It’s also a great tool for learning and exploring C#, like in this “Debug this!”
    where you can explore how overriding works. Can you think of more ways to experiment
    with overriding subclasses?
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您一直在使用 Visual Studio 调试器来查找代码中的错误。它也是学习和探索 C# 的好工具，就像在这个“Debug this！”中一样，您可以探索覆盖的工作方式。您能想到更多实验覆盖子类的方法吗？
- en: '![Images](assets/299fig01.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/299fig01.png)'
- en: '**There’s an important reason for virtual and override!**'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '**有一个重要的原因需要使用 virtual 和 override！**'
- en: The `virtual` and `override` keywords aren’t just for decoration. They make
    a real difference in how your program works. The `virtual` keyword tells C# that
    a member (like a method, property, or field) can be extended—without it, you can’t
    override it at all. The `override` keyword tells C# that you’re extending the
    member. If you leave out the `override` keyword in a subclass, you’re creating
    a *completely unrelated* method that just *happens to have the same name*.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`virtual` 和 `override` 关键字不仅仅是装饰。它们在程序运行中真正起到作用。`virtual` 关键字告诉 C# 成员（如方法、属性或字段）可以被扩展——没有它，你根本无法覆盖它。`override`
    关键字告诉 C# 你正在扩展该成员。如果在子类中省略 `override` 关键字，你实际上是创建了一个完全无关的方法，只是恰巧有相同的名称。'
- en: That sounds a little weird, right? But it actually makes sense—and the best
    way to really understand how `virtual` and `override` work is by writing code.
    So let’s build a real example to experiment with them.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 听起来有点奇怪，对吧？但实际上是有道理的——真正理解 `virtual` 和 `override` 如何工作的最佳方法就是编写代码。因此，让我们构建一个真实的示例来进行实验。
- en: '**When a subclass overrides a method in its base class, the more specific version
    defined in the subclass is always called—even when it’s being called by a method
    in the base class.**'
  id: totrans-147
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**当子类覆盖其基类中的方法时，总是调用在子类中定义的更具体版本，即使它是由基类中的方法调用的。**'
- en: Build an app to explore virtual and override
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建一个应用程序来探索 virtual 和 override
- en: A really important part of inheritance in C# is extending class members. That’s
    how a subclass can inherit some of its behavior from its base class, but override
    certain members where it needs to—and that’s where the `virtual` **and** `override`
    **keywords** come in. The `virtual` keyword determines which class members can
    be extended. When you want to extend a member, you ***must*** use the `override`
    keyword. Let’s create some classes to experiment with `virtual` and `override`.
    You’re going to create a class that represents a safe containing valuable jewels—you’ll
    build a class for some sneaky thieves to steal the jewels.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在C#中，继承的一个非常重要的部分是扩展类成员。这就是子类可以从基类继承某些行为，但需要在需要的地方重写某些成员的地方——这就是`virtual`和`override`关键字的用途。`virtual`关键字确定哪些类成员可以被扩展。当你想扩展一个成员时，***必须***使用`override`关键字。让我们创建一些类来实验`virtual`和`override`。你将创建一个代表包含贵重珠宝的保险柜的类——为了一些狡猾的小偷来偷取珠宝。
- en: '![Images](assets/300fig01.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![图像](assets/300fig01.png)'
- en: '**Create a new console app and add the Safe class.**'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**创建一个新的控制台应用程序并添加Safe类。**'
- en: 'Here’s the code for the Safe class:'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是Safe类的代码：
- en: '![Images](assets/300fig001.png)'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图像](assets/300fig001.png)'
- en: '**Add a class for the person who owns the safe.**'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**为拥有保险柜的人添加一个类。**'
- en: 'The safe owner is forgetful and occasionally forgets their extremely secure
    safe password. Add a SafeOwner class to represent them:'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 保险柜的主人有些健忘，偶尔会忘记他们极为安全的保险柜密码。添加一个SafeOwner类来代表他们：
- en: '[PRE3]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '**Add Locksmith class that can pick the lock.**'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**添加一个能够挑锁的Locksmith类。**'
- en: 'If a safe owner hires a professional locksmith to open their safe, they expect
    that locksmith to return the contents safe and sound. That’s exactly what the
    Locksmith.OpenSafe method does:'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果一个保险柜的主人雇佣专业的锁匠来打开他们的保险柜，他们期望那位锁匠安全无恙地归还里面的内容。这正是Locksmith.OpenSafe方法所做的事情：
- en: Note
  id: totrans-159
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The Locksmith’s OpenSafe method picks the lock, opens the safe, and then calls
    ReturnContents to get the valuables safely back to the owner.
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 锁匠的OpenSafe方法挑锁、打开保险柜，然后调用ReturnContents将贵重物品安全地归还给主人。
- en: '[PRE4]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '![Images](assets/301fig01.png)'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图像](assets/301fig01.png)'
- en: '**Add a JewelThief class that wants to steal the valuables.**'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**添加一个想要窃取贵重物品的JewelThief类。**'
- en: 'Uh-oh. Looks like there’s a burglar—and the worst kind, one who’s also a highly
    skilled locksmith able to open safes. Add this JewelThief class that extends Locksmith:'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 糟糕。看起来有个窃贼——更糟糕的是，他是一个高技能的锁匠，能够打开保险柜。添加这个扩展Locksmith的JewelThief类：
- en: Note
  id: totrans-165
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: JewelThief extends Locksmith and inherits the OpenSafe method and Combination
    property, but its ReturnContents method steals the jewels instead of returning
    them. INGENIOUS!
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: JewelThief扩展了Locksmith并继承了OpenSafe方法和Combination属性，但其ReturnContents方法窃取了珠宝而不是归还它们。聪明！
- en: '[PRE5]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '**Add a Main method that makes the JewelThief steal the jewels.**'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**添加一个主方法，让珠宝窃贼偷走宝石。**'
- en: It’s time for the big heist! In this Main method, the JewelThief sneaks into
    the house and uses its inherited Locksmith.OpenSafe method to get the safe combination.
    **What do you think will happen when it runs?**
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在是大抢劫的时候了！在这个主方法中，珠宝窃贼潜入房屋，并使用其继承的Locksmith.OpenSafe方法来获取保险柜的密码。**你认为它运行时会发生什么？**
- en: '[PRE6]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: A subclass can hide methods in the base class
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 子类可以隐藏基类中的方法
- en: 'Go ahead and run the JewelThief program. Here’s what you should see:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行JewelThief程序。你应该看到以下内容：
- en: '**Thank you for returning my precious jewels!**'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '**感谢您归还我的珍贵宝石！**'
- en: 'Did you expect the program’s output to be different? Maybe something like this:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 你是否预期程序的输出会有所不同？也许是这样的：
- en: '[PRE7]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: It looks like the JewelThief object acted just like a Locksmith object! So what
    happened?
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来JewelThief对象表现得就像Locksmith对象一样！那么发生了什么？
- en: Hiding methods versus overriding methods
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 隐藏方法与重写方法
- en: 'The reason the JewelThief object acted like a Locksmith object when its ReturnContents
    method was called was because of the way the JewelThief class declared its ReturnContents
    method. There’s a big hint in that warning message you got when you compiled your
    program:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: JewelThief对象在调用其ReturnContents方法时表现得像Locksmith对象一样，是因为JewelThief类声明了其ReturnContents方法的方式。在你编译程序时得到的警告信息中有一个重要的提示：
- en: '![Images](assets/302fig01.png)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![图像](assets/302fig01.png)'
- en: Since the JewelThief class inherits from Locksmith and replaces the ReturnContents
    method with its own method, it looks like JewelThief is overriding Locksmith’s
    ReturnContents method—but that’s not actually what’s happening. You probably expected
    JewelThief to override the method (which we’ll talk about in a minute), but instead
    JewelThief is hiding it.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 JewelThief 类继承自 Locksmith 并用自己的方法替换了 ReturnContents 方法，看起来像是 JewelThief 覆盖了
    Locksmith 的 ReturnContents 方法—但实际上并非如此。你可能期望 JewelThief 覆盖该方法（我们稍后会讨论），但实际上 JewelThief
    是在隐藏它。
- en: Note
  id: totrans-181
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: JewelThief
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: JewelThief
- en: '*Locksmith.* ReturnContents'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '*Locksmith.* ReturnContents'
- en: '*JewelThief.* ReturnContents'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '*JewelThief.* ReturnContents'
- en: 'There’s a big difference. When a subclass **hides** a method, it replaces (technically,
    it redeclares) a method in its base class ***that has the same name***. So now
    our subclass really has two different methods that share a name: one that it inherits
    from its base class, and another brand-new one that’s defined in that class.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这有很大的不同。当子类***隐藏***一个方法时，它替换（技术上来说是重新声明）其基类中***同名的方法***。所以现在我们的子类实际上有两种不同的方法，它们共享一个名称：一个是从基类继承的，另一个是在该类中定义的全新方法。
- en: Use the new keyword when you’re hiding methods
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 当你隐藏方法时，请使用 `new` 关键字
- en: 'Take a close look at that warning message. Sure, we know we *should* read our
    warnings, but sometimes we don’t...right? This time, actually read what it says:
    `**Use the new keyword if hiding was intended**`.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细看看那个警告信息。当然，我们知道我们*应该*读取我们的警告，但有时我们不会...对吧？这一次，确实读一下它说了什么：`**如果打算隐藏，请使用 new
    关键字**`。
- en: 'So go back to your program and add the `new` keyword:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，回到你的程序并添加 `new` 关键字：
- en: '[PRE8]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As soon as you add `new` to your JewelThief class’s ReturnContents method declaration,
    that warning message will go away—but your code still won’t act the way you expect
    it to!
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦在 JewelThief 类的 ReturnContents 方法声明中加入了 `new` 关键字，警告信息就会消失—但是你的代码仍然不会按照你的期望行动！
- en: It still calls the ReturnContents method defined in the Locksmith class. Why?
    Because the ReturnContents method is being called **from a method defined by the
    Locksmith class**—specifically, from inside Locksmith.OpenSafe—even though it’s
    being initiated by a JewelThief object. If JewelThief only hides Locksmith’s ReturnContents
    method, its own ReturnContents method will never be called.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 它仍然调用了 Locksmith 类中定义的 ReturnContents 方法。为什么？因为 ReturnContents 方法正是**由 Locksmith
    类定义的一个方法**—具体来说，是在 Locksmith.OpenSafe 内部调用，即使这是由 JewelThief 对象发起的。如果 JewelThief
    只是隐藏了 Locksmith 的 ReturnContents 方法，那么它自己的 ReturnContents 方法将永远不会被调用。
- en: If a subclass just adds a method with the same name as a method in its base
    class, it only hides the base class method instead of overriding it.
  id: totrans-192
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果子类只是添加了一个与基类中方法同名的方法，它只会隐藏基类方法而不是覆盖它。
- en: Use different references to call hidden methods
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用不同的引用来调用隐藏方法
- en: Now we know that JewelThief only ***hides*** the ReturnContents method (as opposed
    to ***overriding*** it). That causes it to act like a Locksmith object ***whenever
    it’s called like a Locksmith object***. JewelThief inherits one version of ReturnContents
    from Locksmith, and it defines a second version of it, which means that there
    are two different methods with the same name. That means your class needs **two
    different ways to call it**.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道 JewelThief 只是***隐藏***了 ReturnContents 方法（与***覆盖***不同）。这导致它在像 Locksmith
    对象一样被调用时表现得像一个 Locksmith 对象。JewelThief 继承了 Locksmith 的一个版本的 ReturnContents，并定义了第二个版本，这意味着有两个同名方法。这意味着你的类需要**两种不同的调用方式**。
- en: There are two different ways to call the ReturnContents method. If you’ve got
    an instance of JewelThief, you can use a JewelThief reference variable to call
    the new ReturnContents method. If you use a Locksmith reference variable to call
    it, it will call the hidden Locksmith ReturnContents method.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种不同的调用 ReturnContents 方法的方式。如果你有一个 JewelThief 的实例，你可以使用 JewelThief 的引用变量来调用新的
    ReturnContents 方法。如果你使用 Locksmith 的引用变量来调用它，它将调用隐藏的 Locksmith ReturnContents 方法。
- en: 'Here’s how that works:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这是如何工作的：
- en: Note
  id: totrans-197
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: '[PRE9]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note
  id: totrans-199
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: '**Can you figure out how to get JewelThief to override the ReturnContents method
    instead of just hiding it? See if you can do it before reading the next section!**'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '**你能想出如何使 JewelThief 覆盖 ReturnContents 方法而不仅仅是隐藏它吗？在阅读下一节之前，看看你能否做到！**'
- en: Use the override and virtual keywords to inherit behavior
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 override 和 virtual 关键字来继承行为
- en: 'We really want our JewelThief class to always use its own ReturnContents method,
    no matter how it’s called. This is the way we expect inheritance to work most
    of the time: a subclass can **override** a method in the base class so the method
    in the subclass is called instead. Start by using the `override` keyword when
    you declare the ReturnContents method:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '我们真的希望我们的 JewelThief 类始终使用自己的 ReturnContents 方法，无论如何调用它。这通常是我们期望继承工作的方式：子类可以
    **重写** 基类的方法，使得调用子类中的方法。首先在声明 ReturnContents 方法时使用 `override` 关键字：  '
- en: '![Images](assets/304fig01.png)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/304fig01.png)'
- en: 'But that’s not everything you need to do. If you just add the `override` keyword
    to the class declaration, you’ll get a compiler error:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 但这还不是你需要做的一切。如果只是在类声明中添加 `override` 关键字，你会得到一个编译器错误：
- en: '![Images](assets/304fig02.png)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/304fig02.png)'
- en: 'Again, take a really close look and read what the error says. JewelThief can’t
    override the inherited member ReturnContents **because it’s not marked** `virtual,
    abstract`, or `override` in Locksmith. Well, that’s an error we can fix with a
    quick change. Mark Locksmith’s ReturnContents with the `virtual` keyword:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，仔细观察并阅读错误信息。JewelThief 无法重写继承的成员 ReturnContents **因为它在 Locksmith 中没有标记**
    `virtual, abstract` 或 `override`。好的，这是一个我们可以通过快速更改来修复的错误。用 `virtual` 关键字标记 Locksmith
    的 ReturnContents 方法：
- en: '![Images](assets/304fig03.png)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/304fig03.png)'
- en: 'Now run your program again. Here’s the output we’ve been looking for:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 现在重新运行你的程序。这是我们一直在寻找的输出结果：
- en: '![Images](assets/304fig04.png)![Images](assets/305fig01.png)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/304fig04.png)![图片](assets/305fig01.png)'
- en: '**Exactly. Most of the time you want to override methods, but hiding them is
    an option.**'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '**没错。大多数情况下你会想要重写方法，但隐藏它们也是一种选择。**'
- en: When you’re working with a subclass that extends a base class, you’re much more
    likely to use overriding than you are to use hiding. So when you see that compiler
    warning about hiding a method, pay attention to it! Make sure you really want
    to hide the method, and didn’t just forget to use the `virtual` and `override`
    keywords. If you always use the `virtual`, `override`, and `new` keywords correctly,
    you’ll never run into a problem like this again!
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在一个扩展基类的子类中工作时，你更有可能使用重写而不是隐藏。所以当你看到关于隐藏方法的编译器警告时，要注意！确保你真的想隐藏该方法，而不是只是忘记使用
    `virtual` 和 `override` 关键字。如果你总是正确使用 `virtual`、`override` 和 `new` 关键字，你就不会再遇到这样的问题了！
- en: If you want to override a method in a base class, always mark it with the virtual
    keyword, and always use the override keyword any time you want to override the
    method in a subclass. If you don’t, you’ll end up accidentally hiding methods
    instead.
  id: totrans-212
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果你想在基类中重写一个方法，总是使用 `virtual` 关键字进行标记，并且每次你想在子类中重写方法时都使用 `override` 关键字。如果不这样做，你可能会意外隐藏方法。
- en: A subclass can access its base class using the base keyword
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 子类可以使用 base 关键字访问其基类
- en: Even when you override a method or property in your base class, sometimes you’ll
    still want to access it. Luckily, we can use `base`, which lets us access any
    member of the base class.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在基类中重写了方法或属性，有时你仍然希望访问它。幸运的是，我们可以使用 `base` 关键字来访问基类的任何成员。
- en: '**All animals eat, so the Vertebrate class has an Eat method that takes a Food
    object as its parameter.**'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**所有动物都吃东西，所以 Vertebrate 类有一个以 Food 对象为参数的 Eat 方法。**'
- en: '[PRE10]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '![Images](assets/306fig01.png)![Images](assets/306fig02.png)'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](assets/306fig01.png)![图片](assets/306fig02.png)'
- en: '**Chameleons eat by catching food with their tongues. So the Chameleon class
    inherits from Vertebrate but overrides Eat.**'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**变色龙通过用舌头捕食来进食。因此，Chameleon 类继承自 Vertebrate 但重写了 Eat 方法。**'
- en: '![Images](assets/306fig03.png)'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](assets/306fig03.png)'
- en: '**Instead of duplicating the code, we can use the `base` keyword to call the
    method that was overridden. Now we have access to both the old and the new version
    of Eat.**'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**我们可以使用 `base` 关键字调用被重写的方法，而不是复制代码。现在我们可以访问旧版本和新版本的 Eat 方法。**'
- en: '![Images](assets/306fig04.png)'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](assets/306fig04.png)'
- en: When a base class has a constructor, your subclass needs to call it
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 当一个基类有构造函数时，你的子类需要调用它。
- en: 'Let’s go back to the code you wrote with the Bird, Pigeon, Ostrich, and Egg
    classes. We want to add a BrokenEgg class that extends Egg, and make 25% of the
    eggs that the Pigeon lays broken. **Replace the** `new` **statement** in Pigeon.LayEgg
    with this `if/else` that creates a new instance of either Egg or BrokenEgg:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到你用 Bird、Pigeon、Ostrich 和 Egg 类编写的代码。我们想要添加一个 BrokenEgg 类扩展 Egg，并且让鸽子产下的蛋中有
    25% 是破损的。在 Pigeon.LayEgg 中，用这个 `if/else` 语句替换掉原来的 `new` 语句，来创建一个新的 Egg 或 BrokenEgg
    实例：
- en: '***Add this!***'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '***添加这个！***'
- en: '[PRE11]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now we just need a BrokenEgg class that extends Egg. Let’s make it identical
    to the Egg class, except that it has a constructor that writes a message to the
    console letting us know that an egg is broken:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们只需要一个扩展Egg的BrokenEgg类。让我们使它与Egg基类相同，只是它有一个构造函数，用来向控制台输出一条消息，告诉我们一个蛋是破碎的：
- en: '[PRE12]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Go ahead and **make those two changes** to your Egg program.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 继续并**进行这两个更改**到你的Egg程序。
- en: 'Uh-oh—looks like those new lines of code caused compiler errors:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 哎呀—看起来那些新代码行引起了编译器错误：
- en: 'The first error is on the line where you create a new BrokenEgg: *CS1729 –
    ’BrokenEgg’ does not contain a constructor that takes 2 arguments*'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个错误出现在你创建一个新的BrokenEgg的那一行：*CS1729 – ’BrokenEgg’没有包含一个接受2个参数的构造函数*
- en: 'The second error is in the BrokenEgg constructor: *CS7036 – There is no argument
    given that corresponds to the required formal parameter ’size’ of ’Egg.Egg(double,
    string)’*'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个错误在BrokenEgg构造函数中：*CS7036 – 没有提供与’Egg.Egg(double, string)’的必需形式参数’size’对应的参数*
- en: 'This is another great opportunity to ***read those errors*** and figure out
    what went wrong. The first error is pretty clear: the statement that creates a
    BrokenEgg instance is trying to pass two arguments to the constructor, but the
    BrokenEgg class has a parameterless constructor. So go ahead and **add parameters
    to the constructor**:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 这是另一个很好的机会***阅读这些错误***并找出哪里出错了。第一个错误非常清楚：创建BrokenEgg实例的语句试图传递两个参数给构造函数，但BrokenEgg类只有一个无参数的构造函数。因此，请**向构造函数添加参数**：
- en: '[PRE13]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: That takes care of the first error—now the Main method compiles just fine. What
    about the other error?
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 这解决了第一个错误—现在Main方法编译得很好。其他错误呢？
- en: 'Let’s break down what that error says:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分析一下那个错误说了什么：
- en: It’s complaining about *Egg.Egg(double, string)*—this refers to the Egg class
    constructor.
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它在*Egg.Egg(double, string)*上抱怨—这是指Egg类的构造函数。
- en: It says something about *parameter ’size’*, which the Egg class needs in order
    to set its Size property.
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它说了些关于*参数’大小’*的东西，这是Egg类需要的，以便设置其Size属性。
- en: But there is *no argument given*, because it’s not enough to just modify the
    BrokenEgg constructor to take arguments that match the parameter. It also needs
    to **call that base class constructor.**
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 但是*没有提供参数*，因为仅仅修改BrokenEgg构造函数以接受与参数相匹配是不够的。它还需要**调用基类构造函数**。
- en: Modify the BrokenEgg class to **use the `base` keyword to call the base class
    constructor:**
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 修改BrokenEgg类以**使用`base`关键字调用基类构造函数：**
- en: '[PRE14]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Now your code compiles. Try running it—now when a Pigeon lays an egg, about
    a quarter of them will print a message about being broken when they’re instantiated
    (but after that, the rest of the output is the same as before).
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你的代码编译了。尝试运行它—现在当鸽子下蛋时，大约四分之一的蛋在实例化时会打印关于破碎的消息（但之后，其余的输出与之前相同）。
- en: Note
  id: totrans-242
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: '![Images](assets/relax.png)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/relax.png)'
- en: '**It’s easy to go back to an old project.**'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '**轻松回到旧项目。**'
- en: You can get the IDE to load a previous project by choosing *Recent Projects
    and Solutions* (Windows) or *Recent Solutions* (Mac) from the File menu.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过从文件菜单中选择*最近的项目和解决方案*（Windows）或*最近的解决方案*（Mac）来让IDE加载以前的项目。
- en: A subclass and base class can have different constructors
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 子类和基类可以有不同的构造函数
- en: 'When we modified BrokenEgg to call the base class constructor, we made its
    constructor match the one in the Egg base class. What if we want all broken eggs
    to have a size of zero and a color that starts with the word “broken”? **Modify
    the statement that instantiates BrokenEgg** so it only takes the color argument:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们修改BrokenEgg以调用基类构造函数时，我们使其构造函数与Egg基类中的构造函数匹配。如果我们想让所有破碎的蛋的大小为零，并且颜色以“破碎”开头，**修改实例化BrokenEgg的语句**以只接受颜色参数：
- en: '[PRE15]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '***Modify this!***'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '***修改这个！***'
- en: When you make that change you’ll get the “required formal parameter” compiler
    error again—which makes sense, because the BrokenEgg constructor has two parameters,
    but you’re only passing it one argument.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 当你做出这些更改时，你会再次得到“必需形式参数”编译器错误—这是有道理的，因为BrokenEgg构造函数有两个参数，但你只传递了一个参数。
- en: 'Fix your code **by modifying the BrokenEgg constructor to take one parameter**:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 通过**修改BrokenEgg构造函数以接受一个参数**来修复你的代码：
- en: '![Images](assets/308fig001.png)'
  id: totrans-252
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/308fig001.png)'
- en: 'Now run your program again. The BrokenEgg constructor will still write its
    message to the console during the for loop in the Pigeon constructor, but now
    it will also cause the Egg to initialize its Size and Color fields. When the foreach
    loop in the Main method writes egg.Description to the console, it writes this
    message for each broken egg:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 现在再次运行你的程序。在鸽子构造函数的for循环中，BrokenEgg构造函数仍然会将其消息写入控制台，但现在它还会导致Egg初始化其Size和Color字段。当Main方法中的foreach循环将egg.Description写入控制台时，它会为每个破碎的蛋写入这条消息：
- en: '[PRE16]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Note
  id: totrans-255
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Did you know that pigeons typically only lay one or two eggs? How would you
    modify the Pigeon class to take this into account?
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 你知道鸽子通常只产下一到两个蛋吗？你会如何修改Pigeon类以考虑这一点？
- en: '![Images](assets/308fig01.png)![Images](assets/308fig02.png)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/308fig01.png)![图片](assets/308fig02.png)'
- en: It’s time to finish the job for Owen
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 是时候为Owen完成工作了
- en: 'The first thing you did in this chapter was modify the damage calculator you
    built for Owen to roll for damage for either a sword or an arrow. It worked, and
    your SwordDamage and ArrowDamage classes were well-encapsulated. But aside from
    a few lines of code, ***those two classes were identical***. You’ve learned that
    having code repeated in different classes is inefficient and error-prone, especially
    if you want to keep extending the program to add more classes for different kinds
    of weapons. Now you have a new tool to solve this problem: **inheritance**. So
    it’s time for you to finish the damage calculator app. You’ll do it in two steps:
    first you’ll design the new class model on paper, and then you’ll implement it
    in code.'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中你做的第一件事是修改为Owen构建的伤害计算器，以便为剑或箭进行伤害掷骰。它起作用了，你的SwordDamage和ArrowDamage类封装良好。但除了几行代码外，***这两个类是相同的***。你已经学会了在不同类中重复代码是低效和容易出错的，特别是如果你想继续扩展程序以添加更多不同种类武器的类。现在你有了一个解决这个问题的新工具：**继承**。所以现在是时候完成伤害计算器应用程序了。你将分两步完成：首先你会在纸上设计新的类模型，然后你会在代码中实现它。
- en: '**Building your class model on paper before you write code helps you understand
    your problem better so you can solve it more effectively.**'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '**在编写代码之前在纸上构建你的类模型有助于更好地理解问题，从而更有效地解决它。**'
- en: '![Images](assets/309fig001.png)'
  id: totrans-261
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/309fig001.png)'
- en: When your classes overlap as little as possible, that’s an important design
    principle called separation of concerns
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 当你的类尽可能少地重叠时，这是一个重要的设计原则，称为关注点分离。
- en: If you design your classes well today, they’ll be easier to modify later. Imagine
    if you had a dozen different classes to calculate damage for different weapons.
    What if you wanted to change Magic from a bool to an int, so you could have weapons
    with enchantment bonuses (like a +3 magic mace or +1 magic dagger)? With inheritance,
    you’d just have to change the Magic property in the superclass. Of course, you’d
    have to modify the CalculateDamage method for each class—but it would be a lot
    less work, and there’s no danger of accidentally forgetting to modify one of the
    classes. (That happens in professional software development *all the time!*)
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你今天设计好你的类，以后修改起来会更容易。想象一下，如果你有十几个不同的类来计算不同武器的伤害。如果你想将Magic从布尔值更改为整数，这样你就可以拥有具有附魔奖励的武器（如+3魔法权杖或+1魔法匕首）会怎样？通过继承，你只需更改超类中的Magic属性。当然，你必须修改每个类的CalculateDamage方法，但这将是更少的工作量，而且不会有遗漏修改其中一个类的危险。（这在专业软件开发中*经常发生！*）
- en: This is an example of **separation of concerns**, because each class has only
    the code that concerns one specific part of the problem that your program solves.
    Code that only concerns swords goes in SwordDamage, code only for arrows goes
    in ArrowDamage, and code that’s shared between them goes in WeaponDamage.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 这是**关注点分离**的一个例子，因为每个类只包含解决程序解决的问题的一个特定部分的代码。只涉及剑的代码放在SwordDamage中，只涉及箭的代码放在ArrowDamage中，而只涉及它们之间共享的代码放在WeaponDamage中。
- en: When you’re designing classes, separation of concerns is one of the first things
    you should think about. If one class seems to be doing two different things, try
    to figure out if you can split it into two classes.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 当你设计类时，关注点分离是你应该考虑的首要事项之一。如果一个类似乎在做两件不同的事情，试着看看是否可以将其拆分为两个类。
- en: '![Images](assets/311fig02.png)'
  id: totrans-266
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/311fig02.png)'
- en: '**When your classes are well-encapsulated, it makes your code much easier to
    modify.**'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '**当你的类封装良好时，它会使你的代码更容易修改。**'
- en: If you know a professional developer, ask them the most annoying thing they’ve
    had to do at work in the last year. There’s a good chance they’ll talk about having
    to make a change to a class, but to do that they had to change these two other
    classes, which required three other changes, and it was hard just to keep track
    of all the changes. Designing your classes with encapsulation in mind is a great
    way to avoid ending up in that situation.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你认识一个专业的开发者，问问他们在过去一年中工作中最让他们烦恼的事情是什么。他们很可能会谈到不得不修改一个类，但为了做到这一点，他们必须更改另外两个类，这就需要三个其他的更改，而且很难跟踪所有的更改。在设计类时考虑封装是避免陷入这种情况的好方法。
- en: Use the debugger to really understand how these classes work
  id: totrans-269
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用调试器真正理解这些类如何工作。
- en: 'One of the most important ideas in this chapter is that when you extend a class,
    you can override its methods to make pretty significant changes to the way it
    behaves. Use the debugger to really understand how that works:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中最重要的一个概念之一是，当你扩展一个类时，你可以重写它的方法，从而对它的行为做出相当大的改变。使用调试器真正理解它是如何工作的：
- en: '**Set breakpoints** on the lines in the Roll, Magic, and Flaming setters that
    call CalculateDamage.'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在调用CalculateDamage的Roll、Magic和Flaming setter行上设置断点。
- en: Add a Console.WriteLine statement to WeaponDamage.CalculateDamage. *This statement
    will never get called.*
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在WeaponDamage.CalculateDamage中添加一个Console.WriteLine语句。*这个语句永远不会被调用*。
- en: Run your program. When it hits any of the breakpoints, use **Step Into** to
    enter the CalculateDamage method. ***It will step into the subclass***—the WeaponDamage.CalculateDamage
    method is never called.
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行你的程序。当它命中任何断点时，使用**Step Into**进入CalculateDamage方法。***它将进入子类*** —— WeaponDamage.CalculateDamage
    方法从未被调用。
- en: Do This!
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 做这个！
- en: Note
  id: totrans-275
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'We’re about to talk about an important element of game design: dynamics. It’s
    actually such an important concept that it goes beyond game design. In fact, you
    can find dynamics in almost any kind of app.'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 我们即将讨论游戏设计的一个重要元素：动态性。实际上，它是一个如此重要的概念，以至于它超越了游戏设计。事实上，你几乎可以在任何类型的应用程序中找到动态性。
- en: Note
  id: totrans-277
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Dynamics can feel like a really abstract concept at first! We’ll spend more
    time on it later in the chapter—but for now, keep all of this stuff about dynamics
    in mind when you’re doing the next project. See if you can spot how dynamics come
    into play as you’re coding it.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 一开始，动态性可能感觉像一个非常抽象的概念！在本章后面的时间里我们会更多地讨论它 —— 但现在，在你编写下一个项目时，请记住所有与动态性相关的内容。
- en: '![Images](assets/315fig01.png)'
  id: totrans-279
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/315fig01.png)'
- en: '**Video games** *are* serious business.'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '**视频游戏** *是* 严肃的生意。'
- en: The video game industry is growing globally every year, and employs hundreds
    of thousands of people all over the world, and it’s a business that a talented
    game designer can break into! There’s an entire ecosystem of **independent game
    developers** who build and sell games, either as individuals or on small teams.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 视频游戏行业每年在全球范围内都在增长，并雇佣成千上万的人，这是一个有才华的游戏设计师可以进入的行业！有一个完整的**独立游戏开发者**生态系统，他们个人或小团队构建和销售游戏。
- en: But you’re right—C# is a serious language, and it’s used for all sorts of serious,
    non-gaming applications. In fact, while C# is a favorite language among game developers,
    it’s also one of the most common languages found in businesses across many different
    industries.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 但你是对的 —— C# 是一门严肃的语言，它被用于各种严肃的非游戏应用程序。事实上，虽然C#是游戏开发人员喜爱的语言之一，但它也是许多不同行业中的企业中最常见的语言之一。
- en: So for this next project, let’s get some practice with inheritance by building
    a ***serious business application***.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，对于下一个项目，让我们通过构建一个***严肃的商业应用程序***来练习继承。
- en: Note
  id: totrans-284
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Go to the Visual Studio for Mac Learner’s Guide for the Mac version of ths project.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 前往Visual Studio for Mac学习指南，查看该项目的Mac版本。
- en: Build a beehive management system
  id: totrans-286
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建一个蜂箱管理系统。
- en: '***The queen bee needs your help!*** Her hive is out of control, and she needs
    a program to help manage her honey production business. She’s got a beehive full
    of workers, and a whole bunch of jobs that need to be done around the hive, but
    somehow she’s lost control of which bee is doing what, and whether or not she’s
    got the beepower to do the jobs that need to be done. It’s up to you to build
    a **beehive management system** to help her keep track of her workers. Here’s
    how it’ll work.'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '***蜂王需要你的帮助！*** 她的蜂箱失控了，她需要一个程序来帮助管理她的蜜生产业务。她有一个满是工人的蜂箱，以及一大堆需要在蜂箱周围完成的工作，但不知何故，她失去了对哪只蜜蜂正在做什么以及她是否有足够的蜜能力来完成这些工作的控制。你需要建立一个**蜂箱管理系统**来帮助她跟踪她的工人。以下是它的工作原理。'
- en: '![Images](assets/316fig01.png)'
  id: totrans-288
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/316fig01.png)'
- en: '**The queen assigns jobs to her workers.**'
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**皇后分配工作给她的工人们。**'
- en: There are three different jobs that the workers can do. **Nectar collector**
    bees fly out and bring nectar back to the hive. **Honey manufacturer** bees turn
    that nectar into honey, which bees eat to keep working. Finally, the queen is
    constantly laying eggs, and **egg care** bees make sure they become workers.
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 工人们可以做三种不同的工作。**采蜜蜂**飞出去将花蜜带回蜂箱。**制蜜蜂**把花蜜转化为蜜，蜜蜂吃以维持工作。最后，蜂王不断产卵，**蛋护理**蜜蜂确保它们成为工人。
- en: '**When the jobs are all assigned, it’s time to work.**'
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**当所有工作都分配完毕，就是工作的时候了。**'
- en: Once the queen’s done assigning the work, she’ll tell the bees to work the next
    shift by clicking the “Work the next shift” button in her Beehive Management System
    app, which generates a shift report that tells her how many bees are assigned
    to each job and the status of the nectar and honey in the **honey vault**.
  id: totrans-292
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 皇后分配工作完成后，她会通过在她的蜂箱管理系统应用程序中点击“开始下一个班次”按钮，告诉蜜蜂们去工作，这将生成一个班次报告，告诉她分配到每个工作的蜜蜂数量以及蜜罐中花蜜和蜜的状态。
- en: '![Images](assets/316fig02.png)'
  id: totrans-293
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](assets/316fig02.png)'
- en: Like all business leaders, the queen is focused on **growth**. The beehive business
    is hard work, and she measures her hive in the total number of workers. Can you
    help the queen keep adding workers? How big can she grow the hive before it runs
    out of honey and she has to file for bee-nkruptcy?
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 就像所有的业务领袖一样，皇后专注于**增长**。蜂箱业务是一项艰苦的工作，她用工蜂的总人数来衡量她的蜂箱。你能帮助皇后继续增加工蜂吗？她能在蜜用尽之前让蜂箱增长到多大？
- en: The beehive management system class model
  id: totrans-295
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 蜂箱管理系统类模型
- en: Here are the classes that you’ll build for the beehive management system. There’s
    an inheritance model with a base class and four subclasses, a static class to
    manage the honey and nectar that drive the hive business, and the MainWindow class
    with the code-behind for the main window.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是你将为蜂箱管理系统构建的类。有一个带有基类和四个子类的继承模型，一个静态类来管理驱动蜂箱业务的蜜和花蜜，以及具有主窗口代码后台的`MainWindow`类。
- en: '![Images](assets/317fig01.png)'
  id: totrans-297
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/317fig01.png)'
- en: Note
  id: totrans-298
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: '![Images](assets/relax.png)'
  id: totrans-299
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/relax.png)'
- en: '**This class model is just the start. We’ll give more details so you can write
    the code.**'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '**这个类模型只是一个开始。我们将提供更多细节，以便您编写代码。**'
- en: Examine this class model really carefully. It has a lot of information about
    the app you’re about to build. Next, we’ll give you all of the details you need
    to write the code for these classes.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细检查这个类模型。它包含了即将构建的应用程序的大量信息。接下来，我们将为您提供编写这些类所需的所有细节。
- en: 'The Queen class: how she manages the worker bees'
  id: totrans-302
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 皇后类：她如何管理工蜂
- en: 'When you **press the button to work the next shift**, the button’s Click event
    handler calls the Queen object’s WorkTheNextShift method, which is inherited from
    the Bee base class. Here’s what happens next:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 当你**按下按钮来开始下一个班次**时，按钮的点击事件处理程序调用了皇后对象的`WorkTheNextShift`方法，该方法继承自蜜蜂基类。接下来会发生以下事情：
- en: Bee.WorkTheNextShift calls HoneyVault.ConsumeHoney(HoneyConsumed), using the
    CostPerShift property (which each subclass overrides with a different value) to
    determine how much honey she needs to work.
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Bee.WorkTheNextShift`调用`HoneyVault.ConsumeHoney(HoneyConsumed)`，使用`CostPerShift`属性（每个子类使用不同值进行覆盖）来确定她需要多少蜜来工作。'
- en: Bee.WorkTheNextShift then calls DoJob, which the Queen also overrides.
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Bee.WorkTheNextShift`接着调用`DoJob`，皇后也对此进行了重写。'
- en: Queen.DoJob adds 0.45 eggs to her private eggs field (using a const called EGGS_PER_SHIFT).
    The EggCare bee will call her CareForEggs method, which decreases eggs and increases
    unassignedWorkers.
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Queen.DoJob`会向她的私人蛋字段添加0.45个蛋（使用一个名为`EGGS_PER_SHIFT`的常量）。`EggCare`蜜蜂将调用她的`CareForEggs`方法，这会减少蛋的数量并增加未分配工人的数量。'
- en: Then it uses a foreach loop to call each worker’s WorkTheNextShift method.
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后它使用foreach循环调用每个工作人员的WorkTheNextShift方法。
- en: It consumes honey for each unassigned worker. The HONEY_PER_UNASSIGNED_WORKER
    const tracks how much each one consumes per shift.
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个未分配的工作人员每个班次消耗蜂蜜。常量HONEY_PER_UNASSIGNED_WORKER跟踪每个工作人员每班次消耗的蜂蜜量。
- en: Finally, it calls its UpdateStatusReport method.
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，它调用它的UpdateStatusReport方法。
- en: When you **press the button to assign a job** to a bee, the event handler calls
    the Queen object’s AssignBee method, which takes a string with the job name (you’ll
    get that name from jobSelector.text). It uses a `switch` statement to create a
    new instance of the appropriate Bee subclass and pass it to AddWorker, so make
    sure you **add the AddWorker method** below to your Queen class.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 当您**按下按钮分配工作**给一只蜜蜂时，事件处理程序调用女王对象的AssignBee方法，该方法接受一个字符串作为工作名称（您将从jobSelector.text中获取该名称）。它使用`switch`语句来创建适当的Bee子类的新实例，并将其传递给AddWorker，所以确保您在Queen类中**添加AddWorker方法**。
- en: '![Images](assets/318fig01.png)'
  id: totrans-311
  prefs: []
  type: TYPE_IMG
  zh: '![图像](assets/318fig01.png)'
- en: Note
  id: totrans-312
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: '**The length of an Array instance can’t be changed during its lifetime. That’s
    why C# has this useful static **Array.Resize method.** It doesn’t actually resize
    the array. Instead, it creates a new one and copies the contents of the old one
    into it. Notice how it uses the ref keyword—we’ll learn more about that later
    in the book.**'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '**Array实例的长度在其生命周期中不能被更改。这就是为什么C#有这个有用的静态**Array.Resize方法。它实际上不会调整数组的大小。相反，它会创建一个新数组，并将旧数组的内容复制到新数组中。请注意它如何使用ref关键字——我们将在本书的后面学到更多关于它的知识。**'
- en: '[PRE17]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Note
  id: totrans-315
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: You’ll need this AddWorker method to add a new worker to the Queen’s worker
    array. It calls Array.Resize to expand the array, then adds the new worker Bee
    to it.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 要将新工作人员添加到女王的工作人员数组中，您需要使用这个AddWorker方法。它调用Array.Resize来扩展数组，然后将新工作人员Bee添加到数组中。
- en: 'The UI: add the XAML for the main window'
  id: totrans-317
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: UI：为主窗口添加XAML
- en: Create a **new WPF app called BeehiveManagementSystem**. The main window is
    laid out with a grid, with `Title="Beehive Management System" Height="325" Width="625"`.
    It uses the same Label, StackPanel, and Button controls you’ve used in previous
    chapters, and introduces two new controls. The dropdown list under Job Assignments
    is a **ComboBox** control, which lets users choose from a list of options. The
    status report under Queen’s Report is displayed in a **TextBox** control.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为**蜂巢管理系统**的新WPF应用程序。主窗口采用一个网格布局，`Title="蜂巢管理系统" Height="325" Width="625"`。它使用了您在前几章中使用过的相同的Label、StackPanel和Button控件，并引入了两个新控件。作业分配下拉列表是一个**ComboBox**控件，允许用户从一个选项列表中进行选择。女王报告下的状态报告显示在一个**TextBox**控件中。
- en: '![Images](assets/319fig01.png)![Images](assets/319fig03.png)'
  id: totrans-319
  prefs: []
  type: TYPE_IMG
  zh: '![图像](assets/319fig01.png)![图像](assets/319fig03.png)'
- en: Note
  id: totrans-320
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Don’t get overwhelmed or intimidated by the length of this exercise! Just break
    it down into small steps. Once you start working on it, you’ll see it’s all review
    of things you’ve learned.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 不要被这个练习的长度所吓倒或者感到不知所措！只需将其分解为小步骤。一旦开始工作，您会发现这都是您学到的东西的复习。
- en: '![Images](assets/327fig01.png)'
  id: totrans-322
  prefs: []
  type: TYPE_IMG
  zh: '![图像](assets/327fig01.png)'
- en: '**OK, you got us. Yes, you’re right. This is a game.**'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '**好吧，你们猜对了。是的，这是一个游戏。**'
- en: Specifically, it’s a **resource management game**, or a game where the mechanics
    are focused on collecting, monitoring, and using resources. If you’ve played a
    simulation game like SimCity or strategy game like Civilization, you’ll recognize
    resource management as a big part of the game, where you need resources like money,
    metal, fuel, wood, or water to run a city or build an empire.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，这是一个**资源管理游戏**，或者一个重点放在收集、监控和使用资源上的游戏。如果您玩过像SimCity这样的模拟游戏或者像文明这样的策略游戏，您将会认识到资源管理是游戏的重要部分，您需要资源如金钱、金属、燃料、木材或水来运营一个城市或建立一个帝国。
- en: 'Resource management games are a great way to experiment with the relationship
    between ***mechanics, dynamics, and aesthetics***:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '**资源管理游戏是实验***机制、动态和美学***关系的绝佳方式：'
- en: 'The **mechanics** are simple: the player assigns workers and then initiates
    the next shift. Then each bee either adds nectar, reduces nectar/increases honey,
    or reduces eggs/increases workers. The egg count increases, and the report is
    displayed.'
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**机制**很简单：玩家分配工作人员，然后启动下一个班次。然后每只蜜蜂要么添加花蜜，要么减少花蜜/增加蜂蜜，要么减少卵/增加工作人员。卵数增加，并显示报告。'
- en: The **aesthetics** are more complex. Players feel stress as the honey or nectar
    levels fall and the low level warning is displayed. They feel excitement when
    they make a choice, and satisfaction when it affects the game—and then stress
    again, as the numbers stop increasing and start decreasing again.
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**美学**更加复杂。玩家感受到当蜜或花蜜水平下降时的压力，并显示低水平警告时的兴奋。当他们做出选择并影响游戏时感到满足——然后再次感到压力，因为数字停止增加并开始再次减少。'
- en: The game is driven by the **dynamics**. There’s nothing in the code that makes
    the honey or nectar scarce—they’re just consumed by the bees and eggs.
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 游戏由**动态**驱动。没有任何代码使蜂蜜或花蜜稀缺——它们只是被蜜蜂和蛋消耗。
- en: Note
  id: totrans-329
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注：
- en: Really take a minute and think about this, because it gets to the heart of what
    dynamics are about. Do you see any way to use some of these ideas in other kinds
    of programs, and not just games?
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 真的花一分钟思考这个，因为它触及到动态本质。你看到如何在其他类型的程序中使用其中一些想法，而不仅仅是游戏吗？
- en: Feedback drives your Beehive Management game
  id: totrans-331
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 反馈驱动你的蜂巢管理游戏。
- en: Let’s take a few minutes and really understand how this game works. The nectar
    conversion ratio has a big impact on your game. If you change the constants, it
    can make really big differences in gameplay. If it takes just a little honey to
    convert an egg to a worker, the game gets really easy. If it takes a lot, the
    game gets much harder. But if you go through the classes, you won’t find a difficulty
    setting. There’s no Difficultly field on any of them. Your Queen doesn’t get special
    power-ups to help make the game easier, or tough enemies or boss battles to make
    it more difficult. In other words, there’s ***no code that explicitly creates
    a relationship*** between the number of eggs or workers and the difficulty of
    the game. So what’s going on?
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们花几分钟真正了解这款游戏是如何运作的。花蜜转化比对你的游戏有很大影响。如果你改变常数，它可能会对游戏玩法产生很大影响。如果只需少量蜂蜜即可将蛋转化为工蜂，游戏会变得非常容易。如果需要很多，游戏会变得更加困难。但是如果你查看类，你不会找到困难设置。在任何类上都没有困难字段。你的女王不会获得特殊的力量来帮助游戏变得更容易，或者艰难的敌人或boss战来增加难度。换句话说，没有明确创建蛋或工蜂数量与游戏难度之间关系的***代码***。那么究竟发生了什么？
- en: 'You’ve probably played with **feedback** before. Start a video call between
    your phone and your computer. Hold the phone near the computer speaker and you’ll
    hear noisy echoes. Point the camera at the computer screen and you’ll see a picture
    of the screen inside the picture of the screen inside the picture of the screen,
    and it will turn into a crazy pattern if you tilt the phone. This is feedback:
    you’re taking the live video or audio output and *feed*ing it right *back* into
    the input. There’s nothing in the code of the video call app that specifically
    generates those crazy sounds or images. Instead, they **emerge** from the feedback.'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能之前玩过**反馈**。在你的手机和电脑之间启动一个视频通话。将手机靠近电脑扬声器，你会听到嘈杂的回声。将相机对准电脑屏幕，你会看到屏幕的图像在图像的屏幕中，如果你倾斜手机，它将变成一个疯狂的图案。这就是反馈：你正在将实时视频或音频输出反馈到输入中。视频通话应用程序的代码中没有专门生成那些疯狂声音或图像的部分。相反，它们是从反馈中**出现**的。
- en: '![Images](assets/328fig01.png)'
  id: totrans-334
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/328fig01.png)'
- en: Workers and honey are in a feedback loop
  id: totrans-335
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工人和蜂蜜处于反馈循环中。
- en: 'Your Beehive Management game is based on a series of **feedback loops**: lots
    of little cycles where parts of the game interact with each other. For example,
    honey manufacturers add honey to the vault, which is consumed by honey manufacturers,
    who make more honey.'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 你的蜂巢管理游戏是基于一系列**反馈循环**：许多小循环，在游戏的各个部分相互作用。例如，蜂蜜生产商向金库中添加蜂蜜，蜂蜜被蜜蜂消耗，蜜蜂再制造更多的蜂蜜。
- en: '![Images](assets/328fig02.png)'
  id: totrans-337
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/328fig02.png)'
- en: And that’s just one feedback loop. There are many different feedback loops in
    your game, and they make the whole game more complex, more interesting, and (hopefully!)
    more fun.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一个反馈循环。在你的游戏中有许多不同的反馈循环，它们使整个游戏变得更加复杂、更加有趣，希望是更加有趣的。
- en: '![Images](assets/328fig03.png)'
  id: totrans-339
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/328fig03.png)'
- en: The Beehive Management System is turn-based...now let’s convert it to real-time
  id: totrans-340
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 蜂巢管理系统是一种回合制的……现在让我们将其转换为实时。
- en: A **turn-based game** is a game where the flow is broken down into parts—in
    the case of the Beehive Management System, into shifts. The next shift doesn’t
    start until you click a button, so you can take all the time you want to assign
    workers. We can use a DispatcherTimer (like the one you used in [#start_building_with_chash_build_somethin](ch01.html#start_building_with_chash_build_somethin))
    to **convert it to a real-time game** where time progresses continuously—and we
    can do it with just a few lines of code.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: '**回合制游戏**是将游戏流程分解为若干部分的游戏——在蜂巢管理系统的情况下，分解为轮次。只有当您点击按钮时，下一个轮次才会开始，因此您可以随意分配工人。我们可以使用一个`DispatcherTimer`（就像您在[#start_building_with_chash_build_somethin](ch01.html#start_building_with_chash_build_somethin)中使用的那个）将其**转换为实时游戏**，而且只需几行代码即可实现。'
- en: '**Add a using line to the top of your MainWindow.xaml.cs file.**'
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**在您的MainWindow.xaml.cs文件顶部添加一个using行。**'
- en: 'We’ll be using a DispatcherTimer to force the game to work the next shift every
    second and a half. DispatcherTimer is in the System.Windows.Threading namespace,
    so you’ll need to add this `using` line to the top of your *MainWindow.xaml.cs*
    file:'
  id: totrans-343
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将使用一个`DispatcherTimer`来强制游戏每隔一秒半进行下一轮操作。`DispatcherTimer`位于`System.Windows.Threading`命名空间中，因此您需要将以下`using`行添加到您的*MainWindow.xaml.cs*文件顶部：
- en: '[PRE18]'
  id: totrans-344
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Note
  id: totrans-345
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: '**You used a DispatcherTimer in [#start_building_with_chash_build_somethin](ch01.html#start_building_with_chash_build_somethin)
    to add a timer to your animal matching game. This code is very similar to the
    code you used in [#start_building_with_chash_build_somethin](ch01.html#start_building_with_chash_build_somethin).
    Take a few minutes and flip back to that project to remind yourself how the DispatcherTimer
    works.**'
  id: totrans-346
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**您在[#start_building_with_chash_build_somethin](ch01.html#start_building_with_chash_build_somethin)中使用了一个`DispatcherTimer`为您的动物匹配游戏添加了一个计时器。这段代码与您在[#start_building_with_chash_build_somethin](ch01.html#start_building_with_chash_build_somethin)中使用的代码非常相似。花几分钟回顾一下那个项目，以便提醒自己`DispatcherTimer`的工作原理。**'
- en: '**Add a private field with a DispatcherTimer reference.**'
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**添加一个私有字段，引用一个`DispatcherTimer`。**'
- en: 'Now you’ll need to create a new DispatcherTimer. Put it in a private field
    at the top of the MainWindow class:'
  id: totrans-348
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在您需要创建一个新的`DispatcherTimer`。将其放在MainWindow类的顶部作为一个私有字段：
- en: '[PRE19]'
  id: totrans-349
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '**Make the timer call the WorkShift button’s Click event handler method.**'
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**使计时器调用“工作轮次”按钮的Click事件处理方法。**'
- en: 'We want the timer to keep the game moving forward, so if the player doesn’t
    click the button quickly enough it will automatically trigger the next shift.
    Start by adding this code:'
  id: totrans-351
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们希望计时器能够推动游戏向前发展，因此如果玩家不足够快地点击按钮，它将自动触发下一轮操作。首先添加以下代码：
- en: '![Images](assets/330fig01.png)'
  id: totrans-352
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](assets/330fig01.png)'
- en: Now run your game. A new shift starts every 1.5 seconds, whether or not you
    click the button. This is a small change to the mechanics, but it ***dramatically
    changes the dynamics of the game***, which leads to a huge difference in aesthetics.
    It’s up to you to decide if the game is better as a turn-based or real-time simulation.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行游戏。每隔1.5秒钟就会开始一个新的轮次，无论您是否点击按钮。这对机制来说是一个小变化，但它***显著改变了游戏的动态***，从而在美学上产生了巨大差异。由您决定游戏是作为回合制还是实时模拟更好。
- en: '![Images](assets/331fig01.png)'
  id: totrans-354
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/331fig01.png)'
- en: '**Yes! The timer changed the mechanics, which altered the dynamics, which in
    turn impacted the aesthetics.**'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: '**是的！计时器改变了机制，从而改变了动态，进而影响了美学。**'
- en: 'Let’s take a minute and think about that feedback loop. The change in mechanics
    (a timer that automatically clicks the “Work the next shift” button every 1.5
    seconds) creates a totally new dynamic: a window when players must make decisions,
    or else the game makes the decision for them. That increases the pressure, which
    gives some players a satisfying shot of adrenaline, but just causes stress in
    other players—the aesthetics changed, which makes the game more fun for some people
    but less fun for others.'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们花一分钟思考一下这个反馈循环。机制的变化（每隔1.5秒自动点击“进行下一轮操作”按钮的计时器）创造了一个全新的动态：玩家必须在一定时间内做出决策，否则游戏会替他们做出决策。这增加了压力，对某些玩家来说提供了令人满意的肾上腺素冲击，但对其他玩家来说只是造成了压力——美学发生了变化，对一些人来说使游戏更有趣，但对其他人来说则没那么有趣。
- en: But you only added half a dozen lines of code to your game, and none of them
    included “make this decision or else” logic. That’s an example of behavior that
    **emerged** from how the timer and the button work together.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 但是您只向游戏中添加了半打行代码，而且其中没有包括“做出这个决定，否则”的逻辑。这是计时器和按钮如何协同工作所**衍生出的**行为的一个例子。
- en: Note
  id: totrans-358
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: There’s a feedback loop here, too. As players feels more stress, they make worse
    decisions, changing the game... aesthetics feeds back into mechanics.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 这里也有一个反馈环路。随着玩家感受到更大的压力，他们会做出更糟糕的决策，改变游戏……美学反过来影响了机制。
- en: '![Images](assets/331fig02.png)'
  id: totrans-360
  prefs: []
  type: TYPE_IMG
  zh: '![图像](assets/331fig02.png)'
- en: '**Feedback loops and emergence are important programming concepts.**'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: '**反馈环路和新兴行为是重要的编程概念。**'
- en: We designed this project to give you practice with inheritance, but *also* to
    let you explore and experiment with **emergent** behavior. That’s behavior that
    comes not just from what your objects do individually, but also out of ***the
    way objects interact with each other***. The constants in the game (like the nectar
    conversion ratio) are an important part of that emergent interaction. When we
    created this exercise, we started out by setting those constants to some initial
    values, then we tweaked them by making tiny adjustments until we ended up with
    a system that’s not quite in **equilibrium**—a state where everything is perfectly
    balanced—so the player needs to keep making decisions in order to make the game
    last as long as possible. That’s all driven by the feedback loops between the
    eggs, workers, nectar, honey, and queen.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 我们设计这个项目是为了让你练习继承，*同时*让你探索和实验**新兴**行为。这种行为不仅来自于你的对象单独做什么，还来自于***对象之间如何相互作用***。游戏中的常数（如花蜜转换比）是这种新兴互动的重要组成部分。当我们创建这个练习时，我们从一些初始值开始设置这些常数，然后通过微小的调整来调整它们，直到我们得到一个不完全处于**平衡**状态的系统——这是一种一切都完美平衡的状态——所以玩家需要继续做出决策，以尽可能地延长游戏时间。这一切都受到蛋、工人、花蜜、蜂蜜和女王之间的反馈环路的驱动。
- en: Note
  id: totrans-363
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Try experimenting with these feedback loops. Add more eggs per shift or start
    the hive with more honey, for example, and the game gets easier. Go ahead, give
    it a try! You can change the entire feel of the game just by making small changes
    to a few constants.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试用这些反馈环路进行实验。例如，每班增加更多的蛋或者用更多的蜜开始蜂巢，游戏会变得更容易。继续吧，试试看！你可以通过对几个常数进行小的修改来改变整个游戏的感觉。
- en: Some classes should never be instantiated
  id: totrans-365
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 有些类永远不应该被实例化
- en: Remember our zoo simulator class hierarchy? You’ll definitely end up instantiating
    a bunch of Hippos, Dogs, and Lions. What about the Canine and Feline classes?
    How about the Animal class? It turns out that **there are some classes that just
    don’t need to be instantiated**...and, in fact, *don’t make any sense* if they
    are.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 还记得我们的动物园模拟器类层次结构吗？你肯定会实例化一堆河马、狗和狮子。那么Canine和Feline类呢？动物类呢？事实证明，**有些类根本不需要被实例化**……实际上，*如果它们被实例化了，就毫无意义*。
- en: Does that sound weird? Actually, it happens all the time—in fact, you created
    several classes earlier in the chapter that should never be instantiated.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 听起来奇怪吗？事实上，这种情况经常发生——事实上，你在本章早些时候创建了几个类，它们永远不应该被实例化。
- en: '![Images](assets/332fig01.png)'
  id: totrans-368
  prefs: []
  type: TYPE_IMG
  zh: '![图像](assets/332fig01.png)'
- en: '[PRE20]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '![Images](assets/332fig02.png)'
  id: totrans-370
  prefs: []
  type: TYPE_IMG
  zh: '![图像](assets/332fig02.png)'
- en: '[PRE21]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Note
  id: totrans-372
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: '**Your Bird class was tiny—it just had a shared instance of Random and a LayEggs
    method that only existed so the subclasses could override it. Your WeaponDamage
    class was a lot bigger—it had a lot of properties. It also had a CalculateDamage
    class for the subclasses to override, which it called from its WeaponDamage method.**'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: '**你的Bird类很小——它只有一个共享的Random实例和一个LayEggs方法，只存在于子类可以覆盖它的情况下。你的WeaponDamage类要大得多——它有很多属性。它还有一个CalculateDamage类，供子类覆盖，它从它的WeaponDamage方法调用。**'
- en: '![Images](assets/333fig01.png)'
  id: totrans-374
  prefs: []
  type: TYPE_IMG
  zh: '![图像](assets/333fig01.png)'
- en: '[PRE22]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Note
  id: totrans-376
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: '**The Bee class had a WorkTheNextShift method that consumed honey and then
    did whatever job the bee was supposed to do—so it expected the subclass to override
    the DoJob method to actually do the job.**'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: '**Bee类有一个WorkTheNextShift方法，消耗蜜然后做蜜蜂应该做的工作——因此它期望子类覆盖DoJob方法来实际执行工作。**'
- en: An abstract class is an intentionally incomplete class
  id: totrans-378
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 抽象类是一个有意不完整的类
- en: It’s really common to have a class with “placeholder” members that it expects
    the subclasses to implement. It could be at the top of the hierarchy (like your
    Bee, WeaponDamage, or Bird classes) or in the middle (like Feline or Canine in
    the zoo simulator class model). They take advantage of the fact that C# always
    calls the most specific method, like how WeaponDamage calls the CalculateDamage
    method that’s only implemented in SwordDamage or ArrowDamage, or how Bee.WorkTheNextShift
    depends on the subclasses to implement the DoJob method.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 很常见的情况是有一个类具有“占位符”成员，期望子类来实现。它可以位于层次结构的顶部（例如Bee、WeaponDamage或Bird类）或中间（例如动物园模拟器类模型中的Feline或Canine）。它们利用C#总是调用最具体方法的特性，例如WeaponDamage调用仅在SwordDamage或ArrowDamage中实现的CalculateDamage方法，或者Bee.WorkTheNextShift依赖于子类来实现DoJob方法。
- en: 'C# has a tool that’s built specifically for this: an **abstract class**. It’s
    a class that’s intentionally incomplete, with empty class members that serve as
    placeholders for the subclasses to implement. To make a class abstract, **add
    the** `abstract` **keyword to the class declaration**. Here’s what you need to
    know about abstract classes.'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: C#专门为此构建了一个工具：**抽象类**。这是一个故意不完整的类，其中的空类成员作为子类实现的占位符。要使一个类成为抽象类，需在类声明中添加`abstract`关键字。以下是关于抽象类的重要内容。
- en: '**An abstract class works just like a normal class.**'
  id: totrans-381
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**抽象类的工作方式与普通类完全相同。**'
- en: You define an abstract class just like a normal one. It has fields and methods,
    and it can inherit from other classes, too, exactly like a normal class. There’s
    almost nothing new to learn.
  id: totrans-382
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 定义抽象类与定义普通类几乎完全相同。它有字段和方法，可以像普通类一样继承其他类。几乎没有什么新的东西需要学习。
- en: '**An abstract class can have incomplete “placeholder” members.**'
  id: totrans-383
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**抽象类可以具有不完整的“占位符”成员。**'
- en: An abstract class can include declarations of properties and methods that must
    be implemented by inheriting classes. A method that has a declaration but no statements
    or method body is called an **abstract method**, and a property that only declares
    its accessors but doesn’t define them is called an **abstract property**. Subclasses
    that extend it must implement all abstract methods and properties unless they’re
    also abstract.
  id: totrans-384
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 抽象类可以包含需要由继承类实现的属性和方法声明。具有声明但没有语句或方法体的方法称为**抽象方法**，而仅声明其访问器而不定义其方法体的属性称为**抽象属性**。扩展抽象类的子类必须实现所有抽象方法和属性，除非它们本身也是抽象的。
- en: '**Only abstract classes can have abstract members.**'
  id: totrans-385
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**只有抽象类可以拥有抽象成员。**'
- en: If you put an abstract method or property into a class, then you’ll have to
    mark that class abstract or your code won’t compile. You’ll learn more about how
    to mark a class abstract in a minute.
  id: totrans-386
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你在一个类中放置了抽象方法或属性，则必须将该类标记为抽象，否则你的代码将无法编译。稍后你将了解如何将类标记为抽象。
- en: '**An abstract class can’t be instantiated.**'
  id: totrans-387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**抽象类不能被实例化。**'
- en: The opposite of abstract is **concrete**. A concrete method is one that has
    a body, and all the classes you’ve been working with so far are concrete classes.
    The biggest difference between an **abstract** class and a **concrete** class
    is that you can’t use `new` to create an instance of an abstract class. If you
    do, C# will give you an error when you try to compile your code.
  id: totrans-388
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 抽象的反义词是**具体**。具体方法是有方法体的方法，到目前为止你所使用的所有类都是具体类。抽象类和具体类最大的不同之处在于你不能使用`new`关键字创建抽象类的实例。如果尝试这样做，C#在编译代码时会报错。
- en: 'Try it now! **Create a new console app**, add an empty abstract class, and
    try to instantiate it:'
  id: totrans-389
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在试试吧！**创建一个新的控制台应用程序**，添加一个空的抽象类，并尝试实例化它：
- en: '![Images](assets/334fig01.png)'
  id: totrans-390
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](assets/334fig01.png)'
- en: '![Images](assets/335fig01.png)'
  id: totrans-391
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/335fig01.png)'
- en: '**Because you want to provide some of the code, but still require that subclasses
    fill in the rest of the code.**'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: '**因为你希望提供部分代码，但仍然要求子类填写其余的代码。**'
- en: Sometimes ***bad things happen*** when you create objects that should never
    be instantiated. The class at the top of your class diagram usually has some fields
    that it expects its subclasses to set. An Animal class may have a calculation
    that depends on a Boolean called HasTail or Vertebrate, but there’s no way for
    it to set that itself. ***Here’s a quick example of a class that’s problematic
    when instantiated...***
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候当你创建不应该被实例化的对象时***会发生糟糕的事情***。类图顶部的类通常有一些字段，它期望其子类设置。例如，Animal类可能有一个依赖于名为HasTail或Vertebrate的布尔值的计算，但它本身无法设置这些值。***以下是一个创建该类时出现问题的快速示例...***
- en: '***Do this!***'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: '***做这个！***'
- en: '[PRE23]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '**Before you run this code, can you figure out what it will print to the console?**'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: '**在运行此代码之前，你能猜到它会打印什么到控制台吗？**'
- en: '![Images](assets/336fig001.png)'
  id: totrans-397
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/336fig001.png)'
- en: Like we said, some classes should never be instantiated
  id: totrans-398
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 正如我们所说，有些类永远不应该被实例化。
- en: 'Try running the PlanetMission console app. Did it do what you expected? It
    printed two lines to the console:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试运行PlanetMission控制台应用程序。它表现如你所期望的吗？它在控制台打印了两行：
- en: '[PRE24]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: But then it threw an exception.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 但然后它抛出了一个异常。
- en: The problems all started when you created an instance of the PlanetMission class.
    Its FuelNeeded method expects the fields to be set by the subclass. When they
    aren’t, they get their default values—zero. When C# tries to divide a number by
    zero...
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 所有问题都始于你创建PlanetMission类的实例。它的FuelNeeded方法期望子类设置字段。当它们没有设置时，它们会得到它们的默认值——零。当C#试图将一个数字除以零时……
- en: '![Images](assets/336fig01.png)'
  id: totrans-403
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/336fig01.png)'
- en: 'Solution: use an abstract class'
  id: totrans-404
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案：使用一个抽象类
- en: 'When you mark a class `abstract`, C# won’t let you write code to instantiate
    it. So how does that fix this problem? It’s like the old saying goes—prevention
    is better than cure. Add the `abstract` keyword to the PlanetMission class declaration:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将一个类标记为`abstract`时，C#不会让你编写代码来实例化它。那么这如何解决这个问题呢？就像古话说的那样——预防胜于治疗。在PlanetMission类声明中添加`abstract`关键字：
- en: '![Images](assets/336fig02.png)'
  id: totrans-406
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/336fig02.png)'
- en: 'As soon as you make the change, the compiler gives you an error:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你做出这个改变，编译器就会给你一个错误：
- en: '![Images](assets/336fig03.png)'
  id: totrans-408
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/336fig03.png)'
- en: 'Your code won’t compile at all—and no compiled code means no exception. This
    is really similar to the way you used the `private` keyword in [#encapsulation_keep_your_privateshellippr](ch05.html#encapsulation_keep_your_privateshellippr),
    or `virtual` and `override` earlier in this chapter. Making some members private
    doesn’t change the behavior. It just prevents your code from building if you break
    the encapsulation. The `abstract` keyword works the same way: you’ll never get
    an exception instantiating an abstract class because the C# compiler *won’t let
    you instantiate one in the first place*.'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 你的代码根本编译不了——没有编译的代码就没有异常。这与你在[#封装_保持您的私人信息](ch05.html#encapsulation_keep_your_privateshellippr)中使用`private`关键字的方式非常相似，或者在本章早些时候使用`virtual`和`override`关键字一样。使一些成员私有并不会改变行为。它只是防止你的代码在违反封装性时编译。`abstract`关键字的工作方式也相同：你永远不会因为实例化抽象类而得到异常，因为C#编译器*根本不允许你首先实例化它*。
- en: When you add the abstract keyword to a class declaration, the compiler gives
    you an error any time you try to create an instance of that class.
  id: totrans-410
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当你在类声明中添加abstract关键字时，每当你试图创建该类的实例时，编译器都会给出一个错误。
- en: An abstract method doesn’t have a body
  id: totrans-411
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个抽象方法没有方法体
- en: 'The Bird class that you built was never meant to be instantiated. That’s why
    it uses Console.Error to write an error message if a program tries to instantiate
    it and call its LayEggs method:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 你构建的Bird类从来就不是用来实例化的。这就是为什么如果程序试图实例化它并调用其LayEggs方法，它会使用Console.Error输出错误消息：
- en: '[PRE25]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Since we don’t ever want to instantiate the Bird class, let’s add the `abstract`
    keyword to its declaration. But that’s not enough—not only should this class never
    be instantiated, but we want to **require** that every subclass that extends Bird
    **must override the LayEggs method**.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们根本不希望实例化Bird类，让我们在其声明中添加`abstract`关键字。但这还不够——不仅应该禁止实例化这个类，而且我们希望**要求**每个扩展Bird的子类**必须覆盖**LayEggs方法。
- en: And that’s exactly what happens when you add the `abstract` keyword to a class
    member. An **abstract method** only has a class declaration but ***no method body***
    that must be implemented by any subclass that extends the abstract class. The
    **body** of a method is the code between the curly braces that comes after the
    declaration—and it’s something abstract methods can’t have.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是当你在类成员中添加`abstract`关键字时发生的情况。一个**抽象方法**只有一个类声明，但是***没有方法体***，必须由任何扩展抽象类的子类实现。方法的**方法体**是在声明之后的大括号之间的代码，这是抽象方法不能拥有的。
- en: 'Go back to your Bird project from earlier and **replace the Bird class** with
    this abstract class:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 回到你之前的鸟项目，用这个抽象类**替换Bird类**：
- en: '![Images](assets/337fig03.png)'
  id: totrans-417
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/337fig03.png)'
- en: '[PRE26]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Your program still runs exactly like it did before! But try adding this line
    to the Main method:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 你的程序仍然像之前一样运行！但尝试在Main方法中添加这一行：
- en: '[PRE27]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'and you’ll get a compiler error:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 你会得到一个编译器错误：
- en: '![Images](assets/337fig01.png)'
  id: totrans-422
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/337fig01.png)'
- en: 'Try to add a body to the LayEggs method:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试给LayEggs方法添加一个方法体：
- en: '[PRE28]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'and you’ll get a different compiler error:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 你会得到一个不同的编译器错误：
- en: '![Images](assets/337fig02.png)'
  id: totrans-426
  prefs: []
  type: TYPE_IMG
  zh: '![图像](assets/337fig02.png)'
- en: '**If an abstract class has virtual members, every subclass must override all
    of those members.**'
  id: totrans-427
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**如果一个抽象类有虚拟成员，每个子类必须覆盖所有这些成员。**'
- en: Abstract properties work just like abstract methods
  id: totrans-428
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 抽象属性的工作方式就像抽象方法一样
- en: 'Let’s go back to the Bee class from our earlier example. We already know that
    we don’t want the class to be instantiated, so let’s modify it to turn it into
    an abstract class. We can do that just by adding the `abstract` modifier to the
    class declaration, and changing the DoJob method to an abstract method without
    a body:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到我们之前示例中的Bee类。我们已经知道我们不希望这个类可以被实例化，所以让我们修改它将其变成一个抽象类。我们可以通过在类声明中添加`abstract`修饰符，并将DoJob方法改为没有方法体的抽象方法来实现：
- en: '[PRE29]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'But there’s one other virtual member—and it’s not a method. It’s the CostPerShift
    property, which the Bee.WorkTheNextShift method calls to figure out how much honey
    the bee will require this shift:'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 但还有另一个虚拟成员——它不是一个方法。它是CostPerShift属性，Bee.WorkTheNextShift方法调用它来计算蜜蜂本班次需要多少蜂蜜：
- en: '[PRE30]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We learned in [#encapsulation_keep_your_privateshellippr](ch05.html#encapsulation_keep_your_privateshellippr)
    that properties are really just methods that are called like fields. Use the `abstract`
    **keyword to create an abstract property** just like you do with a method:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[#encapsulation_keep_your_privateshellippr](ch05.html#encapsulation_keep_your_privateshellippr)中学到，属性实际上只是被称为字段的方法。使用`abstract`
    **关键字创建抽象属性**，就像创建方法一样：
- en: '[PRE31]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Abstract properties can have a get accessor, a set accessor, or both get and
    set accessors. Setters and getters in abstract properties **can’t have method
    bodies**. Their declarations look just like automatic properties—but they’re not,
    because they don’t have any implementation at all. Like abstract methods, abstract
    properties are placeholders for properties that must be implemented by any subclass
    that extends their class.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象属性可以有获取器、设置器或两者。抽象属性中的设置器和获取器**不能有方法体**。它们的声明看起来像自动属性——但它们不是，因为它们根本没有实现。与抽象方法一样，抽象属性是必须由任何扩展它们的子类实现的属性的占位符。
- en: 'Here’s the whole abstract Bee class, complete with abstract method and property:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是完整的抽象Bee类，包括抽象方法和属性：
- en: '[PRE32]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '***Replace this!***'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: '***替换这里！***'
- en: '**Replace the Bee class** in your Beehive Management System app with this new
    abstract one. It will still work! But now if you try to instantiate the Bee class
    with `new Bee()`; you’ll get a compiler error. Even more importantly, ***you’ll
    get an error if you extend Bee but forget to implement CostPerShift***.'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: '**在你的蜂箱管理系统应用中用这个新的抽象类替换Bee类**。它仍然可以工作！但是现在，如果你尝试用`new Bee()`来实例化Bee类，你会得到一个编译器错误。更重要的是，***如果你扩展了Bee却忘记了实现CostPerShift，你会得到一个错误***。'
- en: '![Images](assets/340fig01.png)'
  id: totrans-440
  prefs: []
  type: TYPE_IMG
  zh: '![图像](assets/340fig01.png)'
- en: '**Was this the first time you’ve read through the code you wrote for previous
    exercises?**'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: '**这是你第一次读你为之前的练习编写的代码吗？**'
- en: 'It may feel a little weird to go back to code you wrote before—but that’s actually
    something a lot of developers do, and it’s a habit you should get used to. Did
    you find things that you would do differently the second time around? Are there
    improvements or changes that you might make? It’s always a good idea to take the
    time to refactor your code. That’s exactly what you did in this exercise: you
    changed the structure of the code without modifying its behavior. ***That’s refactoring.***'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾之前编写的代码可能会感觉有点奇怪，但这实际上是许多开发者的做法，你应该逐渐习惯这种习惯。你发现了第二次写代码时会有不同的想法吗？有没有改进或修改的地方？花时间重构你的代码总是一个好主意。这就是你在这个练习中做的：改变代码结构而不修改其行为。***这就是重构。***
- en: '![Images](assets/341fig01.png)'
  id: totrans-443
  prefs: []
  type: TYPE_IMG
  zh: '![图像](assets/341fig01.png)'
- en: '**That sounds great! But there’s a problem.**'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: '**听起来不错！但有个问题。**'
- en: If C# let you inherit from more than one base class, it would open up a whole
    can of worms. When a language lets one subclass inherit from two base classes,
    it’s called **multiple inheritance**. If C# supported multiple inheritance, you
    would end up in a big fat class conundrum called...
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 如果C#允许你从多个基类继承，那将会引发一系列问题。当一个语言允许一个子类从两个基类继承时，这被称为**多重继承**。如果C#支持多重继承，你将会陷入一个被称为“大胖子类难题”的困境中…
- en: '*The Deadly Diamond of Death*'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: '*致命的死亡菱形*'
- en: Note
  id: totrans-447
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: That’s its real name! Some developers just call it the “diamond problem.”
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 那就是它的真名！有些开发者只是称之为“菱形问题”。
- en: '![Images](assets/341fig02.png)'
  id: totrans-449
  prefs: []
  type: TYPE_IMG
  zh: '![图像](assets/341fig02.png)'
- en: '**What would happen in a CRAZY world where C# allowed multiple inheritance?
    Let’s play a little game of “what if” and find out.**'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: '**在一个疯狂的世界里，假设 C# 允许多重继承。让我们玩一场“假设”游戏，看看会发生什么。**'
- en: '***What if...*** you had a class called Appliance that had an abstract method
    called TurnOn?'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: '***如果……*** 你有一个名为 Appliance 的类，其中有一个名为 TurnOn 的抽象方法呢？'
- en: '***And what if...*** it had two subclasses: Oven with a Temperature property,
    and Toaster with a SicesOfBread property?'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: '***如果……*** 它有两个子类：Oven 有一个温度属性，Toaster 有一个面包片数属性呢？'
- en: '***And what if...*** you wanted to create a ToasterOven class that inherited
    both Temperature and SlicesOfBread?'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: '***如果……*** 你想创建一个继承了温度和面包片数的 ToasterOven 类呢？'
- en: '***And what if...***C# supported multiple inheritance, so you could do that?'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: '***如果……*** C# 支持多重继承，那你就可以这么做？'
- en: Then there’s only one more question...
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 那么就只剩下一个问题了……
- en: '***Which TurnOn does ToasterOven inherit?***'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: '***ToasterOven 继承了哪个 TurnOn？***'
- en: Does it get the version from Oven? Or does it get the version from Toaster?
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 它会从 Oven 那里得到版本吗？还是从 Toaster 那里得到版本呢？
- en: '***There’s no way to know!***'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: '***没有办法知道！***'
- en: '**And that’s why C# doesn’t allow multiple inheritance.**'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: '**这就是为什么 C# 不允许多重继承的原因。**'
- en: '![Images](assets/342fig01.png)'
  id: totrans-460
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/342fig01.png)'
