["```cs\npublic void CancelableMethodWithOverload(CancellationToken cancellationToken)\n{\n  // Code goes here.\n}\n\npublic void CancelableMethodWithOverload()\n{\n  CancelableMethodWithOverload(CancellationToken.None);\n}\n\npublic void CancelableMethodWithDefault(\n    CancellationToken cancellationToken = default)\n{\n  // Code goes here.\n}\n```", "```cs\nvoid IssueCancelRequest()\n{\n  using var cts = new CancellationTokenSource();\n  var task = CancelableMethodAsync(cts.Token);\n\n  // At this point, the operation has been started.\n\n  // Issue the cancellation request.\n  cts.Cancel();\n}\n```", "```cs\nasync Task IssueCancelRequestAsync()\n{\n  using var cts = new CancellationTokenSource();\n  var task = CancelableMethodAsync(cts.Token);\n\n  // At this point, the operation is happily running.\n\n  // Issue the cancellation request.\n  cts.Cancel();\n\n  // (Asynchronously) wait for the operation to finish.\n  try\n  {\n    await task;\n    // If we get here, the operation completed successfully\n    //  before the cancellation took effect.\n  }\n  catch (OperationCanceledException)\n  {\n    // If we get here, the operation was canceled before it completed.\n  }\n  catch (Exception)\n  {\n    // If we get here, the operation completed with an error\n    //  before the cancellation took effect.\n    throw;\n  }\n}\n```", "```cs\nprivate CancellationTokenSource _cts;\n\nprivate async void StartButton_Click(object sender, RoutedEventArgs e)\n{\n  StartButton.IsEnabled = false;\n  CancelButton.IsEnabled = true;\n  try\n  {\n    _cts = new CancellationTokenSource();\n    CancellationToken token = _cts.Token;\n    await Task.Delay(TimeSpan.FromSeconds(5), token);\n    MessageBox.Show(\"Delay completed successfully.\");\n  }\n  catch (OperationCanceledException)\n  {\n    MessageBox.Show(\"Delay was canceled.\");\n  }\n  catch (Exception)\n  {\n    MessageBox.Show(\"Delay completed with error.\");\n    throw;\n  }\n  finally\n  {\n    StartButton.IsEnabled = true;\n    CancelButton.IsEnabled = false;\n  }\n}\n\nprivate void CancelButton_Click(object sender, RoutedEventArgs e)\n{\n  _cts.Cancel();\n  CancelButton.IsEnabled = false;\n}\n```", "```cs\npublic int CancelableMethod(CancellationToken cancellationToken)\n{\n  for (int i = 0; i != 100; ++i)\n  {\n    Thread.Sleep(1000); // Some calculation goes here.\n    cancellationToken.ThrowIfCancellationRequested();\n  }\n  return 42;\n}\n```", "```cs\npublic int CancelableMethod(CancellationToken cancellationToken)\n{\n  for (int i = 0; i != 100000; ++i)\n  {\n    Thread.Sleep(1); // Some calculation goes here.\n    if (i % 1000 == 0)\n      cancellationToken.ThrowIfCancellationRequested();\n  }\n  return 42;\n}\n```", "```cs\nasync Task IssueTimeoutAsync()\n{\n  using var cts = new CancellationTokenSource(TimeSpan.FromSeconds(5));\n  CancellationToken token = cts.Token;\n  await Task.Delay(TimeSpan.FromSeconds(10), token);\n}\n```", "```cs\nasync Task IssueTimeoutAsync()\n{\n  using var cts = new CancellationTokenSource();\n  CancellationToken token = cts.Token;\n  cts.CancelAfter(TimeSpan.FromSeconds(5));\n  await Task.Delay(TimeSpan.FromSeconds(10), token);\n}\n```", "```cs\npublic async Task<int> CancelableMethodAsync(CancellationToken cancellationToken)\n{\n  await Task.Delay(TimeSpan.FromSeconds(2), cancellationToken);\n  return 42;\n}\n```", "```cs\nvoid RotateMatrices(IEnumerable<Matrix> matrices, float degrees,\n    CancellationToken token)\n{\n  Parallel.ForEach(matrices,\n      new ParallelOptions { CancellationToken = token },\n      matrix => matrix.Rotate(degrees));\n}\n```", "```cs\nvoid RotateMatrices2(IEnumerable<Matrix> matrices, float degrees,\n    CancellationToken token)\n{\n  // Warning: not recommended; see below.\n  Parallel.ForEach(matrices, matrix =>\n  {\n    matrix.Rotate(degrees);\n    token.ThrowIfCancellationRequested();\n  });\n}\n```", "```cs\nIEnumerable<int> MultiplyBy2(IEnumerable<int> values,\n    CancellationToken cancellationToken)\n{\n  return values.AsParallel()\n      .WithCancellation(cancellationToken)\n      .Select(item => item * 2);\n}\n```", "```cs\nprivate IDisposable _mouseMovesSubscription;\n\nprivate void StartButton_Click(object sender, RoutedEventArgs e)\n{\n  IObservable<Point> mouseMoves = Observable\n      .FromEventPattern<MouseEventHandler, MouseEventArgs>(\n          handler => (s, a) => handler(s, a),\n          handler => MouseMove += handler,\n          handler => MouseMove -= handler)\n      .Select(x => x.EventArgs.GetPosition(this));\n  _mouseMovesSubscription = mouseMoves.Subscribe(value =>\n  {\n    MousePositionLabel.Content = \"(\" + value.X + \", \" + value.Y + \")\";\n  });\n}\n\nprivate void CancelButton_Click(object sender, RoutedEventArgs e)\n{\n  if (_mouseMovesSubscription != null)\n    _mouseMovesSubscription.Dispose();\n}\n```", "```cs\nCancellationToken cancellationToken = ...\nIObservable<int> observable = ...\nint lastElement = await observable.TakeLast(1).ToTask(cancellationToken);\n// or: int lastElement = await observable.ToTask(cancellationToken);\n```", "```cs\nCancellationToken cancellationToken = ...\nIObservable<int> observable = ...\nint firstElement = await observable.Take(1).ToTask(cancellationToken);\n```", "```cs\nCancellationToken cancellationToken = ...\nIObservable<int> observable = ...\nIList<int> allElements = await observable.ToList().ToTask(cancellationToken);\n```", "```cs\nusing (var cancellation = new CancellationDisposable())\n{\n  CancellationToken token = cancellation.Token;\n  // Pass the token to methods that respond to it.\n}\n// At this point, the token is canceled.\n```", "```cs\nIPropagatorBlock<int, int> CreateMyCustomBlock(\n    CancellationToken cancellationToken)\n{\n  var blockOptions = new ExecutionDataflowBlockOptions\n  {\n    CancellationToken = cancellationToken\n  };\n  var multiplyBlock = new TransformBlock<int, int>(item => item * 2,\n      blockOptions);\n  var addBlock = new TransformBlock<int, int>(item => item + 2,\n      blockOptions);\n  var divideBlock = new TransformBlock<int, int>(item => item / 2,\n      blockOptions);\n\n  var flowCompletion = new DataflowLinkOptions\n  {\n    PropagateCompletion = true\n  };\n  multiplyBlock.LinkTo(addBlock, flowCompletion);\n  addBlock.LinkTo(divideBlock, flowCompletion);\n\n  return DataflowBlock.Encapsulate(multiplyBlock, divideBlock);\n}\n```", "```cs\nasync Task<HttpResponseMessage> GetWithTimeoutAsync(HttpClient client,\n    string url, CancellationToken cancellationToken)\n{\n  using CancellationTokenSource cts = CancellationTokenSource\n      .CreateLinkedTokenSource(cancellationToken);\n  cts.CancelAfter(TimeSpan.FromSeconds(2));\n  CancellationToken combinedToken = cts.Token;\n\n  return await client.GetAsync(url, combinedToken);\n}\n```", "```cs\nasync Task<PingReply> PingAsync(string hostNameOrAddress,\n    CancellationToken cancellationToken)\n{\n  using var ping = new Ping();\n  Task<PingReply> task = ping.SendPingAsync(hostNameOrAddress);\n  using CancellationTokenRegistration _ = cancellationToken\n      .Register(() => ping.SendAsyncCancel());\n  return await task;\n}\n```"]