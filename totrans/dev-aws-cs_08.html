<html><head></head><body>
<div id="sbo-rt-content"><section data-pdf-bookmark="Chapter 8. Developing with AWS C# SDK" data-type="chapter" epub:type="chapter"><div class="chapter" id="Chapter8">
<h1><span class="label">Chapter 8. </span>Developing with AWS C# SDK</h1>
<p><a data-primary="SDK (Software Development Kit)" data-secondary="developing with AWS C# SDK" data-type="indexterm" id="ix_ch08-asciidoc0"/>Throughout this book we have utilized many ways to interact with AWS from your development machine.  We have been using the <a href="https://aws.amazon.com/console">AWS Management Console</a>, and we have been using the AWS CLI both through Cloud9 and locally by installing the CLI locally to our machine.  In this last chapter, we will take a look at some tools and integrations that offer a third way to integrate with and control your AWS services, through integrated development environments (IDEs) you will most likely already be familiar with: Visual Studio and Visual Studio Code.  Both of these IDEs have extensions for AWS that allow you to interrogate your AWS resources, and we will be covering both in this chapter.</p>
<p>After looking at some of the features of the UI toolkits for AWS, we will also be taking a closer look at the AWS C# SDK.  We have been using the SDK extensively throughout this book, so you should be familiar with the basics, but there is a lot more this collection of NuGet packages has to offer.</p>
<p>Lastly, we are going to round off this book by exploring some of the artificial intelligence (AI) services in AWS and how we can utilize these in .NET.  So let’s jump straight in and talk about the AWS Toolkit for Visual Studio and how you can set up your Visual Studio workflow so that deployment to AWS feels seamless.</p>
<section class="pagebreak-before less_space" data-pdf-bookmark="Using AWS Toolkit for Visual Studio In Depth" data-type="sect1"><div class="sect1" id="idm45599649475696">
<h1>Using AWS Toolkit for Visual Studio In Depth</h1>
<p><a data-primary="SDK (Software Development Kit)" data-secondary="AWS Toolkit for Visual Studio in depth" data-type="indexterm" id="ix_ch08-asciidoc1"/><a data-primary="Toolkit for Visual Studio" data-type="indexterm" id="ix_ch08-asciidoc2"/>The AWS Toolkit is an extension that supplements the Visual Studio interface with various AWS-related functionality.  The aim of the toolkit is to make Visual Studio feel as natively integrated into AWS as it does out of the box with Microsoft’s own cloud services.  With the toolkit installed you will be able to quickly deploy your code to a multitude of AWS services with the same “publish” workflow you are probably already familiar with.</p>
<p>The toolkit adds menu options, context menu options, project templates, and an AWS Explorer window, all of which we will cover in this chapter.</p>
<section data-pdf-bookmark="Configuring Visual Studio for AWS Toolkit" data-type="sect2"><div class="sect2" id="VS-AWS-Toolkit">
<h2>Configuring Visual Studio for AWS Toolkit</h2>
<p><a data-primary="Toolkit for Visual Studio" data-secondary="configuring Visual Studio for" data-type="indexterm" id="ix_ch08-asciidoc3"/><a data-primary="Visual Studio" data-secondary="configuring for Toolkit for Visual Studio" data-type="indexterm" id="ix_ch08-asciidoc4"/>We briefly covered installation of the toolkit in <a data-type="xref" href="ch01.xhtml#one-aws-tookit-visual-studio">“Using Visual Studio with AWS and AWS Toolkit for Visual Studio”</a>, so just to recap: you can find the toolkit extension in the <a href="https://oreil.ly/CuWwr">Visual Studio Marketplace</a>, or through AWS’s web page for <a href="https://aws.amazon.com/visualstudio">AWS Toolkit for Visual Studio</a>, the latter of which also contains links to guides and documentation that can help you in getting the most out of AWS in Visual Studio.</p>
<p>There are three versions of the toolkit that span five versions of Visual Studio, so be sure to download the correct <em>.msi</em> installer file for your version of Visual Studio:</p>
<ul>
<li>
<p>AWS Toolkit for Visual Studio 2013–2015</p>
</li>
<li>
<p>AWS Toolkit for Visual Studio 2017–2019</p>
</li>
<li>
<p>AWS Toolkit for Visual Studio 2022</p>
</li>
</ul>
<p>The examples in this book will be using AWS Toolkit for Visual Studio 2022; however, screens for earlier versions of Visual Studio are not radically dissimilar.</p>
<p>Once you have installed the extension and opened up Visual Studio, you will be presented with the Getting Started page as shown in <a data-type="xref" href="#Figure-8-1">Figure 8-1</a>.</p>
<p>Before we can connect to AWS from Visual Studio, we need to configure the toolkit with some AWS credentials so it can make API calls to AWS services on our behalf.  The toolkit uses the access key and secret key(s) from your AWS credentials file, stored against a profile.  You can find your AWS credentials files under <em>~/.aws/credentials</em> (Linux or macOS) or <em>%USERPROFILE%\.aws\credentials</em> (Windows), with the profile name in square brackets.  For example:</p>
<pre data-type="programlisting">[default]
aws_access_key_id = &lt;your-access-key&gt;
aws_secret_access_key = &lt;your-secret-key&gt;</pre>
<figure><div class="figure" id="Figure-8-1">
<img alt="doac 0801" height="774" src="assets/doac_0801.png" width="1088"/>
<h6><span class="label">Figure 8-1. </span>Getting started with the AWS Toolkit</h6>
</div></figure>
<p>If you already have credentials stored on your machine, then you can skip this step as the toolkit will pick them up inside Visual Studio.  If you do not have credentials stored, then you can create an IAM user and download credentials, then import into the Credential Setup section in <a data-type="xref" href="#Figure-8-1">Figure 8-1</a>.</p>
<p>Once you have credentials stored on your machine, you can begin exploring the AWS Toolkit features inside Visual Studio, and what better place to start than the AWS Explorer, accessible from the new Tools → AWS Explorer menu option (<a data-type="xref" href="#Figure-8-2">Figure 8-2</a>).</p>
<figure><div class="figure" id="Figure-8-2">
<img alt="doac 0802" height="207" src="assets/doac_0802.png" width="437"/>
<h6><span class="label">Figure 8-2. </span>AWS Explorer menu option</h6>
</div></figure>
<p>We introduced the AWS Explorer at the start of this book; you can see an example of the Explorer window in <a data-type="xref" href="ch01.xhtml#Figure-1-7">Figure 1-14</a> under <a data-type="xref" href="ch01.xhtml#one-aws-tookit-visual-studio">“Using Visual Studio with AWS and AWS Toolkit for Visual Studio”</a>. Alongside AWS Explorer, the toolkit installs a handful of AWS-specific project templates and blueprints.  These serve as an excellent way to both accelerate the creation of a new project and as a means of experimentation with different AWS deployment models for your code.<a data-startref="ix_ch08-asciidoc4" data-type="indexterm" id="idm45599649446304"/><a data-startref="ix_ch08-asciidoc3" data-type="indexterm" id="idm45599649445632"/></p>
</div></section>
<section data-pdf-bookmark="Project Templates from AWS" data-type="sect2"><div class="sect2" id="idm45599649444704">
<h2>Project Templates from AWS</h2>
<p><a data-primary="Toolkit for Visual Studio" data-secondary="project templates from AWS" data-type="indexterm" id="idm45599649443216"/>Select from one of the newly installed project templates by choosing “AWS” in the <em>Project type</em> filter, as shown in <a data-type="xref" href="#Figure-8-3">Figure 8-3</a>. The project templates are for applications built on AWS Lambda, like many of the examples we have covered in this book.</p>
<figure><div class="figure" id="Figure-8-3">
<img alt="doac 0803" height="600" src="assets/doac_0803.png" width="931"/>
<h6><span class="label">Figure 8-3. </span>Project templates in Visual Studio</h6>
</div></figure>
<p>If we select this template, “AWS Serverless Application with Tests (.NET Core - C#),” then we will be presented with another selection where we can choose from one of what AWS calls “blueprints” on the next screen.  These blueprints are ways to further configure your template project to best reflect the project you are creating.  In this case (<a data-type="xref" href="#Figure-8-4">Figure 8-4</a>), we selected Serverless Application in the preceding step, so we are offered several different blueprints for a serverless application.</p>
<figure><div class="figure" id="Figure-8-4">
<img alt="doac 0804" height="548" src="assets/doac_0804.png" width="826"/>
<h6><span class="label">Figure 8-4. </span>AWS project blueprints</h6>
</div></figure>
<p>Choose the ASP.NET Core Web API blueprint and click “Finish” to create the project we will use in the next example.</p>
</div></section>
<section data-pdf-bookmark="Publishing to AWS from Visual Studio" data-type="sect2"><div class="sect2" id="idm45599649434800">
<h2>Publishing to AWS from Visual Studio</h2>
<p><a data-primary="Toolkit for Visual Studio" data-secondary="publishing to AWS from Visual Studio" data-type="indexterm" id="idm45599649433456"/><a data-primary="Visual Studio" data-secondary="publishing to AWS from" data-type="indexterm" id="idm45599649432400"/>With our serverless ASP.NET Core Web API project created from the blueprint, let’s open up the Solution Explorer and visit some of the files that have been created:</p>
<dl>
<dt>serverless.template</dt>
<dd>
<p>This file is the Serverless Application Model (SAM) template for our resources.  This file allows us to configure our infrastructure from one file, which can be checked into version control.  We covered SAM in <a data-type="xref" href="ch04.xhtml#4-serverless-application-model">“Serverless Application Model (SAM)”</a>.</p>
</dd>
<dt>AWSServerless1.Tests</dt>
<dd>
<p>This test project has been created, including a single unit test in <em>ValuesControllerTests.cs</em> to serve as a starting point for writing unit tests for our API.  The test project included in this AWS blueprint uses <a href="https://xunit.net">xUnit</a>, which has been brought in as a NuGet dependency.</p>
</dd>
<dt>aws-lambda-tools-defaults.json</dt>
<dd>
<p>This stores the publish settings for our project.  Settings added in the next step will be saved to this file as defaults, so you do not need to re-enter them each time.</p>
</dd>
</dl>
<p>The new project that was created from this blueprint is ready to publish immediately—we don’t need to make any changes.  We can use the AWS Toolkit to publish this serverless project directly from Visual Studio.  To do this, open the context menu by right-clicking on the project name and selecting one of the “Publish to AWS…” options.  As you can see in <a data-type="xref" href="#Figure-8-5">Figure 8-5</a>, the AWS Toolkit has added two new menu items you can use to publish your project.</p>
<figure><div class="figure" id="Figure-8-5">
<img alt="doac 0805" height="399" src="assets/doac_0805.png" width="442"/>
<h6><span class="label">Figure 8-5. </span>New publish options added by the toolkit</h6>
</div></figure>
<p>However you choose to publish your application, the toolkit will use the <em>serverless.template</em> file described previously to create a CloudFormation stack for your project and then build and push your code to AWS.</p>
</div></section>
<section data-pdf-bookmark="AWS Toolkit for Visual Studio Code" data-type="sect2"><div class="sect2" id="idm45599649420048">
<h2>AWS Toolkit for Visual Studio Code</h2>
<p><a data-primary="Toolkit for Visual Studio" data-secondary="Toolkit for Visual Studio Code" data-type="indexterm" id="ix_ch08-asciidoc5"/><a data-primary="Visual Studio Code" data-type="indexterm" id="ix_ch08-asciidoc6"/>The rise of Visual Studio Code has been nothing short of meteoric.  From public release in 2016 to being used by over <a href="https://oreil.ly/KJeur">70% of professional software developers</a> in 2022, it is clear that Visual Studio Code has supplanted other IDEs for development across the industry.  C# developers often turn to Visual Studio Code as a lightweight alternative to Visual Studio, and so in 2019 AWS announced the release of their <a href="https://oreil.ly/spYbP">AWS Toolkit for Visual Studio Code</a>.</p>
<p class="pagebreak-before">The VS Code toolkit includes a version of the AWS Explorer found in Visual Studio, allowing you to browse and interact with your AWS services from a new “AWS” menu option under the side bar.  <a data-type="xref" href="#Figure-8-6">Figure 8-6</a> shows how the AWS Explorer in VSCode allows you to browse and interact with your resources.</p>
<figure><div class="figure" id="Figure-8-6">
<img alt="doac 0806" height="543" src="assets/doac_0806.png" width="951"/>
<h6><span class="label">Figure 8-6. </span>AWS Explorer in Visual Studio Code</h6>
</div></figure>
<p>Installing the toolkit is as simple as searching “AWS Toolkit” in the extensions marketplace from within Visual Studio Code (Ctrl+Shift+X on Windows, or ⌘-Shift-X on macOS).</p>
<p>As with the AWS Toolkit for Visual Studio, the VS Code extension uses your AWS credential profiles stored under <em>~/.aws/credentials</em> (Linux or macOS) or <em>%USERPROFILE%\.aws\credentials</em> (Windows).  You can select which profile to use by opening the Command Palette (Ctrl+Shift+P on Windows, or ⌘-Shift-P on macOS) and selecting AWS: Choose AWS Profile.  This will bring up the option to select a profile or, if you don’t have any profiles saved, set one up from within Visual Studio Code.</p>
<p>Alongside the AWS Explorer (<a data-type="xref" href="#Figure-8-6">Figure 8-6</a>), the AWS Toolkit for Visual Studio Code also provides an array of AWS commands you can invoke from the Command Palette.  Simply search for “AWS:” to bring up all the commands with this prefix.  A few of these are shown in <a data-type="xref" href="#Figure-8-7">Figure 8-7</a>.</p>
<figure><div class="figure" id="Figure-8-7">
<img alt="doac 0807" height="424" src="assets/doac_0807.png" width="950"/>
<h6><span class="label">Figure 8-7. </span>AWS commands in VS Code</h6>
</div></figure>
<p>This brings us to the end of our overview of the AWS Toolkits for both Visual Studio and Visual Studio Code.<a data-startref="ix_ch08-asciidoc6" data-type="indexterm" id="idm45599649403984"/><a data-startref="ix_ch08-asciidoc5" data-type="indexterm" id="idm45599649403280"/>  Next, let’s take a quick look at the AWS Toolkit for Rider.</p>
</div></section>
<section data-pdf-bookmark="AWS Toolkit for Rider" data-type="sect2"><div class="sect2" id="idm45599649402352">
<h2>AWS Toolkit for Rider</h2>
<p><a data-primary="JetBrains Rider, AWS Toolkit for" data-type="indexterm" id="idm45599649401136"/><a data-primary="Rider, AWS Toolkit for" data-type="indexterm" id="idm45599649400368"/><a data-primary="Toolkit for Visual Studio" data-secondary="AWS Toolkit for Rider and" data-type="indexterm" id="idm45599649399696"/>The last AWS Toolkit extension to be aware of is that provided for JetBrains Rider.  The <a href="https://aws.amazon.com/rider">AWS Toolkit for Rider</a> provides similar functionality to the toolkits for the other IDEs we have seen here, including an AWS Lambda project template that integrates into Rider’s New Project dialog and creates a simple <code>Hello World</code> project and test project.</p>
<p>The AWS Toolkit for Rider also supports running an AWS Lambda locally inside a Docker container, allowing you to debug AWS Lambda from within Rider.  We also have a new Deploy Serverless Application context menu item on the <em>template.yaml</em> file in your solution that allows you to deploy your Lambda function from within Rider.<a data-startref="ix_ch08-asciidoc2" data-type="indexterm" id="idm45599649396352"/><a data-startref="ix_ch08-asciidoc1" data-type="indexterm" id="idm45599649395648"/></p>
<p>Next in this chapter, we are going to take a closer look at the AWS SDK for .NET, and jump back into some C#.</p>
</div></section>
</div></section>
<section data-pdf-bookmark="Key SDK Features" data-type="sect1"><div class="sect1" id="idm45599649394208">
<h1>Key SDK Features</h1>
<p><a data-primary="SDK (Software Development Kit)" data-secondary="key features" data-type="indexterm" id="idm45599649392672"/><a data-primary="SDK for .NET" data-secondary="key features" data-type="indexterm" id="idm45599649391680"/>The <a href="https://aws.amazon.com/sdk-for-net">AWS SDK for .NET</a> is a collection of over 300 NuGet packages that make it easy to call AWS services from applications running on .NET.  The SDK libraries can be imported into any .NET project and used from your code to make authenticated calls to the various AWS APIs.</p>
<div data-type="tip"><h6>Tip</h6>
<p>You can explore more tools, libraries, and other resources on the <a href="https://github.com/aws/dotnet">.NET on AWS on GitHub</a> page, which contains links to GitHub repositories for all the open source tools maintained by AWS including the AWS SDK for .NET</p>
</div>
<p>All the SDK libraries follow a common pattern of service clients that wrap API calls to AWS.  These are implemented in the SDK using strongly typed request and response classes available for use in your C# code.  An example of one of these client classes is the <code>AmazonS3Client</code> from the <a href="https://oreil.ly/xuwoj">AWSSDK.S3</a> package:</p>
<pre data-code-language="csharp" data-type="programlisting"><code class="kt">var</code> <code class="n">s3Client</code> <code class="p">=</code> <code class="k">new</code> <code class="n">AmazonS3Client</code><code class="p">(</code><code class="n">Amazon</code><code class="p">.</code><code class="n">RegionEndpoint</code><code class="p">.</code><code class="n">USEast1</code><code class="p">);</code>

<code class="k">await</code> <code class="n">s3Client</code><code class="p">.</code><code class="n">CopyObjectAsync</code><code class="p">(</code>
        <code class="n">sourceBucket</code><code class="p">,</code>
        <code class="n">sourceKey</code><code class="p">,</code>
        <code class="n">destinationBucket</code><code class="p">,</code>
        <code class="n">destinationKey</code>
<code class="p">);</code></pre>
<p>Here we are invoking the <code>copy-object</code> on an AWS Simple Storage Service (S3) bucket to copy one key to another key.  We start by creating a new instance of the service client (in this case <code>AmazonS3Client</code>) with some configuration values (<code>AmazonS3Config</code>).  Then, with the instance of the service client, we invoke the asynchronous version of the method <code>CopyObjectAsync()</code>.  The preceding code snippet is the equivalent of calling the following from the AWS command line:</p>
<pre data-code-language="bash" data-type="programlisting">aws s3api copy-object --copy-source &lt;source-bucket&gt; --key &lt;key&gt; --bucket &lt;dest&gt;</pre>
<p>This pattern is followed for the majority of AWS services, as all AWS service clients inherit from the base class <a href="https://oreil.ly/5b17a"><code>Amazon.Runtime.AmazonServiceClient</code></a>. This gives all AWS service client objects access to common functionality such as credentials management, logging, metrics, retries, and timeouts, some of which we will cover later in this chapter.</p>
<section data-pdf-bookmark="Authentication in the AWS .NET SDK" data-type="sect2"><div class="sect2" id="idm45599649307920">
<h2>Authentication in the AWS .NET SDK</h2>
<p><a data-primary="authentication" data-type="indexterm" id="idm45599649353712"/><a data-primary="SDK (Software Development Kit)" data-secondary="authentication in AWS .NET SDK" data-type="indexterm" id="idm45599649353328"/><a data-primary="security" data-secondary="authentication in AWS .NET SDK" data-type="indexterm" id="idm45599649352592"/>In order to make calls to AWS APIs, you need to pass credentials to the AWS .NET SDK.  There are several methods to do this, and different methods will be applicable in different scenarios.  For example, if you are running your code locally for development purposes, you may want to authenticate with the access key and secret stored in one of your AWS profiles.  When you deploy your code to AWS, however, you can use the IAM user configured for the specific EC2 instance, App Runner, or AWS Lambda function that is executing your code.</p>
<p class="pagebreak-before">When you use a service client, the AWS SDK for .NET will look for credentials in the following places, in order:</p>
<ol>
<li>
<p>Credentials passed to the constructor of a service client object, for example <code>new AmazonS3Client(awsAccessKeyId, awsSecretAccessKey)</code>.</p>
</li>
<li>
<p>A named credentials profile on the local machine, as covered previously in <a data-type="xref" href="#VS-AWS-Toolkit">“Configuring Visual Studio for AWS Toolkit”</a>, with the profile name coming from <em>appsettings.{env}.json</em>.</p>
</li>
<li>
<p>A named credentials profile on the local machine, with the profile name stored in an environment variable called <code>AWS_PROFILE</code>.</p>
</li>
<li>
<p>A named credentials profile with the name <code>[default]</code>, if it exists.</p>
</li>
<li>
<p>Access key, secret, and session tokens stored in the environment variables <code>AWS_ACCESS_KEY_ID</code>, <code>AWS_SECRET_ACCESS_KEY</code>, and <code>AWS_SESSION_TOKEN</code>, 
<span class="keep-together">respectively</span>.</p>
</li>
<li>
<p>Access key and secret only, in the environment variables <code>AWS_ACCESS_KEY_ID</code> and <code>AWS_SECRET_ACCESS_KEY</code>.</p>
</li>
<li>
<p>IAM role native to the EC2 task, EC2 instance, or other execution environment your .NET code is running on.</p>
</li>
</ol>
<p>The easiest and most flexible way to configure AWS credentials for the SDK, and the way that allows you to best manage multiple credentials for different environments, is to use the <em>appsettings.{env}.json</em> files, and load them in using <code>AWSSDK.Extensions.NETCore.Setup</code>, which we will look at next.</p>
</div></section>
<section data-pdf-bookmark="Dependency Injection with the AWS SDK" data-type="sect2"><div class="sect2" id="idm45599649288128">
<h2>Dependency Injection with the AWS SDK</h2>
<p><a data-primary="dependency injection" data-type="indexterm" id="ix_ch08-asciidoc7"/><a data-primary="SDK (Software Development Kit)" data-secondary="dependency injection with" data-type="indexterm" id="ix_ch08-asciidoc8"/><a data-primary="SDK for .NET" data-secondary="dependency injection with" data-type="indexterm" id="ix_ch08-asciidoc9"/>Dependency injection is an extremely common pattern in .NET applications that allows you to configure all your dependencies in one place and inject them into your .NET controllers or other services, achieving inversion of control (IoC).  If you are not familiar with dependency injection and IoC, a brief overview can be found on <a href="https://oreil.ly/rk9Ql">YouTube</a>.</p>
<p>Versions of .NET from .NET Core onward support dependency injection as part of the framework, using the classes found in <code>Microsoft.Extensions.DependencyInjection</code>.  Services (dependencies) are registered with the container in the <em>Program.cs</em> or <em>Startup.cs</em> files of your project.  Here, an implementation of <code>MyDependency</code> is being registered against the interface <code>IMyDependency</code> in our .NET 6 <em>Program.cs</em> file:</p>
<pre data-code-language="csharp" data-type="programlisting"><code class="kt">var</code> <code class="n">builder</code> <code class="p">=</code> <code class="n">WebApplication</code><code class="p">.</code><code class="n">CreateBuilder</code><code class="p">(</code><code class="n">args</code><code class="p">);</code>
<code class="n">builder</code><code class="p">.</code><code class="n">Services</code><code class="p">.</code><code class="n">AddControllers</code><code class="p">();</code>

<code class="c1">// Add a dependency to the DI container</code>
<code class="n">builder</code><code class="p">.</code><code class="n">Services</code><code class="p">.</code><code class="n">AddScoped</code><code class="p">&lt;</code><code class="n">IMyDependency</code><code class="p">,</code> <code class="n">MyDependency</code><code class="p">&gt;();</code></pre>
<p>When we use the AWS SDK for .NET, we can add AWS service clients into the .NET dependency injection container using similar syntax, with the help of the NuGet package AWSSDK.Extensions.NETCore.Setup. This package allows us to do two important things: register AWS service clients as dependencies, and use an <em>appsettings.json</em> file to store our AWS configuration, as previously mentioned.</p>
<p>To load the configuration settings, add the AWSSDK.Extensions.NETCore.Setup NuGet package to your .NET Core / 6+ project and then add these two lines into your service registration code:</p>
<pre data-code-language="csharp" data-type="programlisting"><code class="kt">var</code> <code class="n">awsOptions</code> <code class="p">=</code> <code class="n">builder</code><code class="p">.</code><code class="n">Configuration</code><code class="p">.</code><code class="n">GetAWSOptions</code><code class="p">();</code>

<code class="n">builder</code><code class="p">.</code><code class="n">Services</code><code class="p">.</code><code class="n">AddDefaultAWSOptions</code><code class="p">(</code><code class="n">awsOptions</code><code class="p">);</code></pre>
<p>Alternatively, if you are using a <code>Startup</code> class, then the code will look like this:</p>
<pre data-code-language="csharp" data-type="programlisting"><code class="k">public</code> <code class="k">class</code> <code class="nc">Startup</code>
<code class="p">{</code>
    <code class="k">public</code> <code class="nf">Startup</code><code class="p">(</code><code class="n">IConfiguration</code> <code class="n">configuration</code><code class="p">)</code>
    <code class="p">{</code>
        <code class="n">Configuration</code> <code class="p">=</code> <code class="n">configuration</code><code class="p">;</code>
    <code class="p">}</code>

    <code class="k">public</code> <code class="n">IConfiguration</code> <code class="n">Configuration</code> <code class="p">{</code> <code class="k">get</code><code class="p">;</code> <code class="p">}</code>

    <code class="k">public</code> <code class="k">void</code> <code class="nf">ConfigureServices</code><code class="p">(</code><code class="n">IServiceCollection</code> <code class="n">services</code><code class="p">)</code>
    <code class="p">{</code>
        <code class="n">services</code><code class="p">.</code><code class="n">AddControllers</code><code class="p">(</code><code class="p">)</code><code class="p">;</code>

        <code class="kt">var</code> <code class="n">awsOptions</code> <code class="p">=</code> <code class="n">Configuration</code><code class="p">.</code><code class="n">GetAWSOptions</code><code class="p">(</code><code class="p">)</code><code class="p">;</code>

        <code class="n">services</code><code class="p">.</code><code class="n">AddDefaultAWSOptions</code><code class="p">(</code><code class="n">awsOptions</code><code class="p">)</code><code class="p">;</code> <a class="co" href="#callout_developing_with_aws_c__sdk_CO1-1" id="co_developing_with_aws_c__sdk_CO1-1"><img alt="1" height="12" src="assets/1.png" width="12"/></a>
    <code class="p">}</code>

    <code class="k">public</code> <code class="k">void</code> <code class="nf">Configure</code><code class="p">(</code><code class="n">IApplicationBuilder</code> <code class="n">app</code><code class="p">,</code> <code class="n">IWebHostEnvironment</code> <code class="n">env</code><code class="p">)</code>
    <code class="p">{</code>
        <code class="c1">// ...
</code>    <code class="p">}</code>
<code class="p">}</code></pre>
<dl class="calloutlist">
<dt><a class="co" href="#co_developing_with_aws_c__sdk_CO1-1" id="callout_developing_with_aws_c__sdk_CO1-1"><img alt="1" height="12" src="assets/1.png" width="12"/></a></dt>
<dd><p>Add the configuration settings in for use in all resolved service clients.</p></dd>
</dl>
<p>You can use your <em>appsettings.&lt;env&gt;.json</em> settings file(s) reference the name of your AWS credentials profile, among other settings.  This allows you to have different AWS credentials for each environment, connecting to AWS under a different IAM user with roles and permissions bespoke to that environment.  An example of <em>appsettings.Development.json</em> using a local profile called “my-profile-name” would look like this:</p>
<pre data-code-language="json" data-type="programlisting"><code class="p">{</code>
  <code class="nt">"AWS"</code><code class="p">:</code> <code class="p">{</code>
    <code class="nt">"Region"</code><code class="p">:</code> <code class="s2">"us-east-1"</code><code class="p">,</code>
    <code class="nt">"Profile"</code><code class="p">:</code> <code class="s2">"my-profile-name"</code>
  <code class="p">},</code>
  <code class="nt">"MyKey"</code><code class="p">:</code> <code class="s2">"My appsettings.json Value"</code>
<code class="p">}</code></pre>
<p>The settings under the AWS node map to the class <code>Amazon.AWSConfigs</code> and a full list of available properties can be found in the <a href="https://oreil.ly/38DIi">documentation for Amazon.AWSConfigs</a>.</p>
<p>Once you have default AWS options added to your dependency injection container, you can go ahead and start to register AWS service clients as dependencies for use in your application.  Service clients from the AWS SDK will have a concrete class and an interface you can register it against.  This allows you to easily mock the interface for unit testing or to otherwise modify the behavior of your application without modifying any of the calling logic.  Here is an example using the <code>AmazonLambdaClient</code> service client from <code>AWSSDK.Lambda</code>.  This client allows us to invoke a function on AWS Lambda from our C# code:</p>
<pre data-code-language="csharp" data-type="programlisting"><code class="kt">var</code> <code class="n">awsOptions</code> <code class="p">=</code> <code class="n">builder</code><code class="p">.</code><code class="n">Configuration</code><code class="p">.</code><code class="n">GetAWSOptions</code><code class="p">(</code><code class="p">)</code><code class="p">;</code>

<code class="n">builder</code><code class="p">.</code><code class="n">Services</code><code class="p">.</code><code class="n">AddDefaultAWSOptions</code><code class="p">(</code><code class="n">awsOptions</code><code class="p">)</code><code class="p">;</code>

<code class="n">services</code><code class="p">.</code><code class="n">AddAWSService</code><code class="p">&lt;</code><code class="n">IAmazonLambda</code><code class="p">&gt;</code><code class="p">(</code><code class="p">)</code><code class="p">;</code> <a class="co" href="#callout_developing_with_aws_c__sdk_CO2-1" id="co_developing_with_aws_c__sdk_CO2-1"><img alt="1" height="12" src="assets/1.png" width="12"/></a></pre>
<dl class="calloutlist">
<dt><a class="co" href="#co_developing_with_aws_c__sdk_CO2-1" id="callout_developing_with_aws_c__sdk_CO2-1"><img alt="1" height="12" src="assets/1.png" width="12"/></a></dt>
<dd><p>Register the AWS Lambda service client using the interface.  At runtime this will be injected as an instance of <code>AmazonLambdaClient</code>.</p></dd>
</dl>
<p>With this service registered, you can inject it into a .NET controller through the constructor:</p>
<pre data-code-language="csharp" data-type="programlisting"><code class="na">[Route("api/[controller]</code><code class="s">")]</code>
<code class="k">public</code> <code class="k">class</code> <code class="nc">ExampleController</code> <code class="p">:</code> <code class="n">ControllerBase</code>
<code class="p">{</code>
    <code class="k">private</code> <code class="k">readonly</code> <code class="n">IAmazonLambda</code> <code class="n">_lambdaClient</code><code class="p">;</code>

    <code class="k">public</code> <code class="nf">ExampleController</code><code class="p">(</code><code class="n">IAmazonLambda</code> <code class="n">lambdaClient</code><code class="p">)</code>
    <code class="p">{</code>
        <code class="n">_lambdaClient</code> <code class="p">=</code> <code class="n">lambdaClient</code><code class="p">;</code>
    <code class="p">}</code>

    <code class="k">public</code> <code class="k">async</code> <code class="n">Task</code> <code class="nf">DoSomething</code><code class="p">()</code>
    <code class="p">{</code>
        <code class="k">await</code> <code class="n">_lambdaClient</code><code class="p">.</code><code class="n">InvokeAsync</code><code class="p">(</code><code class="k">new</code> <code class="n">Amazon</code><code class="p">.</code><code class="n">Lambda</code><code class="p">.</code><code class="n">Model</code><code class="p">.</code><code class="n">InvokeRequest</code>
        <code class="p">{</code>
            <code class="n">FunctionName</code> <code class="p">=</code> <code class="s">"MyLambdaFunction"</code><code class="p">,</code>
            <code class="n">InvocationType</code> <code class="p">=</code> <code class="n">InvocationType</code><code class="p">.</code><code class="n">Event</code>
        <code class="p">});</code>
    <code class="p">}</code>
<code class="p">}</code></pre>
<p>Notice how we are only referencing the abstraction <code>IAmazonLambda</code> in our code and calling <code>IAmazonLambda.InvokeAsync(...)</code> to invoke the AWS Lambda function.  This allows us to unit test our <code>DoSomething()</code> method above by mocking out <code>IAmazonLambda</code>, either by implementing a mock version of this interface or using a tool such as <a href="https://nugetmusthaves.com/Package/Moq">Moq</a> to automate the implementation.</p>
<p>The credentials to make this call to AWS Lambda and invoke our function will be retrieved via the use of credentials referenced by the profile in <em>appsettings.{env}.json</em> file, allowing us to configure separate credentials for each environment and/or local development user.<a data-startref="ix_ch08-asciidoc9" data-type="indexterm" id="idm45599648830896"/><a data-startref="ix_ch08-asciidoc8" data-type="indexterm" id="idm45599648830256"/><a data-startref="ix_ch08-asciidoc7" data-type="indexterm" id="idm45599648829584"/></p>
</div></section>
<section data-pdf-bookmark="Retries and Timeouts" data-type="sect2"><div class="sect2" id="idm45599649287216">
<h2>Retries and Timeouts</h2>
<p><a data-primary="retries, SDK and" data-type="indexterm" id="idm45599648827744"/><a data-primary="SDK (Software Development Kit)" data-secondary="retries and timeouts" data-type="indexterm" id="idm45599648827040"/><a data-primary="timeouts" data-type="indexterm" id="idm45599648826128"/>Since the methods in the AWS SDK make HTTP calls over the network to AWS APIs, there is always the chance that something can go wrong and a call can fail.  The base <code>AmazonServiceClient</code> class that all the SDK service clients inherit from includes functionality to manage retries.  Retry behavior can be configured by setting two properties on the service client configuration:</p>
<dl>
<dt>RetryMode</dt>
<dd>
<p>Set to one of three values from the <code>Amazon.Runtime.RequestRetryMode</code> enum.  These are <code>Legacy</code>, <code>Standard</code>, or <code>Adaptive</code>.</p>
</dd>
<dt>MaxErrorRetry</dt>
<dd>
<p>The number of times to retry a failing call from the SDK service clients before throwing an exception in your code.</p>
</dd>
</dl>
<p>You can set these values individually when creating a new instance of any AWS service client, for example:</p>
<p>To follow on from the previous example of dependency injection, however, you may want to set them globally for all service clients used in your application.  You can do this by either setting the environment variables <code>AWS_RETRY_MODE</code> and <code>AWS_MAX_ATTEMPTS</code>, or by adding configuration keys into your AWS config file like this:</p>
<pre data-type="programlisting">[default]
retry_mode = Adaptive
[profile profile-name]
region = eu-west-2</pre>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>The AWS config file is located alongside your credentials file under <em>~/.aws/credentials</em> (Linux or macOS) or <em>%USERPROFILE%\.aws\credentials</em> (Windows).</p>
</div>
<p>These values will be loaded into the <code>AWSOptions.DefaultClientConfig</code> property of your AWS options object:</p>
<pre data-code-language="csharp" data-type="programlisting"><code class="kt">var</code> <code class="n">awsOptions</code> <code class="p">=</code> <code class="n">builder</code><code class="p">.</code><code class="n">Configuration</code><code class="p">.</code><code class="n">GetAWSOptions</code><code class="p">();</code>

<code class="c1">// Default retry mode and max error setting for all service clients</code>
<code class="kt">var</code> <code class="n">retryMode</code> <code class="p">=</code> <code class="n">awsOptions</code><code class="p">.</code><code class="n">DefaultClientConfig</code><code class="p">.</code><code class="n">RetryMode</code><code class="p">;</code>
<code class="kt">var</code> <code class="n">maxErrorRetry</code> <code class="p">=</code> <code class="n">awsOptions</code><code class="p">.</code><code class="n">DefaultClientConfig</code><code class="p">.</code><code class="n">MaxErrorRetry</code><code class="p">;</code>

<code class="n">builder</code><code class="p">.</code><code class="n">Services</code><code class="p">.</code><code class="n">AddDefaultAWSOptions</code><code class="p">(</code><code class="n">awsOptions</code><code class="p">);</code>

<code class="n">services</code><code class="p">.</code><code class="n">AddAWSService</code><code class="p">&lt;</code><code class="n">IAmazonLambda</code><code class="p">&gt;();</code></pre>
<p>From here we can use or modify the values in our code to fine-tune how retries are performed in the AWS SDK.</p>
</div></section>
<section data-pdf-bookmark="Paginators" data-type="sect2"><div class="sect2" id="idm45599648828784">
<h2>Paginators</h2>
<p><a data-primary="paginators" data-type="indexterm" id="idm45599648787136"/><a data-primary="SDK (Software Development Kit)" data-secondary="paginators" data-type="indexterm" id="idm45599648786432"/>As well as retries and timeouts, the SDK service clients also include pagination functionality for services that may return large arrays of data.  For services that support it, pagination is a really nice feature that replaces the continuation token approach with a new object-based approach that returns an async enumerable.</p>
<p>First, let’s look at how we can paginate large results set <em>without</em> paginators, by using the <code>request.ContinuationToken</code> property.  We are calling <code>s3Client.ListObjectsV2Async(...)</code> inside a <code>do...while</code> loop while there is a continuation token in the response:</p>
<pre data-code-language="csharp" data-type="programlisting"><code class="k">public</code> <code class="k">static</code> <code class="k">async</code> <code class="n">IAsyncEnumerable</code><code class="p">&lt;</code><code class="kt">string</code><code class="p">&gt;</code>
        <code class="n">GetAllPaginatedKeys</code><code class="p">(</code><code class="k">this</code> <code class="n">IAmazonS3</code> <code class="n">s3Client</code><code class="p">,</code> <code class="kt">string</code> <code class="n">bucketName</code><code class="p">)</code>
<code class="p">{</code>
    <code class="kt">string?</code> <code class="n">continuationToken</code> <code class="p">=</code> <code class="k">null</code><code class="p">;</code>
    <code class="k">do</code>
    <code class="p">{</code>
        <code class="kt">var</code> <code class="n">response</code> <code class="p">=</code> <code class="k">await</code> <code class="n">s3Client</code><code class="p">.</code><code class="n">ListObjectsV2Async</code><code class="p">(</code>
            <code class="k">new</code> <code class="n">ListObjectsV2Request</code>
            <code class="p">{</code>
                <code class="n">BucketName</code> <code class="p">=</code> <code class="n">bucketName</code><code class="p">,</code>
                <code class="n">ContinuationToken</code> <code class="p">=</code> <code class="n">continuationToken</code>
            <code class="p">});</code>

        <code class="k">foreach</code> <code class="p">(</code><code class="kt">var</code> <code class="n">responseObject</code> <code class="k">in</code> <code class="n">response</code><code class="p">.</code><code class="n">S3Objects</code><code class="p">)</code>
        <code class="p">{</code>
            <code class="k">yield</code> <code class="k">return</code> <code class="n">responseObject</code><code class="p">.</code><code class="n">Key</code><code class="p">;</code>
        <code class="p">}</code>
        <code class="n">continuationToken</code> <code class="p">=</code> <code class="n">response</code><code class="p">.</code><code class="n">NextContinuationToken</code><code class="p">;</code>
    <code class="p">}</code>
    <code class="k">while</code> <code class="p">(</code><code class="n">continuationToken</code> <code class="p">!=</code> <code class="k">null</code><code class="p">);</code>
<code class="p">}</code></pre>
<p>This is fine; however, despite the advantages we get from returning an <code>IAsyncEnumerable&lt;T&gt;</code>, this is still quite a lot of code to do something as simple as chaining the results from multiple pages.  Since version 3.5 of the AWS SDK for .NET, we can now have access to the <code>Paginators</code> property on this <code>IAmazonS3</code> interface.<sup><a data-type="noteref" href="ch08.xhtml#idm45599648642496" id="idm45599648642496-marker">1</a></sup>  Here is the same method but using paginators.  Notice how the call to <code>Paginators.ListObjectsV2</code> is <em>synchronous</em> whereas the call to <code>listObjectsV2Paginator.S3Objects</code> is asynchronous.  The first call encapsulates our request object but does not actually call off to the API until we iterate over the <code>S3Objects</code> property on the paginator:</p>
<pre data-code-language="csharp" data-type="programlisting"><code class="k">public</code> <code class="k">static</code> <code class="k">async</code> <code class="n">IAsyncEnumerable</code><code class="p">&lt;</code><code class="kt">string</code><code class="p">&gt;</code>
        <code class="n">GetAllPaginatedKeys</code><code class="p">(</code><code class="k">this</code> <code class="n">IAmazonS3</code> <code class="n">s3Client</code><code class="p">,</code> <code class="kt">string</code> <code class="n">bucketName</code><code class="p">)</code>
<code class="p">{</code>
    <code class="kt">var</code> <code class="n">listObjectsV2Paginator</code> <code class="p">=</code> <code class="n">s3Client</code><code class="p">.</code><code class="n">Paginators</code><code class="p">.</code><code class="n">ListObjectsV2</code><code class="p">(</code>
        <code class="k">new</code> <code class="n">ListObjectsV2Request</code>
        <code class="p">{</code>
            <code class="n">BucketName</code> <code class="p">=</code> <code class="n">bucketName</code>
        <code class="p">});</code>

    <code class="k">await</code> <code class="nf">foreach</code> <code class="p">(</code><code class="kt">var</code> <code class="n">s3Object</code> <code class="k">in</code> <code class="n">listObjectsV2Paginator</code><code class="p">.</code><code class="n">S3Objects</code><code class="p">)</code>
    <code class="p">{</code>
        <code class="k">yield</code> <code class="k">return</code> <code class="n">s3Object</code><code class="p">.</code><code class="n">Key</code><code class="p">;</code>
    <code class="p">}</code>
<code class="p">}</code></pre>
<p>The paginator in this example returns <code>IPaginatedEnumerable&lt;S3Object&gt;</code>, which inherits <code>IAsyncEnumerable&lt;S3Object&gt;</code>, allowing us to <code>await foreach</code> over it.</p>
<p>This concludes our look at the AWS SDK for .NET and how you can get the most out of the common features that AWS has included in its service client classes.  Next we are going to round out this chapter—and this book—with a look at some of the ways AWS can bring AI into your C# codebase, through their various Artificial Intelligence as a service (AIaaS) products.</p>
</div></section>
</div></section>
<section data-pdf-bookmark="Using AWS AI Services" data-type="sect1"><div class="sect1" id="idm45599648516224">
<h1>Using AWS AI Services</h1>
<p><a data-primary="AI services" data-type="indexterm" id="ix_ch08-asciidoc10"/><a data-primary="SDK (Software Development Kit)" data-secondary="AWS AI services and" data-type="indexterm" id="ix_ch08-asciidoc11"/>A natural next step in using AWS is to dive into high-level AI services.  One of the enormous advantages of using the AWS platform is the high-level AI and ML services available.  These services allow the developer to build solutions quickly in services ranging from computer vision to natural language processing.  Here is a complete list of <a href="https://oreil.ly/oxoiD">AI services on AWS</a>. In this chapter, we are going to explore two of these AI services: Amazon Comprehend and Amazon Rekognition.  These services offer analysis for text and images, respectively, using pretrained machine learning models.  Between Comprehend and Rekognition we can cover many of the most common usages for AI that a typical .NET application may require.</p>
<section data-pdf-bookmark="AWS Comprehend" data-type="sect2"><div class="sect2" id="idm45599648511952">
<h2>AWS Comprehend</h2>
<p><a data-primary="AI services" data-secondary="AWS Comprehend" data-type="indexterm" id="ix_ch08-asciidoc12"/><a data-primary="Comprehend" data-type="indexterm" id="ix_ch08-asciidoc13"/><a data-primary="natural language processing (NLP), AWS Comprehend and" data-type="indexterm" id="ix_ch08-asciidoc14"/>Let’s get started exploring these AI services by using Amazon Comprehend.  Amazon Comprehend is a service that uses natural language processing (NLP) to find critical insights about the content of documents.  This capability could be essential for a company looking to detect customer sentiment in reports.  You can work with one or multiple documents at the same time.  The services available include the following items:</p>
<dl>
<dt>Entities</dt>
<dd>
<p>Amazon Comprehend returns document entities, including nouns like people, places, and locations.</p>
</dd>
<dt>Key phrases</dt>
<dd>
<p>Amazon Comprehend extracts vital phrases from a critical document to explain what is in the document.</p>
</dd>
<dt>PII</dt>
<dd>
<p>This function detects the presence of <a href="https://oreil.ly/GjsXC">personally identifiable information (PII)</a>.</p>
</dd>
<dt>Language</dt>
<dd>
<p>This function can successfully classify up to 100 languages as the primary language in the document.</p>
</dd>
<dt>Sentiment</dt>
<dd>
<p>This function detects a document’s emotional sentiment, including positive, neutral, negative, or mixed.</p>
</dd>
<dt>Syntax</dt>
<dd>
<p>This function extracts the parts of speech in a document, finding everything from adjectives to nouns.</p>
</dd>
</dl>
<p>One of the best ways to start any AI service on AWS is with the command line using AWS CloudShell. Let’s start with a snippet of code that you can paste into a CloudShell Bash terminal.  The command uses the following style of <code>aws</code> followed by the name of the service <code>comprehend</code>, then the feature of the service <code>detect-sentiment</code>:</p>
<pre data-code-language="bash" data-type="programlisting">aws comprehend detect-sentiment <code class="se">\</code>
    --language-code <code class="s2">"en"</code> <code class="se">\</code>
    --text <code class="s2">"I love C#."</code></pre>
<p class="pagebreak-before">The output shown in <a data-type="xref" href="#Figure-1-10">Figure 8-8</a> returns a JSON payload that includes the <code>SentimentScore</code>, i.e., the emotion of the text.</p>
<figure><div class="figure" id="Figure-1-10">
<img alt="doac 0808" height="571" src="assets/doac_0808.png" width="1037"/>
<h6><span class="label">Figure 8-8. </span>Async listing buckets</h6>
</div></figure>
<p>Another way to explore this API is by dynamically piping text from a website into our CLI.  This step works through the use of <code>lynx</code>.  Let’s run this to help us determine the sentiment around Albert Einstein on Wikipedia:</p>
<ol>
<li>
<p>First, install <code>lynx</code>:</p>
<pre data-type="programlisting">sudo yum install lynx</pre>
</li>
<li>
<p>Next, dump the page for Albert Einstein and pipe it into less to explore it:</p>
<pre data-type="programlisting">lynx -dump https://en.wikipedia.org/wiki/Albert_Einstein | less</pre>
</li>
<li>
<p>By using <code>wc -l</code>, we get a count of the lines:</p>
<pre data-type="programlisting">lynx -dump https://en.wikipedia.org/wiki/Albert_Einstein | wc -l</pre>
</li>
<li>
<p>To get the number of bytes, we can use <code>wc --bytes</code>:</p>
<pre data-type="programlisting">lynx -dump https://en.wikipedia.org/wiki/Albert_Einstein | wc \
 --bytes</pre>
<p>The result shows:</p>
<pre data-type="programlisting">432232</pre>
</li>
</ol>
<p>If you run <code>aws comprehend detect-sentiment help</code>, it can only process 5000 bytes.  Because of this, we need to truncate the output.
The truncation is done via <code>head</code> and then assigned to a Bash <code>TEXT</code> variable:</p>
<pre data-code-language="bash" data-type="programlisting"><code class="nv">TEXT</code><code class="o">=</code><code class="sb">`</code>lynx -dump https://en.wikipedia.org/wiki/Albert_Einstein <code class="p">|</code> head -c <code class="m">5000</code><code class="sb">`</code></pre>
<p>Next, the command’s output using the <code>$TEXT</code> shows that Wikipedia content around Albert Einstein is generally <code>NEUTRAL</code> with a significant <code>POSITIVE</code> percentage of 34%:</p>
<pre data-code-language="bash" data-type="programlisting">aws comprehend detect-sentiment --language-code <code class="s2">"en"</code> --text <code class="s2">"</code><code class="nv">$TEXT</code><code class="s2">"</code>
<code class="o">{</code>
    <code class="s2">"Sentiment"</code>: <code class="s2">"NEUTRAL"</code>,
    <code class="s2">"SentimentScore"</code>: <code class="o">{</code>
        <code class="s2">"Positive"</code>: <code class="m">0</code>.3402811586856842,
        <code class="s2">"Negative"</code>: <code class="m">0</code>.0033634265419095755,
        <code class="s2">"Neutral"</code>: <code class="m">0</code>.6556956768035889,
        <code class="s2">"Mixed"</code>: <code class="m">0</code>.0006596834864467382
    <code class="o">}</code>
<code class="o">}</code></pre>
<p>The Bash command line also makes building one solution and pivoting into another common.  In the following example, we switch to detecting entities from the same blob of Wikipedia text.  Notice that we use <code>--output text</code> to use the power of Bash to filter the output:</p>
<pre data-code-language="bash" data-type="programlisting">aws comprehend detect-entities <code class="se">\</code>
    --language-code <code class="s2">"en"</code> <code class="se">\</code>
    --text <code class="s2">"</code><code class="nv">$TEXT</code><code class="s2">"</code> <code class="se">\</code>
    --output text <code class="p">|</code> head</pre>
<p>The output of the command shows the following entities:</p>
<pre data-code-language="bash" data-type="programlisting">ENTITIES    <code class="m">20</code>     <code class="m">29</code>     <code class="m">0</code>.632317066192627     Wikipedia          ORGANIZATION
ENTITIES    <code class="m">126</code>    <code class="m">141</code>    <code class="m">0</code>.9918091297149658    Albert Einstein    PERSON
ENTITIES    <code class="m">151</code>    <code class="m">160</code>    <code class="m">0</code>.7205400466918945    Wikipedia          ORGANIZATION
ENTITIES    <code class="m">230</code>    <code class="m">236</code>    <code class="m">0</code>.9783479571342468    German             OTHER
ENTITIES    <code class="m">256</code>    <code class="m">264</code>    <code class="m">0</code>.9940117001533508    Einstein           PERSON
ENTITIES    <code class="m">305</code>    <code class="m">313</code>    <code class="m">0</code>.9899683594703674    Einstein           PERSON
ENTITIES    <code class="m">341</code>    <code class="m">356</code>    <code class="m">0</code>.9821130633354187    Albert Einstein    PERSON
ENTITIES    <code class="m">379</code>    <code class="m">394</code>    <code class="m">0</code>.990595817565918     Albert Einstein    PERSON
ENTITIES    <code class="m">401</code>    <code class="m">409</code>    <code class="m">0</code>.814979076385498     Einstein           PERSON
ENTITIES    <code class="m">410</code>    <code class="m">414</code>    <code class="m">0</code>.9937220215797424    <code class="m">1921</code>               DATE</pre>
<p>We could go even further and count the unique entities found using Bash.  The following Bash pipeline converts entity column to lowercase then formats to easily count unusual occurrences.  It isn’t perfect, but it gets us a close enough proof of concept to know how to prototype APIs with Bash before moving on to C#:</p>
<pre data-code-language="bash" data-type="programlisting">aws comprehend detect-entities <code class="se">\</code>
    --language-code <code class="s2">"en"</code> <code class="se">\</code>
    --text <code class="s2">"</code><code class="nv">$TEXT</code><code class="s2">"</code> <code class="se">\</code>
    --output text <code class="se">\</code>
    <code class="p">|</code> cut -f <code class="m">5</code> <code class="se">\</code>
    <code class="p">|</code> tr -cd <code class="s2">"[:alpha:][:space:]"</code> <code class="se">\</code>
    <code class="p">|</code> tr <code class="s1">' [:upper:]'</code> <code class="s1">'\n[:lower:]'</code> <code class="se">\</code>
    <code class="p">|</code> tr -s <code class="s1">'\n'</code> <code class="se">\</code>
    <code class="p">|</code> sort <code class="se">\</code>
    <code class="p">|</code> uniq -c <code class="se">\</code>
    <code class="p">|</code> sort -nr -k <code class="m">1</code> <code class="se">\</code>
    <code class="p">|</code> head</pre>
<p>The output of the Bash pipeline shows us that several entities are worth exploring more, at least from the initial part of the text extracted:</p>
<pre data-code-language="bash" data-type="programlisting">     <code class="m">12</code> einstein
      <code class="m">9</code> of
      <code class="m">6</code> university
      <code class="m">4</code> german
      <code class="m">4</code> empire
      <code class="m">4</code> Albert
      <code class="m">3</code> kingdom
      <code class="m">2</code> Zurich
      <code class="m">2</code> wrttemberg
      <code class="m">2</code> Wikipedia</pre>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>You can also watch a walk-through of using Bash to extract entities from scratch on <a href="https://oreil.ly/NzKhQ">O’Reilly</a> or <a href="https://oreil.ly/DwlYG">YouTube</a>.</p>
</div>
<p>With those explorations out of the way, let’s move to code up a solution in C#.</p>
<p>Again, select a Visual Studio Console App and install Comprehend via NuGet as shown in <a data-type="xref" href="#Figure-1-11">Figure 8-9</a>.</p>
<figure><div class="figure" id="Figure-1-11">
<img alt="doac 0809" height="754" src="assets/doac_0809.png" width="1544"/>
<h6><span class="label">Figure 8-9. </span>NuGet Comprehend install</h6>
</div></figure>
<p>Here is the sentiment detection done using the <code>DetectSentimentAsync()</code> method of the service class found in the AWSSDK.Comprehend package:</p>
<pre data-code-language="csharp" data-type="programlisting"><code class="k">using</code> <code class="nn">Amazon</code><code class="p">;</code>
<code class="k">using</code> <code class="nn">Amazon.Comprehend</code><code class="p">;</code>
<code class="k">using</code> <code class="nn">Amazon.Comprehend.Model</code><code class="p">;</code>

<code class="c1">// Display title</code>
<code class="n">Console</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code><code class="s">"AWS AI API Sentiment Detector"</code> <code class="p">+</code> <code class="n">Environment</code><code class="p">.</code><code class="n">NewLine</code><code class="p">);</code>

<code class="c1">// Ask for phrase</code>
<code class="n">Console</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code><code class="s">"Type in phrase for analysis"</code> <code class="p">+</code> <code class="n">Environment</code><code class="p">.</code><code class="n">NewLine</code><code class="p">);</code>
<code class="kt">var</code> <code class="n">phrase</code> <code class="p">=</code> <code class="n">Console</code><code class="p">.</code><code class="n">ReadLine</code><code class="p">();</code>

<code class="c1">// Detect Sentiment</code>
<code class="kt">var</code> <code class="n">comprehendClient</code> <code class="p">=</code> <code class="k">new</code> <code class="n">AmazonComprehendClient</code><code class="p">(</code><code class="n">RegionEndpoint</code><code class="p">.</code><code class="n">EUWest1</code><code class="p">);</code>
<code class="n">Console</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code><code class="s">"Calling DetectSentiment"</code><code class="p">);</code>

<code class="kt">var</code> <code class="n">detectSentimentResponse</code> <code class="p">=</code> <code class="k">await</code>
<code class="n">comprehendClient</code><code class="p">.</code><code class="n">DetectSentimentAsync</code><code class="p">(</code>
<code class="k">new</code> <code class="nf">DetectSentimentRequest</code><code class="p">()</code>
<code class="p">{</code>
    <code class="n">Text</code> <code class="p">=</code> <code class="n">phrase</code><code class="p">,</code>
    <code class="n">LanguageCode</code> <code class="p">=</code> <code class="s">"en"</code>
<code class="p">});</code>
<code class="n">Console</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code><code class="n">detectSentimentResponse</code><code class="p">.</code><code class="n">Sentiment</code><code class="p">);</code>
<code class="n">Console</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code><code class="s">"Done"</code><code class="p">);</code></pre>
<p>Running the Console Application and entering some text, as illustrated in <a data-type="xref" href="#Figure-1-12">Figure 8-10</a>, shows our statement is a <code>MIXED</code> sentiment.</p>
<figure><div class="figure" id="Figure-1-12">
<img alt="doac 0810" height="301" src="assets/doac_0810.png" width="1099"/>
<h6><span class="label">Figure 8-10. </span>Output of Comprehend Console App</h6>
</div></figure>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>You can also watch a walk-through of using C# with AWS Comprehend on <a href="https://oreil.ly/bNhVs">O’Reilly</a> or <a href="https://youtu.be/zhiNMmg8FxA">YouTube</a>.</p>
</div>
<p>This example has used <code>DetectSentimentAsync()</code> to detect the <em>sentiment</em> (overall mood) of the text; however, we can just as easily perform entity detection on our text by calling <code>client.DetectEntities()</code> and inspecting the list of entities AWS detected in the text.<a data-startref="ix_ch08-asciidoc14" data-type="indexterm" id="idm45599648031680"/><a data-startref="ix_ch08-asciidoc13" data-type="indexterm" id="idm45599648031040"/><a data-startref="ix_ch08-asciidoc12" data-type="indexterm" id="idm45599648030368"/> Another service that offers entity detection, but this time in an image, is AWS Rekognition.</p>
</div></section>
<section data-pdf-bookmark="AWS Rekognition" data-type="sect2"><div class="sect2" id="idm45599648511008">
<h2>AWS Rekognition</h2>
<p><a data-primary="AI services" data-secondary="AWS Rekognition" data-type="indexterm" id="ix_ch08-asciidoc15"/><a data-primary="computer vision, AWS Rekognition and" data-type="indexterm" id="ix_ch08-asciidoc16"/><a data-primary="Rekognition" data-type="indexterm" id="ix_ch08-asciidoc17"/><a data-primary="vision, computer" data-type="indexterm" id="ix_ch08-asciidoc18"/>Rekognition is AWS’s computer vision service for both images and video.  It provides a number of pretrained machine learning models to fit a range of different image recognition needs, all in an easy-to-use API available through the .NET SDK and priced using a pay-as-you-go model.  You can try the service out with your own image by searching for “Rekognition” in the AWS Management Console and clicking the Try Demo button.  From here you can upload an image from your machine (or choose a sample image provided by AWS) and select from one of the pretrained models.  <a data-type="xref" href="#Figure-8-X">Figure 8-11</a> shows the results of the <em>label detection</em> algorithm, as you can see AWS Rekognition has identified this image as 98.1% likely to contain a cat.<sup><a data-type="noteref" href="ch08.xhtml#idm45599648023152" id="idm45599648023152-marker">2</a></sup></p>
<figure><div class="figure" id="Figure-8-X">
<img alt="doac 0811" height="820" src="assets/doac_0811.png" width="1004"/>
<h6><span class="label">Figure 8-11. </span>Testing out Rekognition through the Management Console</h6>
</div></figure>
<p>Calling AWS Rekognition from your C# code is as simple as installing the AWSSDK.Rekognition package from NuGet and utilizing the <code>Amazon.Rekognition.AmazonRekognitionClient</code> service class to call the API.  You can inject or instantiate this service class in any of the ways we have seen earlier in this chapter; in this example, we have registered it with <code>services.AddAWSService&lt;IAmazonRekognition&gt;();</code>:</p>
<pre data-code-language="csharp" data-type="programlisting"><code class="k">using</code> <code class="nn">Amazon.Rekognition</code><code class="p">;</code>
<code class="k">using</code> <code class="nn">Amazon.Rekognition.Model</code><code class="p">;</code>
<code class="k">using</code> <code class="nn">Microsoft.AspNetCore.Mvc</code><code class="p">;</code>

<code class="k">namespace</code> <code class="nn">AwsRekognitionExample.Controllers</code><code class="p">;</code>

<code class="na">[Route("api/[controller]</code><code class="s">")]</code>
<code class="k">public</code> <code class="k">class</code> <code class="nc">ImageController</code>
<code class="p">{</code>
    <code class="k">private</code> <code class="k">readonly</code> <code class="n">IAmazonRekognition</code> <code class="n">_rekognition</code><code class="p">;</code>

    <code class="k">public</code> <code class="nf">ImageController</code><code class="p">(</code><code class="n">IAmazonRekognition</code> <code class="n">rekognition</code><code class="p">)</code>
    <code class="p">{</code>
        <code class="n">_rekognition</code> <code class="p">=</code> <code class="n">rekognition</code><code class="p">;</code>
    <code class="p">}</code>

<code class="na">    [HttpGet]</code>
    <code class="k">public</code> <code class="k">async</code> <code class="n">Task</code><code class="p">&lt;</code><code class="kt">string</code><code class="p">&gt;</code> <code class="n">GetFirstLabel</code><code class="p">()</code>
    <code class="p">{</code>
        <code class="kt">var</code> <code class="n">response</code> <code class="p">=</code> <code class="k">await</code> <code class="n">_rekognition</code><code class="p">.</code><code class="n">DetectLabelsAsync</code><code class="p">(</code>
            <code class="k">new</code> <code class="n">DetectLabelsRequest</code>
            <code class="p">{</code>
                <code class="n">Image</code> <code class="p">=</code> <code class="k">new</code> <code class="n">Image</code><code class="p">()</code>
                <code class="p">{</code>
                    <code class="n">S3Object</code> <code class="p">=</code> <code class="k">new</code> <code class="n">S3Object</code><code class="p">()</code>
                    <code class="p">{</code>
                        <code class="n">Name</code> <code class="p">=</code> <code class="s">"cat.jpg"</code><code class="p">,</code>
                        <code class="n">Bucket</code> <code class="p">=</code> <code class="s">"photos-bucket"</code><code class="p">,</code>
                    <code class="p">},</code>
                <code class="p">},</code>
                <code class="n">MaxLabels</code> <code class="p">=</code> <code class="m">10</code><code class="p">,</code>
                <code class="n">MinConfidence</code> <code class="p">=</code> <code class="m">75F</code><code class="p">,</code>
            <code class="p">});</code>

        <code class="k">return</code> <code class="n">response</code><code class="p">.</code><code class="n">Labels</code><code class="p">.</code><code class="n">FirstOrDefault</code><code class="p">()?.</code><code class="n">Name</code> <code class="p">??</code> <code class="s">"None"</code><code class="p">;</code>
    <code class="p">}</code>
<code class="p">}</code></pre>
<p>In this example, we are calling <code>IAmazonRekognitionDetectLabelsAsync(...)</code> and passing a reference to the image in an S3 bucket.  The Rekognition API works by loading the image data from an S3 bucket over accepting image data in the HTTP call to invoke the function. Saving large data files like images to S3 first, and then calling services such as AWS Rekognition is a good pattern to follow in a cloud native AWS application as it allows you to architect an event-driven system.  If you need to upload the image first, you could utilize an S3 trigger much like we did in<a data-startref="ix_ch08-asciidoc18" data-type="indexterm" id="idm45599648007584"/><a data-startref="ix_ch08-asciidoc17" data-type="indexterm" id="idm45599648006976"/><a data-startref="ix_ch08-asciidoc16" data-type="indexterm" id="idm45599648006368"/><a data-startref="ix_ch08-asciidoc15" data-type="indexterm" id="idm45599647888640"/> <a data-type="xref" href="ch04.xhtml#3-resume-example-event-driven">“C# Résumé Uploader example: event-driven”</a><a data-startref="ix_ch08-asciidoc11" data-type="indexterm" id="idm45599647887168"/><a data-startref="ix_ch08-asciidoc10" data-type="indexterm" id="idm45599647886496"/>.<a data-startref="ix_ch08-asciidoc0" data-type="indexterm" id="idm45599647856224"/></p>
</div></section>
</div></section>
<section data-pdf-bookmark="Critical Thinking Discussion Questions" data-type="sect1"><div class="sect1" id="idm45599647855488">
<h1>Critical Thinking Discussion Questions</h1>
<ul>
<li>
<p>What are a few real-world consequences of using timeouts in communicating the AWS SDK in production code?</p>
</li>
<li>
<p>What are a few real-world consequences of using retries in communicating the AWS SDK in production code?</p>
</li>
<li>
<p>What new workflows are enabled by using async communication using the AWS SDK?</p>
</li>
<li>
<p>What architecture patterns are most cost-effective to avoid duplicate API calls in production systems?</p>
</li>
<li>
<p>What unique advantages does .NET coupled with AWS give you?</p>
</li>
</ul>
</div></section>
<section data-pdf-bookmark="Exercises" data-type="sect1"><div class="sect1" id="idm45599647849472">
<h1>Exercises</h1>
<ul>
<li>
<p>Set up the AWS Toolkit for Visual Studio if you haven’t already and use it to create a new S3 bucket, create a folder inside the bucket, and finally upload an image or file from your desktop.</p>
</li>
<li>
<p>Expand on the AWS Rekognition example and convert it to a web service deployed on AWS App Runner.</p>
</li>
<li>
<p>Expand on the AWS Comprehend example and convert it to a web service deployed on AWS App Runner.</p>
</li>
<li>
<p>Create a portfolio project highlighting a complete master of .NET on AWS showing end-to-end development skills, including IaC and frontend.</p>
</li>
</ul>
</div></section>
<section data-pdf-bookmark="Conclusion" data-type="sect1"><div class="sect1" id="idm45599647844016">
<h1>Conclusion</h1>
<p><a data-primary="cloud native (term)" data-type="indexterm" id="idm45599647842640"/>We have used the term cloud native several times in this book, and you have no doubt encountered it many times in the wild, but let’s think about what it really means and why it matters. Cloud native code runs either exclusively in, or at least is optimized for, the cloud.  By writing our code with the intention of running it exclusively on AWS, we can adopt a much deeper level of integration with AWS services such as message queues, databases, logging, and reporting.  If our C# code is born in the cloud (the dictionary definition of the word <em>native</em>), we can write it to best take advantage of the services around it.  Sure, there are trade-offs.  Local development is more difficult if you have architected your application to use exclusively AWS Lambda functions.  Complexity can increase exponentially if you increasingly integrate AWS X-Ray tracing for performance monitoring into every execution path.  There are trade-offs; however, the benefits you gain in performance, flexibility, and often cost, will often vastly outweigh these drawbacks.</p>
<p><a data-primary="Toolkit for Visual Studio" data-secondary="advantages of" data-type="indexterm" id="idm45599647841136"/>Remember, whether you prefer to develop in Visual Studio, VS Code, or Cloud9, there is a C# AWS workflow to suit you. <a data-primary="Toolkit for Visual Studio" data-type="indexterm" id="idm45599647839936"/>The AWS Toolkit for Visual Studio has been around in one form or another since Visual Studio 2008 and is regularly updated to keep pace with additions to both AWS and Visual Studio itself.  The latest version of the toolkit is even rolling out a new Publish to AWS experience that aims to make publishing your code to the cloud even simpler, allowing you to rapidly test your code in the environment it will be native to: the cloud.  <a data-primary="Cloud9" data-type="indexterm" id="idm45599647839168"/>For us, we love Cloud9 for its seamless integration into AWS services and ability to access it from anywhere you have a web browser.  Web-based IDEs may not be for everyone, but if you regularly change development machines or use portable or loaner devices for development, having your code accessible from anywhere in the cloud can be a game changer.</p>
<p>Amazon Web Services is the most broadly adopted cloud platform in the world and has been supporting .NET in the cloud since 2008.  With over 200 services offering everything from a simple Windows virtual machine you can spin up for any task imaginable, to machine learning services like those we have visited in this chapter, AWS supports .NET on 485 instance types, 255 different AMIs for Windows workloads, and 40 different Linux AMIs with .NET or SQL Server preconfigured. This all means deploying to and integrating with AWS from your C# codebase has never been easier.</p>
<p>In this book we have covered many of the ways you can leverage AWS in your application, but there are many more we have not had time to cover.  There are open source .NET tools, Windows samples for AWS CodeBuild, an MQTT client for leveraging Internet of Things (IoT) services, and over 20 AWS services for machine learning alone.  Among these, AWS SageMaker is a service that allows you to train and deploy your own ML models, a topic we could fill an entire book with by itself.</p>
<p>What we have covered, however, should give you an entry point into Amazon’s cloud services and help you plan the next stage of development for your .NET codebase(s). Whether that be a migration, containerization, or rewrite from the ground up, we hope the topics on these pages have given you enough food for thought.</p>
</div></section>
<div data-type="footnotes"><p data-type="footnote" id="idm45599648642496"><sup><a href="ch08.xhtml#idm45599648642496-marker">1</a></sup> The example here is just using the Simple Storage Service (S3) client; however, this same <code>Paginators</code> property is available on many different service clients for AWS services that have methods potentially returning a large number of items.</p><p data-type="footnote" id="idm45599648023152"><sup><a href="ch08.xhtml#idm45599648023152-marker">2</a></sup> We almost got to the end of this book without including a picture of James’s cat.</p></div></div></section></div></body></html>