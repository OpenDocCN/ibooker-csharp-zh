["```cs\npublic interface ICurriedFunctions\n{\n decimal Add(decimal a, decimal b);\n}\n\nvar curry = // some logic for obtaining an implementation of the interface\n\nvar answer = curry.Add(100, 200);\n```", "```cs\npublic interface ICurriedFunctions\n{\n decimal Add(decimal a, decimal b);\n}\n\nvar curry = // some logic for obtaining an implementation of the interface\n\nvar answer = curry.Add(100); // What could it be?\n```", "```cs\npublic interface ICurriedFunctions\n{\n decimal Add(decimal a, decimal b);\n}\n\nvar curry = // some logic for obtaining an implementation of the interface\n\nvar add100 = curry.Add(100); // Func<decimal,decimal>, adds 100 to the input\n\nvar answerA = add100(200); // 300 -> 200+100\nvar answerB = add100(0); // 100 -> 0+100\nvar answerC = add100(900); // 1000 -> 900+100\n```", "```cs\n// Input in the format:\n//\n//title,author,publicationDate\n//The Hitch-Hiker's Guide to the Galaxy,Douglas Adams,1979\n//Dimension of Miracles,Robert Sheckley,1968\n//The Stainless Steel Rat,Harry Harrison,1957\n//The Unorthodox Engineers,Colin Kapp,1979\n\npublic IEnumerable<Book> ParseBooks(string fileName) =>\n File.ReadAllText(fileName)\n  .Split(\"\\r\\n\")\n  .Skip(1) // Skip the header\n  .Select(x => x.split(\",\").ToArray())\n  .Select(x => new Book\n  {\n   Title = x[0],\n   Author = x[1],\n   PublicationDate = x[2]\n  });\n\nvar bookData = parseBooks(\"books.csv\");\n```", "```cs\npublic IEnumerable<Book> ParseBooks(\n string lineBreak,\n bool skipHeader,\n string fieldDelimiter,\n string fileName\n) =>\n File.ReadAllText(fileName)\n  .Split(lineBreak)\n  .Skip(skipHeader ? 1 : 0)\n  .Select(x => x.split(fieldDelimiter).ToArray())\n  .Select(x => new Book\n  {\n   Title = x[0],\n   Author = x[1],\n   PublicationDate = x[2]\n  });\n\nvar bookData = ParseBooks(Environment.NewLine, true, \",\", \"books.csv\");\n```", "```cs\nvar bookData1 = ParseBooks(Environment.NewLine, true,  \",\", \"books.csv\");\nvar bookData2 = ParseBooks(Environment.NewLine, true, \"|\", \"books2.csv\");\nvar bookData3 = ParseBooks(\"\\n\", false, \",\", \"books3.csv\");\n```", "```cs\n// First some magic that curries the parseBooks function\n// I'll look into implementation details later, let's just\n// understand the theory for now.\n\nvar curriedParseBooks = ParseBooks.Curry();\n\n// these two have 3 parameters - string, string, string\nvar parseSkipHeader = curriedParseBooks(true);\nvar parseNoHeader = curriedParseBooks(false);\n\n// 2 parameters\nvar parseSkipHeaderEnvNl = parseSkipHeader(Environment.NewLine);\nvar parseNoHeaderLinux = parseNoHeader(\"\\n\");\n\n// 1 parameter each\nvar parseSkipHeaderEnvNlCommarDel = parseSkipHeaderEnvNl(\",\");\nvar parseSkipHeaderEnvNlPipeDel = parseSkipHeaderEnvNl(\"|\");\nvar parseNoHeaderLinuxCommarDel = parseNoHeaderLinux(\",\");\n\n// Actual data, Enumerables of Book data\nvar bookData1 = parseSkipHeaderEnvNlCommarDel(\"books.csv\");\nvar bookData2 = parseSkipHeaderEnvNlPipeDel(\"books2.csv\");\nvar bookData3 = parseNoHeaderLinuxCommarDel(\"books3.csv\");\n```", "```cs\nvar bookData1 = parseBooks(true)(Environment.NewLine)(\",\")(\"books.csv\")\nvar bookData2 = parseBooks(true)(Environment.NewLine)(\"|\")(\"books2.csv\")\nvar bookData3 = parseBooks(true)(\"\\n\")(\",\")(\"books3.csv\")\n```", "```cs\n// For the sake of this exercise, the parameters are\n// an enum (log type - warning, error, info, etc.) and a string\n// containing a message to store in the log file\nvar logger = getLoggerFunction()\nvar curriedLogger = logger.Curry();\n\nvar logInfo = curriedLogger(LogLevel.Info);\nvar logWarning = curriedLogger(LogLevel.Warning);\nvar logError = curriedLogger(LogLevel.Error);\n\n// You'd use them then, like this:\n\nlogInfo(\"This currying lark works a treat!\");\n```", "```cs\n// once again, the Currying process is just magic for now.\n// Keep reading for the implementation\n\nvar add = ((x,y) => x + y).Curry();\nvar subtract = ((x,y) => y - x).Curry();\nvar multiply = ((x,y) => x * y).Curry();\nvar divide = ((x,y) => y / x).Curry();\n```", "```cs\nvar celsiusToFahrenheit = x =>\n x.Map(multiply(9))\n .Map(divide(5))\n .Map(add(32));\n\nvar fahrenheitToCelsius = x=>\n x.Map(subtract(32))\n  .Map(multiply(5))\n  .Map(divide(9));\n```", "```cs\nvar Add = (decimal x) => (decimal y) => x + y;\nvar Subtract = (decimal x) => (decimal y) => y - x;\nvar Multiply = (decimal x) => (decimal y) => x * y;\nvar Divide = (decimal x) => (decimal y) => y / x;\n```", "```cs\npublic static class CurryingExtensions\n{\n  public static Func<T1, Func<T2, TOut>> Curry<T1, T2, TOut>(\n   Func<T1, T2, TOut> functionToCurry) =>\n    (T1 x) => (T2 y) => functionToCurry(x, y);\n\n  public static Func<T1, Func<T2, Func<T3, TOut>>> Curry<T1, T2, T3, TOut>(\n   Func<T1, T2, T3, TOut> functionToCurry) =>\n    (T1 x) => (T2 y) => (T3 z) => functionToCurry(x, y, z);\n\n  public static Func<T1, Func<T2, Func<T3, Func<T4, TOut>>>> Curry<T1, T2, T3, T4, TOut>(\n   Func<T1, T2, T3, T4, TOut> functionToCurry) =>\n    (T1 x) => (T2 y) => (T3 z) => (T4 a) => functionToCurry(x, y, z, a);\n}\n```", "```cs\nvar Add = F.Curry((decimal x, decimal y) => x + y);\nvar Subtract = F.Curry((decimal x, decimal y) => y - x);\nvar Multiply = F.Curry((decimal x, decimal y) => x * y);\nvar Divide = F.Curry((decimal y, decimal y) => y / x);\n```", "```cs\npublic static class Ext\n{\n\tpublic static Func<T1,Func<T2, T3>> Curry<T1,T2,T3>(\n\t this Func<T1,T2,T3> @this) =>\n\t\t (T1 x) => (T2 y) => @this(x, y);\n\n\tpublic static Func<T1,Func<T2,Func<T3,T4>>>Curry<T1,T2,T3,T4>(\n\t this Func<T1,T2,T3,T4> @this) =>\n\t\t (T1 x) => (T2 y) => (T3 z) => @this(x, y, z);\n\n\tpublic static Func<T1,Func<T2,Func<T3,Func<T4,T5>>>>Curry<T1,T2,T3,T4,T5>(\n\t this Func<T1,T2,T3,T4,T5> @this) =>\n\t\t (T1 x) => (T2 y) => (T3 z) => (T4 a) => @this(x, y, z, a);\n}\n```", "```cs\n// specifically define the function on one line\n// it has to be stored as a `Func` delegate, rather than a\n// Lambda expression\nvar Add = (decimal x, decimal y) => x + y;\nvar CurriedAdd = Add.Curry();\n\nvar add10 = CurriedAdd(10);\nvar answer = add10(100);\n// answer = 110\n```", "```cs\nvar curriedParseBooks = parseBooks.Curry();\n\nvar parseNoHeaderLinuxCommaDel = curriedParseBooks(false)(\"\\n\")(\",\");\n\nvar parseWindowsHeader = curriedParseBooks(true)(Environment.NewLine);\nvar parseWindowsHeaderComma = parseWindowsHeader(\",\");\nvar parseWindowsHeaderPipe = parseWindowsHeader(\"|\");\n\n// Actual data, Enumerables of Book data\nvar bookData1 = parseWindowsHeaderComma(\"books.csv\");\nvar bookData2 = parseWindowsHeaderPipe(\"books2.csv\");\nvar bookData3 = parseNoHeaderLinuxCommaDel(\"books3.csv\");\n```", "```cs\n// I'm using an extension method called Partial to apply\n// parameters.  Check out the next section for implementation details\n\nvar parseNoHeaderLinuxCommarDel = ParseBooks.Partial(false,\"\\n\",\",\");\n\nvar parseWindowsHeader =\n curriedParseBooks.Partial(true,Environment.NewLine);\nvar parseWindowsHeaderComma = parseWindowsHeader.Partial(\",\");\nvar parseWindowsHeaderPipe = parseWindowsHeader.Partial(\"|\");\n\n// Actual data, Enumerables of Book data\nvar bookData1 = parseWindowsHeaderComma(\"books.csv\");\nvar bookData2 = parseWindowsHeaderPipe(\"books2.csv\");\nvar bookData3 = parseNoHeaderLinuxCommarDel(\"books3.csv\");\n```", "```cs\npublic static class PartialApplicationExtensions\n{\n// 4 parameters to 1\n public static Func<T4,TOut> Partial<T1,T2,T3,T4,TOut>(\n  this Func<T1,T2,T3,T4,TOut> f,\n  T1 one, T2 two, T3 three) => (T4 four) => f(one, two, three, four);\n\n// 4 parameters to 2\n public static Func<T3,T4,TOut>Partial<T1,T2,T3,T4,TOut>(\n  this Func<T1,T2,T3,T4,TOut> f,\n  T1 one, T2 two) => (T3 three, T4 four) => f(one, two, three, four);\n\n // 2 parameters to 1\n public static Func<T2, TOut> Partial<T1,T2,TOut>(\n  this Func<T1,T2,TOut> f, T1 one) =>\n   (T2 two) => f(one, two);\n\n}\n```"]