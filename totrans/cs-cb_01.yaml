- en: Chapter 1\. Constructing Types and Apps
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章 构建类型和应用
- en: One of the first things we do as developers is design, organize, and create
    new types. This chapter helps with these tasks by offering several useful recipes
    for setting up the project, managing object lifetime, and establishing patterns.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 开发人员的首要任务之一是设计、组织和创建新类型。本章通过提供几种有用的方法来帮助完成这些任务，包括设置项目、管理对象生命周期和建立模式。
- en: Establishing Architecture
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 建立架构
- en: When you’re first setting up a project, you have to think about the overall
    architecture. There’s a concept called *separation of concerns* wherein each part
    of an application has a specific purpose (e.g., the UI layer interacts with users,
    a business logic layer manages rules, and a data layer interacts with a data source).
    Each layer has a purpose or responsibilities and contains the code to perform
    its operations.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在初次设置项目时，你需要考虑整体架构。有一个叫做*关注点分离*的概念，即应用程序的每个部分都有特定的目的（例如，UI层与用户交互，业务逻辑层管理规则，数据层与数据源交互）。每一层都有自己的目的或职责，并包含执行其操作的代码。
- en: In addition to promoting more loosely coupled code, separation of concerns makes
    it easier for developers to work with that code because it’s easier to find where
    a certain operation occurs. This makes it easier to add new features and maintain
    existing code. The benefits of this are higher quality applications and more productive
    work. It pays to get started right, which is why we have [Recipe 1.5](#designing_application_layers).
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 除了促进更松散耦合的代码之外，关注点分离还使开发人员更容易处理代码，因为更容易找到特定操作发生的位置。这使得添加新功能和维护现有代码更加容易。其好处包括更高质量的应用程序和更高效的工作。因此，从一开始就做好准备是值得的，这也是为什么我们有[第1.5节](#designing_application_layers)。
- en: Related to loosely coupling code, there’s inversion of control (IoC), which
    helps decouple code and promotes testability. [Recipe 1.2](#removing_explicit_dependencies)
    explains how this works. When we look at ensuring quality, in [Chapter 3](ch03.xhtml#ensuring_quality),
    you’ll see how IoC fits in to unit testing.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 与松散耦合代码相关的还有控制反转（IoC），它有助于解耦代码并促进可测试性。[第1.2节](#removing_explicit_dependencies)解释了其工作原理。在关于确保质量的章节[第3章](ch03.xhtml#ensuring_quality)中，您将了解IoC如何适用于单元测试。
- en: Applying Patterns
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用模式
- en: A lot of the code we write is Transaction Script, where the user interacts with
    a UI and the code performs some type of create, read, update, or delete (CRUD)
    operation in the database and returns the result. Other times, we have complex
    interactions between objects that are difficult to organize. We need other patterns
    to solve these hard problems.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们编写的大部分代码是交易脚本（Transaction Script），用户通过UI与之交互，代码执行数据库中的创建、读取、更新或删除（CRUD）操作，并返回结果。有时，我们需要处理对象之间复杂的交互，这些问题难以组织。我们需要其他模式来解决这些难题。
- en: This chapter presents a few useful patterns in a rather informal manner. The
    idea is that you’ll have some code to rename and adapt to your purposes and a
    rationale on when a given pattern would be useful. As you read through each pattern,
    try to think about other code you’ve written or other situations where that pattern
    would have simplified the code.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章以比较非正式的方式介绍了一些有用的模式。其核心思想是，你会有一些代码可以重命名和调整以适应你的目的，以及一个关于何时使用某个模式的理由。在阅读每个模式时，试着思考你已经编写的其他代码或其他情况，看看该模式如何简化代码。
- en: If you run into the problem of having different APIs to different systems and
    needing to switch between them, you’ll be interested in reading [Recipe 1.8](#making-classes-adapt).
    It shows how to build a single interface to solve this problem.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你遇到不同系统的不同API并需要在它们之间切换的问题，你会对阅读[第1.8节](#making-classes-adapt)感兴趣。它展示了如何构建一个单一接口来解决这个问题。
- en: Managing Object Lifetime
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理对象生命周期
- en: Other important tasks we perform relate to object lifetime—that is, instantiating
    objects in memory, holding objects in memory for processing, and the subsequent
    release of that memory when the object is no longer needed. Recipes [1.3](#delegating_object_creation_to_a_class)
    and [1.4](#delegating_object_creation_to_a_method) show a couple of nice factory
    patterns that let you decouple object creation from code. This fits in with the
    IoC concepts mentioned previously.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们执行的其他重要任务与对象生命周期相关，即在内存中实例化对象，将对象保留在内存中进行处理，并在不再需要对象时释放该内存。第[1.3节](#delegating_object_creation_to_a_class)和[1.4节](#delegating_object_creation_to_a_method)的配方展示了一些漂亮的工厂模式，让您能够将对象创建与代码解耦。这与前面提到的IoC概念是一致的。
- en: One way to manage object creation is through a fluid interface, where you can
    include optional settings (via methods) and validate before object construction.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 通过流接口管理对象创建是一种方法，您可以通过方法包含可选设置，并在对象构建之前进行验证。
- en: Another important object-lifetime consideration is disposal. Think about the
    drawbacks of excessive resource consumption, including memory use, file locks,
    and any other object that holds operating system resources. These problems often
    result in application crashes and are difficult to detect and fix. Performing
    proper resource cleanup is so important that it’s the first recipe we’ll cover
    in the book.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要的对象生命周期考虑是处置。考虑过度资源消耗的缺点，包括内存使用、文件锁定以及任何持有操作系统资源的其他对象。这些问题通常导致应用程序崩溃，并且很难检测和修复。执行适当的资源清理非常重要，这是我们在本书中将要讨论的第一个方法。
- en: 1.1 Managing Object End-of-Lifetime
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1.1 管理对象生命周期末端
- en: Problem
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: Your application is crashing because of excessive resource usage.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 由于过度资源使用，您的应用程序正在崩溃。
- en: Solution
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Here’s the object with the original problem:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是具有原始问题的对象：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'And here’s how to fix the problem:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这是解决问题的方法：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This is the `Main` method, using this object:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`Main`方法，使用此对象：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Discussion
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: The problem in this code was with the `StreamWriter report`. Whenever you’re
    using some type of resource, such as the `report` file reference, you need to
    release (or dispose) that resource. The specific problem here occurs because the
    app, through the `StreamWriter`, requested a file handle from the Windows OS.
    This app owns that file handle, and Windows expects the owning app to release
    the handle. If your app closes without releasing that handle, Windows prevents
    all applications, including subsequent running of your app, from accessing that
    file. In the worst case, everything crashes in a hard-to-find scenario that involves
    multiple people over a number of hours debugging a critical production problem.
    This occurs because Windows believes that file is still in use.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码中的问题出在`StreamWriter report`上。每当使用某种资源（如`report`文件引用）时，您需要释放（或处理）该资源。此处的特定问题发生在应用程序通过`StreamWriter`请求文件句柄来自Windows操作系统。该应用程序拥有该文件句柄，并且Windows期望拥有的应用程序释放该句柄。如果您的应用程序关闭而没有释放该句柄，Windows将阻止所有应用程序（包括随后运行的您的应用程序）访问该文件。在最糟糕的情况下，所有内容都会在一个难以找到的场景中崩溃，这涉及多人数小时调试关键生产问题。这是因为Windows认为文件仍在使用中。
- en: The solution is to implement the dispose pattern, which involves adding code
    that makes it easy to release resources. The solution code implements the `IDisposable`
    interface. `IDisposable` only specifies the `Dispose()` method, without parameters,
    and there’s more to be done than just adding that method, including another `Dispose`
    method overload that keeps track of what type of disposal to do and an optional
    finalizer.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案是实现处置模式，其中包括添加代码以便于释放资源。解决方案代码实现了`IDisposable`接口。`IDisposable`仅指定了`Dispose()`方法，无需参数，但除了添加该方法之外，还需执行更多操作，包括另一个`Dispose`方法重载，用于跟踪要执行的处置类型以及一个可选的终结器。
- en: 'Complicating the implementation is a field and parameter that control disposal
    logic: `disposed` and `disposing`. The `disposed` field ensures that this object
    gets disposed only one time. Inside the `Dispose(bool)` method, there’s an `if`
    statement, ensuring that if `disposed` is `true` (the object has been disposed),
    then it won’t execute any disposal logic. The first time through `Dispose(bool)`,
    disposed will be `false` and the code in the `if` block will execute. Make sure
    that you also set `disposed` to `true` to ensure this code doesn’t run anymore—the
    consequences of not doing so bring exposure to unpredictable errors like an `ObjectDisposedException`.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 复杂化实现的是控制处置逻辑的字段和参数：`disposed`和`disposing`。`disposed`字段确保此对象仅被处置一次。在`Dispose(bool)`方法内部，有一个`if`语句，确保如果`disposed`为`true`（对象已处置），则不会执行任何处置逻辑。通过`Dispose(bool)`的第一次，`disposed`将为`false`，并且`if`块中的代码将执行。确保您还设置`disposed`为`true`，以确保此代码不再运行——不这样做的后果将暴露于像`ObjectDisposedException`这样的不可预测错误。
- en: The `disposing` parameter tells `Dispose(bool)` how it’s being called. Notice
    that `Dispose()` (without parameters) and the finalizer call `Dispose(bool)`.
    When `Dispose()` calls `Dispose(bool)`, `disposing` is `true`. This makes it easy
    for calling code, if written properly, to instantiate `DeploymentProcess` in a
    `using` statement or wrap it in the `finally` block of a `try/finally`.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`disposing`参数告诉`Dispose(bool)`它是如何被调用的。请注意，`Dispose()`（无参数）和最终器调用`Dispose(bool)`。当`Dispose()`调用`Dispose(bool)`时，disposing为`true`。如果调用代码正确编写，这使得在`using`语句中实例化`DeploymentProcess`或在`try/finally`块的`finally`中包装它变得很容易。'
- en: The finalizer calls `Dispose(bool)` with `disposing` set to `false`, meaning
    that it isn’t being run by calling application code. The `Dispose(bool)` method
    uses the `disposing` value to determine whether it should release managed resources.
    Unmanaged resources are released regardless of whether `Dispose()` or the finalizer
    calls `Dispose(bool)`.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 最终器会使用`disposing`设置为`false`调用`Dispose(bool)`，这意味着它不是由调用应用程序代码运行的。`Dispose(bool)`方法使用`disposing`值来确定是否应释放托管资源。无论是`Dispose()`还是最终器调用`Dispose(bool)`，非托管资源都会被释放。
- en: Let’s clarify what is happening with the finalizer. The .NET CLR garbage collector
    (GC) executes an object’s finalizer when it cleans that object from memory. The
    GC can make multiple passes over objects, calling finalizers being one of the
    last things it does. Managed objects are instantiated and managed by the .NET
    CLR, and you don’t have control over when they’re released, which could potentially
    result in out-of-order releases. You have to check the disposing value to prevent
    an `Object​Dispose⁠d​Exception` in case the dependent object was disposed by the
    GC first.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们澄清一下最终器（finalizer）的作用。当.NET CLR垃圾收集器（GC）清理内存中的对象时，它会执行对象的最终器。GC可以多次通过对象，调用最终器是它执行的最后几件事情之一。由.NET
    CLR实例化和管理的托管对象，你无法控制它们何时释放，这可能导致无序释放的情况发生。你必须检查disposing值，以防止在依赖对象被GC首先释放时出现`Object​Dispose⁠d​Exception`。
- en: What the finalizer gives you is a way to clean up unmanaged resources. An unmanaged
    resource, such as the file handle that `StreamWriter` obtained, doesn’t belong
    to the .NET CLR; it belongs to the Windows OS. There are situations where developers
    might need to explicitly call into a Win32/64 dynamic link library (DLL) to get
    a handle to an OS or third-party device. The reason you need the finalizer is
    that if your object doesn’t get disposed properly, there’s no other way to release
    that handle, which could crash your system for the same reason we need to release
    managed objects. So, the finalizer is a just-in-case mechanism to ensure the code
    that needs to release the unmanaged resource will execute.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 最终器给你的是清理非托管资源的方法。非托管资源，如`StreamWriter`获取的文件句柄，不属于.NET CLR，而属于Windows操作系统。有些情况下，开发人员可能需要显式调用Win32/64动态链接库（DLL）以获取OS或第三方设备的句柄。你需要最终器的原因是，如果对象没有正确释放，没有其他方法释放该句柄，这可能会因为需要释放托管对象而导致系统崩溃。因此，最终器是一个备用机制，确保需要释放非托管资源的代码会执行。
- en: A lot of applications don’t have objects that use unmanaged resources. In that
    case, don’t even add the finalizer. Having the finalizer adds overhead to the
    object because the GC has to do accounting to recognize objects that do have finalizers
    and call them in a multi-pass collection. Omitting the finalizer avoids this.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 很多应用程序没有使用非托管资源的对象。在这种情况下，甚至不要添加最终器。最终器会增加对象的开销，因为GC必须进行账户处理来识别是否有最终器对象，并在多次通过集合时调用它们。省略最终器可以避免这种情况。
- en: On a related note, remember to call `GC.SuppressFinalize` in the `Dispose()`
    method. This is another optimization telling the GC to not call the finalizer
    for this object, because all resources—managed and unmanaged—are released when
    the application calls `IDisposable.Dispose()`.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，在`Dispose()`方法中记得调用`GC.SuppressFinalize`。这是另一个优化，告诉GC不要为此对象调用最终器，因为当应用程序调用`IDisposable.Dispose()`时，所有资源（托管和非托管）都已释放。
- en: Note
  id: totrans-34
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Generally, you should always call `GC.SuppressFinalize` in `Dispose()`, even
    if the class doesn’t have a finalizer. That said, there are some nuances that
    you might be interested in. If a class is both `sealed` and doesn’t have a finalizer,
    you can safely omit the call to `GC.SuppressFinalize`. However, classes that aren’t
    `sealed` could potentially be inherited by another class that does include a finalizer.
    In this case, calling `GC.SuppressFinalize` protects against improper implementations.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，即使类没有终结器，也应该在 `Dispose()` 中调用 `GC.SuppressFinalize`。尽管如此，还是有一些微妙之处可能会引起您的兴趣。如果一个类既是
    `sealed` 且没有终结器，可以安全地省略对 `GC.SuppressFinalize` 的调用。然而，未 `sealed` 的类可能会被另一个包含终结器的类继承。在这种情况下，调用
    `GC.SuppressFinalize` 可以防止不当的实现。
- en: For classes without finalizers, `GC.SuppressFinalize` has no effect. If you
    chose to leave out the call to `GC.SuppressFinalize` and the class has a finalizer,
    the CLR will call that finalizer.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 对于没有终结器的类，`GC.SuppressFinalize` 没有效果。如果选择省略对 `GC.SuppressFinalize` 的调用并且类有一个终结器，CLR
    将调用该终结器。
- en: The `Main` method shows how to properly use the `DeploymentProcess` object.
    It instantiates and wraps the object in a `using` statement. The object exists
    in memory until the `using` statement block ends. At that time, the program calls
    the `Dispose()` method.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`Main` 方法显示如何正确使用 `DeploymentProcess` 对象。它实例化并在 `using` 语句中包装该对象。对象在 `using`
    语句块结束之前存在于内存中。此时，程序调用 `Dispose()` 方法。'
- en: 1.2 Removing Explicit Dependencies
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1.2 移除显式依赖关系
- en: Problem
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: Your application is tightly coupled and difficult to maintain.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 您的应用程序紧密耦合且难以维护。
- en: Solution
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Define the types you need:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 定义您需要的类型：
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'And start the application like this:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 并像这样启动应用程序：
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Discussion
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: The term *tightly coupled* often means that one piece of code is overburdened
    with the responsibility of instantiating the types (dependencies) it uses. This
    requires the code to know how to construct, manage lifetime, and contain logic
    for dependencies. This distracts from the purpose of the code in solving the problem
    that it exists for. It duplicates instantiation of dependencies in different classes.
    This makes the code brittle because changes in dependency interfaces affect all
    other code that needs to instantiate that dependency. Additionally, code that
    instantiates its dependencies makes it difficult, if not impossible, to perform
    proper unit testing.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '*紧密耦合* 这个术语通常指的是代码的一部分被赋予实例化其使用的类型（依赖项）的责任。这要求代码知道如何构建、管理生命周期并包含依赖项的逻辑。这使得代码的目的是解决其存在问题的代码变得分散。在不同的类中重复依赖项的实例化。这使得代码变得脆弱，因为依赖接口的更改会影响到需要实例化该依赖项的所有其他代码。此外，实例化其依赖项的代码使得进行正确的单元测试变得困难，甚至不可能。'
- en: 'The solution is dependency injection, which is a technique to define dependency
    type instantiation in one place and expose a service that other types can use
    to obtain instances of those dependencies. There are a couple of ways to perform
    dependency injection: service locator and inversion of control (IoC). Which to
    use and when is an active debate; let’s avoid venturing into theoretical territory.
    To keep things simple, this solution uses IoC, which is a common and straightforward
    approach.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案是依赖注入，这是一种在一个地方定义依赖类型实例化并公开其他类型可以使用的服务来获取这些依赖项的技术。执行依赖注入有几种方法：服务定位器和控制反转（IoC）。何时使用哪种方法是一个活跃的讨论；让我们避免涉及理论领域。为了简化，此解决方案使用了IoC，这是一种常见且直接的方法。
- en: The specific solution requires that you have types that rely on other dependency
    types, configure type constructors to accept dependencies, reference a library
    to help manage the IoC container, and use the container to declare how to instantiate
    types. The following paragraphs explain how this works. [Figure 1-1](#ioc_sequence)
    shows the relationship of objects and sequence of IoC operations for the solution.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 具体解决方案要求您拥有依赖于其他依赖类型的类型，配置类型构造函数以接受依赖项，引用一个库来帮助管理 IoC 容器，并使用容器声明如何实例化类型。以下段落解释了这是如何工作的。[图 1-1](#ioc_sequence)
    显示了解决方案的对象关系和 IoC 操作的顺序。
- en: '![IoC for the Solution](Images/cscb_0101.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![解决方案的 IoC](Images/cscb_0101.png)'
- en: Figure 1-1\. IoC for the solution
  id: totrans-51
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 1-1\. 解决方案的 IoC
- en: The solution is a utility to help manage a deployment process, validating whether
    the deployment process is configured properly. It has a `DeploymentService` class
    that runs the process. Notice that the `DeploymentService` constructor accepts
    the classes `DeploymentArtifacts` and `DeploymentRepository`. `DeploymentService`
    does not instantiate these classes—rather, they are injected.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案是一个实用工具，帮助管理部署过程，验证部署过程是否配置正确。它有一个 `DeploymentService` 类来运行该过程。注意 `DeploymentService`
    构造函数接受 `DeploymentArtifacts` 和 `DeploymentRepository` 类。`DeploymentService` 并不实例化这些类
    —— 而是通过注入方式提供。
- en: To inject these classes, you can use an IoC container, which is a library that
    helps to automatically instantiate types and to automatically instantiate and
    provide instances of dependency types. The IoC container in the solution, as shown
    in the `using` declaration, is the `Microsoft.Extensions.DependencyInjection`
    namespace, which you can reference as the NuGet package by the same name.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 要注入这些类，可以使用一个 IoC 容器，它是一个帮助自动实例化类型并提供依赖项类型实例的库。解决方案中的 IoC 容器，如 `using` 声明中所示，是
    `Microsoft.Extensions.DependencyInjection` 命名空间，你可以引用同名的 NuGet 包。
- en: While we want to inject all dependencies for every type in the application,
    you must still instantiate the IoC container directly, which is why the `Main`
    method instantiates `ServiceCollection` as services. Then use the `services` instance
    to add all of the dependencies, including `DeploymentService`.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们希望为应用程序中的每种类型注入所有依赖项，但你仍然必须直接实例化 IoC 容器，这就是为什么 `Main` 方法实例化 `ServiceCollection`
    作为服务的原因。然后使用 `services` 实例添加所有依赖项，包括 `DeploymentService`。
- en: The IoC container can help manage the lifetime of objects. This solution uses
    `AddTransient`, which means that the container should create a new instance every
    time its type is requested. A couple of other examples of managing object lifetime
    are `AddSingleton`, which instantiates an object only one time and passes that
    one instance to all objects, and `AddScoped`, which gives more control over the
    lifetime of the object. In ASP.NET, `AddScoped` is set to the current request.
    Over time, you’ll want to think more about what the lifetime of your objects should
    be and investigate these options in more depth. For now, it’s simple to get started
    with `AddTransient`.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: IoC 容器可以帮助管理对象的生命周期。这个解决方案使用了 `AddTransient`，这意味着容器在每次请求类型时应创建一个新的实例。管理对象生命周期的另外两个例子是
    `AddSingleton`，它仅实例化对象一次并将该实例传递给所有对象；以及 `AddScoped`，它更多地控制对象的生命周期。在 ASP.NET 中，`AddScoped`
    设置为当前请求。随着时间的推移，你将需要更深入地考虑对象的生命周期应该是什么，并更深入地研究这些选项。目前来说，通过 `AddTransient` 开始是很简单的。
- en: The call to `BuildServiceProvider` converts `services`, a `ServiceCollection`,
    into a `ServiceProvider`. The term *IoC container* refers to this `ServiceProvider`
    instance—it instantiates and locates types to be injected.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 对 `BuildServiceProvider` 的调用将 `services`（一个 `ServiceCollection`）转换为 `ServiceProvider`。术语
    *IoC 容器* 指的是这个 `ServiceProvider` 实例 —— 它实例化和定位要注入的类型。
- en: You can see the container in action, calling `GetRequiredService` to return
    an instance implementing `IDeploymentService`. Going back to the `ServiceCollection`,
    notice that there’s an `AddTransient` associating the `DeploymentService` class
    with the `IDeploymentService` interface. This means that `GetRequiredService`
    will return an instance of `DeploymentService`.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到容器正在调用 `GetRequiredService` 返回实现 `IDeploymentService` 接口的实例。回到 `ServiceCollection`，注意到有一个
    `AddTransient` 将 `DeploymentService` 类与 `IDeploymentService` 接口关联起来。这意味着 `GetRequiredService`
    将返回一个 `DeploymentService` 的实例。
- en: Finally, `Main` instantiates `Program`, with the new `DeploymentService` instance.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`Main` 实例化 `Program`，带有新的 `DeploymentService` 实例。
- en: Going back to the constructor for `DeploymentService`, you can see that it expects
    to be called with instances for `DeploymentArtifacts` and `DeploymentRepository`.
    Because we used the IoC container to instantiate `DeploymentService`, the IoC
    container also knows how to instantiate its dependencies, which were also added
    to the `ServiceCollection`, with calls to `AddTransient`. This solution only used
    three types; you can build object dependency graphs much deeper than this.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 回到 `DeploymentService` 的构造函数，你可以看到它期望使用 `DeploymentArtifacts` 和 `DeploymentRepository`
    的实例来调用。因为我们使用了 IoC 容器来实例化 `DeploymentService`，IoC 容器也知道如何实例化它的依赖项，这些依赖项也已添加到 `ServiceCollection`
    中，使用了 `AddTransient` 进行调用。这个解决方案仅使用了三种类型；你可以构建比这更深层次的对象依赖图。
- en: Also, notice how the `DeploymentService` constructor saves the injected instances
    in `readonly` fields, making them available for use by `DeploymentService` members.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请注意`DeploymentService`构造函数将注入的实例保存在`readonly`字段中，以便`DeploymentService`成员可以使用它们。
- en: The beauty of IoC is that instantiation only happens in one place, and you don’t
    have to code all of that in your constructors or in members that need a new instance
    of a dependency. This makes your code more loosely coupled and maintainable. It
    also opens the opportunity for higher quality by making the type more unit testable.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: IoC的优点在于只在一个地方进行实例化，您无需在构造函数或需要依赖项新实例的成员中编写所有代码。这使得您的代码更松散耦合且更易于维护。它还通过使类型更具单元测试可能性来提高质量。
- en: See Also
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '[Recipe 3.1, “Writing a Unit Test”](ch03.xhtml#writing_a_unit_test)'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '[Recipe 3.1，“编写单元测试”](ch03.xhtml#writing_a_unit_test)'
- en: 1.3 Delegating Object Creation to a Class
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1.3 将对象创建委托给类
- en: Problem
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You’re using IoC, the type you’re trying to instantiate doesn’t have an interface,
    and you have complex construction requirements.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 您正在使用IoC，但您要实例化的类型没有接口，并且您有复杂的构造要求。
- en: Solution
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'We want to instantiate this class:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要实例化这个类：
- en: '[PRE5]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We’ll use this class for IoC:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将用这个类来进行IoC：
- en: '[PRE6]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'And here’s the `IValidatorFactory` implementation:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`IValidatorFactory`的实现：
- en: '[PRE7]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Then instantiate the factory like this:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 然后像这样实例化工厂：
- en: '[PRE8]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Discussion
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: As discussed in [Recipe 1.2](#removing_explicit_dependencies), IoC is a best
    practice because it decouples dependencies, making code easier to maintain, more
    adaptable, and easier to test. The problem is that there are exceptions and situations
    that cause difficulties with the best of plans. One of these problems occurs when
    trying to use a third-party API without an interface.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如[Recipe 1.2](#removing_explicit_dependencies)中所述，IoC是一种最佳实践，因为它解耦了依赖关系，使代码更易于维护、更具适应性和更易于测试。问题在于即使有最佳计划，也会出现异常和导致困难的情况。其中之一是在没有接口的情况下尝试使用第三方API时。
- en: The solution shows a `ThirdPartyDeploymentService` class. You can see the code
    and what it does. In reality, even if you can read the code through reflection
    or disassembler, it doesn’t help because you can’t add your interface. Even if
    `ThirdPartyDeploymentService` were open source, you would have to weigh the decision
    to fork the library for your own modifications—the trade-off being that your modifications
    are brittle in the face of new features and maintenance to the original open source
    library. An example is the `System.Net.HttpClient` class in the .NET Framework,
    which doesn’t have an interface. Ultimately, you’ll need to evaluate the situation
    and make a decision that works for you, but the factory class described here can
    be an effective work-around.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案展示了`ThirdPartyDeploymentService`类。您可以查看代码以及其功能。但实际上，即使您通过反射或反汇编器阅读代码，也无济于事，因为您无法添加自己的接口。即使`ThirdPartyDeploymentService`是开源的，您也必须权衡是否要分叉库以进行自己的修改——这种权衡是因为您的修改在面对原始开源库的新功能和维护时可能变得脆弱。例如，.NET
    Framework中的`System.Net.HttpClient`类就没有接口。最终，您需要评估情况并做出适合您的决定，但这里描述的工厂类可以是一个有效的解决方法。
- en: 'To see how a factory class works, observe the `IValidatorFactory` interface.
    This is the interface we’ll use for IoC. Next, examine how the `ValidatorFactory`
    class implements the `IValidatorFactory` interface. Its `CreateDeploymentService`
    instantiates and returns the `ThirdPartyDeploymentService`. This is what a factory
    does: it creates objects for us.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解工厂类的工作原理，请观察`IValidatorFactory`接口。这是我们用于IoC的接口。接下来，看看`ValidatorFactory`类如何实现`IValidatorFactory`接口。它的`CreateDeploymentService`方法实例化并返回`ThirdPartyDeploymentService`。这就是工厂的作用：为我们创建对象。
- en: Note
  id: totrans-80
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: This is related to the proxy pattern. The `ValidatorFactory` controls access
    to a `ThirdPartyDeploymentService` instance. However, rather than returning an
    object to control access to members of `ThirdPartyDeploymentService`, `CreateDeploymentService`
    returns a direct `ThirdPartyDeploymentService` instance.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这与代理模式相关。`ValidatorFactory`控制对`ThirdPartyDeploymentService`实例的访问。但是，与其返回一个用于控制`ThirdPartyDeploymentService`成员访问的对象，`CreateDeploymentService`返回一个直接的`ThirdPartyDeploymentService`实例。
- en: To simplify this example, the code doesn’t use an IoC container—though it would
    be normal to use factories alongside IoC. Instead, the `Main` method instantiates
    `ValidatorFactory` and passes that instance to the `Program` constructor, which
    is the important part of this example.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 简化这个示例，代码不使用 IoC 容器——虽然在使用 IoC 时通常会同时使用工厂。相反，`Main` 方法实例化 `ValidatorFactory`
    并将该实例传递给 `Program` 构造函数，这是示例的重要部分。
- en: Examine how the constructor takes the `IValidatorFactory` reference and calls
    `Cre⁠ate​DeploymentService`. Now we’ve been able to inject the dependency and
    maintain the loose coupling we sought.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 检查构造函数如何获取 `IValidatorFactory` 引用并调用 `CreateDeploymentService`。现在我们已经能够注入依赖项并保持所寻求的松耦合。
- en: Another benefit is that since the `ThirdPartyDeploymentService` is instantiated
    in the factory class, you can make any future changes to class instantiation without
    affecting consuming code.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个好处是，由于 `ThirdPartyDeploymentService` 是在工厂类中实例化的，您可以在不影响消费代码的情况下对类实例化进行任何未来更改。
- en: See Also
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '[Recipe 1.2, “Removing Explicit Dependencies”](#removing_explicit_dependencies)'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '[食谱 1.2，“消除显式依赖项”](#removing_explicit_dependencies)'
- en: 1.4 Delegating Object Creation to a Method
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1.4 将对象创建委托给方法
- en: Problem
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want a plug-in framework and need to structure object instantiation someplace
    other than application logic.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要一个插件框架，并且需要在应用程序逻辑之外的某个地方结构化对象实例化。
- en: Solution
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Here’s the abstract base class with the object creation contract:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这是带有对象创建契约的抽象基类：
- en: '[PRE9]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'These are a couple of classes that instantiate associated plug-in classes:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是几个实例化相关插件类的类：
- en: '[PRE10]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The plug-in classes implement the `IDeploymentPlugin` interface:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 插件类实现了 `IDeploymentPlugin` 接口：
- en: '[PRE11]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'And here are the plug-in classes being instantiated:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是正在实例化的插件类：
- en: '[PRE12]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Finally, here’s how it all fits together:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这是它们如何完美结合在一起的方式：
- en: '[PRE13]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Discussion
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: Plug-in systems are all around us. Excel can consume and emit different document
    types, Adobe works with multiple image types, and Visual Studio Code has numerous
    extensions. These are all plug-in systems, and whether the only plug-ins available
    are via vendor or third party, they all leverage the same concept—the code must
    be able to adapt to handling a new abstract object type.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 插件系统无处不在。Excel 可以消费和发出不同类型的文档，Adobe 可以处理多种图像类型，Visual Studio Code 有许多扩展。这些都是插件系统，无论插件是否只能通过供应商或第三方获得，它们都利用了相同的概念——代码必须能够适应处理新的抽象对象类型。
- en: While the previous examples are ubiquitous in our daily lives, many developers
    won’t be building those types of systems. That said, the plug-in model is a powerful
    opportunity for making our applications extensible. Application integration is
    a frequent use case where your application needs to consume documents from customers,
    other departments, or other businesses. Sure, web services and other types of
    APIs are popular, but needing to consume an Excel spreadsheet is normal. As soon
    as you do that, someone has data in a different format, like CSV, JSON, tab delimited,
    and more. Another side of the story is the frequent need to export data in a format
    that multiple users need to consume.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管前面的示例在我们的日常生活中无处不在，但许多开发人员不会构建那些类型的系统。话虽如此，插件模型是增强我们应用程序可扩展性的强大机会。应用程序集成是一个频繁使用的用例，其中您的应用程序需要从客户、其他部门或其他企业消费文档。当然，Web
    服务和其他类型的 API 很受欢迎，但需要消费 Excel 电子表格是正常的。一旦这样做，有人会有不同格式的数据，如 CSV、JSON、制表符分隔等。另一方面，经常需要以多个用户需要消费的格式导出数据。
- en: In this spirit, the solution demonstrates a situation where a plug-in system
    allows an application to add support for new deployment types. This is a typical
    situation where you’ve built the system to handle the deployment artifacts that
    you know about, but the system is so useful that everyone else wants to add their
    own deployment logic, which you never knew about when original requirements were
    written.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种精神下，该解决方案演示了插件系统允许应用程序添加支持新部署类型的情况。这是一个典型的情况，您已经构建了处理您知道的部署工件的系统，但是这个系统非常有用，每个人都希望添加自己的部署逻辑，这在编写原始需求时是不可预见的。
- en: In the solution, each of the `DeploymentManagers` implement the abstract base
    class, `DeploymentManagementBase`. `DeploymentManagementBase` orchestrates the
    logic, and the derived `DeploymentManager` classes are simply factories for their
    associated plugins. Notice that `DeploymentManagementBase` uses polymorphism to
    let derived classes instantiate their respective plug-in classes.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在解决方案中，每个`DeploymentManager`都实现了抽象基类`DeploymentManagementBase`。`DeploymentManagementBase`编排逻辑，而派生的`DeploymentManager`类只是其关联插件的工厂。请注意，`DeploymentManagementBase`使用多态性让派生类实例化其各自的插件类。
- en: Tip
  id: totrans-106
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: If this is getting a little complex, you might want to review Recipes [1.2](#removing_explicit_dependencies)
    and [1.3](#delegating_object_creation_to_a_class). This is one level of abstraction
    above that.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这变得有点复杂，您可能需要查看配方[1.2](#removing_explicit_dependencies)和[1.3](#delegating_object_creation_to_a_class)。这是比那高一个抽象级别。
- en: The solution shows two classes that implement the `IDeploymentPlugin` interface.
    The `DeploymentManagementBase` class consumes the `IDeploymentPlugin` interface,
    delegating calls to its methods to the plug-in classes that implement that interface.
    Notice how `Validate` calls `Validate` on the `IDeploymentPlugin` instance.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案展示了实现`IDeploymentPlugin`接口的两个类。`DeploymentManagementBase`类消费`IDeploymentPlugin`接口，将调用委托给实现该接口的插件类的方法。请注意`Validate`如何调用`IDeploymentPlugin`实例上的`Validate`方法。
- en: The `Program` has no knowledge of the plug-in classes. It operates on instances
    of `DeploymentManagementBase`, as demonstrated where `Main` calls `GetPlugins`
    and receives an array of `DeploymentManagementBase` instances. `Program` doesn’t
    care about the plug-ins. For demo simplicity, `GetPlugins` is a method in `Program`
    but could be another class with a mechanism for selecting which plug-ins to use.
    Notice in the `Run` method how it iterates through `DeploymentManagementBase`
    instances.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`Program`不知道插件类。它操作`DeploymentManagementBase`的实例，正如`Main`调用`GetPlugins`并接收`DeploymentManagementBase`实例数组所示。`Program`不关心插件。为简化演示，`GetPlugins`是`Program`中的一个方法，但可以是另一个具有选择要使用的插件机制的类。请注意`Run`方法如何遍历`DeploymentManagementBase`实例。'
- en: Note
  id: totrans-110
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Making `DeploymentManagementBase` implement an interface might make IoC more
    consistent if you’re using interfaces everywhere else. That said, an abstract
    base class can often work for most IoC containers, mocking, and unit testing tools.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在使用接口的所有其他地方，`DeploymentManagementBase`实现接口可能会使IoC更一致。也就是说，一个抽象基类通常适用于大多数IoC容器、模拟和单元测试工具。
- en: To recap, the `DeploymentManagementBase` encapsulates all functionality and
    delegates work to plug-in classes. The code that makes the plug-in are the deployment
    managers, plug-in interface, and plug-in classes. The consuming code only works
    with a collection of `DeploymentManagementBase` and is blissfully unaware of the
    specific plug-in implementations.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，`DeploymentManagementBase`封装了所有功能，并委托工作给插件类。编写插件的代码是部署管理器、插件接口和插件类。消费代码只与一组`DeploymentManagementBase`一起工作，并且对特定插件实现毫不知情。
- en: 'Here’s where the power comes in. Whenever you or any third party you allow
    wants to extend the system for a new type of deployment, they do this:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是力量所在。每当您或允许的任何第三方希望为新类型的部署扩展系统时，他们就会这样做：
- en: Create a new `DeploymentPlugin` class that implements your `IDeploymentPlugin`
    interface.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的实现`IDeploymentPlugin`接口的`DeploymentPlugin`类。
- en: Create a new `DeploymentManagement` class that derives from `DeploymentManagementBase`.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的从`DeploymentManagementBase`派生的`DeploymentManagement`类。
- en: Implement the `DeploymentManagement.CreateDeploymentService` method to instantiate
    and return the new `DeploymentPlugin`.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`DeploymentManagement.CreateDeploymentService`方法以实例化并返回新的`DeploymentPlugin`。
- en: Finally, the `GetPlugins` method, or some other logic of your choosing, would
    add that new code to its collections of plug-ins to operate on.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`GetPlugins`方法或您选择的其他逻辑将该新代码添加到其插件集合中以进行操作。
- en: See Also
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '[Recipe 1.2, “Removing Explicit Dependencies”](#removing_explicit_dependencies)'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '[配方 1.2，“移除显式依赖项”](#removing_explicit_dependencies)'
- en: '[Recipe 1.3, “Delegating Object Creation to a Class”](#delegating_object_creation_to_a_class)'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '[配方 1.3，“将对象创建委托给类”](#delegating_object_creation_to_a_class)'
- en: 1.5 Designing Application Layers
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1.5 设计应用层
- en: Problem
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You’re setting up a new application and are unsure of how to structure the project.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 您正在设置一个新的应用程序，并且不确定如何结构化项目。
- en: Solution
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Here’s a data access layer class:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个数据访问层类：
- en: '[PRE14]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Here’s a business logic layer class:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个业务逻辑层类：
- en: '[PRE15]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'These two classes are part of the UI layer:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个类属于 UI 层的一部分：
- en: '[PRE16]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This is the application entry point (part of the UI layer):'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这是应用程序的入口点（UI 层的一部分）：
- en: '[PRE17]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Discussion
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: There are endless ways to set up and plan the structure of new projects, with
    some approaches better than others. Rather than viewing this discussion as a definitive
    conclusion, think of it as a few options with trade-offs that help you think about
    your own approach.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 有无数种设置和规划新项目结构的方式，其中一些方法比其他方法更好。与其将这个讨论视为最终结论，不如把它看作是一些具有权衡的选项，这些选项可以帮助你思考自己的方法。
- en: The antipattern here is Big Ball of Mud (BBoM) architecture. BBoM is where a
    developer opens a single project and starts adding all the code at the same layer
    in the application. While this approach might help knock out a quick prototype,
    it has severe complications in the long run. Over time most apps need new features
    and maintenance to fix bugs. What happens is that the code begins to run together
    and there’s often much duplication, commonly referred to as *spaghetti code*.
    Seriously, no one wants to maintain code like this, and you should avoid it.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的反模式是大块混乱（BBoM）架构。BBoM 是指开发者打开一个项目并在应用程序的同一层添加所有代码的情况。虽然这种方法可能有助于快速原型开发，但从长远来看会带来严重的复杂性问题。随着时间的推移，大多数应用程序需要新增功能和修复
    bug。问题在于代码开始混合在一起，通常会出现大量重复，被称为*意大利面代码*。严肃地说，没有人愿意维护这样的代码，你应该避免它。
- en: Warning
  id: totrans-136
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: When under time pressure, it’s easy to think that creating a quick prototype
    might be an acceptable use of time. However, resist this urge. The cost of maintenance
    on a BBoM prototype project is high. The time required to work with spaghetti
    code to add a new feature or fix a bug quickly wipes out any perceived up-front
    gains from a sloppy prototype. Because of duplication, fixing a bug in one place
    leaves the same bug in other parts of the application. This means not only that
    a developer has to fix the bug multiple times but that the entire life cycle of
    QA, deployment, customer discovery, help desk service, and management wastes time
    on what would be multiple unnecessary cycles. The content in this section helps
    you avoid this antipattern.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在时间紧迫时，人们很容易认为创建一个快速原型可能是可以接受的时间使用方式。然而，要抵制这种冲动。在 BBoM 原型项目上进行维护的成本很高。在意大利面代码上添加新功能或修复
    bug 的时间远远超过了看似快速原型的初期收益。由于重复，修复一个地方的 bug 会在应用程序的其他部分留下相同的 bug。这不仅意味着开发者必须多次修复
    bug，而且整个 QA、部署、客户发现、帮助台服务和管理的生命周期都会因多次不必要的周期而浪费时间。本节内容帮助你避免这种反模式。
- en: The primary concept to grasp here is separation of concerns. You’ll often hear
    this simplified as a layered architecture where you have UI, business logic, and
    data layers, with each section named for the type of code placed in that layer.
    This section uses the layered approach with the goal of showing how to achieve
    separation of concerns and associated benefits.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这里需要理解的主要概念是关注点分离。通常听到的是简化为分层架构，在其中你有 UI、业务逻辑和数据层，每个部分都按其所含代码类型命名。本节采用分层方法，旨在展示如何实现关注点分离及其相关的好处。
- en: Note
  id: totrans-139
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Sometimes the idea of a layered architecture makes people think they must route
    application communication through the layers or that certain operations are restricted
    to their layer. This isn’t quite true or practical. For example, business logic
    can be found in different layers, such as rules for validating user input in the
    UI layer as well as logic for how to process a certain request. Another example
    of exceptions to communication patterns is when a user needs to select a set of
    operations on a form—there isn’t any business logic involved and the UI layer
    can request the list of items from the data layer directly. What we want is separation
    of concerns to enhance the maintainability of the code; any dogmatic/idealistic
    restrictions that don’t make sense run counter to that goal.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 有时人们会认为分层架构的理念要求将应用程序通信路由通过各层，或者某些操作仅限于其层次。这并不完全正确或实际。例如，业务逻辑可以在不同的层中找到，比如在
    UI 层中用于验证用户输入的规则以及处理特定请求的逻辑。另一个违背通信模式的例外是当用户需要在表单上选择一组操作时，没有任何业务逻辑参与，UI 层可以直接从数据层请求项目列表。我们要的是关注点分离，以增强代码的可维护性；任何不合理的教条/理想主义限制都会与这一目标背道而驰。
- en: The solution starts with a data access layer, `GreetingRepository`. This simulates
    the repository pattern, which is an abstraction so that calling code doesn’t need
    to think about how to retrieve the data. Ideally, creating a separate data project
    promises an additional benefit of reusing that data access layer in another project
    that needs access to the same data. Sometimes you get reuse and other times you
    don’t, though you always get the benefits of reducing duplication and knowing
    where the data access logic resides.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案从数据访问层`GreetingRepository`开始。这模拟了存储库模式，它是一个抽象层，使调用代码不需要考虑如何检索数据。理想情况下，创建一个单独的数据项目可以在需要访问相同数据的另一个项目中重复使用该数据访问层，这带来了额外的重用优势。有时你能够重用，有时不能，尽管你总是能够减少重复并知道数据访问逻辑所在的好处。
- en: The business logic layer has a `Greeting` class. Notice how it uses the `isNew`
    parameter to determine which method of `GreetingRepository` to call. Anytime you
    find yourself needing to write logic for how to handle a user request, consider
    putting that code in another class that is considered part of the business logic
    layer. If you already have code like this, refactor it out into a separate object
    named for the type of logic it needs to handle.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 业务逻辑层有一个`Greeting`类。注意它如何使用`isNew`参数来确定调用`GreetingRepository`的哪个方法。每当你发现自己需要编写处理用户请求的逻辑时，考虑将该代码放入另一个被视为业务逻辑层一部分的类中。如果你已经有这样的代码，请将其重构为一个名为逻辑类型的独立对象。
- en: Finally, there’s the UI layer, which is composed of the `SignIn` and `Menu`
    classes. These classes handle the interaction with the user, yet they delegate
    any logic to the business logic layer. `Program` might be considered part of the
    UI layer, though it’s only orchestrating interaction/navigation between other
    UI layer classes and doesn’t perform UI operations itself.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，还有 UI 层，由`SignIn`和`Menu`类组成。这些类处理与用户的交互，但将任何逻辑委托给业务逻辑层。`Program`可能被视为 UI
    层的一部分，尽管它仅在其他 UI 层类之间进行交互/导航，并不执行 UI 操作本身。
- en: Note
  id: totrans-144
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The way I wrote the solution was so you would see the definition of a class
    before it was used. However, when actually doing the design, you might start with
    the UI layer and then work down through business logic and data access.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我写解决方案的方式是让你在使用类的定义之前看到它。然而，在实际设计时，你可能会从 UI 层开始，然后逐步通过业务逻辑和数据访问进行工作。
- en: There are a couple of dimensions to separation of concerns in this code. `Greeting​Re⁠pository`
    is only concerned with data, and `Greeting` data in particular. For example, if
    the app needed data to show in a `Menu`, you would need another class called `MenuRepository`
    that did CRUD operations on `Menu` data. `Greeting` only handles business logic
    for `Greeting` data. If a `Menu` had its own business logic, you might consider
    a separate business logic layer class for that, but only if it made sense. As
    you can see in the UI layer, `SignIn` only handles interaction with the user for
    signing into the app, and `Menu` only handles interaction with the user for displaying
    and choosing what they want to do. The beauty is that now you or anyone else can
    easily go into the application and find the code concerning the subject you need
    to address.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，关注点分离有几个方面。`Greeting​Re⁠pository`只关注数据，特别是`Greeting`数据。例如，如果应用程序需要在`Menu`中显示数据，你需要另一个名为`MenuRepository`的类来执行`Menu`数据的
    CRUD 操作。`Greeting`只处理`Greeting`数据的业务逻辑。如果`Menu`有自己的业务逻辑，你可以考虑为其创建一个单独的业务逻辑层类，但前提是有意义。正如你在
    UI 层中看到的那样，`SignIn`仅处理与用户登录应用程序的交互，而`Menu`仅处理显示和选择用户想要做什么的交互。美妙的地方在于，现在你或其他任何人都可以轻松进入应用程序，并找到涉及需要解决的主题的代码。
- en: Figures [1-2](#simple_app), [1-3](#separate_data), and [1-4](#enterprise_layout)
    show how you might structure each layer into a Visual Studio solution. [Figure 1-2](#simple_app)
    is for a very simple app, like a utility that is unlikely to have many features.
    In this case, it’s OK to keep the layers in the same project because there isn’t
    a lot of code and anything extra doesn’t have tangible benefit.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 图[1-2](#simple_app)、[1-3](#separate_data)和[1-4](#enterprise_layout)展示了如何将每个层结构化为
    Visual Studio 解决方案。[图 1-2](#simple_app)适用于非常简单的应用程序，比如一个不太可能有很多功能的实用程序。在这种情况下，将层保持在同一个项目中是可以接受的，因为代码量不大，而且任何额外的东西都没有实际的好处。
- en: '![Project Layout for a Simple App](Images/cscb_0102.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![简单应用的项目布局](Images/cscb_0102.png)'
- en: Figure 1-2\. Project layout for a simple app
  id: totrans-149
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 1-2\. 简单应用的项目布局
- en: '[Figure 1-3](#separate_data) shows how you might structure a project that’s
    a little larger and will grow over time, which I’ll loosely call midsize for the
    sake of discussion. Notice that it has a separate data access layer. The purpose
    of that is potential reuse. Some projects offer different UIs for different customers.
    For example, there might be a chatbot or mobile app that accesses the data for
    users but a web app for administrators. Having the data access layer as a separate
    project makes this possible. Notice how `SystemApp.Console` has an assembly reference
    to `SystemApp.Data`.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 1-3](#separate_data)展示了如何组织一个稍大且随时间增长的项目，为了讨论方便，我将其大致称为中型项目。请注意它具有单独的数据访问层。其目的在于可能的重用性。某些项目为不同的客户提供不同的UI。例如，可能有一个聊天机器人或移动应用用于用户访问数据，但为管理员提供一个Web应用。将数据访问层作为单独的项目使这种情况成为可能。请注意`SystemApp.Console`与`SystemApp.Data`有一个程序集引用。'
- en: '![ Project Layout to Separate UI and Data Layers](Images/cscb_0103.png)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![项目布局以分离UI和数据层](Images/cscb_0103.png)'
- en: Figure 1-3\. Project layout to separate UI and data layers
  id: totrans-152
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1-3\. 项目布局以分离UI和数据层
- en: For larger enterprise apps, you’ll want to break the layers apart, as shown
    in [Figure 1-4](#enterprise_layout). The problem to solve here is that you want
    a cleaner break between sections of code to encourage loose coupling. Large applications
    often become complex and hard to manage unless you control the architecture in
    a way that encourages best practices.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 对于更大型的企业应用程序，您将希望按照[图 1-4](#enterprise_layout)的方式将层分开。要解决的问题是希望在代码段之间有更清晰的分隔，以鼓励松耦合。大型应用程序通常变得复杂且难以管理，除非以鼓励最佳实践的方式控制架构。
- en: '![Project Layout for Separation of Concerns](Images/cscb_0104.png)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![关注点分离的项目布局](Images/cscb_0104.png)'
- en: Figure 1-4\. Project layout for separation of concerns
  id: totrans-155
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1-4\. 关注点分离的项目布局
- en: For the enterprise scenario, this example is small. However, imagine the complexity
    of a growing application. As you add new business logic, you’ll begin finding
    code that gets reused. Also, you’ll naturally have some code that can stand on
    its own, like a service layer for accessing an external API. The opportunity here
    is to have a reusable library that might be useful in other applications. Therefore,
    you’ll want to refactor anything reusable into its own project. On a growing project,
    you can rarely anticipate every aspect or feature that an app will support, and
    watching for these changes and refactoring will help to keep your code, project,
    and architecture healthier.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 对于企业场景，此示例较小。但是，想象一下不断增长的应用程序的复杂性。随着添加新的业务逻辑，您将开始发现可以重用的代码。此外，您自然会有一些可以独立运行的代码，例如用于访问外部API的服务层。这里的机会在于创建一个可在其他应用程序中有用的可重用库。因此，您将希望将任何可重用的内容重构为自己的项目。在不断增长的项目中，您很少能够预料到应用程序将支持的每个方面或功能，监视这些变化并重构将有助于保持代码、项目和架构的健康性。
- en: 1.6 Returning Multiple Values from a Method
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1.6 从方法返回多个值
- en: Problem
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You need to return multiple values from a method, and using classic approaches
    such as `out` parameters or returning a custom type doesn’t feel intuitive.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要从方法中返回多个值，使用经典方法如`out`参数或返回自定义类型并不直观。
- en: Solution
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: '`ValidationStatus` has a deconstructor:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`ValidationStatus`有一个析构函数：'
- en: '[PRE18]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The `DeploymentService` shows how to return a tuple:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`DeploymentService`展示了如何返回元组：'
- en: '[PRE19]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'And here’s how to consume the returned tuple:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是如何使用返回的元组：
- en: '[PRE20]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Discussion
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: Historically, the typical way to return multiple values from a method was to
    create a custom type or add multiple `out` parameters. It always felt wasteful
    to create a custom type that would only be used one time for the purpose of returning
    values. The other option, to use multiple `out` parameters, felt clunky too. Using
    a tuple is more elegant. A *tuple* is a value type that lets you group data into
    a single object without declaring a separate type.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 历史上，从方法返回多个值的典型方法是创建自定义类型或添加多个`out`参数。创建一个仅用于返回值一次的自定义类型总感觉有些浪费。另一种选择，使用多个`out`参数，也感觉笨拙。使用元组更加优雅。*元组*是一种值类型，允许你将数据组合成一个单独的对象，而无需声明单独的类型。
- en: Note
  id: totrans-169
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The tuple type described in this section was a new feature of C# 7.0\. It aliases
    the .NET `ValueTuple`, which is a mutable value type whose members are fields.
    In contrast, the .NET Framework has a `Tuple` class, which is an immutable reference
    type whose members are properties. Both `ValueTuple` and `Tuple` named members
    `Item1`, `Item2`, …, `ItemN`; in contrast, you’re free to provide more meaningful
    names for C# tuple members.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 本节描述的元组类型是C# 7.0的一个新特性。它别名.NET的`ValueTuple`，这是一个可变的值类型，其成员是字段。相比之下，.NET Framework有一个`Tuple`类，它是一个不可变的引用类型，其成员是属性。`ValueTuple`和`Tuple`都命名成员为`Item1`、`Item2`，...，`ItemN`；相反，你可以为C#元组成员提供更有意义的名称。
- en: If using a version of .NET prior to 4.7, you must explicitly reference the `System.ValueTuple`
    NuGet package.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用早于4.7版的.NET版本，必须显式引用`System.ValueTuple` NuGet包。
- en: The solution shows a couple of different aspects of tuples, deconstruction,
    and how to return a tuple from a method. The `ValidationStatus` class has a `Deconstruct`
    method and C# uses that to produce a tuple from an instance of the class. This
    class wasn’t strictly necessary for this example, but it does demonstrate an interesting
    way of converting a class to a tuple.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案展示了元组的几个不同方面，解构以及如何从方法返回一个元组。`ValidationStatus`类有一个`Deconstruct`方法，C#使用它来从类的实例生成一个元组。这个类在这个示例中并不是必需的，但它确实演示了一种将类转换为元组的有趣方式。
- en: The `DeploymentService` class shows how to return a tuple. Notice that the return
    type of the `PrepareDeployment` method is a tuple. The property names in the tuple
    return type are optional, though meaningful variable names could make the code
    easier to read.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`DeploymentService`类展示了如何返回一个元组。注意，`PrepareDeployment`方法的返回类型是一个元组。元组返回类型中的属性名称是可选的，不过有意义的变量名可以使代码更易读。'
- en: The code calls `Validate`, which returns an instance of `ValidationStatus`.
    The next line, assigning status to the tuple, uses the deconstructor to return
    a tuple instance. `PrepareDeployment` uses those values to return a new tuple
    to the caller.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 代码调用`Validate`，它返回一个`ValidationStatus`实例。下一行，将`status`分配给元组，使用解构器返回一个元组实例。`PrepareDeployment`使用这些值向调用者返回一个新的元组。
- en: The solution implementation of `PrepareDeployment` shows the mechanics of working
    with tuples, which is useful for learning, though not very elegant. In practice,
    it would be cleaner to return `status` from the method because the deconstructor
    will run implicitly.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`PrepareDeployment`的解决方案实现展示了与元组的工作机制，这对学习很有用，尽管不是非常优雅。在实践中，从方法中返回`status`将更加清晰，因为解构器将隐式运行。'
- en: The `Start` method, in `Program`, shows how to call `PrepareDeployment` and
    consume the tuple it returns.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`Program`中的`Start`方法展示了如何调用`PrepareDeployment`并消耗它返回的元组。'
- en: 1.7 Converting from Legacy to Strongly Typed Classes
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1.7 从传统类型转换为强类型类
- en: Problem
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You have a legacy type that operates on values of type `object` and need to
    modernize to a strongly typed implementation.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 你有一个操作`object`类型值的传统类型，并且需要现代化为强类型实现。
- en: Solution
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Here’s a `Deployment` class that we’ll be using:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个我们将使用的`Deployment`类：
- en: '[PRE21]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'And here’s a legacy `CircularQueue` collection:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个传统的`CircularQueue`集合：
- en: '[PRE22]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This code shows how to use the legacy collection:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码展示了如何使用传统集合：
- en: '[PRE23]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Next, here’s the legacy collection refactored as a generic collection:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将传统集合重构为泛型集合：
- en: '[PRE24]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'With code that shows how to use the new generic collection:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 使用展示如何使用新的泛型集合的代码：
- en: '[PRE25]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Here’s demo code to show both collections in action:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是演示代码，展示了两种集合的使用方式：
- en: '[PRE26]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Discussion
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: The first version of C# didn’t have generics. Instead, we had a `System.Collections`
    namespace with collections like `Dictionary`, `List`, and `Stack` that operated
    on instances of type `object`. If the instances in the collection were reference
    types, the conversion performance to/from object was negligible. However, if you
    wanted to manage a collection of value types, the boxing/unboxing performance
    penalty became more excruciating the larger the collection got or the more operations
    performed.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: C#的第一个版本没有泛型。相反，我们有一个`System.Collections`命名空间，其中包含像`Dictionary`、`List`和`Stack`这样的集合，这些集合操作的是`object`类型的实例。如果集合中的实例是引用类型，那么从对象到对象的转换性能是可以忽略的。然而，如果你想管理值类型的集合，装箱/拆箱的性能代价将随着集合的增大或执行的操作增多而变得更加严重。
- en: Microsoft had always intended to add generics, and they finally arrived in C#
    2\. However, in the meantime, there was a ton of nongeneric code written. Imagine
    all of the new object-based collections that developers needed to write on their
    own for things like sets, priority queues, and tree data structures. Add to that
    types like delegates, which were the primary means of method reference and async
    communication and operated on objects. There’s a long list of nongeneric code
    that’s been written, and chances are that you’ll encounter some of it as you progress
    through your career.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: Microsoft一直打算在C# 2中添加泛型，最终也确实实现了。但在此期间，开发人员需要编写大量非泛型代码，例如集合、优先队列和树数据结构。还有像委托这样的类型，它们是方法引用和异步通信的主要手段，操作对象。有很长一段非泛型代码列表已经编写，并且很可能在您的职业生涯中会遇到其中的一些。
- en: As C# developers, we appreciate the benefits of strongly typed code, making
    it easier to find and fix compile-time errors, making an application more maintainable,
    and improving quality. For this reason, you might have a strong desire to refactor
    a given piece of nongeneric code so that it too is strongly typed with generics.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 作为C#开发人员，我们欣赏强类型代码的好处，它使查找和修复编译时错误更容易，使应用程序更易于维护并提高质量。因此，您可能强烈希望重构给定的某段非泛型代码，使其也能够使用泛型。
- en: 'The process is basically this: whenever you see type `object`, convert it to
    generic.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 过程基本上是这样的：每当看到`object`类型时，将其转换为泛型类型。
- en: The solution shows a `Deployment` object that performs a health check on a deployed
    artifact. Since we have multiple artifacts, we also need to hold multiple `Deployment`
    instances in a collection. The collection is a (partially implemented) circular
    queue, and there’s a `HealthCheck` class that loops through the queue and periodically
    performs a health check with the next `Deployment` instance.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案展示了一个`Deployment`对象，该对象对部署的工件执行健康检查。由于我们有多个工件，我们还需要在一个集合中持有多个`Deployment`实例。该集合是一个（部分实现的）循环队列，还有一个`HealthCheck`类，该类循环遍历队列并定期与下一个`Deployment`实例执行健康检查。
- en: '`HealthCheckObject` operates on old nongeneric code and `HealthCheckGeneric`
    operates on new generic code. The difference between the two is that the `HealthCheck​Ob⁠ject`
    `Configure` method instantiates a nongeneric `CircularQueue`, and the `HealthCheckGeneric`
    `Configure` method instantiates a generic `CircularQueue<T>`. Our primary task
    is to convert `CircularQueue` to `CircularQueue<T>`.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`HealthCheckObject`操作旧的非泛型代码，而`HealthCheckGeneric`操作新的泛型代码。两者之间的区别在于，`HealthCheckObject`的`Configure`方法实例化一个非泛型的`CircularQueue`，而`HealthCheckGeneric`的`Configure`方法实例化一个泛型的`CircularQueue<T>`。我们的主要任务是将`CircularQueue`转换为`CircularQueue<T>`。'
- en: 'Since we’re working with a collection, the first task is to add the type parameter
    to the class, `CircularQueue<T>`. Then look for anywhere the code uses the `object`
    type and convert that to the class type parameter, `T`:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们正在处理一个集合，第一步是向类`CircularQueue<T>`添加类型参数。然后查找代码中使用`object`类型的地方，并将其转换为类类型参数`T`：
- en: Convert the `object items[]` field to `T items[]`.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`object items[]`字段转换为`T items[]`。
- en: In the constructor, instantiate a new `T[]` instead of `object[]`.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在构造函数中，实例化一个新的`T[]`而不是`object[]`。
- en: Change the `Add` parameter from `object` to `T`.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Add`方法的参数从`object`更改为`T`。
- en: Change the `Next` return type from `object` to `T`.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Next`方法的返回类型从`object`更改为`T`。
- en: In `Next`, change the `object item` variable to `T item`.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Next`方法中，将`object item`变量更改为`T item`。
- en: After changing `object` types to `T`, you have a new strongly typed generic
    collection.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 将`object`类型更改为`T`后，您将获得一个新的强类型泛型集合。
- en: The `Program` class demonstrates how both of these collections work.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '`Program`类演示了这两个集合如何工作。'
- en: 1.8 Making Classes Adapt to Your Interface
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1.8 使类适应您的接口
- en: Problem
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You have a third-party library with similar functionality as your code, but
    it doesn’t have the same interface.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 您有一个与您的代码功能相似的第三方库，但它没有相同的接口。
- en: Solution
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'This is the interface we want to work with:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们要使用的接口：
- en: '[PRE27]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Here are a couple of classes that implement that interface:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是实现该接口的几个类：
- en: '[PRE28]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Here’s a third-party class that doesn’t implement `IDeploymentService`:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个未实现`IDeploymentService`的第三方类：
- en: '[PRE29]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This is the adapter that implements `IDeploymentService`:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 这是实现`IDeploymentService`的适配器：
- en: '[PRE30]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This code shows how to include the third-party service by using the adapter:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码显示如何通过使用适配器包含第三方服务：
- en: '[PRE31]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Discussion
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: An adapter is a class that wraps another class but exposes the functionality
    of the wrapped class with the interface you need.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 适配器是一个类，它包装另一个类，并使用您需要的接口暴露包装类的功能。
- en: There are various situations where the need for an adapter class comes into
    play. What if you have a group of objects that implement an interface and want
    to use a third-party class that doesn’t match the interface that your code works
    with? What if your code is written for a third-party API, like a payment service,
    and you know you want to eventually switch to a different provider with a different
    API? What if you need to use native code via Platform Invocation Services (P/Invoke)
    or Component Object Model (COM) interop and didn’t want the details of that interface
    to bleed into your code? These scenarios are all good candidates for considering
    an adapter.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 有各种情况需要使用适配器类。如果您有一组实现接口的对象，并且想要使用不符合您代码接口的第三方类会怎么样？如果您的代码是为第三方API编写的，比如支付服务，并且您知道最终想要切换到具有不同API的不同提供商会怎么样？如果您需要通过平台调用服务（P/Invoke）或组件对象模型（COM）互操作使用本地代码，并且不希望该接口的细节渗入到您的代码中会怎么样？这些情况都是考虑使用适配器的良好候选者。
- en: The solution has `DeploymentService` classes that implement `IDeploymentService`.
    You can see in the `Program` `Start` method that it only operates on instances
    that implement `IDeploymentService`.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案中有实现`IDeploymentService`的`DeploymentService`类。您可以在`Program`的`Start`方法中看到，它仅操作实现了`IDeploymentService`的实例。
- en: Sometime later, you encounter the need to integrate `ThirdPartyDeploymentService`
    into the app. However, it doesn’t implement `IDeploymentService`, and you don’t
    have the code for `ThirdPartyDeploymentService`.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 之后的某个时候，您需要将`ThirdPartyDeploymentService`集成到应用程序中。然而，它没有实现`IDeploymentService`，而且您没有`ThirdPartyDeploymentService`的代码。
- en: The `ThirdPartyDeploymentAdapter` class solves the problem. It implements the
    `IDeploymentService` interface and instantiates its own copy of `ThirdPartyDeploymentService`,
    and the `Validate` method delegates the call to `ThirdPartyDeploymentService`.
    Notice that the `Program` `Configure` method adds an instance of `ThirdPartyDeploymentAdapter`
    to the collection that `Start` operates on.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '`ThirdPartyDeploymentAdapter`类解决了这个问题。它实现了`IDeploymentService`接口，并实例化了自己的`ThirdPartyDeploymentService`副本，`Validate`方法委托调用了`ThirdPartyDeploymentService`。请注意，`Program`的`Configure`方法将一个`ThirdPartyDeploymentAdapter`实例添加到`Start`操作的集合中。'
- en: This was a demo to show you how to design an adapter. In practice, the `Perform​Vali⁠dation`
    method of `ThirdPartyDeploymentService` likely has different parameters and a
    different return type. The `ThirdPartyDeploymentAdapter` `Validate` method will
    be responsible for preparing arguments and reshaping return values to ensure they
    conform to the proper `IDeploymentService` interface.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个演示，向您展示如何设计适配器。在实践中，`ThirdPartyDeploymentService`的`Perform​Vali⁠dation`方法可能具有不同的参数和不同的返回类型。`ThirdPartyDeploymentAdapter`的`Validate`方法将负责准备参数并重新塑造返回值，以确保它们符合适当的`IDeploymentService`接口。
- en: 1.9 Designing a Custom Exception
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1.9 设计自定义异常
- en: Problem
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: The .NET Framework library doesn’t have an exception type that fits your requirements.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: .NET Framework库没有符合您需求的异常类型。
- en: Solution
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'This is a custom exception:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个自定义异常：
- en: '[PRE32]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'And this is an enum type for a property on that exception:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 并且这是该异常属性的枚举类型：
- en: '[PRE33]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'This code shows how to throw the custom exception:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码显示了如何抛出自定义异常：
- en: '[PRE34]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'And this code catches the custom exception:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 并且这段代码捕获了自定义异常：
- en: '[PRE35]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Discussion
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: The beautiful thing about C# exceptions are that they’re strongly typed. When
    your code catches them, you can write specific handling logic for just that type
    of exception. The .NET Framework has a few exceptions, like `ArgumentNullException`,
    that get some reuse (you can throw yourself) in the average code base, but often
    you’ll need to throw an exception with the semantics and data that gives a developer
    a fairer chance of figuring out why a method couldn’t complete its intended purpose.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: C#异常的美妙之处在于它们是强类型的。当您的代码捕获它们时，您可以为仅针对该类型的异常编写特定的处理逻辑。.NET Framework有一些异常，如`ArgumentNullException`，在平均代码库中可以得到一些重复使用（您可以自行抛出），但通常您需要抛出一个具有语义和数据的异常，以便开发人员更有机会弄清楚为何方法无法完成其预期目的。
- en: The exception in the solution is `DeploymentValidationException`, which indicates
    a problem related to the deployment process during the validation phase. It derives
    from `Exception`. Depending on how extensive your custom exception framework is,
    you could create your own base exception for a hierarchy and classify a derived
    exception tree from that. The benefit is that you would have flexibility in catch
    blocks to catch more general or specific exceptions as necessary. That said, if
    you only need a couple of custom exceptions, the extra design work of an exception
    hierarchy might be overkill.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案中的异常是 `DeploymentValidationException`，表示在验证阶段的部署过程中出现问题。它派生自 `Exception`。根据你的自定义异常框架的扩展程度，你可以为其创建自己的基础异常以构建异常的层次结构，并从中分类派生异常树。这样做的好处是，你可以在
    catch 块中灵活地捕获更一般或特定的异常。尽管如此，如果你只需要一些自定义异常，那么异常层次结构的额外设计工作可能有些多余。
- en: The first three constructors mirror the `Exception` class options for message
    and inner exception. You’ll also want custom constructors for instantiating with
    your custom data.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 前三个构造函数与 `Exception` 类的选项相同，用于消息和内部异常。你还需要自定义构造函数以便使用你的自定义数据进行实例化。
- en: Note
  id: totrans-245
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: In the past, there’s been discussion of whether a custom exception should derive
    from `Exception` or `ApplicationException`, where `Exception` was for .NET-type
    hierarchies and `ApplicationException` was for custom exception hierarchies. However,
    the distinction blurred over time with some .NET Framework types deriving from
    both with no apparent consistency or reason. So, deriving from `Exception` seems
    to be fine these days.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去，关于自定义异常应该派生自 `Exception` 还是 `ApplicationException` 曾有过讨论，其中 `Exception`
    用于 .NET 类型层次结构，而 `ApplicationException` 用于自定义异常层次结构。然而，随着时间的推移，这种区别变得模糊了，一些 .NET
    Framework 类型同时从两者派生，而没有明显的一致性或理由。因此，目前看来，从 `Exception` 派生是可以接受的。
- en: '`DeploymentValidationException` has a property, of the enum type `Validation​Fai⁠lureReason`.
    Besides having semantics unique to the reason for throwing an exception, another
    purpose of a custom exception is to include important information for exception
    handling and/or debugging.'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '`DeploymentValidationException` 具有一个属性，其枚举类型为 `Validation​Fai⁠lureReason`。除了有关抛出异常原因的独特语义外，自定义异常的另一个目的是包含重要的异常处理和/或调试信息。'
- en: Overriding `ToString` is also a good idea. Logging frameworks might just receive
    the `Exception` reference, resulting in a call to `ToString`. As in this example,
    you’ll want to ensure your custom data gets included in the string output. This
    ensures people can read the full state of the exception, along with the stack
    trace.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 覆盖 `ToString` 也是个好主意。日志框架可能只会接收 `Exception` 引用，从而调用 `ToString`。就像本例中一样，你希望确保你的自定义数据包含在字符串输出中。这样可以确保人们可以阅读异常的完整状态，包括堆栈跟踪。
- en: The `Program` `Main` method demonstrates how nice it is to be able to handle
    the specific type, rather than another type that might not fit or the general
    `Exception` class.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '`Program` `Main` 方法演示了能够处理特定类型而不是可能不适合或通用的 `Exception` 类型的好处。'
- en: 1.10 Constructing Objects with Complex Configuration
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1.10 使用复杂配置构造对象
- en: Problem
  id: totrans-251
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You need to build a new type with complex configuration options without an unnecessary
    expansion of constructors.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要构建一个具有复杂配置选项的新类型，而无需不必要地扩展构造函数。
- en: Solution
  id: totrans-253
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Here’s the `DeploymentService` class we want to build:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们想要构建的 `DeploymentService` 类：
- en: '[PRE36]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This is the class that builds the `DeploymentService` instance:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类是构建 `DeploymentService` 实例的类：
- en: '[PRE37]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Here’s how to use the `DeploymentBuilder` class:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 这是如何使用 `DeploymentBuilder` 类的方法：
- en: '[PRE38]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Discussion
  id: totrans-260
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: In [Recipe 1.9](#designing_a_custom_exception), the `DeploymentValidationException`
    class has multiple constructors. Normally, this isn’t a problem. The first three
    constructors are a typical convention for exception classes. Subsequent constructors
    add new parameters for initializing new fields.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [Recipe 1.9](#designing_a_custom_exception) 中，`DeploymentValidationException`
    类有多个构造函数。通常情况下，这不是问题。前三个构造函数是异常类的典型约定。后续的构造函数为初始化新字段添加了新的参数。
- en: However, what if the class you were designing had a lot of options and there
    was a strong possibility that new features would require new options? Further,
    developers will want to pick and choose what options to configure the class with.
    Imagine the exponential explosion of new constructors for every new option added
    to the class. In such a scenario, constructors are practically useless. The builder
    pattern can solve this problem.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你设计的类有很多选项，并且有很强的可能性需要新功能，会怎么样呢？此外，开发人员将希望根据需要选择配置类。想象一下，为每个添加到类中的新选项创建新构造函数会带来指数级的增长。在这种情况下，构造函数几乎没有用处。建造者模式可以解决这个问题。
- en: An example of an object that implements the builder pattern is the ASP.NET `ConfigSettings`.
    Another is the `ServiceCollection` from [Recipe 1.2](#removing_explicit_dependencies)—the
    code isn’t entirely written in a fluid manner, but it could be because it follows
    the builder pattern.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 实现建造者模式的对象示例包括ASP.NET的`ConfigSettings`和[Recipe 1.2](#removing_explicit_dependencies)中的`ServiceCollection`——虽然代码并非完全按照流式处理编写，但可以，因为它遵循建造者模式。
- en: The Solution has a `DeploymentService` class, which is what we want to build.
    Its properties have default values in case a developer doesn’t configure a given
    value. In general terms, the class that the builder creates will also have other
    methods and members for its intended purpose.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案有一个`DeploymentService`类，这正是我们想要构建的。如果开发人员没有配置给定的值，则其属性具有默认值。一般来说，建造者创建的类还将具有其他用于其预期目的的方法和成员。
- en: The `DeploymentBuilder` class implements the builder pattern. Notice that all
    of the methods, except for `Build`, return the same instance (`this`) of the same
    type, `DeploymentBuilder`. They also use the parameter to configure the `DeploymentService`
    field that was instantiated with the `DeploymentBuilder` instance. The `Build`
    method returns the `DeploymentService` instance.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '`DeploymentBuilder`类实现了建造者模式。请注意，除了`Build`方法外，所有方法都返回相同类型`DeploymentBuilder`的同一实例（`this`），并使用参数配置了使用`DeploymentBuilder`实例化的`DeploymentService`字段。`Build`方法返回`DeploymentService`实例。'
- en: How the configuration and instantiation occur are implementation details of
    the `DeploymentBuilder` that you can vary as needed. You can also accept any parameter
    type you need and perform the configuration. Also, you can collect configuration
    data and only instantiate the target class when the `Build` method runs. Another
    advantage is that the order in which parameters are set is irrelevant. You have
    all the flexibility to design the internals of the builder for what makes sense
    to you.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 如何配置和实例化是`DeploymentBuilder`的实现细节，可以根据需要进行变化。你也可以接受任何你需要的参数类型并进行配置。此外，你可以收集配置数据，并仅在运行`Build`方法时实例化目标类。另一个优势是参数设置的顺序不重要。你可以根据自己的需要灵活设计建造者的内部。
- en: Finally, notice how the `Main` method instantiates `DeploymentBuilder`, uses
    its fluent interface for configuration, and calls `Build` to return the `DeploymentService`
    instance. This example used every method, but that wasn’t required because you
    have the option to use some, none, or all.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，请注意`Main`方法如何实例化`DeploymentBuilder`，使用其流畅的接口进行配置，并调用`Build`方法返回`DeploymentService`实例。这个示例使用了每个方法，但这并非必需，因为你可以选择使用一些，全部或者不使用。
- en: See Also
  id: totrans-268
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Recipe 1.2, “Removing Explicit Dependencies”](#removing_explicit_dependencies)'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '[Recipe 1.2，“消除显式依赖项”](#removing_explicit_dependencies)'
- en: '[Recipe 1.9, “Designing a Custom Exception”](#designing_a_custom_exception)'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '[Recipe 1.9，“设计自定义异常”](#designing_a_custom_exception)'
