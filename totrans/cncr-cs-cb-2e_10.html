<html><head></head><body><section data-pdf-bookmark="Chapter 10. Cancellation" data-type="chapter" epub:type="chapter"><div class="chapter" id="cancellation">&#13;
<h1><span class="label">Chapter 10. </span>Cancellation</h1>&#13;
&#13;
&#13;
<p>The<a data-primary="cancellation" data-secondary="overview" data-type="indexterm" id="ch10over"/> .NET 4.0 framework introduced exhaustive and well-designed cancellation support. This support is cooperative, which means that cancellation can be requested but not enforced on code. Since cancellation is cooperative, it isn’t possible to cancel code unless it is written to support cancellation. For this reason, I recommend supporting cancellation in as much of your own code as possible.</p>&#13;
&#13;
<p>Cancellation<a data-primary="CancellationTokenSource type" data-type="indexterm" id="idm45458691790328"/><a data-primary="CancellationToken type" data-type="indexterm" id="idm45458691789576"/> is a type of signal, with two different sides: a source that triggers the cancellation and a receiver that then responds to the cancellation. In .NET, the source is <code>CancellationTokenSource</code> and the receiver is <code>CancellationToken</code>. The recipes in this chapter cover both sources and receivers of cancellation in normal usage and describe how to use the cancellation support to interoperate with nonstandard forms of cancellation.</p>&#13;
&#13;
<p>Cancellation<a data-primary="cancellation" data-secondary="exceptions thrown by" data-type="indexterm" id="idm45458691787144"/><a data-primary="error handling" data-secondary="with cancellation" data-secondary-sortas="cancellation" data-type="indexterm" id="idm45458691786136"/> is treated as a special kind of error. The convention is that canceled code will throw an exception of type <code>OperationCanceledException</code> (or a derived type, such as <code>TaskCanceledException</code>). This way the calling code knows that the cancellation was observed.</p>&#13;
&#13;
<p>To indicate to calling code that your method supports cancellation, you should take a <code>CancellationToken</code> as a parameter. This parameter is usually the last parameter, unless your method also reports progress (<a data-type="xref" href="ch02.html#recipe-async-progress">Recipe 2.3</a>). You can also consider providing an overload or default parameter value for consumers that do not require cancellation:</p>&#13;
&#13;
<pre data-code-language="csharp" data-type="programlisting"><code class="k">public</code> <code class="k">void</code> <code class="nf">CancelableMethodWithOverload</code><code class="p">(</code><code class="n">CancellationToken</code> <code class="n">cancellationToken</code><code class="p">)</code>&#13;
<code class="p">{</code>&#13;
  <code class="c1">// Code goes here.</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="k">public</code> <code class="k">void</code> <code class="nf">CancelableMethodWithOverload</code><code class="p">()</code>&#13;
<code class="p">{</code>&#13;
  <code class="n">CancelableMethodWithOverload</code><code class="p">(</code><code class="n">CancellationToken</code><code class="p">.</code><code class="n">None</code><code class="p">);</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="k">public</code> <code class="k">void</code> <code class="nf">CancelableMethodWithDefault</code><code class="p">(</code>&#13;
    <code class="n">CancellationToken</code> <code class="n">cancellationToken</code> <code class="p">=</code> <code class="k">default</code><code class="p">)</code>&#13;
<code class="p">{</code>&#13;
  <code class="c1">// Code goes here.</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p><code>CancellationToken.None</code> <a data-primary="CancellationToken.None value" data-type="indexterm" id="idm45458691780136"/>represents a cancellation token that will never be canceled, and is a special value that is equivalent to <code>default(CancellationToken)</code>. Consumers pass this value when they don’t ever want the operation to be canceled.</p>&#13;
&#13;
<p>Asynchronous streams have a similar but more complex way of handling cancellation. Canceling asynchronous streams is covered in detail <a data-startref="ch10over" data-type="indexterm" id="idm45458691754776"/>in <a data-type="xref" href="ch03.html#recipe-async-streams-cancellation">Recipe 3.4</a>.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section class="recipe" data-pdf-bookmark="10.1 Issuing Cancellation Requests" data-type="sect1"><div class="sect1" id="recipe-cancellationtokensource">&#13;
<h1>10.1 Issuing Cancellation Requests</h1>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="idm45458691674568">&#13;
<h2>Problem</h2>&#13;
&#13;
<p>Your <a data-primary="cancellation" data-secondary="requests for, issuing" data-type="indexterm" id="ch10r1a"/>code calls cancelable code (that takes a <code>CancellationToken</code>) and you need to cancel it.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="idm45458691671144">&#13;
<h2>Solution</h2>&#13;
&#13;
<p>The<a data-primary="CancellationTokenSource type" data-type="indexterm" id="ch10r1b"/> <code>CancellationTokenSource</code> type is the source for a <code>CancellationToken</code>. It only enables code to respond to cancellation requests; the <code>CancellationTokenSource</code> members enable code to request cancellation.</p>&#13;
&#13;
<p>Each <code>CancellationTokenSource</code> is independent from every other one (unless you link them, as considered in <a data-type="xref" href="#recipe-linked-cancellationtokens">Recipe 10.8</a>). The <code>Token</code> property returns a <code>CancellationToken</code> for that source, and the <code>Cancel</code> method issues the actual cancellation request.</p>&#13;
&#13;
<p>The following code illustrates creating a <code>CancellationTokenSource</code> and using <code>Token</code> and <code>Cancel</code>. The code uses an <code>async</code> method because it’s easier to illustrate in a short code sample; the same <code>Token</code>/<code>Cancel</code> pair is used to cancel <em>all</em> kinds of code:</p>&#13;
<pre data-code-language="csharp" data-type="programlisting"><code class="k">void</code> <code class="nf">IssueCancelRequest</code><code class="p">()</code>&#13;
<code class="p">{</code>&#13;
  <code class="k">using</code> <code class="k">var</code> <code class="n">cts</code> <code class="p">=</code> <code class="k">new</code> <code class="n">CancellationTokenSource</code><code class="p">();</code>&#13;
  <code class="kt">var</code> <code class="n">task</code> <code class="p">=</code> <code class="n">CancelableMethodAsync</code><code class="p">(</code><code class="n">cts</code><code class="p">.</code><code class="n">Token</code><code class="p">);</code>&#13;
&#13;
  <code class="c1">// At this point, the operation has been started.</code>&#13;
&#13;
  <code class="c1">// Issue the cancellation request.</code>&#13;
  <code class="n">cts</code><code class="p">.</code><code class="n">Cancel</code><code class="p">();</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>In the preceding example code, the <code>task</code> variable is ignored after it has started running; in real-world code, that task would probably be stored somewhere and awaited so that the end user is aware of the final result.</p>&#13;
&#13;
<p>When <a data-primary="cancellation" data-secondary="exceptions thrown by" data-type="indexterm" id="idm45458691640456"/><a data-primary="error handling" data-secondary="with cancellation" data-secondary-sortas="cancellation" data-type="indexterm" id="idm45458691639448"/>you cancel code, there is almost always a race condition. The cancelable code may have been <em>just about to finish</em> when the cancel request is made, and if it doesn’t happen to check its cancellation token before finishing, it will actually complete successfully. In fact, when you cancel code, there are three possibilities: it may respond to the cancellation request (throwing <code>OperationCanceledException</code>), it may finish successfully, or it may finish with an error unrelated to the cancellation (throwing a different exception).</p>&#13;
&#13;
<p>The following code is just like the last, except that it awaits the task, illustrating all three possible results:</p>&#13;
<pre data-code-language="csharp" data-type="programlisting"><code class="k">async</code> <code class="n">Task</code> <code class="nf">IssueCancelRequestAsync</code><code class="p">()</code>&#13;
<code class="p">{</code>&#13;
  <code class="k">using</code> <code class="k">var</code> <code class="n">cts</code> <code class="p">=</code> <code class="k">new</code> <code class="n">CancellationTokenSource</code><code class="p">();</code>&#13;
  <code class="kt">var</code> <code class="n">task</code> <code class="p">=</code> <code class="n">CancelableMethodAsync</code><code class="p">(</code><code class="n">cts</code><code class="p">.</code><code class="n">Token</code><code class="p">);</code>&#13;
&#13;
  <code class="c1">// At this point, the operation is happily running.</code>&#13;
&#13;
  <code class="c1">// Issue the cancellation request.</code>&#13;
  <code class="n">cts</code><code class="p">.</code><code class="n">Cancel</code><code class="p">();</code>&#13;
&#13;
  <code class="c1">// (Asynchronously) wait for the operation to finish.</code>&#13;
  <code class="k">try</code>&#13;
  <code class="p">{</code>&#13;
    <code class="k">await</code> <code class="n">task</code><code class="p">;</code>&#13;
    <code class="c1">// If we get here, the operation completed successfully</code>&#13;
    <code class="c1">//  before the cancellation took effect.</code>&#13;
  <code class="p">}</code>&#13;
  <code class="k">catch</code> <code class="p">(</code><code class="n">OperationCanceledException</code><code class="p">)</code>&#13;
  <code class="p">{</code>&#13;
    <code class="c1">// If we get here, the operation was canceled before it completed.</code>&#13;
  <code class="p">}</code>&#13;
  <code class="k">catch</code> <code class="p">(</code><code class="n">Exception</code><code class="p">)</code>&#13;
  <code class="p">{</code>&#13;
    <code class="c1">// If we get here, the operation completed with an error</code>&#13;
    <code class="c1">//  before the cancellation took effect.</code>&#13;
    <code class="k">throw</code><code class="p">;</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Normally, setting up the <code>CancellationTokenSource</code> and issuing the cancellation are in separate methods. Once you cancel a <code>CancellationTokenSource</code> instance, it is permanently canceled. If you need another source, you must create another instance. The following code is a more realistic GUI-based example that uses one button to start an asynchronous operation and another button to cancel it. It also disables and enables <code>StartButton</code> and <code>CancelButton</code> so that there can only be one operation at a time:</p>&#13;
&#13;
<pre data-code-language="csharp" data-type="programlisting"><code class="k">private</code> <code class="n">CancellationTokenSource</code> <code class="n">_cts</code><code class="p">;</code>&#13;
&#13;
<code class="k">private</code> <code class="k">async</code> <code class="k">void</code> <code class="nf">StartButton_Click</code><code class="p">(</code><code class="kt">object</code> <code class="n">sender</code><code class="p">,</code> <code class="n">RoutedEventArgs</code> <code class="n">e</code><code class="p">)</code>&#13;
<code class="p">{</code>&#13;
  <code class="n">StartButton</code><code class="p">.</code><code class="n">IsEnabled</code> <code class="p">=</code> <code class="k">false</code><code class="p">;</code>&#13;
  <code class="n">CancelButton</code><code class="p">.</code><code class="n">IsEnabled</code> <code class="p">=</code> <code class="k">true</code><code class="p">;</code>&#13;
  <code class="k">try</code>&#13;
  <code class="p">{</code>&#13;
    <code class="n">_cts</code> <code class="p">=</code> <code class="k">new</code> <code class="n">CancellationTokenSource</code><code class="p">();</code>&#13;
    <code class="n">CancellationToken</code> <code class="n">token</code> <code class="p">=</code> <code class="n">_cts</code><code class="p">.</code><code class="n">Token</code><code class="p">;</code>&#13;
    <code class="k">await</code> <code class="n">Task</code><code class="p">.</code><code class="n">Delay</code><code class="p">(</code><code class="n">TimeSpan</code><code class="p">.</code><code class="n">FromSeconds</code><code class="p">(</code><code class="m">5</code><code class="p">),</code> <code class="n">token</code><code class="p">);</code>&#13;
    <code class="n">MessageBox</code><code class="p">.</code><code class="n">Show</code><code class="p">(</code><code class="s">"Delay completed successfully."</code><code class="p">);</code>&#13;
  <code class="p">}</code>&#13;
  <code class="k">catch</code> <code class="p">(</code><code class="n">OperationCanceledException</code><code class="p">)</code>&#13;
  <code class="p">{</code>&#13;
    <code class="n">MessageBox</code><code class="p">.</code><code class="n">Show</code><code class="p">(</code><code class="s">"Delay was canceled."</code><code class="p">);</code>&#13;
  <code class="p">}</code>&#13;
  <code class="k">catch</code> <code class="p">(</code><code class="n">Exception</code><code class="p">)</code>&#13;
  <code class="p">{</code>&#13;
    <code class="n">MessageBox</code><code class="p">.</code><code class="n">Show</code><code class="p">(</code><code class="s">"Delay completed with error."</code><code class="p">);</code>&#13;
    <code class="k">throw</code><code class="p">;</code>&#13;
  <code class="p">}</code>&#13;
  <code class="k">finally</code>&#13;
  <code class="p">{</code>&#13;
    <code class="n">StartButton</code><code class="p">.</code><code class="n">IsEnabled</code> <code class="p">=</code> <code class="k">true</code><code class="p">;</code>&#13;
    <code class="n">CancelButton</code><code class="p">.</code><code class="n">IsEnabled</code> <code class="p">=</code> <code class="k">false</code><code class="p">;</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="k">private</code> <code class="k">void</code> <code class="nf">CancelButton_Click</code><code class="p">(</code><code class="kt">object</code> <code class="n">sender</code><code class="p">,</code> <code class="n">RoutedEventArgs</code> <code class="n">e</code><code class="p">)</code>&#13;
<code class="p">{</code>&#13;
  <code class="n">_cts</code><code class="p">.</code><code class="n">Cancel</code><code class="p">();</code>&#13;
  <code class="n">CancelButton</code><code class="p">.</code><code class="n">IsEnabled</code> <code class="p">=</code> <code class="k">false</code><code class="p">;</code>&#13;
<code class="p">}</code></pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="idm45458691670520">&#13;
<h2>Discussion</h2>&#13;
&#13;
<p>The most realistic example in this recipe used a GUI application, but don’t get the impression that cancellation is just for user interfaces. Cancellation<a data-primary="ASP.NET" data-secondary="cancellation tokens" data-type="indexterm" id="idm45458691584152"/> has its place on the server as well; for example, ASP.NET provides a cancellation token representing the request timeout or client disconnect. It’s true that cancellation token sources are rarer on the server side, but there’s no reason you can’t use them; they’re useful if you need to cancel for some reason not covered by ASP.NET cancellation, such as an additional timeout for a portion of the request <a data-startref="ch10r1a" data-type="indexterm" id="idm45458691465496"/><a data-startref="ch10r1b" data-type="indexterm" id="idm45458691464824"/>processing.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="See Also" data-type="sect2"><div class="sect2" id="idm45458691463768">&#13;
<h2>See Also</h2>&#13;
&#13;
<p><a data-type="xref" href="#recipe-cancel-async">Recipe 10.4</a> covers passing tokens to <code>async</code> code.</p>&#13;
&#13;
<p><a data-type="xref" href="#recipe-cancel-parallel">Recipe 10.5</a> covers passing tokens to parallel code.</p>&#13;
&#13;
<p><a data-type="xref" href="#recipe-cancel-rx">Recipe 10.6</a> covers using tokens with reactive code.</p>&#13;
&#13;
<p><a data-type="xref" href="#recipe-cancel-dataflow">Recipe 10.7</a> covers passing tokens to dataflow meshes.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section class="recipe" data-pdf-bookmark="10.2 Responding to Cancellation Requests by Polling" data-type="sect1"><div class="sect1" id="recipe-cancellationtoken">&#13;
<h1>10.2 Responding to Cancellation Requests by Polling</h1>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="idm45458691455960">&#13;
<h2>Problem</h2>&#13;
&#13;
<p>You <a data-primary="cancellation" data-secondary="requests for, responding to" data-type="indexterm" id="ch10r2a"/>have a loop in your code that needs to support cancellation.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="idm45458691453000">&#13;
<h2>Solution</h2>&#13;
&#13;
<p>When <a data-primary="CancellationToken type" data-type="indexterm" id="idm45458691451464"/><a data-primary="ThrowIfCancellationRequested method" data-type="indexterm" id="ch10r2b"/>you have a processing loop in your code, then there isn’t a lower-level API to which you can pass the <code>CancellationToken</code>. In this case, you should periodically check whether the token has been canceled. The following code observes the token periodically while executing a CPU-bound loop:</p>&#13;
&#13;
<pre data-code-language="csharp" data-type="programlisting"><code class="k">public</code> <code class="kt">int</code> <code class="nf">CancelableMethod</code><code class="p">(</code><code class="n">CancellationToken</code> <code class="n">cancellationToken</code><code class="p">)</code>&#13;
<code class="p">{</code>&#13;
  <code class="k">for</code> <code class="p">(</code><code class="kt">int</code> <code class="n">i</code> <code class="p">=</code> <code class="m">0</code><code class="p">;</code> <code class="n">i</code> <code class="p">!=</code> <code class="m">100</code><code class="p">;</code> <code class="p">++</code><code class="n">i</code><code class="p">)</code>&#13;
  <code class="p">{</code>&#13;
    <code class="n">Thread</code><code class="p">.</code><code class="n">Sleep</code><code class="p">(</code><code class="m">1000</code><code class="p">);</code> <code class="c1">// Some calculation goes here.</code>&#13;
    <code class="n">cancellationToken</code><code class="p">.</code><code class="n">ThrowIfCancellationRequested</code><code class="p">();</code>&#13;
  <code class="p">}</code>&#13;
  <code class="k">return</code> <code class="m">42</code><code class="p">;</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>If your loop is very tight (i.e., if the body of your loop executes very quickly), then you may want to limit how often you check your cancellation token. As always, measure your performance before and after a change like this before deciding which way is best. The following code is similar to the previous example, but it has more iterations of a faster loop, so I added a limit to how often the token is checked:</p>&#13;
&#13;
<pre data-code-language="csharp" data-type="programlisting"><code class="k">public</code> <code class="kt">int</code> <code class="nf">CancelableMethod</code><code class="p">(</code><code class="n">CancellationToken</code> <code class="n">cancellationToken</code><code class="p">)</code>&#13;
<code class="p">{</code>&#13;
  <code class="k">for</code> <code class="p">(</code><code class="kt">int</code> <code class="n">i</code> <code class="p">=</code> <code class="m">0</code><code class="p">;</code> <code class="n">i</code> <code class="p">!=</code> <code class="m">100000</code><code class="p">;</code> <code class="p">++</code><code class="n">i</code><code class="p">)</code>&#13;
  <code class="p">{</code>&#13;
    <code class="n">Thread</code><code class="p">.</code><code class="n">Sleep</code><code class="p">(</code><code class="m">1</code><code class="p">);</code> <code class="c1">// Some calculation goes here.</code>&#13;
    <code class="k">if</code> <code class="p">(</code><code class="n">i</code> <code class="p">%</code> <code class="m">1000</code> <code class="p">==</code> <code class="m">0</code><code class="p">)</code>&#13;
      <code class="n">cancellationToken</code><code class="p">.</code><code class="n">ThrowIfCancellationRequested</code><code class="p">();</code>&#13;
  <code class="p">}</code>&#13;
  <code class="k">return</code> <code class="m">42</code><code class="p">;</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>The proper limit to use depends entirely on how much work you’re doing and how responsive the cancellation needs to be.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="idm45458691452696">&#13;
<h2>Discussion</h2>&#13;
&#13;
<p>The majority of the time, your code should just pass through the <code>CancellationToken</code> to the next layer. There are examples of this in Recipes <a data-type="xref" data-xrefstyle="select:labelnumber" href="#recipe-cancel-async">10.4</a>,&#13;
<a data-type="xref" data-xrefstyle="select:labelnumber" href="#recipe-cancel-parallel">10.5</a>, <a data-type="xref" data-xrefstyle="select:labelnumber" href="#recipe-cancel-rx">10.6</a>, and <a data-type="xref" data-xrefstyle="select:labelnumber" href="#recipe-cancel-dataflow">10.7</a>. The polling technique in this recipe should only be used if you have a processing loop that needs to support cancellation.</p>&#13;
&#13;
<p>There’s <a data-primary="IsCancellationRequested method" data-type="indexterm" id="idm45458691253128"/>another member on <code>CancellationToken</code> called <code>IsCancellationRequested</code>, which starts returning <code>true</code> when the token is canceled. Some people use this member to respond to cancellation, usually by returning a default or <code>null</code> value. I do not recommend this approach for most code. The standard cancellation pattern is to raise an <code>OperationCanceledException</code>, which is taken care of by <code>ThrowIfCancellationRequested</code>. If code further up the stack wants to catch the exception and act like the result is <code>null</code>, then that’s fine, but any code taking a <code>CancellationToken</code> should follow the standard cancellation pattern. If you do decide not to follow the cancellation pattern, at least document it clearly.</p>&#13;
&#13;
<p><code>ThrowIfCancellationRequested</code> works by <em>polling</em> the cancellation token; your code has to call it at regular intervals. There’s also a way to register a callback that is invoked when cancellation is requested. The callback approach is more about interoperating with other cancellation systems; <a data-type="xref" href="#recipe-cancellationtoken-callbacks">Recipe 10.9</a> covers using callbacks with <a data-startref="ch10r2a" data-type="indexterm" id="idm45458691246360"/><a data-startref="ch10r2b" data-type="indexterm" id="idm45458691245688"/>cancellation.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="See Also" data-type="sect2"><div class="sect2" id="idm45458691244632">&#13;
<h2>See Also</h2>&#13;
&#13;
<p><a data-type="xref" href="#recipe-cancel-async">Recipe 10.4</a> covers passing tokens to <code>async</code> code.</p>&#13;
&#13;
<p><a data-type="xref" href="#recipe-cancel-parallel">Recipe 10.5</a> covers passing tokens to parallel code.</p>&#13;
&#13;
<p><a data-type="xref" href="#recipe-cancel-rx">Recipe 10.6</a> covers using tokens with reactive code.</p>&#13;
&#13;
<p><a data-type="xref" href="#recipe-cancel-dataflow">Recipe 10.7</a> covers passing tokens to dataflow meshes.</p>&#13;
&#13;
<p><a data-type="xref" href="#recipe-cancellationtoken-callbacks">Recipe 10.9</a> covers using callbacks instead of polling to respond to cancellation requests.</p>&#13;
&#13;
<p><a data-type="xref" href="#recipe-cancellationtokensource">Recipe 10.1</a> covers issuing a cancellation request.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section class="recipe" data-pdf-bookmark="10.3 Canceling Due to Timeouts" data-type="sect1"><div class="sect1" id="recipe-cancel-timeout">&#13;
<h1>10.3 Canceling Due to Timeouts</h1>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="idm45458691234328">&#13;
<h2>Problem</h2>&#13;
&#13;
<p>You <a data-primary="cancellation" data-secondary="timeouts causing" data-type="indexterm" id="ch10r3a"/><a data-primary="timeouts" data-type="indexterm" id="ch10r3b"/>have some code that needs to stop running after a timeout.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="idm45458691230392">&#13;
<h2>Solution</h2>&#13;
&#13;
<p>Cancellation is a natural solution for timeout situations. A timeout is just one type of cancellation request. The code that needs to be canceled merely observes the cancellation token just like any other cancellation; it should neither know nor care that the cancellation source is a timer.</p>&#13;
&#13;
<p>There are some convenience methods for cancellation token sources that automatically issue a cancel request based on a timer. You can pass the timeout into the constructor:</p>&#13;
<pre data-code-language="csharp" data-type="programlisting"><code class="k">async</code> <code class="n">Task</code> <code class="nf">IssueTimeoutAsync</code><code class="p">()</code>&#13;
<code class="p">{</code>&#13;
  <code class="k">using</code> <code class="k">var</code> <code class="n">cts</code> <code class="p">=</code> <code class="k">new</code> <code class="n">CancellationTokenSource</code><code class="p">(</code><code class="n">TimeSpan</code><code class="p">.</code><code class="n">FromSeconds</code><code class="p">(</code><code class="m">5</code><code class="p">));</code>&#13;
  <code class="n">CancellationToken</code> <code class="n">token</code> <code class="p">=</code> <code class="n">cts</code><code class="p">.</code><code class="n">Token</code><code class="p">;</code>&#13;
  <code class="k">await</code> <code class="n">Task</code><code class="p">.</code><code class="n">Delay</code><code class="p">(</code><code class="n">TimeSpan</code><code class="p">.</code><code class="n">FromSeconds</code><code class="p">(</code><code class="m">10</code><code class="p">),</code> <code class="n">token</code><code class="p">);</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Alternatively, <a data-primary="CancellationTokenSource type" data-type="indexterm" id="idm45458691226584"/><a data-primary="CancelAfter method" data-type="indexterm" id="idm45458691170760"/>if you already have a <code>CancellationTokenSource</code> instance, you can start a timeout for that instance:</p>&#13;
<pre data-code-language="csharp" data-type="programlisting"><code class="k">async</code> <code class="n">Task</code> <code class="nf">IssueTimeoutAsync</code><code class="p">()</code>&#13;
<code class="p">{</code>&#13;
  <code class="k">using</code> <code class="k">var</code> <code class="n">cts</code> <code class="p">=</code> <code class="k">new</code> <code class="n">CancellationTokenSource</code><code class="p">();</code>&#13;
  <code class="n">CancellationToken</code> <code class="n">token</code> <code class="p">=</code> <code class="n">cts</code><code class="p">.</code><code class="n">Token</code><code class="p">;</code>&#13;
  <code class="n">cts</code><code class="p">.</code><code class="n">CancelAfter</code><code class="p">(</code><code class="n">TimeSpan</code><code class="p">.</code><code class="n">FromSeconds</code><code class="p">(</code><code class="m">5</code><code class="p">));</code>&#13;
  <code class="k">await</code> <code class="n">Task</code><code class="p">.</code><code class="n">Delay</code><code class="p">(</code><code class="n">TimeSpan</code><code class="p">.</code><code class="n">FromSeconds</code><code class="p">(</code><code class="m">10</code><code class="p">),</code> <code class="n">token</code><code class="p">);</code>&#13;
<code class="p">}</code></pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="idm45458691168440">&#13;
<h2>Discussion</h2>&#13;
&#13;
<p>To execute code with a timeout, use <code>CancellationTokenSource</code> and <code>CancelAfter</code> (or the constructor). There are other ways to do the same thing, but using the existing cancellation system is the easiest and most efficient option.</p>&#13;
&#13;
<p>Remember that the code to be canceled needs to observe the cancellation token; it isn’t possible to easily cancel un-cancelable <a data-startref="ch10r3a" data-type="indexterm" id="idm45458691138776"/><a data-startref="ch10r3b" data-type="indexterm" id="idm45458691138072"/>code.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="See Also" data-type="sect2"><div class="sect2" id="idm45458691137016">&#13;
<h2>See Also</h2>&#13;
&#13;
<p><a data-type="xref" href="#recipe-cancel-async">Recipe 10.4</a> covers passing tokens to <code>async</code> code.</p>&#13;
&#13;
<p><a data-type="xref" href="#recipe-cancel-parallel">Recipe 10.5</a> covers passing tokens to parallel code.</p>&#13;
&#13;
<p><a data-type="xref" href="#recipe-cancel-rx">Recipe 10.6</a> covers using tokens with reactive code.</p>&#13;
&#13;
<p><a data-type="xref" href="#recipe-cancel-dataflow">Recipe 10.7</a> covers passing tokens to dataflow meshes.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section class="recipe" data-pdf-bookmark="10.4 Canceling async Code" data-type="sect1"><div class="sect1" id="recipe-cancel-async">&#13;
<h1>10.4 Canceling async Code</h1>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="idm45458691129144">&#13;
<h2>Problem</h2>&#13;
&#13;
<p>You <a data-primary="asynchronous programming" data-secondary="cancellation in" data-type="indexterm" id="idm45458691127784"/><a data-primary="cancellation" data-secondary="in asynchronous code" data-secondary-sortas="asynchronous" data-type="indexterm" id="idm45458691126808"/>are using <code>async</code> code and need to support cancellation.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="idm45458691124792">&#13;
<h2>Solution</h2>&#13;
&#13;
<p>The <a data-primary="CancellationToken type" data-type="indexterm" id="idm45458691123464"/>simplest way to support cancellation in asynchronous code is to just pass the <code>CancellationToken</code> through to the next layer. The following example code performs an asynchronous delay and then returns a value; it supports cancellation by passing the token to <code>Task.Delay</code>:</p>&#13;
&#13;
<pre data-code-language="csharp" data-type="programlisting"><code class="k">public</code> <code class="k">async</code> <code class="n">Task</code><code class="p">&lt;</code><code class="kt">int</code><code class="p">&gt;</code> <code class="n">CancelableMethodAsync</code><code class="p">(</code><code class="n">CancellationToken</code> <code class="n">cancellationToken</code><code class="p">)</code>&#13;
<code class="p">{</code>&#13;
  <code class="k">await</code> <code class="n">Task</code><code class="p">.</code><code class="n">Delay</code><code class="p">(</code><code class="n">TimeSpan</code><code class="p">.</code><code class="n">FromSeconds</code><code class="p">(</code><code class="m">2</code><code class="p">),</code> <code class="n">cancellationToken</code><code class="p">);</code>&#13;
  <code class="k">return</code> <code class="m">42</code><code class="p">;</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Many asynchronous APIs support <code>CancellationToken</code>, so enabling cancellation yourself is usually a simple matter of taking a token and passing it along. As a general rule, if your method calls APIs that take <code>CancellationToken</code>, then your method should also take a <code>CancellationToken</code> and pass it to every API that supports it.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="idm45458691096888">&#13;
<h2>Discussion</h2>&#13;
&#13;
<p>Unfortunately, some methods don’t support cancellation. When you’re in this situation, there’s no easy solution. It’s not possible to safely stop arbitrary code unless it’s wrapped in a separate executable. If your code calls code that doesn’t support cancellation, and if you don’t want to wrap that code in a separate executable, you do always have the option of <em>pretending</em> to cancel the operation by ignoring the result.</p>&#13;
&#13;
<p>Cancellation should be provided as an option whenever possible. This is because proper cancellation at a higher level depends on proper cancellation at the lower level. So, when you’re writing your own <code>async</code> methods, try your best to include support for cancellation; you never know what higher-level method will want to call yours, and it might need cancellation.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="See Also" data-type="sect2"><div class="sect2" id="idm45458691093256">&#13;
<h2>See Also</h2>&#13;
&#13;
<p><a data-type="xref" href="#recipe-cancellationtokensource">Recipe 10.1</a> covers issuing a cancellation request.</p>&#13;
&#13;
<p><a data-type="xref" href="#recipe-cancel-timeout">Recipe 10.3</a> covers using cancellation as a timeout.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section class="recipe" data-pdf-bookmark="10.5 Canceling Parallel Code" data-type="sect1"><div class="sect1" id="recipe-cancel-parallel">&#13;
<h1>10.5 Canceling Parallel Code</h1>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="idm45458691088088">&#13;
<h2>Problem</h2>&#13;
&#13;
<p>You <a data-primary="parallel programming" data-secondary="cancellation in" data-type="indexterm" id="ch10r5a"/><a data-primary="cancellation" data-secondary="in parallel code" data-secondary-sortas="parallel" data-type="indexterm" id="ch10r5b"/>are using parallel code and need to support cancellation.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="idm45458691083576">&#13;
<h2>Solution</h2>&#13;
&#13;
<p>The <a data-primary="ParallelOptions type" data-type="indexterm" id="idm45458691081816"/><a data-primary="CancellationToken type" data-type="indexterm" id="idm45458691081080"/>easiest way to support cancellation is to pass the <code>CancellationToken</code> through to the parallel code. <code>Parallel</code> methods support this by taking a <code>ParallelOptions</code> instance. You can set the <code>CancellationToken</code> on a <code>ParallelOptions</code> instance in the following manner:</p>&#13;
&#13;
<pre data-code-language="csharp" data-type="programlisting"><code class="k">void</code> <code class="nf">RotateMatrices</code><code class="p">(</code><code class="n">IEnumerable</code><code class="p">&lt;</code><code class="n">Matrix</code><code class="p">&gt;</code> <code class="n">matrices</code><code class="p">,</code> <code class="kt">float</code> <code class="n">degrees</code><code class="p">,</code>&#13;
    <code class="n">CancellationToken</code> <code class="n">token</code><code class="p">)</code>&#13;
<code class="p">{</code>&#13;
  <code class="n">Parallel</code><code class="p">.</code><code class="n">ForEach</code><code class="p">(</code><code class="n">matrices</code><code class="p">,</code>&#13;
      <code class="k">new</code> <code class="n">ParallelOptions</code> <code class="p">{</code> <code class="n">CancellationToken</code> <code class="p">=</code> <code class="n">token</code> <code class="p">},</code>&#13;
      <code class="n">matrix</code> <code class="p">=&gt;</code> <code class="n">matrix</code><code class="p">.</code><code class="n">Rotate</code><code class="p">(</code><code class="n">degrees</code><code class="p">));</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Alternatively, it’s possible to observe the <code>CancellationToken</code> directly in your loop body:</p>&#13;
&#13;
<pre data-code-language="csharp" data-type="programlisting"><code class="k">void</code> <code class="nf">RotateMatrices2</code><code class="p">(</code><code class="n">IEnumerable</code><code class="p">&lt;</code><code class="n">Matrix</code><code class="p">&gt;</code> <code class="n">matrices</code><code class="p">,</code> <code class="kt">float</code> <code class="n">degrees</code><code class="p">,</code>&#13;
    <code class="n">CancellationToken</code> <code class="n">token</code><code class="p">)</code>&#13;
<code class="p">{</code>&#13;
  <code class="c1">// Warning: not recommended; see below.</code>&#13;
  <code class="n">Parallel</code><code class="p">.</code><code class="n">ForEach</code><code class="p">(</code><code class="n">matrices</code><code class="p">,</code> <code class="n">matrix</code> <code class="p">=&gt;</code>&#13;
  <code class="p">{</code>&#13;
    <code class="n">matrix</code><code class="p">.</code><code class="n">Rotate</code><code class="p">(</code><code class="n">degrees</code><code class="p">);</code>&#13;
    <code class="n">token</code><code class="p">.</code><code class="n">ThrowIfCancellationRequested</code><code class="p">();</code>&#13;
  <code class="p">});</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>The alternative method is more work and doesn’t compose as well because the parallel loop will wrap the <code>OperationCanceledException</code> within an <code>AggregateException</code>. Also, if you pass the <code>CancellationToken</code> as part of a <code>ParallelOptions</code> instance, the <code>Parallel</code> class may make more intelligent decisions about how often to check the token. For these reasons, it’s best to pass the token as an option. If you pass the token as an option, you could <em>also</em> pass the token to the loop body, but you don’t want to <em>only</em> pass the token to the loop body.</p>&#13;
&#13;
<p>Parallel<a data-primary="PLINQ (Parallel LINQ)" data-secondary="cancellation with" data-type="indexterm" id="idm45458690925336"/><a data-primary="WithCancellation method" data-type="indexterm" id="idm45458690924328"/> LINQ (PLINQ) also has built-in support for cancellation, using the <code>WithCancellation</code> operator:</p>&#13;
&#13;
<pre data-code-language="csharp" data-type="programlisting"><code class="n">IEnumerable</code><code class="p">&lt;</code><code class="kt">int</code><code class="p">&gt;</code> <code class="n">MultiplyBy2</code><code class="p">(</code><code class="n">IEnumerable</code><code class="p">&lt;</code><code class="kt">int</code><code class="p">&gt;</code> <code class="n">values</code><code class="p">,</code>&#13;
    <code class="n">CancellationToken</code> <code class="n">cancellationToken</code><code class="p">)</code>&#13;
<code class="p">{</code>&#13;
  <code class="k">return</code> <code class="n">values</code><code class="p">.</code><code class="n">AsParallel</code><code class="p">()</code>&#13;
      <code class="p">.</code><code class="n">WithCancellation</code><code class="p">(</code><code class="n">cancellationToken</code><code class="p">)</code>&#13;
      <code class="p">.</code><code class="n">Select</code><code class="p">(</code><code class="n">item</code> <code class="p">=&gt;</code> <code class="n">item</code> <code class="p">*</code> <code class="m">2</code><code class="p">);</code>&#13;
<code class="p">}</code></pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="idm45458690922056">&#13;
<h2>Discussion</h2>&#13;
&#13;
<p>Supporting cancellation for parallel work is important for a good user experience. If your application is doing parallel work, it’ll use a large amount of CPU at least for a short time. High CPU usage is something that users notice, even if it doesn’t interfere with other applications on the same machine. So, I recommend supporting cancellation whenever you do parallel computation (or any other CPU-intensive work), even if the total time spent with high CPU usage isn’t extremely <a data-startref="ch10r5a" data-type="indexterm" id="idm45458690859240"/><a data-startref="ch10r5b" data-type="indexterm" id="idm45458690858536"/>long.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="See Also" data-type="sect2"><div class="sect2" id="idm45458690857480">&#13;
<h2>See Also</h2>&#13;
&#13;
<p><a data-type="xref" href="#recipe-cancellationtokensource">Recipe 10.1</a> covers issuing a cancellation request.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section class="recipe" data-pdf-bookmark="10.6 Canceling System.Reactive Code" data-type="sect1"><div class="sect1" id="recipe-cancel-rx">&#13;
<h1>10.6 Canceling System.Reactive Code</h1>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="idm45458690853464">&#13;
<h2>Problem</h2>&#13;
&#13;
<p>You <a data-primary="reactive programming" data-secondary="cancellation in" data-type="indexterm" id="ch10r6a"/><a data-primary="cancellation" data-secondary="in reactive code" data-secondary-sortas="reactive" data-type="indexterm" id="ch10r6b"/>have some reactive code, and you need it to be cancelable.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="idm45458690848984">&#13;
<h2>Solution</h2>&#13;
&#13;
<p>The<a data-primary="reactive programming" data-secondary="subscriptions" data-type="indexterm" id="ch10r6c"/><a data-primary="subscriptions" data-type="indexterm" id="ch10r6d"/> System.Reactive library has a notion of a <em>subscription</em> to an observable stream. Your code can dispose of the subscription to unsubscribe from the stream. In many cases, this is sufficient to logically cancel the stream. For example, the following code subscribes to mouse clicks when one button is pressed and unsubscribes (cancels the subscription) when another button is pressed:</p>&#13;
&#13;
<pre data-code-language="csharp" data-type="programlisting"><code class="k">private</code> <code class="n">IDisposable</code> <code class="n">_mouseMovesSubscription</code><code class="p">;</code>&#13;
&#13;
<code class="k">private</code> <code class="k">void</code> <code class="nf">StartButton_Click</code><code class="p">(</code><code class="kt">object</code> <code class="n">sender</code><code class="p">,</code> <code class="n">RoutedEventArgs</code> <code class="n">e</code><code class="p">)</code>&#13;
<code class="p">{</code>&#13;
  <code class="n">IObservable</code><code class="p">&lt;</code><code class="n">Point</code><code class="p">&gt;</code> <code class="n">mouseMoves</code> <code class="p">=</code> <code class="n">Observable</code>&#13;
      <code class="p">.</code><code class="n">FromEventPattern</code><code class="p">&lt;</code><code class="n">MouseEventHandler</code><code class="p">,</code> <code class="n">MouseEventArgs</code><code class="p">&gt;(</code>&#13;
          <code class="n">handler</code> <code class="p">=&gt;</code> <code class="p">(</code><code class="n">s</code><code class="p">,</code> <code class="n">a</code><code class="p">)</code> <code class="p">=&gt;</code> <code class="n">handler</code><code class="p">(</code><code class="n">s</code><code class="p">,</code> <code class="n">a</code><code class="p">),</code>&#13;
          <code class="n">handler</code> <code class="p">=&gt;</code> <code class="n">MouseMove</code> <code class="p">+=</code> <code class="n">handler</code><code class="p">,</code>&#13;
          <code class="n">handler</code> <code class="p">=&gt;</code> <code class="n">MouseMove</code> <code class="p">-=</code> <code class="n">handler</code><code class="p">)</code>&#13;
      <code class="p">.</code><code class="n">Select</code><code class="p">(</code><code class="n">x</code> <code class="p">=&gt;</code> <code class="n">x</code><code class="p">.</code><code class="n">EventArgs</code><code class="p">.</code><code class="n">GetPosition</code><code class="p">(</code><code class="k">this</code><code class="p">));</code>&#13;
  <code class="n">_mouseMovesSubscription</code> <code class="p">=</code> <code class="n">mouseMoves</code><code class="p">.</code><code class="n">Subscribe</code><code class="p">(</code><code class="k">value</code> <code class="p">=&gt;</code>&#13;
  <code class="p">{</code>&#13;
    <code class="n">MousePositionLabel</code><code class="p">.</code><code class="n">Content</code> <code class="p">=</code> <code class="s">"("</code> <code class="p">+</code> <code class="k">value</code><code class="p">.</code><code class="n">X</code> <code class="p">+</code> <code class="s">", "</code> <code class="p">+</code> <code class="k">value</code><code class="p">.</code><code class="n">Y</code> <code class="p">+</code> <code class="s">")"</code><code class="p">;</code>&#13;
  <code class="p">});</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="k">private</code> <code class="k">void</code> <code class="nf">CancelButton_Click</code><code class="p">(</code><code class="kt">object</code> <code class="n">sender</code><code class="p">,</code> <code class="n">RoutedEventArgs</code> <code class="n">e</code><code class="p">)</code>&#13;
<code class="p">{</code>&#13;
  <code class="k">if</code> <code class="p">(</code><code class="n">_mouseMovesSubscription</code> <code class="p">!=</code> <code class="k">null</code><code class="p">)</code>&#13;
    <code class="n">_mouseMovesSubscription</code><code class="p">.</code><code class="n">Dispose</code><code class="p">();</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>It’s quite convenient to make System.Reactive work with the <code>CancellationTokenSource</code>/<code>CancellationToken</code> system that everything else uses for cancellation. The rest of this recipe covers ways that System.Reactive observables interact with <code>CancellationToken</code>.</p>&#13;
&#13;
<p>The <a data-primary="ToTask method" data-type="indexterm" id="idm45458690840648"/>first major use case is when the observable code is wrapped in asynchronous code. The basic approach was covered in <a data-type="xref" href="ch08.html#recipe-async-interop-rx">Recipe 8.5</a>, and now you want to add <code>CancellationToken</code> support. In general, the easiest way to do this is to perform all operations using reactive operators and then call <code>ToTask</code> to convert the last resulting element to an awaitable task. The following code shows how to asynchronously take the last element in a sequence:</p>&#13;
&#13;
<pre data-code-language="csharp" data-type="programlisting"><code class="n">CancellationToken</code> <code class="n">cancellationToken</code> <code class="p">=</code> <code class="p">...</code>&#13;
<code class="n">IObservable</code><code class="p">&lt;</code><code class="kt">int</code><code class="p">&gt;</code> <code class="n">observable</code> <code class="p">=</code> <code class="p">...</code>&#13;
<code class="kt">int</code> <code class="n">lastElement</code> <code class="p">=</code> <code class="k">await</code> <code class="n">observable</code><code class="p">.</code><code class="n">TakeLast</code><code class="p">(</code><code class="m">1</code><code class="p">).</code><code class="n">ToTask</code><code class="p">(</code><code class="n">cancellationToken</code><code class="p">);</code>&#13;
<code class="c1">// or: int lastElement = await observable.ToTask(cancellationToken);</code></pre>&#13;
&#13;
<p>Taking the first element is very similar; just modify the observable before calling <code>ToTask</code>:</p>&#13;
&#13;
<pre data-code-language="csharp" data-type="programlisting"><code class="n">CancellationToken</code> <code class="n">cancellationToken</code> <code class="p">=</code> <code class="p">...</code>&#13;
<code class="n">IObservable</code><code class="p">&lt;</code><code class="kt">int</code><code class="p">&gt;</code> <code class="n">observable</code> <code class="p">=</code> <code class="p">...</code>&#13;
<code class="kt">int</code> <code class="n">firstElement</code> <code class="p">=</code> <code class="k">await</code> <code class="n">observable</code><code class="p">.</code><code class="n">Take</code><code class="p">(</code><code class="m">1</code><code class="p">).</code><code class="n">ToTask</code><code class="p">(</code><code class="n">cancellationToken</code><code class="p">);</code></pre>&#13;
&#13;
<p>Asynchronously converting the entire observable sequence to a task is likewise similar:</p>&#13;
&#13;
<pre data-code-language="csharp" data-type="programlisting"><code class="n">CancellationToken</code> <code class="n">cancellationToken</code> <code class="p">=</code> <code class="p">...</code>&#13;
<code class="n">IObservable</code><code class="p">&lt;</code><code class="kt">int</code><code class="p">&gt;</code> <code class="n">observable</code> <code class="p">=</code> <code class="p">...</code>&#13;
<code class="n">IList</code><code class="p">&lt;</code><code class="kt">int</code><code class="p">&gt;</code> <code class="n">allElements</code> <code class="p">=</code> <code class="k">await</code> <code class="n">observable</code><code class="p">.</code><code class="n">ToList</code><code class="p">().</code><code class="n">ToTask</code><code class="p">(</code><code class="n">cancellationToken</code><code class="p">);</code></pre>&#13;
&#13;
<p>Finally, <a data-primary="CancellationToken type" data-type="indexterm" id="idm45458690530792"/>let’s consider the reverse situation. We’ve looked at several ways to handle situations where System.Reactive code responds to <code>CancellationToken</code>—that is, where a <code>CancellationTokenSource</code> cancel request is translated into a disposal of that subscription. It’s also possible to go the other way: issuing a cancellation request as a response to disposal.</p>&#13;
&#13;
<p>The<a data-primary="FromAsync method" data-type="indexterm" id="idm45458690498600"/><a data-primary="StartAsync method" data-type="indexterm" id="idm45458690497656"/><a data-primary="SelectMany method" data-type="indexterm" id="idm45458690496984"/> <code>FromAsync</code>, <code>StartAsync</code>, and <code>SelectMany</code> operators all support cancellation, as seen in <a data-type="xref" href="ch08.html#recipe-rx-interop-async">Recipe 8.6</a>. These operators cover the vast majority of use cases. Rx <a data-primary="CancellationDisposable type" data-type="indexterm" id="idm45458690494008"/>also provides a <code>CancellationDisposable</code> type that cancels a <code>CancellationToken</code> when disposed. You can use <code>CancellationDisposable</code> directly, like this:</p>&#13;
&#13;
<pre data-code-language="csharp" data-type="programlisting"><code class="k">using</code> <code class="p">(</code><code class="kt">var</code> <code class="n">cancellation</code> <code class="p">=</code> <code class="k">new</code> <code class="n">CancellationDisposable</code><code class="p">())</code>&#13;
<code class="p">{</code>&#13;
  <code class="n">CancellationToken</code> <code class="n">token</code> <code class="p">=</code> <code class="n">cancellation</code><code class="p">.</code><code class="n">Token</code><code class="p">;</code>&#13;
  <code class="c1">// Pass the token to methods that respond to it.</code>&#13;
<code class="p">}</code>&#13;
<code class="c1">// At this point, the token is canceled.</code></pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="idm45458690449912">&#13;
<h2>Discussion</h2>&#13;
&#13;
<p>System.Reactive (Rx) has its own notion of cancellation: disposing subscriptions. This recipe looked at several ways to make Rx play nicely with the universal cancellation framework introduced in .NET 4.0. As long as you are in the Rx world portion of your code, use the Rx subscription/disposal system; it’s cleanest if you only introduce <code>CancellationToken</code> support at the <a data-startref="ch10r6a" data-type="indexterm" id="idm45458690445752"/><a data-startref="ch10r6b" data-type="indexterm" id="idm45458690445016"/><a data-startref="ch10r6c" data-type="indexterm" id="idm45458690444344"/><a data-startref="ch10r6d" data-type="indexterm" id="idm45458690443672"/>boundaries.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="See Also" data-type="sect2"><div class="sect2" id="idm45458690442616">&#13;
<h2>See Also</h2>&#13;
&#13;
<p><a data-type="xref" href="ch08.html#recipe-async-interop-rx">Recipe 8.5</a> covers asynchronous wrappers around Rx code (without cancellation <span class="keep-together">support).</span></p>&#13;
&#13;
<p><a data-type="xref" href="ch08.html#recipe-rx-interop-async">Recipe 8.6</a> covers Rx wrappers around asynchronous code (with cancellation support).</p>&#13;
&#13;
<p><a data-type="xref" href="#recipe-cancellationtokensource">Recipe 10.1</a> covers issuing a cancellation request.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section class="recipe" data-pdf-bookmark="10.7 Canceling Dataflow Meshes" data-type="sect1"><div class="sect1" id="recipe-cancel-dataflow">&#13;
<h1>10.7 Canceling Dataflow Meshes</h1>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="idm45458690435928">&#13;
<h2>Problem</h2>&#13;
&#13;
<p>You <a data-primary="dataflow" data-secondary="cancellation in" data-type="indexterm" id="ch10r7a"/><a data-primary="cancellation" data-secondary="in dataflow code" data-secondary-sortas="dataflow" data-type="indexterm" id="ch10r7b"/>are using dataflow meshes and need to support cancellation.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="idm45458690431448">&#13;
<h2>Solution</h2>&#13;
&#13;
<p>The <a data-primary="CancellationToken type" data-type="indexterm" id="idm45458690430152"/><a data-primary="DataflowBlockOptions type" data-type="indexterm" id="idm45458690429416"/>best way to support cancellation in your code is to pass the <code>CancellationToken</code> through to a cancelable API. Each block in a dataflow mesh supports cancellation as a part of its <code>DataflowBlockOptions</code>. If you want to extend your custom dataflow block with cancellation support, set the <code>CancellationToken</code> property on the block options:</p>&#13;
&#13;
<pre data-code-language="csharp" data-type="programlisting"><code class="n">IPropagatorBlock</code><code class="p">&lt;</code><code class="kt">int</code><code class="p">,</code> <code class="kt">int</code><code class="p">&gt;</code> <code class="n">CreateMyCustomBlock</code><code class="p">(</code>&#13;
    <code class="n">CancellationToken</code> <code class="n">cancellationToken</code><code class="p">)</code>&#13;
<code class="p">{</code>&#13;
  <code class="kt">var</code> <code class="n">blockOptions</code> <code class="p">=</code> <code class="k">new</code> <code class="n">ExecutionDataflowBlockOptions</code>&#13;
  <code class="p">{</code>&#13;
    <code class="n">CancellationToken</code> <code class="p">=</code> <code class="n">cancellationToken</code>&#13;
  <code class="p">};</code>&#13;
  <code class="kt">var</code> <code class="n">multiplyBlock</code> <code class="p">=</code> <code class="k">new</code> <code class="n">TransformBlock</code><code class="p">&lt;</code><code class="kt">int</code><code class="p">,</code> <code class="kt">int</code><code class="p">&gt;(</code><code class="n">item</code> <code class="p">=&gt;</code> <code class="n">item</code> <code class="p">*</code> <code class="m">2</code><code class="p">,</code>&#13;
      <code class="n">blockOptions</code><code class="p">);</code>&#13;
  <code class="kt">var</code> <code class="n">addBlock</code> <code class="p">=</code> <code class="k">new</code> <code class="n">TransformBlock</code><code class="p">&lt;</code><code class="kt">int</code><code class="p">,</code> <code class="kt">int</code><code class="p">&gt;(</code><code class="n">item</code> <code class="p">=&gt;</code> <code class="n">item</code> <code class="p">+</code> <code class="m">2</code><code class="p">,</code>&#13;
      <code class="n">blockOptions</code><code class="p">);</code>&#13;
  <code class="kt">var</code> <code class="n">divideBlock</code> <code class="p">=</code> <code class="k">new</code> <code class="n">TransformBlock</code><code class="p">&lt;</code><code class="kt">int</code><code class="p">,</code> <code class="kt">int</code><code class="p">&gt;(</code><code class="n">item</code> <code class="p">=&gt;</code> <code class="n">item</code> <code class="p">/</code> <code class="m">2</code><code class="p">,</code>&#13;
      <code class="n">blockOptions</code><code class="p">);</code>&#13;
&#13;
  <code class="kt">var</code> <code class="n">flowCompletion</code> <code class="p">=</code> <code class="k">new</code> <code class="n">DataflowLinkOptions</code>&#13;
  <code class="p">{</code>&#13;
    <code class="n">PropagateCompletion</code> <code class="p">=</code> <code class="k">true</code>&#13;
  <code class="p">};</code>&#13;
  <code class="n">multiplyBlock</code><code class="p">.</code><code class="n">LinkTo</code><code class="p">(</code><code class="n">addBlock</code><code class="p">,</code> <code class="n">flowCompletion</code><code class="p">);</code>&#13;
  <code class="n">addBlock</code><code class="p">.</code><code class="n">LinkTo</code><code class="p">(</code><code class="n">divideBlock</code><code class="p">,</code> <code class="n">flowCompletion</code><code class="p">);</code>&#13;
&#13;
  <code class="k">return</code> <code class="n">DataflowBlock</code><code class="p">.</code><code class="n">Encapsulate</code><code class="p">(</code><code class="n">multiplyBlock</code><code class="p">,</code> <code class="n">divideBlock</code><code class="p">);</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>In this example, I applied the <code>CancellationToken</code> to every block in the mesh, which isn’t strictly necessary. Since I’m also propagating completion along the links, I could apply it to the first block and allow it to propagate through. Cancellations are considered a special form of error, so the blocks further down the pipeline would be completed with an error as that error propagates through. That said, if I’m canceling a mesh, I may as well cancel every block simultaneously, so in this case I usually set the <code>CancellationToken</code> option on every block.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="idm45458690424088">&#13;
<h2>Discussion</h2>&#13;
&#13;
<p>In dataflow meshes, cancellation is <em>not</em> a form of flush. When a block is canceled, it drops all its input and refuses to take any new items. So if you cancel a block while it’s running, you <em>will</em> lose <a data-startref="ch10r7a" data-type="indexterm" id="idm45458690290632"/><a data-startref="ch10r7b" data-type="indexterm" id="idm45458690290008"/>data.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="See Also" data-type="sect2"><div class="sect2" id="idm45458690288952">&#13;
<h2>See Also</h2>&#13;
&#13;
<p><a data-type="xref" href="#recipe-cancellationtokensource">Recipe 10.1</a> covers issuing a cancellation request.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section class="recipe" data-pdf-bookmark="10.8 Injecting Cancellation Requests" data-type="sect1"><div class="sect1" id="recipe-linked-cancellationtokens">&#13;
<h1>10.8 Injecting Cancellation Requests</h1>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="idm45458690284920">&#13;
<h2>Problem</h2>&#13;
&#13;
<p>You <a data-primary="cancellation" data-secondary="requests for, injecting" data-type="indexterm" id="ch10r8a"/>have a layer of your code that needs to respond to cancellation requests and also issue its own cancellation requests to the next layer.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="idm45458690281768">&#13;
<h2>Solution</h2>&#13;
&#13;
<p>The<a data-primary="linked cancellation tokens" data-type="indexterm" id="ch10r8b"/> .NET 4.0 cancellation system has built-in support for this scenario, known as <em>linked cancellation tokens</em>. A cancellation token source can be created linked to one (or many) existing tokens. When you create a linked cancellation token source, the resulting token is canceled when any of the existing tokens is canceled or when the linked source is explicitly canceled.</p>&#13;
&#13;
<p>The <a data-primary="CreateLinkedTokenSource method" data-type="indexterm" id="idm45458690277992"/>following code performs an asynchronous HTTP request. The token passed into the <code>GetWithTimeoutAsync</code> method represents cancellation requested by the end user, and the <code>GetWithTimeoutAsync</code> method also applies a timeout to the request:</p>&#13;
&#13;
<pre data-code-language="csharp" data-type="programlisting"><code class="k">async</code> <code class="n">Task</code><code class="p">&lt;</code><code class="n">HttpResponseMessage</code><code class="p">&gt;</code> <code class="n">GetWithTimeoutAsync</code><code class="p">(</code><code class="n">HttpClient</code> <code class="n">client</code><code class="p">,</code>&#13;
    <code class="kt">string</code> <code class="n">url</code><code class="p">,</code> <code class="n">CancellationToken</code> <code class="n">cancellationToken</code><code class="p">)</code>&#13;
<code class="p">{</code>&#13;
  <code class="k">using</code> <code class="nn">CancellationTokenSource</code> <code class="n">cts</code> <code class="p">=</code> <code class="n">CancellationTokenSource</code>&#13;
      <code class="p">.</code><code class="n">CreateLinkedTokenSource</code><code class="p">(</code><code class="n">cancellationToken</code><code class="p">);</code>&#13;
  <code class="n">cts</code><code class="p">.</code><code class="n">CancelAfter</code><code class="p">(</code><code class="n">TimeSpan</code><code class="p">.</code><code class="n">FromSeconds</code><code class="p">(</code><code class="m">2</code><code class="p">));</code>&#13;
  <code class="n">CancellationToken</code> <code class="n">combinedToken</code> <code class="p">=</code> <code class="n">cts</code><code class="p">.</code><code class="n">Token</code><code class="p">;</code>&#13;
&#13;
  <code class="k">return</code> <code class="k">await</code> <code class="n">client</code><code class="p">.</code><code class="n">GetAsync</code><code class="p">(</code><code class="n">url</code><code class="p">,</code> <code class="n">combinedToken</code><code class="p">);</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>The resulting <code>combinedToken</code> is canceled when either the user cancels the existing <code>cancellationToken</code> or when the linked source is canceled by <code>CancelAfter</code>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="idm45458690222264">&#13;
<h2>Discussion</h2>&#13;
&#13;
<p>Although the preceding example only used a single <code>CancellationToken</code> source, the <code>CreateLinkedTokenSource</code> method can take any number of cancellation tokens as parameters. This enables you to create a single combined token from which you can implement your logical cancellation. For <a data-primary="ASP.NET" data-secondary="cancellation tokens" data-type="indexterm" id="idm45458690219816"/>example, ASP.NET provides a cancellation token that represents the user disconnecting (<code>HttpContext.RequestAborted</code>); handler code may create a linked token that responds to either a user disconnecting or its own cancellation reason, such as a timeout.</p>&#13;
&#13;
<p>Keep in mind the lifetime of the linked cancellation token source. The previous example is the usual use case, where one or more cancellation tokens are passed into the method, which then links them together and passes them on as a combined token. Note also that the example code uses the <code>using</code> statement, which ensures that the linked cancellation token source is disposed of when the operation is complete (and the combined token is no longer being used). Consider what would happen if the code didn’t dispose of the linked cancellation token source: it’s possible that the <code>GetWithTimeoutAsync</code> method may be called multiple times with the same (long-lived) existing token, in which case the code would link a new token source each time the method is invoked. Even after the HTTP requests complete (and nothing is using the combined token), that linked source is still attached to the existing token. To prevent memory leaks like this, dispose of the linked cancellation token source when you no longer need the combined <a data-startref="ch10r8a" data-type="indexterm" id="idm45458690144600"/><a data-startref="ch10r8b" data-type="indexterm" id="idm45458690143896"/>token.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="See Also" data-type="sect2"><div class="sect2" id="idm45458690142840">&#13;
<h2>See Also</h2>&#13;
&#13;
<p><a data-type="xref" href="#recipe-cancellationtokensource">Recipe 10.1</a> covers issuing cancellation requests in general.</p>&#13;
&#13;
<p><a data-type="xref" href="#recipe-cancel-timeout">Recipe 10.3</a> covers using cancellation as a timeout.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section class="recipe" data-pdf-bookmark="10.9 Interop with Other Cancellation Systems" data-type="sect1"><div class="sect1" id="recipe-cancellationtoken-callbacks">&#13;
<h1>10.9 Interop with Other Cancellation Systems</h1>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="idm45458690137704">&#13;
<h2>Problem</h2>&#13;
&#13;
<p>You <a data-primary="cancellation" data-secondary="interop with other systems" data-type="indexterm" id="ch10r9a"/>have some external or legacy code with its own notion of cancellation, and you want to control it using a standard <code>CancellationToken</code>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="idm45458690134232">&#13;
<h2>Solution</h2>&#13;
&#13;
<p>The<a data-primary="callbacks" data-secondary="cancellation using" data-type="indexterm" id="idm45458690132632"/><a data-primary="CancellationToken.Register method" data-type="indexterm" id="ch10r9b"/> <code>CancellationToken</code> has two primary ways to respond to a cancellation request: polling (covered in <a data-type="xref" href="#recipe-cancellationtoken">Recipe 10.2</a>) and callbacks (the subject of this recipe). Polling is normally used for CPU-bound code, such as data processing loops; callbacks are normally used in all other scenarios. You can register a callback for a token using the <code>CancellationToken.Register</code> method.</p>&#13;
&#13;
<p>For example, let’s say you’re wrapping the <code>System.Net.NetworkInformation.Ping</code> type and you want to be able to cancel a ping. The <code>Ping</code> class already has a <code>Task</code>-based API but does not support <code>CancellationToken</code>. Instead, the <code>Ping</code> type has its own <code>SendAsyncCancel</code> method that you can use to cancel a ping. To do this, register a callback that invokes that method:</p>&#13;
<pre data-code-language="csharp" data-type="programlisting"><code class="k">async</code> <code class="n">Task</code><code class="p">&lt;</code><code class="n">PingReply</code><code class="p">&gt;</code> <code class="n">PingAsync</code><code class="p">(</code><code class="kt">string</code> <code class="n">hostNameOrAddress</code><code class="p">,</code>&#13;
    <code class="n">CancellationToken</code> <code class="n">cancellationToken</code><code class="p">)</code>&#13;
<code class="p">{</code>&#13;
  <code class="k">using</code> <code class="k">var</code> <code class="n">ping</code> <code class="p">=</code> <code class="k">new</code> <code class="n">Ping</code><code class="p">();</code>&#13;
  <code class="n">Task</code><code class="p">&lt;</code><code class="n">PingReply</code><code class="p">&gt;</code> <code class="n">task</code> <code class="p">=</code> <code class="n">ping</code><code class="p">.</code><code class="n">SendPingAsync</code><code class="p">(</code><code class="n">hostNameOrAddress</code><code class="p">);</code>&#13;
  <code class="k">using</code> <code class="nn">CancellationTokenRegistration</code> <code class="n">_</code> <code class="p">=</code> <code class="n">cancellationToken</code>&#13;
      <code class="p">.</code><code class="n">Register</code><code class="p">(()</code> <code class="p">=&gt;</code> <code class="n">ping</code><code class="p">.</code><code class="n">SendAsyncCancel</code><code class="p">());</code>&#13;
  <code class="k">return</code> <code class="k">await</code> <code class="n">task</code><code class="p">;</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Now, when a cancellation is requested, the <code>CancellationToken</code> will invoke the <code>SendAsyncCancel</code> method for you, canceling the <code>SendPingAsync</code> method.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="idm45458690064968">&#13;
<h2>Discussion</h2>&#13;
&#13;
<p>The <code>CancellationToken.Register</code> method can be used to interoperate with any kind of alternative cancellation system. But do bear in mind that when a method takes a <code>CancellationToken</code>, a cancellation request should only cancel that one operation. Some alternative cancellation systems implement a cancel by closing some resource, which can cancel multiple operations; this kind of cancellation system doesn’t map well to a <code>CancellationToken</code>. If you do decide to wrap that kind of cancellation in a <code>CancellationToken</code>, you should document its unusual cancellation semantics.</p>&#13;
&#13;
<p>Keep in mind the lifetime of the callback registration. The <code>Register</code> method returns a disposable that should be disposed of when that callback is no longer needed. The preceding example code uses a <code>using</code> statement to clean up when the asynchronous operation completes. If the code didn’t have that <code>using</code> statement, then each time the code is called with the same (long-lived) <code>CancellationToken</code>, it would add another callback (which in turn keeps the <code>Ping</code> object alive). To avoid memory and resource leaks, dispose of the callback registration when you no longer need the <a data-startref="ch10r9a" data-type="indexterm" id="idm45458690058120"/><a data-startref="ch10r9b" data-type="indexterm" id="idm45458690057416"/>callback.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="See Also" data-type="sect2"><div class="sect2" id="idm45458690056488">&#13;
<h2>See Also</h2>&#13;
&#13;
<p><a data-type="xref" href="#recipe-cancellationtoken">Recipe 10.2</a> covers responding to a cancellation token by polling rather than callbacks.</p>&#13;
&#13;
<p><a data-type="xref" href="#recipe-cancellationtokensource">Recipe 10.1</a> covers issuing cancellation requests in general.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section></body></html>