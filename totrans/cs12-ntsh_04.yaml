- en: Chapter 4\. Advanced C#
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we cover advanced C# topics that build on concepts explored
    in Chapters [2](ch02.html#chash_language_basics) and [3](ch03.html#creating_types_in_chash).
    You should read the first four sections sequentially; you can read the remaining
    sections in any order.
  prefs: []
  type: TYPE_NORMAL
- en: Delegates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A delegate is an object that knows how to call a method.
  prefs: []
  type: TYPE_NORMAL
- en: 'A *delegate type* defines the kind of method that *delegate instances* can
    call. Specifically, it defines the method’s *return type* and its *parameter types*.
    The following defines a delegate type called `Transformer`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '`Transformer` is compatible with any method with an `int` return type and a
    single `int` parameter, such as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, more tersely:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Assigning a method to a delegate variable creates a delegate *instance*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'You can invoke a delegate instance in the same way as a method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s a complete example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'A delegate instance literally acts as a delegate for the caller: the caller
    invokes the delegate, and then the delegate calls the target method. This indirection
    decouples the caller from the target method.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'is shorthand for:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Technically, we are specifying a *method group* when we refer to `Square` without
    brackets or arguments. If the method is overloaded, C# will pick the correct overload
    based on the signature of the delegate to which it’s being assigned.
  prefs: []
  type: TYPE_NORMAL
- en: The expression
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: is shorthand for
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: A delegate is similar to a *callback*, a general term that captures constructs
    such as C function pointers.
  prefs: []
  type: TYPE_NORMAL
- en: Writing Plug-in Methods with Delegates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A delegate variable is assigned a method at runtime. This is useful for writing
    plug-in methods. In this example, we have a utility method named `Transform` that
    applies a transform to each element in an integer array. The `Transform` method
    has a delegate parameter, which you can use for specifying a plug-in transform:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We can change the transformation just by changing `Square` to `Cube` in the
    second line of code.
  prefs: []
  type: TYPE_NORMAL
- en: Our `Transform` method is a *higher-order function* because it’s a function
    that takes a function as an argument. (A method that *returns* a delegate would
    also be a higher-order function.)
  prefs: []
  type: TYPE_NORMAL
- en: Instance and Static Method Targets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A delegate’s target method can be a local, static, or instance method. The
    following illustrates a static target method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The following illustrates an instance target method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'When an *instance* method is assigned to a delegate object, the latter maintains
    a reference not only to the method but also to the *instance* to which the method
    belongs. The `System.Delegate` class’s `Target` property represents this instance
    (and will be null for a delegate referencing a static method). Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Because the instance is stored in the delegate’s `Target` property, its lifetime
    is extended to (at least as long as) the delegate’s lifetime.
  prefs: []
  type: TYPE_NORMAL
- en: Multicast Delegates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'All delegate instances have *multicast* capability. This means that a delegate
    instance can reference not just a single target method but also a list of target
    methods. The `+` and `+=` operators combine delegate instances:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The last line is functionally the same as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Invoking `d` will now call both `SomeMethod1` and `SomeMethod2`. Delegates are
    invoked in the order in which they are added.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `-` and `-=` operators remove the right delegate operand from the left
    delegate operand:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Invoking `d` will now cause only `SomeMethod2` to be invoked.
  prefs: []
  type: TYPE_NORMAL
- en: 'Calling `+` or `+=` on a delegate variable with a `null` value works, and it
    is equivalent to assigning the variable to a new value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Similarly, calling `-=` on a delegate variable with a single matching target
    is equivalent to assigning `null` to that variable.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Delegates are *immutable*, so when you call `+=` or `-=`, you’re in fact creating
    a *new* delegate instance and assigning it to the existing variable.
  prefs: []
  type: TYPE_NORMAL
- en: If a multicast delegate has a nonvoid return type, the caller receives the return
    value from the last method to be invoked. The preceding methods are still called,
    but their return values are discarded. For most scenarios in which multicast delegates
    are used, they have `void` return types, so this subtlety does not arise.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: All delegate types implicitly derive from `System.MulticastDelegate`, which
    inherits from `System.Delegate`. C# compiles `+`, `-`, `+=`, and `-=` operations
    made on a delegate to the static `Combine` and `Remove` methods of the `System.Delegate`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: Multicast delegate example
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Suppose that you wrote a method that took a long time to execute. That method
    could regularly report progress to its caller by invoking a delegate. In this
    example, the `HardWork` method has a `ProgressReporter` delegate parameter, which
    it invokes to indicate progress:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'To monitor progress, we can create a multicast delegate instance `p`, such
    that progress is monitored by two independent methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Generic Delegate Types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A delegate type can contain generic type parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'With this definition, we can write a generalized `Transform` utility method
    that works on any type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The Func and Action Delegates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With generic delegates, it becomes possible to write a small set of delegate
    types that are so general they can work for methods of any return type and any
    (reasonable) number of arguments. These delegates are the `Func` and `Action`
    delegates, defined in the `System` namespace (the `in` and `out` annotations indicate
    *variance*, which we cover in the context of delegates shortly):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'These delegates are extremely general. The `Transformer` delegate in our previous
    example can be replaced with a `Func` delegate that takes a single argument of
    type `T` and returns a same-typed value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The only practical scenarios not covered by these delegates are `ref`/`out`
    and pointer parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: When C# was first introduced, the `Func` and `Action` delegates did not exist
    (because generics did not exist). It’s for this historical reason that much of
    .NET uses custom delegate types rather than `Func` and `Action`.
  prefs: []
  type: TYPE_NORMAL
- en: Delegates Versus Interfaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A problem that you can solve with a delegate can also be solved with an interface.
    For instance, we can rewrite our original example with an interface called `ITransformer`
    instead of a delegate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'A delegate design might be a better choice than an interface design if one
    or more of these conditions are true:'
  prefs: []
  type: TYPE_NORMAL
- en: The interface defines only a single method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multicast capability is needed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The subscriber needs to implement the interface multiple times.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the `ITransformer` example, we don’t need to multicast. However, the interface
    defines only a single method. Furthermore, our subscriber might need to implement
    `ITransformer` multiple times, to support different transforms, such as square
    or cube. With interfaces, we’re forced into writing a separate type per transform
    because a class can implement `ITransformer` only once. This is quite cumbersome:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Delegate Compatibility
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Type compatibility
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Delegate types are all incompatible with one another, even if their signatures
    are the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The following, however, is permitted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Delegate instances are considered equal if they have the same method targets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Multicast delegates are considered equal if they reference the same methods
    *in the same order*.
  prefs: []
  type: TYPE_NORMAL
- en: Parameter compatibility
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When you call a method, you can supply arguments that have more specific types
    than the parameters of that method. This is ordinary polymorphic behavior. For
    the same reason, a delegate can have more specific parameter types than its method
    target. This is called *contravariance*. Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: (As with type parameter variance, delegates are variant only for *reference
    conversions*.)
  prefs: []
  type: TYPE_NORMAL
- en: A delegate merely calls a method on someone else’s behalf. In this case, the
    `StringAction` is invoked with an argument of type `string`. When the argument
    is then relayed to the target method, the argument is implicitly upcast to an
    `object`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The standard event pattern is designed to help you utilize contravariance through
    its use of the common `EventArgs` base class. For example, you can have a single
    method invoked by two different delegates, one passing a `MouseEventArgs` and
    the other passing a `KeyEventArgs`.
  prefs: []
  type: TYPE_NORMAL
- en: Return type compatibility
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you call a method, you might get back a type that is more specific than
    what you asked for. This is ordinary polymorphic behavior. For the same reason,
    a delegate’s target method might return a more specific type than described by
    the delegate. This is called *covariance*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '`ObjectRetriever` expects to get back an `object`, but an `object` *subclass*
    will also do: delegate return types are *covariant*.'
  prefs: []
  type: TYPE_NORMAL
- en: Generic delegate type parameter variance
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In [Chapter 3](ch03.html#creating_types_in_chash), we saw how generic interfaces
    support covariant and contravariant type parameters. The same capability exists
    for delegates, too.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you’re defining a generic delegate type, it’s good practice to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Mark a type parameter used only on the return value as covariant (`out`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mark any type parameters used only on parameters as contravariant (`in`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Doing so allows conversions to work naturally by respecting inheritance relationships
    between types.
  prefs: []
  type: TYPE_NORMAL
- en: The following delegate (defined in the `System` namespace) has a covariant `TResult:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'This allows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The following delegate (defined in the `System` namespace) has a contravariant
    `T:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'This allows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When using delegates, two emergent roles commonly appear: *broadcaster* and
    *subscriber*.'
  prefs: []
  type: TYPE_NORMAL
- en: The *broadcaster* is a type that contains a delegate field. The broadcaster
    decides when to broadcast, by invoking the delegate.
  prefs: []
  type: TYPE_NORMAL
- en: The *subscribers* are the method target recipients. A subscriber decides when
    to start and stop listening by calling `+=` and `-=` on the broadcaster’s delegate.
    A subscriber does not know about, or interfere with, other subscribers.
  prefs: []
  type: TYPE_NORMAL
- en: Events are a language feature that formalizes this pattern. An `event` is a
    construct that exposes just the subset of delegate features required for the broadcaster/subscriber
    model. The main purpose of events is to *prevent subscribers from interfering
    with one another*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The easiest way to declare an event is to put the `event` keyword in front
    of a delegate member:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Code within the `Broadcaster` type has full access to `PriceChanged` and can
    treat it as a delegate. Code outside of `Broadcaster` can perform only `+=` and
    `-=` operations on the `PriceChanged` event.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following example. The `Stock` class fires its `PriceChanged`
    event every time the `Price` of the `Stock` changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'If we remove the `event` keyword from our example so that `PriceChanged` becomes
    an ordinary delegate field, our example would give the same results. However,
    `Stock` would be less robust insomuch as subscribers could do the following things
    to interfere with one another:'
  prefs: []
  type: TYPE_NORMAL
- en: Replace other subscribers by reassigning `PriceChanged` (instead of using the
    `+=` operator).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Clear all subscribers (by setting `PriceChanged` to `null`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Broadcast to other subscribers by invoking the delegate.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Standard Event Pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In almost all cases for which events are defined in the .NET libraries, their
    definition adheres to a standard pattern designed to provide consistency across
    library and user code. At the core of the standard event pattern is `System.EventArgs`,
    a predefined .NET class with no members (other than the static `Empty` field).
    `EventArgs` is a base class for conveying information for an event. In our `Stock`
    example, we would subclass `EventArgs` to convey the old and new prices when a
    `PriceChanged` event is fired:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: For reusability, the `EventArgs` subclass is named according to the information
    it contains (rather than the event for which it will be used). It typically exposes
    data as properties or as read-only fields.
  prefs: []
  type: TYPE_NORMAL
- en: 'With an `EventArgs` subclass in place, the next step is to choose or define
    a delegate for the event. There are three rules:'
  prefs: []
  type: TYPE_NORMAL
- en: It must have a `void` return type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It must accept two arguments: the first of type `object` and the second a subclass
    of `EventArgs`. The first argument indicates the event broadcaster, and the second
    argument contains the extra information to convey.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Its name must end with `EventHandler`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '.NET defines a generic delegate called `System.EventHandler<>` to help with
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Before generics existed in the language (prior to C# 2.0), we would have had
    to instead write a custom delegate as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: For historical reasons, most events within the .NET libraries use delegates
    defined in this way.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to define an event of the chosen delegate type. Here, we use
    the generic `EventHandler` delegate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the pattern requires that you write a protected virtual method that
    fires the event. The name must match the name of the event, prefixed with the
    word “On,” and then accept a single `EventArgs` argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'To work robustly in multithreaded scenarios ([Chapter 14](ch14.html#concurrency_and_asynchron)),
    you need to assign the delegate to a temporary variable before testing and invoking
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'We can achieve the same functionality without the `temp` variable with the
    null-conditional operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Being both thread-safe and succinct, this is the best general way to invoke
    events.
  prefs: []
  type: TYPE_NORMAL
- en: This provides a central point from which subclasses can invoke or override the
    event (assuming the class is not sealed).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the complete example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The predefined nongeneric `EventHandler` delegate can be used when an event
    doesn’t carry extra information. In this example, we rewrite `Stock` such that
    the `PriceChanged` event is fired after the price changes, and no information
    about the event is necessary, other than it happened. We also make use of the
    `Even⁠t​Args.Empty` property in order to avoid unnecessarily instantiating an
    instance of `EventArgs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Event Accessors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An event’s *accessors* are the implementations of its `+=` and `-=` functions.
    By default, accessors are implemented implicitly by the compiler. Consider this
    event declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'The compiler converts this to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A private delegate field
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A public pair of event accessor functions (`add_PriceChanged` and `remove_Pri⁠ce​Changed`)
    whose implementations forward the `+=` and `-=` operations to the private delegate
    field
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can take over this process by defining *explicit* event accessors. Here’s
    a manual implementation of the `PriceChanged` event from our previous example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: This example is functionally identical to C#’s default accessor implementation
    (except that C# also ensures thread safety around updating the delegate via a
    lock-free compare-and-swap algorithm; see [*http://albahari.com/threading*](http://albahari.com/threading)).
    By defining event accessors ourselves, we instruct C# not to generate default
    field and accessor logic.
  prefs: []
  type: TYPE_NORMAL
- en: 'With explicit event accessors, you can apply more complex strategies to the
    storage and access of the underlying delegate. There are three scenarios for which
    this is useful:'
  prefs: []
  type: TYPE_NORMAL
- en: When the event accessors are merely relays for another class that is broadcasting
    the event.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the class exposes many events, for which most of the time very few subscribers
    exist, such as a Windows control. In such cases, it is better to store the subscriber’s
    delegate instances in a dictionary because a dictionary will contain less storage
    overhead than dozens of null delegate field references.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When explicitly implementing an interface that declares an event.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is an example that illustrates the last point:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The `add` and `remove` parts of an event are compiled to `add_*XXX*` and `remove_*XXX*`
    methods.
  prefs: []
  type: TYPE_NORMAL
- en: Event Modifiers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Like methods, events can be virtual, overridden, abstract, or sealed. Events
    can also be static:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Lambda Expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A *lambda expression* is an unnamed method written in place of a delegate instance.
    The compiler immediately converts the lambda expression to either of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A delegate instance.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An *expression tree*, of type `Expression<TDelegate>`, representing the code
    inside the lambda expression in a traversable object model. This allows the lambda
    expression to be interpreted later at runtime (see [“Building Query Expressions”](ch08.html#building_query_expressions)).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the following example, `x => x * x` is a lambda expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Internally, the compiler resolves lambda expressions of this type by writing
    a private method and then moving the expression’s code into that method.
  prefs: []
  type: TYPE_NORMAL
- en: 'A lambda expression has the following form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: For convenience, you can omit the parentheses if and only if there is exactly
    one parameter of an inferable type.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our example, there is a single parameter, `x`, and the expression is `x
    * x`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Each parameter of the lambda expression corresponds to a delegate parameter,
    and the type of the expression (which may be `void`) corresponds to the return
    type of the delegate.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our example, `x` corresponds to parameter `i`, and the expression `x * x`
    corresponds to the return type `int`, therefore being compatible with the `Transformer`
    delegate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'A lambda expression’s code can be a *statement block* instead of an expression.
    We can rewrite our example as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Lambda expressions are used most commonly with the `Func` and `Action` delegates,
    so you will most often see our earlier expression written as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s an example of an expression that accepts two parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'If you do not need to use the parameters, you can *discard* them with an underscore
    (from C# 9):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s an example of an expression that takes zero arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'From C# 10, the compiler permits implicit typing with lambda expressions that
    can be resolved via the `Func` and `Action` delegates, so we can shorten this
    statement to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Explicitly Specifying Lambda Parameter and Return Types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The compiler can usually *infer* the type of lambda parameters contextually.
    When this is not the case, you must specify the type of each parameter explicitly.
    Consider the following two methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code will fail to compile, because the compiler cannot infer
    the type of `x`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'We can fix this by explicitly specifying `x`’s type as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'This particular example is simple enough that it can be fixed in two other
    ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'The following example illustrates another use for explicit parameter types
    (from C# 10):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'The compiler infers `sqr` to be of type `Func<int,int>`. (Without specifying
    `int`, implicit typing would fail: the compiler would know that `sqr` should be
    `Func<T,T>`, but it wouldn’t know what `T` should be.)'
  prefs: []
  type: TYPE_NORMAL
- en: 'From C# 10, you can also specify the lambda return type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Specifying a return type can improve compiler performance with complex nested
    lambdas.
  prefs: []
  type: TYPE_NORMAL
- en: Default Lambda Parameters (C# 12)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Just as ordinary methods can have optional parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'so, too, can lambda expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: This feature is useful with libraries such as ASP.NET Minimal API.
  prefs: []
  type: TYPE_NORMAL
- en: Capturing Outer Variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A lambda expression can reference any variables that are accessible where the
    lambda expression is defined. These are called *outer variables*, and can include
    local variables, parameters, and fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: Outer variables referenced by a lambda expression are called *captured variables*.
    A lambda expression that captures variables is called a *closure*.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Variables can also be captured by anonymous methods and local methods. The rules
    for captured variables, in these cases, are the same.
  prefs: []
  type: TYPE_NORMAL
- en: 'Captured variables are evaluated when the delegate is actually *invoked*, not
    when the variables were *captured*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Lambda expressions can themselves update captured variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Captured variables have their lifetimes extended to that of the delegate. In
    the following example, the local variable `seed` would ordinarily disappear from
    scope when `Natural` finished executing. But because `seed` has been *captured*,
    its lifetime is extended to that of the capturing delegate, `natural`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'A local variable *instantiated* within a lambda expression is unique per invocation
    of the delegate instance. If we refactor our previous example to instantiate `seed`
    *within* the lambda expression, we get a different (in this case, undesirable)
    result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Capturing is internally implemented by “hoisting” the captured variables into
    fields of a private class. When the method is called, the class is instantiated
    and lifetime-bound to the delegate instance.
  prefs: []
  type: TYPE_NORMAL
- en: Static lambdas
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When you capture local variables, parameters, instance fields, or the `this`
    reference, the compiler may need to create and instantiate a private class to
    store a reference to the captured data. This incurs a small performance cost,
    because memory must be allocated (and subsequently collected). In situations where
    performance is critical, one micro-optimization strategy is to minimize the load
    on the garbage collector by ensuring that code hot paths incur few or no allocations.
  prefs: []
  type: TYPE_NORMAL
- en: 'From C# 9, you can ensure that a lambda expression, local function, or anonymous
    method doesn’t capture state by applying the `static` keyword. This can be useful
    in micro-optimization scenarios to prevent unintentional memory allocations. For
    example, we can apply the static modifier to a lambda expression as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'If we later try to modify the lambda expression such that it captures a local
    variable, the compiler will generate an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The lambda itself evaluates to a delegate instance, which requires a memory
    allocation. However, if the lambda doesn’t capture variables, the compiler will
    reuse a single cached instance across the life of the application, so there will
    be no cost in practice.
  prefs: []
  type: TYPE_NORMAL
- en: 'This feature can also be used with local methods. In the following example,
    the `Multiply` method cannot access the `factor` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: Of course, the `Multiply` method could still explicitly allocate memory by calling
    `new`. What this protects us from is a potential allocation by *stealth*. Applying
    `static` here is also arguably useful as a documentation tool, indicating a reduced
    level of coupling.
  prefs: []
  type: TYPE_NORMAL
- en: Static lambdas can still access static variables and constants (because these
    do not require a closure).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The `static` keyword acts merely as a *check*; it has no effect on the IL that
    the compiler produces. Without the `static` keyword, the compiler does not generate
    a closure unless it needs to (and even then, it has tricks to mitigate the cost).
  prefs: []
  type: TYPE_NORMAL
- en: Capturing iteration variables
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When you capture the iteration variable of a `for` loop, C# treats that variable
    as though it were declared *outside* the loop. This means that the *same* variable
    is captured in each iteration. The following program writes `333` instead of `012`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Each closure (shown in boldface) captures the same variable, `i`. (This actually
    makes sense when you consider that `i` is a variable whose value persists between
    loop iterations; you can even explicitly change `i` within the loop body if you
    want.) The consequence is that when the delegates are later invoked, each delegate
    sees `i`’s value at the time of *invocation*—which is 3\. We can illustrate this
    better by expanding the `for` loop, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'The solution, if we want to write `012`, is to assign the iteration variable
    to a local variable that’s scoped *within* the loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: Because `loopScopedi` is freshly created on every iteration, each closure captures
    a *different* variable.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Prior to C# 5.0, `foreach` loops worked in the same way. This caused considerable
    confusion: unlike with a `for` loop, the iteration variable in a `foreach` loop
    is immutable, and so you would expect it to be treated as local to the loop body.
    The good news is that it’s now fixed and you can safely capture a `foreach` loop’s
    iteration variable without surprises.'
  prefs: []
  type: TYPE_NORMAL
- en: Lambda Expressions Versus Local Methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The functionality of local methods (see [“Local methods”](ch03.html#local_methods-id00077))
    overlaps with that of lambda expressions. Local methods have the following three
    advantages:'
  prefs: []
  type: TYPE_NORMAL
- en: They can be recursive (they can call themselves) without ugly hacks.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They avoid the clutter of specifying a delegate type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They incur slightly less overhead.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Local methods are more efficient because they avoid the indirection of a delegate
    (which costs some CPU cycles and a memory allocation). They can also access local
    variables of the containing method without the compiler having to “hoist” the
    captured variables into a hidden class.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, in many cases you *need* a delegate—most commonly when calling a higher-order
    function, that is, a method with a delegate-typed parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: (You can see plenty more of these in [Chapter 8](ch08.html#linq_queries)). In
    such cases, you need a delegate anyway, and it’s in precisely these cases that
    lambda expressions are usually terser and cleaner.
  prefs: []
  type: TYPE_NORMAL
- en: Anonymous Methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Anonymous methods are a C# 2.0 feature that was mostly subsumed by C# 3.0’s
    lambda expressions. An anonymous method is like a lambda expression, but it lacks
    the following features:'
  prefs: []
  type: TYPE_NORMAL
- en: Implicitly typed parameters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Expression syntax (an anonymous method must always be a statement block)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ability to compile to an expression tree, by assigning to `Expression<T>`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An anonymous method uses the `delegate` keyword followed (optionally) by a
    parameter declaration and then a method body. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'The first line is semantically equivalent to the following lambda expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'Or simply:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: Anonymous methods capture outer variables in the same way lambda expressions
    do, and can be preceded by the `static` keyword to make them behave like static
    lambdas.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'A unique feature of anonymous methods is that you can omit the parameter declaration
    entirely—even if the delegate expects it. This can be useful in declaring events
    with a default empty handler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'This avoids the need for a null check before firing the event. The following
    is also legal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: try Statements and Exceptions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A `try` statement specifies a code block subject to error-handling or cleanup
    code. The `try` *block* must be followed by one or more `catch` *blocks* and/or
    a `finally` *block*, or both. The `catch` block executes when an error is thrown
    in the `try` block. The `finally` block executes after execution leaves the `try`
    block (or, if present, the `catch` block) to perform cleanup code, regardless
    of whether an exception was thrown.
  prefs: []
  type: TYPE_NORMAL
- en: A `catch` block has access to an `Exception` object that contains information
    about the error. You use a `catch` block to either compensate for the error or
    *rethrow* the exception. You rethrow an exception if you merely want to log the
    problem or if you want to rethrow a new, higher-level exception type.
  prefs: []
  type: TYPE_NORMAL
- en: 'A `finally` block adds determinism to your program: the CLR endeavors to always
    execute it. It’s useful for cleanup tasks such as closing network connections.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A `try` statement looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'Consider the following program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'Because `x` is zero, the runtime throws a `DivideByZeroException` and our program
    terminates. We can prevent this by catching the exception as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: This is a simple example to illustrate exception handling. We could deal with
    this particular scenario better in practice by checking explicitly for the divisor
    being zero before calling `Calc`.
  prefs: []
  type: TYPE_NORMAL
- en: Checking for preventable errors is preferable to relying on `try`/`catch` blocks
    because exceptions are relatively expensive to handle, taking hundreds of clock
    cycles or more.
  prefs: []
  type: TYPE_NORMAL
- en: 'When an exception is thrown within a `try` statement, the CLR performs a test:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Does the* `try` *statement have any compatible* `catch` *blocks?*'
  prefs: []
  type: TYPE_NORMAL
- en: If so, execution jumps to the compatible `catch` block, followed by the `finally`
    block (if present), and then execution continues normally.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If not, execution jumps directly to the `finally` block (if present), then the
    CLR looks up the call stack for other `try` blocks; if found, it repeats the test.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If no function in the call stack takes responsibility for the exception, the
    program terminates.
  prefs: []
  type: TYPE_NORMAL
- en: The catch Clause
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A `catch` clause specifies what type of exception to catch. This must either
    be `System.Exception` or a subclass of `System.Exception`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Catching `System.Exception` catches all possible errors. This is useful in
    the following circumstances:'
  prefs: []
  type: TYPE_NORMAL
- en: Your program can potentially recover regardless of the specific exception type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You plan to rethrow the exception (perhaps after logging it).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Your error handler is the last resort, prior to termination of the program.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More typically, though, you catch *specific exception types* in order to avoid
    having to deal with circumstances for which your handler wasn’t designed (e.g.,
    an `OutOfMemoryException`).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can handle multiple exception types with multiple `catch` clauses (again,
    this example could be written with explicit argument checking rather than exception
    handling):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: Only one `catch` clause executes for a given exception. If you want to include
    a safety net to catch more general exceptions (such as `System.Exception`), you
    must put the more-specific handlers *first*.
  prefs: []
  type: TYPE_NORMAL
- en: 'An exception can be caught without specifying a variable, if you don’t need
    to access its properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'Furthermore, you can omit both the variable and the type (meaning that all
    exceptions will be caught):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: Exception filters
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can specify an *exception filter* in a `catch` clause by adding a `when`
    clause:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'If a `WebException` is thrown in this example, the Boolean expression following
    the `when` keyword is then evaluated. If the result is false, the `catch` block
    in question is ignored and any subsequent `catch` clauses are considered. With
    exception filters, it can be meaningful to catch the same exception type again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: The Boolean expression in the `when` clause can be side-effecting, such as a
    method that logs the exception for diagnostic purposes.
  prefs: []
  type: TYPE_NORMAL
- en: The finally Block
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A `finally` block always executes—regardless of whether an exception is thrown
    and whether the `try` block runs to completion. You typically use `finally` blocks
    for cleanup code.
  prefs: []
  type: TYPE_NORMAL
- en: 'A `finally` block executes after any of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A `catch` block finishes (or throws a new exception).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `try` block finishes (or throws an exception for which there’s no `catch`
    block).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Control leaves the `try` block because of a `jump` statement (e.g., `return`
    or `goto`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The only things that can defeat a `finally` block are an infinite loop or the
    process ending abruptly.
  prefs: []
  type: TYPE_NORMAL
- en: 'A `finally` block helps add determinism to a program. In the following example,
    the file that we open *always* gets closed, regardless of whether:'
  prefs: []
  type: TYPE_NORMAL
- en: The `try` block finishes normally.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Execution returns early because the file is empty (`EndOfStream`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An `IOException` is thrown while reading the file:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we closed the file by calling `Dispose` on the `StreamReader`.
    Calling `Dispose` on an object, within a `finally` block, is a standard convention
    and is supported explicitly in C# through the `using` statement.
  prefs: []
  type: TYPE_NORMAL
- en: The using statement
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Many classes encapsulate unmanaged resources, such as file handles, graphics
    handles, or database connections. These classes implement `System.IDisposable`,
    which defines a single parameterless method named `Dispose` to clean up these
    resources. The `using` statement provides an elegant syntax for calling `Dispose`
    on an `IDisposable` object within a `finally` block.
  prefs: []
  type: TYPE_NORMAL
- en: Thus
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'is precisely equivalent to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: using declarations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you omit the brackets and statement block following a `using` statement
    (C# 8+), it becomes a *using declaration*. The resource is then disposed when
    execution falls outside the *enclosing* statement block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: In this case, `reader` will be disposed when execution falls outside the `if`
    statement block.
  prefs: []
  type: TYPE_NORMAL
- en: Throwing Exceptions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Exceptions can be thrown either by the runtime or in user code. In this example,
    `Display` throws a `System.ArgumentNullException`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Because null-checking an argument and throwing an `ArgumentNullException` is
    such a common code path, there’s actually a shortcut for it, from .NET 6:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we didn’t need to specify the name of the parameter. We’ll explain
    why later, in [“CallerArgumentExpression”](#callerargumentexpression-id00054).
  prefs: []
  type: TYPE_NORMAL
- en: throw expressions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`throw` can also appear as an expression in expression-bodied functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'A `throw` expression can also appear in a ternary conditional expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: Rethrowing an exception
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can capture and rethrow an exception as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If we replaced `throw` with `throw ex`, the example would still work, but the
    `StackTrace` property of the newly propagated exception would no longer reflect
    the original error.
  prefs: []
  type: TYPE_NORMAL
- en: 'Rethrowing in this manner lets you log an error without *swallowing* it. It
    also lets you back out of handling an exception should circumstances turn out
    to be beyond what you expected. The other common scenario is to rethrow a more
    specific exception type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: Notice that when we constructed `XmlException`, we passed in the original exception,
    `ex`, as the second argument. This argument populates the `InnerException` property
    of the new exception and aids debugging. Nearly all types of exception offer a
    similar constructor.
  prefs: []
  type: TYPE_NORMAL
- en: Rethrowing a *less*-specific exception is something you might do when crossing
    a trust boundary, so as not to leak technical information to potential hackers.
  prefs: []
  type: TYPE_NORMAL
- en: Key Properties of System.Exception
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The most important properties of `System.Exception` are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`StackTrace`'
  prefs: []
  type: TYPE_NORMAL
- en: A string representing all the methods that are called from the origin of the
    exception to the `catch` block.
  prefs: []
  type: TYPE_NORMAL
- en: '`Message`'
  prefs: []
  type: TYPE_NORMAL
- en: A string with a description of the error.
  prefs: []
  type: TYPE_NORMAL
- en: '`InnerException`'
  prefs: []
  type: TYPE_NORMAL
- en: The inner exception (if any) that caused the outer exception. This, itself,
    can have another `InnerException`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: All exceptions in C# are runtime exceptions—there is no equivalent to Java’s
    compile-time checked exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: Common Exception Types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following exception types are used widely throughout the CLR and .NET libraries.
    You can throw these yourself or use them as base classes for deriving custom exception
    types:'
  prefs: []
  type: TYPE_NORMAL
- en: '`System.ArgumentException`'
  prefs: []
  type: TYPE_NORMAL
- en: Thrown when a function is called with a bogus argument. This generally indicates
    a program bug.
  prefs: []
  type: TYPE_NORMAL
- en: '`System.ArgumentNullException`'
  prefs: []
  type: TYPE_NORMAL
- en: Subclass of `ArgumentException` that’s thrown when a function argument is (unexpectedly)
    `null`.
  prefs: []
  type: TYPE_NORMAL
- en: '`System.ArgumentOutOfRangeException`'
  prefs: []
  type: TYPE_NORMAL
- en: Subclass of `ArgumentException` that’s thrown when a (usually numeric) argument
    is too big or too small. For example, this is thrown when passing a negative number
    into a function that accepts only positive values.
  prefs: []
  type: TYPE_NORMAL
- en: '`System.InvalidOperationException`'
  prefs: []
  type: TYPE_NORMAL
- en: Thrown when the state of an object is unsuitable for a method to successfully
    execute, regardless of any particular argument values. Examples include reading
    an unopened file or getting the next element from an enumerator for which the
    underlying list has been modified partway through the iteration.
  prefs: []
  type: TYPE_NORMAL
- en: '`System.NotSupportedException`'
  prefs: []
  type: TYPE_NORMAL
- en: Thrown to indicate that a particular functionality is not supported. A good
    example is calling the `Add` method on a collection for which `IsReadOnly` returns
    `true`.
  prefs: []
  type: TYPE_NORMAL
- en: '`System.NotImplementedException`'
  prefs: []
  type: TYPE_NORMAL
- en: Thrown to indicate that a function has not yet been implemented.
  prefs: []
  type: TYPE_NORMAL
- en: '`System.ObjectDisposedException`'
  prefs: []
  type: TYPE_NORMAL
- en: Thrown when the object upon which the function is called has been disposed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another commonly encountered exception type is `NullReferenceException`. The
    CLR throws this exception when you attempt to access a member of an object whose
    value is `null` (indicating a bug in your code). You can throw a `NullReferenceException`
    directly (for testing purposes) as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: The TryXXX Method Pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When writing a method, you have a choice, when something goes wrong, to return
    some kind of failure code or throw an exception. In general, you throw an exception
    when the error is outside the normal workflow—or if you expect that the immediate
    caller won’t be able to cope with it. Occasionally, though, it can be best to
    offer both choices to the consumer. An example of this is the `int` type, which
    defines two versions of its `Parse` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: If parsing fails, `Parse` throws an exception; `TryParse` returns `false`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can implement this pattern by having the `*XXX*` method call the `Try*XXX*`
    method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: Alternatives to Exceptions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As with `int.TryParse`, a function can communicate failure by sending an error
    code back to the calling function via a return type or parameter. Although this
    can work with simple and predictable failures, it becomes clumsy when extended
    to unusual or unpredictable errors, polluting method signatures and creating unnecessary
    complexity and clutter.
  prefs: []
  type: TYPE_NORMAL
- en: It also cannot generalize to functions that are not methods, such as operators
    (e.g., the division operator) or properties. An alternative is to place the error
    in a common place where all functions in the call stack can see it (e.g., a static
    method that stores the current error per thread). This, though, requires each
    function to participate in an error-propagation pattern, which is cumbersome and,
    ironically, itself error prone.
  prefs: []
  type: TYPE_NORMAL
- en: Enumeration and Iterators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Enumeration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An *enumerator* is a read-only, forward-only cursor over a *sequence of values*.
    C# treats a type as an enumerator if it does any of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Has a public parameterless method named `MoveNext` and property called `Current`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implements `System.Collections.Generic.IEnumerator<T>`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implements `System.Collections.IEnumerator`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `foreach` statement iterates over an *enumerable* object. An enumerable
    object is the logical representation of a sequence. It is not itself a cursor
    but an object that produces cursors over itself. C# treats a type as enumerable
    if it does any of the following (the check is performed in this order):'
  prefs: []
  type: TYPE_NORMAL
- en: Has a public parameterless method named `GetEnumerator` that returns an enumerator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implements `System.Collections.Generic.IEnumerable<T>`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implements `System.Collections.IEnumerable`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: (From C# 9) Can bind to an *extension method* named `GetEnumerator` that returns
    an enumerator (see [“Extension Methods”](#extension_methods))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The enumeration pattern is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the high-level way of iterating through the characters in the word
    “beer” using a `foreach` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the low-level way of iterating through the characters in “beer” without
    using a `foreach` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: If the enumerator implements `IDisposable`, the `foreach` statement also acts
    as a `using` statement, implicitly disposing the enumerator object.
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 7](ch07.html#collections-id00055) explains the enumeration interfaces
    in further detail.'
  prefs: []
  type: TYPE_NORMAL
- en: Collection Initializers and Collection Expressions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can instantiate and populate an enumerable object in a single step via
    a *collection initializer*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: 'From C# 12, you can shorten this further with a *collection expression* (note
    the square brackets):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Collection expressions are *target-typed*, meaning that the type of `[1,2,3]`
    depends on the type to which it’s assigned (in this case, `List<int>`). In the
    following example, the target types are `int[]` and `Span<int>` (which we cover
    in [Chapter 23](ch23.html#spanless_thantgreater_than_and-id00089)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: 'Target typing means that you can omit the type in other scenarios where the
    compiler can infer it, such as when calling methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: 'The compiler translates this to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: This requires that the enumerable object implements the `System.Collections.IEnumerable`
    interface, and that it has an `Add` method that has the appropriate number of
    parameters for the call. (With collection expressions, the compiler also supports
    other patterns to allow for the creation of read-only collections.)
  prefs: []
  type: TYPE_NORMAL
- en: 'You can similarly initialize dictionaries (see [“Dictionaries”](ch07.html#dictionaries))
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, more succinctly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: The latter is valid not only with dictionaries but also with any type for which
    an indexer exists.
  prefs: []
  type: TYPE_NORMAL
- en: Iterators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Whereas a `foreach` statement is a *consumer* of an enumerator, an iterator
    is a *producer* of an enumerator. In this example, we use an iterator to return
    a sequence of Fibonacci numbers (where each number is the sum of the previous
    two):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: Whereas a `return` statement expresses, “Here’s the value you asked me to return
    from this method,” a `yield return` statement expresses, “Here’s the next element
    you asked me to yield from this enumerator.” On each `yield` statement, control
    is returned to the caller, but the callee’s state is maintained so that the method
    can continue executing as soon as the caller enumerates the next element. The
    lifetime of this state is bound to the enumerator such that the state can be released
    when the caller has finished enumerating.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The compiler converts iterator methods into private classes that implement `IEnumerable<T>`
    and/or `IEnumerator<T>`. The logic within the iterator block is “inverted” and
    spliced into the `MoveNext` method and `Current` property on the compiler-written
    enumerator class. This means that when you call an iterator method, all you’re
    doing is instantiating the compiler-written class; none of your code actually
    runs! Your code runs only when you start enumerating over the resultant sequence,
    typically with a `foreach` statement.
  prefs: []
  type: TYPE_NORMAL
- en: Iterators can be local methods (see [“Local methods”](ch03.html#local_methods-id00077)).
  prefs: []
  type: TYPE_NORMAL
- en: Iterator Semantics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An iterator is a method, property, or indexer that contains one or more `yield`
    statements. An iterator must return one of the following four interfaces (otherwise,
    the compiler will generate an error):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: An iterator has different semantics, depending on whether it returns an *enumerable*
    interface or an *enumerator* interface. We describe this in [Chapter 7](ch07.html#collections-id00055).
  prefs: []
  type: TYPE_NORMAL
- en: '*Multiple yield statements* are permitted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: yield break
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A return statement is illegal in an iterator block; instead you must use the
    `yield break` statement to indicate that the iterator block should exit early,
    without returning more elements. We can modify `Foo` as follows to demonstrate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: Iterators and try/catch/finally blocks
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A `yield return` statement cannot appear in a `try` block that has a `catch`
    clause:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: Nor can `yield return` appear in a `catch` or `finally` block. These restrictions
    are due to the fact that the compiler must translate iterators into ordinary classes
    with `MoveNext`, `Current`, and `Dispose` members, and translating exception-handling
    blocks would create excessive complexity.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can, however, yield within a `try` block that has (only) a `finally` block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: 'The code in the `finally` block executes when the consuming enumerator reaches
    the end of the sequence or is disposed. A `foreach` statement implicitly disposes
    the enumerator if you break early, making this a safe way to consume enumerators.
    When working with enumerators explicitly, a trap is to abandon enumeration early
    without disposing it, circumventing the `finally` block. You can avoid this risk
    by wrapping explicit use of enumerators in a `using` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: Composing Sequences
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Iterators are highly composable. We can extend our example, this time to output
    even Fibonacci numbers only:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: Each element is not calculated until the last moment—when requested by a `MoveNext()`
    operation. [Figure 4-1](#composing_sequences-id00056) shows the data requests
    and data output over time.
  prefs: []
  type: TYPE_NORMAL
- en: '![Composing sequences](assets/cn10_0401.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-1\. Composing sequences
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The composability of the iterator pattern is extremely useful in LINQ; we discuss
    the subject again in [Chapter 8](ch08.html#linq_queries).
  prefs: []
  type: TYPE_NORMAL
- en: Nullable Value Types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Reference types can represent a nonexistent value with a null reference. Value
    types, however, cannot ordinarily represent null values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: 'To represent null in a value type, you must use a special construct called
    a *nullable type*. A nullable type is denoted with a value type followed by the
    `?` symbol:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: Nullable<T> Struct
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`T?` translates into `System.Nullable<T>`, which is a lightweight immutable
    structure, having only two fields, to represent `Value` and `HasValue`. The essence
    of `System.Nullable<T>` is very simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: The code
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: 'translates to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: Attempting to retrieve `Value` when `HasValue` is false throws an `InvalidOperatio⁠n​Exception`.
    `GetValueOrDefault()` returns `Value` if `HasValue` is true; otherwise, it returns
    `new T()` or a specified custom default value.
  prefs: []
  type: TYPE_NORMAL
- en: The default value of `T?` is `null`.
  prefs: []
  type: TYPE_NORMAL
- en: Implicit and Explicit Nullable Conversions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The conversion from `T` to `T?` is implicit, whereas from `T?` to `T` the conversion
    is explicit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: The explicit cast is directly equivalent to calling the nullable object’s `Value`
    property. Hence, an `InvalidOperationException` is thrown if `HasValue` is false.
  prefs: []
  type: TYPE_NORMAL
- en: Boxing and Unboxing Nullable Values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When `T?` is boxed, the boxed value on the heap contains `T`, not `T?`. This
    optimization is possible because a boxed value is a reference type that can already
    express null.
  prefs: []
  type: TYPE_NORMAL
- en: 'C# also permits the unboxing of nullable value types with the `as` operator.
    The result will be `null` if the cast fails:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: Operator Lifting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `Nullable<T>` struct does not define operators such as `<`, `>`, or even
    `==`. Despite this, the following code compiles and executes correctly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: 'This works because the compiler borrows or “lifts” the less-than operator from
    the underlying value type. Semantically, it translates the preceding comparison
    expression into this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: In other words, if both `x` and `y` have values, it compares via `int`’s less-than
    operator; otherwise, it returns `false`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Operator lifting means that you can implicitly use `T`’s operators on `T?`.
    You can define operators for `T?` in order to provide special-purpose null behavior,
    but in the vast majority of cases, it’s best to rely on the compiler automatically
    applying systematic nullable logic for you. Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: The compiler performs null logic differently depending on the category of operator.
    The following sections explain these different rules.
  prefs: []
  type: TYPE_NORMAL
- en: Equality operators (== and !=)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Lifted equality operators handle nulls just like reference types do. This means
    that two null values are equal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: 'Further:'
  prefs: []
  type: TYPE_NORMAL
- en: If exactly one operand is null, the operands are unequal.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If both operands are non-null, their `Value`s are compared.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Relational operators (<, <=, >=, >)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The relational operators work on the principle that it is meaningless to compare
    null operands. This means that comparing a null value to either a null or a non-null
    value returns `false`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: All other operators (+, −, *, /, %, &, |, ^, <<, >>, +, ++, --, !, ~)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'These operators return null when any of the operands are null. This pattern
    should be familiar to SQL users:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: An exception is when the `&` and `|` operators are applied to `bool?`, which
    we discuss shortly.
  prefs: []
  type: TYPE_NORMAL
- en: Mixing nullable and non-nullable types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can mix and match nullable and non-nullable value types (this works because
    there is an implicit conversion from `T` to `T?`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: bool? with & and | Operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When supplied operands of type `bool?` the `&` and `|` operators treat `null`
    as an *unknown value*. So, `null | true` is true because:'
  prefs: []
  type: TYPE_NORMAL
- en: If the unknown value is false, the result would be true.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the unknown value is true, the result would be true.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Similarly, `null & false` is false. This behavior should be familiar to SQL
    users. The following example enumerates other combinations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: Nullable Value Types and Null Operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Nullable value types work particularly well with the `??` operator (see [“Null-Coalescing
    Operator”](ch02.html#null_coalescing_operator)), as illustrated in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: Using `??` on a nullable value type is equivalent to calling `GetValueOrDefault`
    with an explicit default value except that the expression for the default value
    is never evaluated if the variable is not null.
  prefs: []
  type: TYPE_NORMAL
- en: 'Nullable value types also work well with the null-conditional operator (see
    [“Null-Conditional Operator”](ch02.html#null_conditional_operator)). In the following
    example, length evaluates to null:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: 'We can combine this with the null-coalescing operator to evaluate to zero instead
    of null:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: Scenarios for Nullable Value Types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One of the most common scenarios for nullable value types is to represent unknown
    values. This frequently occurs in database programming, where a class is mapped
    to a table with nullable columns. If these columns are strings (e.g., an EmailAddress
    column on a Customer table), there is no problem because string is a reference
    type in the CLR, which can be null. However, most other SQL column types map to
    CLR struct types, making nullable value types very useful when mapping SQL to
    the CLR:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: 'A nullable type can also be used to represent the backing field of what’s sometimes
    called an *ambient property*. An ambient property, if null, returns the value
    of its parent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: Alternatives to Nullable Value Types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before nullable value types were part of the C# language (i.e., before C# 2.0),
    there were many strategies to deal with them, examples of which still appear in
    the .NET libraries for historical reasons. One of these strategies is to designate
    a particular non-null value as the “null value”; an example is in the string and
    array classes. `String.IndexOf` returns the magic value of `−1` when the character
    is not found:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: 'However, `Array.IndexOf` returns `−1` only if the index is 0-bounded. The more
    general formula is that `IndexOf` returns one less than the lower bound of the
    array. In the next example, `IndexOf` returns `0` when an element is not found:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: 'Nominating a “magic value” is problematic for several reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: It means that each value type has a different representation of null. In contrast,
    nullable value types provide one common pattern that works for all value types.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There might be no reasonable designated value. In the previous example, −1 could
    not always be used. The same is true for our earlier example representing an unknown
    account balance.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Forgetting to test for the magic value results in an incorrect value that might
    go unnoticed until later in execution—when it pulls an unintended magic trick.
    Forgetting to test `HasValue` on a null value, however, throws an `InvalidOperationException`
    on the spot.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ability for a value to be null is not captured in the *type*. Types communicate
    the intention of a program, allow the compiler to check for correctness, and enable
    a consistent set of rules enforced by the compiler.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Nullable Reference Types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Whereas *nullable value types* bring nullability to value types, *nullable reference
    types* (C# 8+) do the opposite. When enabled, they bring (a degree of) *non-nullability*
    to reference types, with the purpose of helping to avoid `NullReferenceException`s.
  prefs: []
  type: TYPE_NORMAL
- en: Nullable reference types introduce a level of safety that’s enforced purely
    by the compiler, in the form of warnings when it detects code that’s at risk of
    generating a `NullReferenceException`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To enable nullable reference types, you must either add the `Nullable` element
    to your *.csproj* project file (if you want to enable it for the entire project):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: 'or/and use the following directives in your code, in the places where it should
    take effect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: 'After being enabled, the compiler makes non-nullability the default: if you
    want a reference type to accept nulls without the compiler generating a warning,
    you must apply the `?` suffix to indicate a *nullable reference type*. In the
    following example, `s1` is non-nullable, whereas `s2` is nullable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Because nullable reference types are compile-time constructs, there’s no runtime
    difference between `string` and `string?`. In contrast, nullable value types introduce
    something concrete into the type system, namely the `Nullable<T>` struct.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following also generates a warning because `x` is not initialized:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: The warning disappears if you initialize `x`, either via a field initializer
    or via code in the constructor.
  prefs: []
  type: TYPE_NORMAL
- en: The Null-Forgiving Operator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The compiler also warns you upon dereferencing a nullable reference type, if
    it thinks a `NullReferenceException` might occur. In the following example, accessing
    the string’s `Length` property generates a warning:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: 'You can remove the warning with the *null-forgiving operator* (`!`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: 'Our use of the null-forgiving operator in this example is dangerous in that
    we could end up throwing the very `NullReferenceException` we were trying to avoid
    in the first place. We could fix it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: Notice now that we don’t need the null-forgiving operator. This is because the
    compiler performs *static flow analysis* and is smart enough to infer—at least
    in simple cases—when a dereference is safe and there’s no chance of a `NullReferenceException`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The compiler’s ability to detect and warn is not bulletproof, and there are
    also limits to what’s possible in terms of coverage. For instance, it’s unable
    to know whether an array’s elements have been populated, and so the following
    does not generate a warning:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: Separating the Annotation and Warning Contexts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Enabling nullable reference types via the `#nullable enable` directive (or
    the `<Nullable>enable</Nullable>` project setting) does two things:'
  prefs: []
  type: TYPE_NORMAL
- en: It enables the *nullable annotation context*, which tells the compiler to treat
    all reference-type variable declarations as non-nullable unless suffixed by the
    `?` symbol.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It enables the *nullable warning context*, which tells the compiler to generate
    warnings upon encountering code at risk of throwing a `NullReference​Excep⁠tion`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It can sometimes be useful to separate these two concepts and enable *just*
    the annotation context, or (less usefully) *just* the warning context:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: (The same trick works with `#nullable disable` and `#nullable restore`.)
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also do it via the project file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: Enabling just the annotation context for a particular class or assembly can
    be a good first step in introducing nullable reference types into a legacy codebase.
    By correctly annotating public members, you ensure your class or assembly can
    act as a “good citizen” to other classes or assemblies—so that *they* can benefit
    fully from nullable reference types—without having to deal with warnings in your
    own class or assembly.
  prefs: []
  type: TYPE_NORMAL
- en: Treating Nullable Warnings as Errors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In greenfield projects, it makes sense to fully enable the nullable context
    from the outset. You might want to take the additional step of treating nullable
    warnings as errors so that your project cannot compile until all null warnings
    have been resolved:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: Extension Methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Extension methods allow an existing type to be extended with new methods without
    altering the definition of the original type. An extension method is a static
    method of a static class, where the `this` modifier is applied to the first parameter.
    The type of the first parameter will be the type that is extended:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: 'The `IsCapitalized` extension method can be called as though it were an instance
    method on a string, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: 'An extension method call, when compiled, is translated back into an ordinary
    static method call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: 'The translation works as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE161]'
  prefs: []
  type: TYPE_PRE
- en: 'Interfaces can be extended, too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: Extension Method Chaining
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Extension methods, like instance methods, provide a tidy way to chain functions.
    Consider the following two functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE163]'
  prefs: []
  type: TYPE_PRE
- en: '`x` and `y` are equivalent, and both evaluate to `"Sausages"`, but `x` uses
    extension methods, whereas `y` uses static methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE164]'
  prefs: []
  type: TYPE_PRE
- en: Ambiguity and Resolution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Namespaces
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'An extension method cannot be accessed unless its class is in scope, typically
    by its namespace being imported. Consider the extension method `IsCapitalized`
    in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE165]'
  prefs: []
  type: TYPE_PRE
- en: 'To use `IsCapitalized`, the following application must import `Utils` in order
    to avoid a compile-time error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE166]'
  prefs: []
  type: TYPE_PRE
- en: Extension methods versus instance methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Any compatible instance method will always take precedence over an extension
    method. In the following example, `Test`’s `Foo` method will always take precedence,
    even when called with an argument `x` of type `int`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE167]'
  prefs: []
  type: TYPE_PRE
- en: The only way to call the extension method in this case is via normal static
    syntax, in other words, `Extensions.Foo(...)`.
  prefs: []
  type: TYPE_NORMAL
- en: Extension methods versus extension methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If two extension methods have the same signature, the extension method must
    be called as an ordinary static method to disambiguate the method to call. If
    one extension method has more specific arguments, however, the more specific method
    takes precedence.
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate, consider the following two classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE168]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code calls `StringHelper`’s `IsCapitalized` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE169]'
  prefs: []
  type: TYPE_PRE
- en: Classes and structs are considered more specific than interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: Demoting an extension method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An interesting scenario can arise when Microsoft adds an extension method to
    a .NET runtime library that conflicts with an extension method in some existing
    third-party library. As the author of the third-party library, you might want
    to “withdraw” your extension method, but without removing it and without breaking
    binary compatibility with existing consumers.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, this is easy to accomplish, simply by removing the `this` keyword
    from your extension method’s definition. This demotes your extension method to
    an ordinary static method. The beauty of this solution is that any assembly that
    was compiled against your old library will continue to work (and bind to *your*
    method, as before). The reason is that extension method calls are converted to
    static method calls during compilation.
  prefs: []
  type: TYPE_NORMAL
- en: Consumers will be affected by your demotion only when they recompile, at which
    time calls to your former extension method will bind to Microsoft’s version (if
    the namespace has been imported). Should the consumer still want to call your
    method, they can do so by invoking it as a static method.
  prefs: []
  type: TYPE_NORMAL
- en: Anonymous Types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An anonymous type is a simple class created by the compiler on the fly to store
    a set of values. To create an anonymous type, use the `new` keyword followed by
    an object initializer, specifying the properties and values the type will contain;
    for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE170]'
  prefs: []
  type: TYPE_PRE
- en: 'The compiler translates this to (approximately) the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE171]'
  prefs: []
  type: TYPE_PRE
- en: You must use the `var` keyword to reference an anonymous type because it doesn’t
    have a name.
  prefs: []
  type: TYPE_NORMAL
- en: The property name of an anonymous type can be inferred from an expression that
    is itself an identifier (or ends with one); thus
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE172]'
  prefs: []
  type: TYPE_PRE
- en: 'is equivalent to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE173]'
  prefs: []
  type: TYPE_PRE
- en: 'Two anonymous type instances declared within the same assembly will have the
    same underlying type if their elements are named and typed identically:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE174]'
  prefs: []
  type: TYPE_PRE
- en: 'Additionally, the `Equals` method is overridden to perform *structural equality
    comparison* (comparison of the data):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE175]'
  prefs: []
  type: TYPE_PRE
- en: 'Whereas the equality operator (`==`) performs referential comparison:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE176]'
  prefs: []
  type: TYPE_PRE
- en: 'You can create arrays of anonymous types as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE177]'
  prefs: []
  type: TYPE_PRE
- en: 'A method cannot (usefully) return an anonymously typed object, because it is
    illegal to write a method whose return type is `var`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE178]'
  prefs: []
  type: TYPE_PRE
- en: (In the following sections, we will describe records and tuples, which offer
    alternative approaches for returning multiple values from a method.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Anonymous types are immutable, so instances cannot be modified after creation.
    However, from C# 10, you can use the `with` keyword to create a copy with variations
    (*nondestructive mutation*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE179]'
  prefs: []
  type: TYPE_PRE
- en: Anonymous types are particularly useful when writing LINQ queries (see [Chapter 8](ch08.html#linq_queries)).
  prefs: []
  type: TYPE_NORMAL
- en: Tuples
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Like anonymous types, tuples provide a simple way to store a set of values.
    Tuples were introduced into C# with the main purpose of allowing methods to return
    multiple values without resorting to `out` parameters (something you cannot do
    with anonymous types). Since then, however, *records* have been introduced, offering
    a concise typed approach that we will describe in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Tuples do almost everything that anonymous types do and have the potential advantage
    of being value types, but they suffer—as you’ll see soon—from runtime type erasure
    with named elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'The simplest way to create a *tuple literal* is to list the desired values
    in parentheses. This creates a tuple with *unnamed* elements, which you refer
    to as `Item1`, `Item2`, and so on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE180]'
  prefs: []
  type: TYPE_PRE
- en: 'Tuples are *value types*, with *mutable* (read/write) elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE181]'
  prefs: []
  type: TYPE_PRE
- en: 'Unlike with anonymous types, you can specify a *tuple type* explicitly. Just
    list each of the element types in parentheses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE182]'
  prefs: []
  type: TYPE_PRE
- en: 'This means that you can usefully return a tuple from a method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE183]'
  prefs: []
  type: TYPE_PRE
- en: 'Tuples play well with generics, so the following types are all legal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE184]'
  prefs: []
  type: TYPE_PRE
- en: Naming Tuple Elements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can optionally give meaningful names to elements when creating tuple literals:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE185]'
  prefs: []
  type: TYPE_PRE
- en: 'You can do the same when specifying *tuple types*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE186]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'In [“Records”](#records-id00087), we’ll show how you can define simple classes
    or structs noiselessly, making it effortless to define a formal return type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE187]'
  prefs: []
  type: TYPE_PRE
- en: Unlike with tuples, a record’s properties (`Name` and `Age`) are strongly typed
    and so can easily be refactored. This approach also reduces code duplication and
    encourages good design in a couple of ways. First, the process of deciding on
    a simple noncontrived name for the type helps validate your design (an inability
    to do so can indicate lack of a single cohesive purpose). Second, it’s likely
    that you’ll end up adding methods or other code to the record (well-named types
    tend to *attract code*), and moving code to the data is a core principle of good
    object-oriented design.
  prefs: []
  type: TYPE_NORMAL
- en: Note that you can still treat the elements as unnamed and refer to them as `Item1`,
    `Item2`, etc. (although Visual Studio hides these fields from IntelliSense).
  prefs: []
  type: TYPE_NORMAL
- en: 'Element names are automatically *inferred* from property or field names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE188]'
  prefs: []
  type: TYPE_PRE
- en: 'Tuples are type compatible with one another if their element types match up
    (in order). Their element names need not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE189]'
  prefs: []
  type: TYPE_PRE
- en: 'Our particular example leads to confusing results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE190]'
  prefs: []
  type: TYPE_PRE
- en: Type erasure
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We stated previously that the C# compiler handles anonymous types by building
    custom classes with named properties for each of the elements. With tuples, C#
    works differently and uses a preexisting family of generic structs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE191]'
  prefs: []
  type: TYPE_PRE
- en: Each of the `ValueTuple<>` structs has fields named `Item1`, `Item2`, and so
    on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Hence, `(string,int)` is an alias for `ValueTuple<string,int>`, and this means
    that named tuple elements have no corresponding property names in the underlying
    types. Instead, the names exist only in the source code, and in the imagination
    of the compiler. At runtime, the names mostly disappear, so if you decompile a
    program that refers to named tuple elements, you’ll see just references to `Item1`,
    `Item2`, and so on. Further, when you examine a tuple variable in a debugger after
    having assigned it to an `object` (or `Dump` it in LINQPad), the element names
    are not there. And for the most part, you cannot use *reflection* ([Chapter 18](ch18.html#reflection_and_metadata))
    to determine a tuple’s element names at runtime. This means that with APIs such
    as `System.Net.Http.HttpClient`, tuples cannot replace anonymous types in scenarios
    such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE192]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: We said that the names *mostly* disappear because there’s an exception. With
    methods/properties that return named tuple types, the compiler emits the element
    names by applying a custom attribute called `TupleElementNamesAttribute` (see
    [“Attributes”](#attributes)) to the member’s return type. This allows named elements
    to work when calling methods in a different assembly (for which the compiler does
    not have the source code).
  prefs: []
  type: TYPE_NORMAL
- en: Aliasing Tuples (C# 12)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'From C# 12, you can leverage the `using` directive to define aliases for tuples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE193]'
  prefs: []
  type: TYPE_PRE
- en: 'This feature also works with tuples that have named elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE194]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, we’ll see shortly how records offer a fully typed solution with the
    same level of conciseness:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE195]'
  prefs: []
  type: TYPE_PRE
- en: ValueTuple.Create
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can also create tuples via a factory method on the (nongeneric) `ValueTuple`
    type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE196]'
  prefs: []
  type: TYPE_PRE
- en: Deconstructing Tuples
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Tuples implicitly support the deconstruction pattern (see [“Deconstructors”](ch03.html#deconstructors-id00060)),
    so you can easily *deconstruct* a tuple into individual variables. Consider the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE197]'
  prefs: []
  type: TYPE_PRE
- en: 'With the tuple’s deconstructor, you can simplify the code to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE198]'
  prefs: []
  type: TYPE_PRE
- en: 'The syntax for deconstruction is confusingly similar to the syntax for declaring
    a tuple with named elements. The following highlights the difference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE199]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s another example, this time when calling a method, and with type inference
    (`var`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE200]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also deconstruct directly into fields and properties, which provides
    a nice shortcut for populating multiple fields or properties in a constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE201]'
  prefs: []
  type: TYPE_PRE
- en: Equality Comparison
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As with anonymous types, the `Equals` method performs structural equality comparison.
    This means that it compares the underlying *data* rather than the *reference*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE202]'
  prefs: []
  type: TYPE_PRE
- en: 'In addition, `ValueTuple<>` overloads the `==` and `!=` operators:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE203]'
  prefs: []
  type: TYPE_PRE
- en: Tuples also override the `GetHashCode` method, making it practical to use tuples
    as keys in dictionaries. We cover equality comparison in detail in [“Equality
    Comparison”](ch06.html#equality_comparison-id00067), and dictionaries in [Chapter 7](ch07.html#collections-id00055).
  prefs: []
  type: TYPE_NORMAL
- en: The `ValueTuple<>` types also implement `IComparable` (see [“Order Comparison”](ch06.html#order_comparison)),
    making it possible to use tuples as a sorting key.
  prefs: []
  type: TYPE_NORMAL
- en: The System.Tuple classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You’ll find another family of generic types in the `System` namespace called
    `Tuple` (rather than `ValueTuple`). These were introduced back in 2010 and were
    defined as classes (whereas the `ValueTuple` types are structs). Defining tuples
    as classes was in retrospect considered a mistake: in the scenarios in which tuples
    are commonly used, structs have a slight performance advantage (in that they avoid
    unnecessary memory allocations), with almost no downside. Hence, when Microsoft
    added language support for tuples in C# 7, it ignored the existing `Tuple` types
    in favor of the new `ValueTuple`. You might still come across the `Tuple` classes
    in code written prior to C# 7\. They have no special language support and are
    used as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE204]'
  prefs: []
  type: TYPE_PRE
- en: Records
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A *record* is a special kind of class or struct that’s designed to work well
    with immutable (read-only) data. Its most useful feature is *nondestructive mutation*;
    however, records are also useful in creating types that just combine or hold data.
    In simple cases, they eliminate boilerplate code while honoring the equality semantics
    most suitable for immutable types.
  prefs: []
  type: TYPE_NORMAL
- en: Records are purely a C# compile-time construct. At runtime, the CLR sees them
    just as classes or structs (with a bunch of extra “synthesized” members added
    by the compiler).
  prefs: []
  type: TYPE_NORMAL
- en: Background
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Writing immutable types (whose fields cannot be modified after initialization)
    is a popular strategy for simplifying software and reducing bugs. It’s also a
    core aspect of functional programming, where mutable state is avoided and functions
    are treated as data. LINQ is inspired by this principle.
  prefs: []
  type: TYPE_NORMAL
- en: In order to “modify” an immutable object, you must create a new one and copy
    over the data while incorporating your modifications (this is called *nondestructive
    mutation*). In terms of performance, this is not as inefficient as you might expect,
    because a *shallow copy* will always suffice (a *deep copy*, where you also copy
    subobjects and collections, is unnecessary when data is immutable). But in terms
    of coding effort, implementing nondestructive mutation can be very inefficient,
    especially when there are many properties. Records solve this problem via a language-supported
    pattern.
  prefs: []
  type: TYPE_NORMAL
- en: A second issue is that programmers—particularly *functional programmers*—sometimes
    use immutable types just to combine data (without adding behavior). Defining such
    types is more work than it should be, requiring a constructor to assign each parameter
    to each public property (a deconstructor may also be useful). With records, the
    compiler can do this work for you.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, one of the consequences of an object being immutable is that its identity
    cannot change, which means that it’s more useful for such types to implement *structural
    equality* than *referential equality*. Structural equality means that two instances
    are the same if their data is the same (as with tuples). Records give you structural
    equality by default—regardless of whether the underlying type is a class or struct—without
    any boilerplate code.
  prefs: []
  type: TYPE_NORMAL
- en: Defining a Record
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A record definition is like a class or struct definition, and can contain the
    same kinds of members, including fields, properties, methods, and so on. Records
    can implement interfaces, and (class-based) records can subclass other (class-based)
    records.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, the underlying type of a record is a class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE205]'
  prefs: []
  type: TYPE_PRE
- en: 'From C# 10, the underlying type of a record can also be a struct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE206]'
  prefs: []
  type: TYPE_PRE
- en: (`record class` is also legal and has the same meaning as `record`.)
  prefs: []
  type: TYPE_NORMAL
- en: 'A simple record might contain just a bunch of init-only properties, and perhaps
    a constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE207]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Our constructor employs a shortcut that we described in the preceding section.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE208]'
  prefs: []
  type: TYPE_PRE
- en: 'is equivalent (in this case) to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE209]'
  prefs: []
  type: TYPE_PRE
- en: 'Upon compilation, C# transforms the record definition into a class (or struct)
    and performs the following additional steps:'
  prefs: []
  type: TYPE_NORMAL
- en: It writes a protected *copy constructor* (and a hidden *Clone* method) to facilitate
    nondestructive mutation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It overrides/overloads the equality-related functions to implement structural
    equality.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It overrides the `ToString()` method (to expand the record’s public properties,
    as with anonymous types).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The preceding record declaration expands into something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE210]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'While there’s nothing to stop you from putting *optional parameters* into the
    constructor, a good pattern (at least in public libraries) is to leave them out
    of the constructor and expose them purely as init-only properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE211]'
  prefs: []
  type: TYPE_PRE
- en: The advantage of this pattern is that you can safely add init-only properties
    later without breaking binary compatibility with consumers who have compiled against
    older versions of your assembly.
  prefs: []
  type: TYPE_NORMAL
- en: Parameter lists
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A record definition can be shortened through the use of a *parameter list*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE212]'
  prefs: []
  type: TYPE_PRE
- en: 'Parameters can include the `in` and `params` modifiers, but not `out` or `ref`.
    If a parameter list is specified, the compiler performs the following extra steps:'
  prefs: []
  type: TYPE_NORMAL
- en: It writes an init-only property per parameter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It writes a *primary constructor* to populate the properties.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It writes a deconstructor.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This means that if we declare our `Point` record simply as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE213]'
  prefs: []
  type: TYPE_PRE
- en: 'the compiler will end up generating (almost) exactly what we listed in the
    preceding expansion. A minor difference is that the parameter names in the primary
    constructor will end up as `X` and `Y` instead of `x` and `y`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE214]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Also, due to being a *primary constructor*, parameters `X` and `Y` become magically
    available to any field or property initializers in your record. We discuss the
    subtleties of this later, in [“Primary Constructors”](#primary_constructors).
  prefs: []
  type: TYPE_NORMAL
- en: 'Another difference, when you define a parameter list, is that the compiler
    also generates a deconstructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE215]'
  prefs: []
  type: TYPE_PRE
- en: 'Records with parameter lists can be subclassed using the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE216]'
  prefs: []
  type: TYPE_PRE
- en: 'The compiler then emits a primary constructor as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE217]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Parameter lists offer a nice shortcut when you need a class that simply groups
    together a bunch of values (a *product type* in functional programming) and can
    also be useful for prototyping. As we’ll see later, they’re not so helpful when
    you need to add logic to the `init` accessors (such as argument validation).
  prefs: []
  type: TYPE_NORMAL
- en: Nondestructive Mutation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The most important step that the compiler performs with all records is to write
    a *copy constructor* (and a hidden *Clone* method). This enables nondestructive
    mutation via the `with` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE218]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, `p2` is a copy of `p1`, but with its `Y` property set to 4\.
    The benefit is more apparent when there are more properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE219]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE220]'
  prefs: []
  type: TYPE_PRE
- en: 'Nondestructive mutation occurs in two phases:'
  prefs: []
  type: TYPE_NORMAL
- en: First, the *copy constructor* clones the record. By default, it copies each
    of the record’s underlying fields, creating a faithful replica while bypassing
    (the overhead of) any logic in the `init` accessors. All fields are included (public
    and private, as well as the hidden fields that back automatic properties).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, each property in the *member initializer list* is updated (this time using
    the `init` accessors).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The compiler translates
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE221]'
  prefs: []
  type: TYPE_PRE
- en: 'into something functionally equivalent to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE222]'
  prefs: []
  type: TYPE_PRE
- en: (The same code would not compile if you wrote it explicitly because `A` and
    `C` are init-only properties. Furthermore, the copy constructor is *protected*;
    C# works around this by invoking it via a public hidden method that it writes
    into the record called `<Clone>$`.)
  prefs: []
  type: TYPE_NORMAL
- en: 'If necessary, you can define your own *copy constructor*. C# will then use
    your definition instead of writing one itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE223]'
  prefs: []
  type: TYPE_PRE
- en: Writing a custom copy constructor might be useful if your record contains mutable
    subobjects or collections that you wish to clone, or if there are computed fields
    that you wish to clear. Unfortunately, you can only *replace*, not *enhance*,
    the default implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'When subclassing another record, the copy constructor is responsible for copying
    only its own fields. To copy the base record’s fields, delegate to the base:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE224]'
  prefs: []
  type: TYPE_PRE
- en: Property Validation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With explicit properties, you can write validation logic into the `init` accessors.
    In the following example, we ensure that `X` can never be `NaN` (Not a Number):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE225]'
  prefs: []
  type: TYPE_PRE
- en: '**Our design ensures that validation occurs both during construction and when
    the object is nondestructively mutated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE226]'
  prefs: []
  type: TYPE_PRE
- en: 'Recall that the automatically generated *copy constructor* copies over all
    fields and automatic properties. This means that the generated copy constructor
    will now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE227]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the copying of the `_x` field circumvents the `X` property accessor.
    However, this cannot break anything, because it’s faithfully copying an object
    that will have already been safely populated via `X`’s `init` accessor.**  **##
    Calculated Fields and Lazy Evaluation
  prefs: []
  type: TYPE_NORMAL
- en: 'A popular functional programming pattern that works well with immutable types
    is *lazy evaluation*, where a value is not computed until required and then is
    cached for reuse. Suppose, for instance, that we want to define a property in
    our `Point` record that returns the distance from the origin `(0, 0)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE228]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s now try to refactor this to avoid the cost of recomputing `DistanceFromOrigin`
    every time the property is accessed. We’ll start by removing the property list
    and defining `X`, `Y`, and `DistanceFromOrigin` as read-only properties. Then
    we can calculate the latter in the constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE229]'
  prefs: []
  type: TYPE_PRE
- en: 'This works, but it doesn’t allow for nondestructive mutation (changing `X`
    and `Y` to init-only properties would break the code because `DistanceFromOrigin`
    would become stale after the `init` accessors execute). It’s also suboptimal in
    that the calculation is always performed, regardless of whether the `DistanceFromOrigin`
    property is ever read. The optimal solution is to cache its value in a field and
    populate it *lazily* (on first use):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE230]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Technically, we *mutate* `_distance` in this code. It’s still fair, though,
    to call `Point` an immutable type. Mutating a field purely to populate a lazy
    value does not invalidate the principles or benefits of immutability, and can
    even be masked through the use of the `Lazy<T>` type that we describe in [Chapter 21](ch21.html#advanced_threadin).
  prefs: []
  type: TYPE_NORMAL
- en: 'With C#’s *null-coalescing assignment operator* (`??=`), we can reduce the
    entire property declaration to one line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE231]'
  prefs: []
  type: TYPE_PRE
- en: (This says, return `_distance` if it’s non-null; otherwise, return `Math.Sqrt
    (X*X + Y*Y)` while assigning it to `_distance`.)
  prefs: []
  type: TYPE_NORMAL
- en: 'To make this work with init-only properties, we need one further step, which
    is to clear the cached `_distance` field when `X` or `Y` is updated via the `init`
    accessor. Here’s the complete code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE232]'
  prefs: []
  type: TYPE_PRE
- en: '`Point` can now be mutated nondestructively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE233]'
  prefs: []
  type: TYPE_PRE
- en: 'A nice bonus is that the autogenerated copy constructor copies over the cached
    `_distance` field. This means that should a record have other properties that
    aren’t involved in the calculation, a nondestructive mutation of those properties
    wouldn’t trigger an unnecessary loss of the cached value. If you don’t care for
    this bonus, an alternative to clearing the cached value in the `init` accessors
    is to write a custom copy constructor that ignores the cached field. This is more
    concise because it works with parameter lists, and the custom copy constructor
    can leverage the deconstructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE234]'
  prefs: []
  type: TYPE_PRE
- en: Note that with either solution, the addition of lazy calculated fields breaks
    the default structural equality comparison (because such fields may or may not
    be populated), although we’ll see shortly that it’s relatively easy to fix.
  prefs: []
  type: TYPE_NORMAL
- en: Primary Constructors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you define a record with a parameter list, the compiler generates property
    declarations automatically, as well as a *primary constructor* (and a deconstructor).
    As we’ve seen, this works well in simple cases, and in more complex cases you
    can omit the parameter list and write the property declarations and constructor
    manually.
  prefs: []
  type: TYPE_NORMAL
- en: 'C# also offers a mildly useful intermediate option—if you’re willing to deal
    with the curious semantics of primary constructors—which is to define a parameter
    list while writing some or all of the property declarations yourself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE235]'
  prefs: []
  type: TYPE_PRE
- en: In this case, we “took over” the `ID` property definition, defining it as read-only
    (instead of init-only), preventing it from partaking in nondestructive mutation.
    If you never need to nondestructively mutate a particular property, making it
    read-only lets you store computed data in the record without having to code up
    a refresh mechanism.
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that we needed to include a *property initializer* (in boldface):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE236]'
  prefs: []
  type: TYPE_PRE
- en: When you “take over” a property declaration, you become responsible for initializing
    its value; the primary constructor no longer does this automatically. (This exactly
    matches the behavior when defining primary constructors on classes or structs.)
    Also note that the `ID` in boldface refers to the *primary constructor parameter*,
    not the `ID` property.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'With record structs, it’s legal to redefine a property as a field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE237]'
  prefs: []
  type: TYPE_PRE
- en: 'In keeping with the semantics of primary constructors on classes and structs
    (see [“Primary Constructors”](#primary_constructors)), the primary constructor
    parameters (`ID`, `LastName`, and `GivenName` in this case) are magically visible
    to all field and property initializers. We can illustrate this by extending our
    example as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE238]'
  prefs: []
  type: TYPE_PRE
- en: Again, the `ID` in boldface refers to the primary constructor parameter, not
    the property. (The reason for there not being an ambiguity is that it’s illegal
    to access properties from initializers.)
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we calculated `_enrollmentYear` from the first four digits
    of the `ID`. While it’s safe to store this in a read-only field (because the `ID`
    property is read-only and so cannot be nondestructively mutated), this code would
    not work so well in the real world. The reason is that without an explicit constructor,
    there’s no central place in which to validate `ID` and throw a meaningful exception
    should it be invalid (a common requirement).
  prefs: []
  type: TYPE_NORMAL
- en: 'Validation is also a good reason for needing to write explicit init-only accessors
    (as we discussed in [“Property Validation”](#property_validation)). Unfortunately,
    primary constructors do not play well in this scenario. To illustrate, consider
    the following record, where an `init` accessor performs a null validation check:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE239]'
  prefs: []
  type: TYPE_PRE
- en: 'Because `Name` is not an automatic property, it cannot define an initializer.
    The best we can do is put the initializer on the backing field (in boldface).
    Unfortunately, doing so bypasses the null check:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE240]'
  prefs: []
  type: TYPE_PRE
- en: 'The difficulty is that there’s no way to assign a primary constructor parameter
    to a property without writing the constructor ourselves. While there are workarounds
    (such as factoring the `init` validation logic into a separate static method that
    we call twice), the simplest workaround is to avoid the parameter list altogether
    and write an ordinary constructor manually (and deconstructor, should you need
    it):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE241]'
  prefs: []
  type: TYPE_PRE
- en: Records and Equality Comparison
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Just as with structs, anonymous types, and tuples, records provide structural
    equality out of the box, meaning that two records are equal if their fields (and
    automatic properties) are equal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE242]'
  prefs: []
  type: TYPE_PRE
- en: 'The *equality operator* also works with records (as it does with tuples):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE243]'
  prefs: []
  type: TYPE_PRE
- en: The default equality implementation for records is unavoidably fragile. In particular,
    it breaks if the record contains lazy values, transient values, arrays, or collection
    types (which require special handling for equality comparison). Fortunately, it’s
    relatively easy to fix (should you need equality to work), and doing so is less
    work than adding full equality behavior to classes or structs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unlike with classes and structs, you do not (and cannot) override the `object.Equals`
    method; instead, you define a public `Equals` method with the following signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE244]'
  prefs: []
  type: TYPE_PRE
- en: The `Equals` method must be `virtual` (not `override`), and it must be *strongly
    typed* such that it accepts the actual record type (`Point` in this case, not
    `object`). Once you get the signature right, the compiler will automatically patch
    in your method.
  prefs: []
  type: TYPE_NORMAL
- en: In our example, we changed the equality logic such that we compare only `X`
    and `Y` (and ignore `_someOtherField`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Should you subclass another record, you can call the `base.Equals` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE245]'
  prefs: []
  type: TYPE_PRE
- en: 'As with any type, if you take over equality comparison, you should also override
    `GetHashCode()`. A nice feature of records is that you don’t overload `!=` or
    `==`; nor do you implement `IEquatable<T>`: this is all done for you. We cover
    this topic of equality comparison fully in [“Equality Comparison”](ch06.html#equality_comparison-id00067).**  **#
    Patterns'
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 3](ch03.html#creating_types_in_chash), we demonstrated how to use
    the `is` operator to test whether a reference conversion will succeed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE246]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, more concisely:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE247]'
  prefs: []
  type: TYPE_PRE
- en: 'This shortcut employs one kind of pattern called a *type pattern*. The `is`
    operator also supports other patterns that were introduced in recent versions
    of C#, such as the *property pattern*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE248]'
  prefs: []
  type: TYPE_PRE
- en: 'Patterns are supported in the following contexts:'
  prefs: []
  type: TYPE_NORMAL
- en: After the `is` operator (`*variable* is *pattern*`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In switch statements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In switch expressions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We’ve already covered the type pattern (and briefly, the tuple pattern) in [“Switching
    on types”](ch02.html#switching_on_types) and [“The is operator”](ch03.html#the_is_operator).
    In this section, we cover more advanced patterns that were introduced in recent
    versions of C#.
  prefs: []
  type: TYPE_NORMAL
- en: Some of the more specialized patterns are intended mostly for use in switch
    statements/expressions. Here, they reduce the need for `when` clauses and let
    you use switches where you couldn’t previously.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The patterns in this section are mildly to moderately useful in some scenarios.
    Remember that you can always replace highly patterned switch expressions with
    simple `if` statements—or, in some cases, the ternary conditional operator—often
    without much extra code.
  prefs: []
  type: TYPE_NORMAL
- en: Constant Pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The constant pattern lets you match directly to a constant, and is useful when
    working with the `object` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE249]'
  prefs: []
  type: TYPE_PRE
- en: 'This expression in boldface is equivalent to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE250]'
  prefs: []
  type: TYPE_PRE
- en: (Being a static operator, C# won’t let you use `==` to compare an `object` directly
    to a constant, because the compiler needs to know the types in advance.)
  prefs: []
  type: TYPE_NORMAL
- en: 'On its own, this pattern is only marginally useful in that there’s a reasonable
    alternative:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE251]'
  prefs: []
  type: TYPE_PRE
- en: As we’ll see soon, the constant pattern becomes much more useful with *pattern
    combinators*.
  prefs: []
  type: TYPE_NORMAL
- en: Relational Patterns
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'From C# 9, you can use the `<`, `>`, `<=`, and `>=` operators in patterns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE252]'
  prefs: []
  type: TYPE_PRE
- en: 'This becomes meaningfully useful in a `switch`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE253]'
  prefs: []
  type: TYPE_PRE
- en: Relational patterns become even more useful in conjunction with *pattern combinators*.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The relational pattern also works when the variable has a compile-time type
    of `object`, but you have to be extremely careful with your use of numeric constants.
    In the following example, the last line prints False because we are attempting
    to match a decimal value to an integer literal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE254]'
  prefs: []
  type: TYPE_PRE
- en: Pattern Combinators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'From C# 9, you can use the `and`, `or`, and `not` keywords to combine patterns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE255]'
  prefs: []
  type: TYPE_PRE
- en: As with the `&&` and `||` operators, `and` has higher precedence than `or`.
    You can override this with parentheses.
  prefs: []
  type: TYPE_NORMAL
- en: 'A nice trick is to combine the `not` combinator with the *type pattern* to
    test whether an object is (not) a type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE256]'
  prefs: []
  type: TYPE_PRE
- en: 'This looks nicer than:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE257]'
  prefs: []
  type: TYPE_PRE
- en: var Pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The *var pattern* is a variation of the *type pattern* whereby you replace
    the type name with the `var` keyword. The conversion always succeeds, so its purpose
    is merely to let you reuse the variable that follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE258]'
  prefs: []
  type: TYPE_PRE
- en: 'This is equivalent to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE259]'
  prefs: []
  type: TYPE_PRE
- en: The ability to introduce and reuse an intermediate variable (`upper`, in this
    case) in an expression-bodied method is convenient—particularly in lambda expressions.
    Unfortunately, it tends to be useful only when the method in question has a `bool`
    return type.
  prefs: []
  type: TYPE_NORMAL
- en: Tuple and Positional Patterns
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The *tuple pattern* (introduced in C# 8) matches tuples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE260]'
  prefs: []
  type: TYPE_PRE
- en: 'You can use this to switch on multiple values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE261]'
  prefs: []
  type: TYPE_PRE
- en: 'The tuple pattern can be considered a special case of the *positional pattern*
    (C# 8+), which matches any type that exposes a `Deconstruct` method (see [“Deconstructors”](ch03.html#deconstructors-id00060)).
    In the following example, we leverage the `Point` record’s compiler-generated
    deconstructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE262]'
  prefs: []
  type: TYPE_PRE
- en: 'You can deconstruct as you match, using the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE263]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s a switch expression that combines a type pattern with a positional pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE264]'
  prefs: []
  type: TYPE_PRE
- en: Property Patterns
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A property pattern (C# 8+) matches on one or more of an object’s property values.
    We gave a simple example previously in the context of the `is` operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE265]'
  prefs: []
  type: TYPE_PRE
- en: 'However, this doesn’t save much over the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE266]'
  prefs: []
  type: TYPE_PRE
- en: 'With switch statements and expressions, property patterns are more useful.
    Consider the `System.Uri` class, which represents a URI. It has properties that
    include `Scheme`, `Host`, `Port`, and `IsLoopback`. In writing a firewall, we
    could decide whether to allow or block a URI by employing a switch expression
    that uses property patterns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE267]'
  prefs: []
  type: TYPE_PRE
- en: 'You can nest properties, making the following clause legal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE268]'
  prefs: []
  type: TYPE_PRE
- en: 'which, from C# 10, can be simplified to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE269]'
  prefs: []
  type: TYPE_PRE
- en: 'You can use other patterns inside property patterns, including the relational
    pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE270]'
  prefs: []
  type: TYPE_PRE
- en: 'More elaborate conditions can be expressed with a `when` clause:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE271]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also combine the property pattern with the type pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE272]'
  prefs: []
  type: TYPE_PRE
- en: 'As you might expect with type patterns, you can introduce a variable at the
    end of a clause and then consume that variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE273]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also use that variable in a `when` clause:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE274]'
  prefs: []
  type: TYPE_PRE
- en: 'A somewhat bizarre twist with property patterns is that you can also introduce
    variables at the *property* level:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE275]'
  prefs: []
  type: TYPE_PRE
- en: 'Implicit typing is permitted, so you can substitute `string` with `var`. Here’s
    a complete example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE276]'
  prefs: []
  type: TYPE_PRE
- en: 'It’s difficult to invent examples for which this saves more than a few characters.
    In our case, the alternative is actually shorter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE277]'
  prefs: []
  type: TYPE_PRE
- en: 'Or:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE278]'
  prefs: []
  type: TYPE_PRE
- en: List Patterns
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: List patterns (from C# 11) work with any collection type that is countable (with
    a `Count` or `Length` property) and indexable (with an indexer of type `int` or
    `System.Index`).
  prefs: []
  type: TYPE_NORMAL
- en: 'A list pattern matches a series of elements in square brackets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE279]'
  prefs: []
  type: TYPE_PRE
- en: 'An underscore matches a single element of any value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE280]'
  prefs: []
  type: TYPE_PRE
- en: 'The `var` pattern also works in matching a single element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE281]'
  prefs: []
  type: TYPE_PRE
- en: 'Two dots indicate a *slice*. A slice matches zero or more elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE282]'
  prefs: []
  type: TYPE_PRE
- en: 'With arrays and other types that support indices and ranges (see [“Indices
    and Ranges”](ch02.html#indices_and_ranges-id00073)), you can follow a slice with
    a `var` pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE283]'
  prefs: []
  type: TYPE_PRE
- en: A list pattern can include at most one slice.
  prefs: []
  type: TYPE_NORMAL
- en: Attributes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You’re already familiar with the notion of attributing code elements of a program
    with modifiers, such as `virtual` or `ref`. These constructs are built into the
    language. *Attributes* are an extensible mechanism for adding custom information
    to code elements (assemblies, types, members, return values, parameters, and generic
    type parameters). This extensibility is useful for services that integrate deeply
    into the type system, without requiring special keywords or constructs in the
    C# language.
  prefs: []
  type: TYPE_NORMAL
- en: Attribute Classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An attribute is defined by a class that inherits (directly or indirectly) from
    the abstract class `System.Attribute`. To attach an attribute to a code element,
    specify the attribute’s type name in square brackets, before the code element.
    For example, the following attaches the `ObsoleteAttribute` to the `Foo` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE284]'
  prefs: []
  type: TYPE_PRE
- en: 'This particular attribute is recognized by the compiler and will cause compiler
    warnings if a type or member marked as obsolete is referenced. By convention,
    all attribute types end in the word “Attribute.” C# recognizes this and allows
    you to omit the suffix when attaching an attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE285]'
  prefs: []
  type: TYPE_PRE
- en: '`ObsoleteAttribute` is a type declared in the `System` namespace as follows
    (simplified for brevity):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE286]'
  prefs: []
  type: TYPE_PRE
- en: The .NET libraries include many predefined attributes. We describe how to write
    your own attributes in [Chapter 18](ch18.html#reflection_and_metadata).
  prefs: []
  type: TYPE_NORMAL
- en: Named and Positional Attribute Parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Attributes can have parameters. In the following example, we apply `XmlTypeAttribute`
    to a class. This attribute instructs the XML serializer (in `System.Xml.Serialization`)
    as to how an object is represented in XML and accepts several *attribute parameters*.
    The following attribute maps the `CustomerEntity` class to an XML element named
    `Customer`, which belongs to the `http://oreilly.com` namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE287]'
  prefs: []
  type: TYPE_PRE
- en: (We cover XML and JSON serialization in the online supplement at [*http://www.albahari.com/nutshell*](http://www.albahari.com/nutshell).)
  prefs: []
  type: TYPE_NORMAL
- en: 'Attribute parameters fall into one of two categories: *positional* or *named*.
    In the preceding example, the first argument is a positional parameter; the second
    is a named parameter. Positional parameters correspond to parameters of the attribute
    type’s public constructors. Named parameters correspond to public fields or public
    properties on the attribute type.'
  prefs: []
  type: TYPE_NORMAL
- en: When specifying an attribute, you must include positional parameters that correspond
    to one of the attribute’s constructors. Named parameters are optional.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 18](ch18.html#reflection_and_metadata), we describe the valid parameter
    types and rules for their evaluation.
  prefs: []
  type: TYPE_NORMAL
- en: Applying Attributes to Assemblies and Backing Fields
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Implicitly, the target of an attribute is the code element it immediately precedes,
    which is typically a type or type member. You can also attach attributes, however,
    to an assembly. This requires that you explicitly specify the attribute’s target.
    Here is how you can use the `AssemblyFileVersion` attribute to attach a version
    to the assembly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE288]'
  prefs: []
  type: TYPE_PRE
- en: 'With the `field:` prefix, you can apply an attribute to the backing fields
    of an automatic property. This is useful in special cases, such as when applying
    the (now-deprecated) `NonSerialized` attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE289]'
  prefs: []
  type: TYPE_PRE
- en: Applying Attributes to Lambda Expressions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'From C# 10, you can apply attributes to the method, parameters, and return
    value of a lambda expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE290]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: This is useful when working with frameworks—such as ASP.NET—that rely on you
    placing attributes on methods that you write. With this feature, you can avoid
    having to create named methods for simple operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'These attributes are applied to the compiler-generated method to which the
    delegate points. In [Chapter 18](ch18.html#reflection_and_metadata), we’ll describe
    how to reflect over attributes in code. For now, here’s the extra code you need
    to resolve that indirection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE291]'
  prefs: []
  type: TYPE_PRE
- en: To avoid syntactical ambiguity when applying attributes to a parameter on a
    lambda expression, parentheses are always required. Attributes are not permitted
    on expression-tree lambdas.
  prefs: []
  type: TYPE_NORMAL
- en: Specifying Multiple Attributes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can specify multiple attributes for a single code element. You can list
    each attribute either within the same pair of square brackets (separated by a
    comma) or in separate pairs of square brackets (or a combination of the two).
    The following three examples are semantically identical:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE292]'
  prefs: []
  type: TYPE_PRE
- en: Caller Info Attributes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can tag optional parameters with one of three *caller info attributes*,
    which instruct the compiler to feed information obtained from the caller’s source
    code into the parameter’s default value:'
  prefs: []
  type: TYPE_NORMAL
- en: '`[CallerMemberName]` applies the caller’s member name.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[CallerFilePath]` applies the path to the caller’s source code file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[CallerLineNumber]` applies the line number in the caller’s source code file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `Foo` method in the following program demonstrates all three:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE293]'
  prefs: []
  type: TYPE_PRE
- en: 'Assuming that our program resides in *c:\source\test\Program.cs*, the output
    would be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE294]'
  prefs: []
  type: TYPE_PRE
- en: 'As with standard optional parameters, the substitution is done at the *calling
    site*. Hence, our `Main` method is syntactic sugar for this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE295]'
  prefs: []
  type: TYPE_PRE
- en: 'Caller info attributes are useful for logging—and for implementing patterns
    such as firing a single change notification event whenever any property on an
    object changes. In fact, there’s a standard interface for this in the `System.ComponentModel`
    namespace, called `INotifyPropertyChanged`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE296]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that `PropertyChangedEventArgs` requires the name of the property that
    changed. By applying the `[CallerMemberName]` attribute, however, we can implement
    this interface and invoke the event without ever specifying property names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE297]'
  prefs: []
  type: TYPE_PRE
- en: CallerArgumentExpression
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A method parameter to which you apply the `[CallerArgumentExpression]` attribute
    (from C# 10) captures an argument expression from the call site:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE298]'
  prefs: []
  type: TYPE_PRE
- en: 'The compiler feeds in the calling expression’s source code literally, including
    comments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE299]'
  prefs: []
  type: TYPE_PRE
- en: 'The main application for this feature is when writing validation and assertion
    libraries. In the following example, an exception is thrown, whose message includes
    the text “2 + 2 == 5”. This aids in debugging:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE300]'
  prefs: []
  type: TYPE_PRE
- en: 'Another example is the static `ThrowIfNull` method on the `ArgumentNullException`
    class. This method was introduced in .NET 6 and is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE301]'
  prefs: []
  type: TYPE_PRE
- en: 'It is used as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE302]'
  prefs: []
  type: TYPE_PRE
- en: You can use `[CallerArgumentExpression]` multiple times, to capture multiple
    argument expressions.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic Binding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Dynamic binding* defers *binding*—the process of resolving types, members,
    and operators—from compile time to runtime. Dynamic binding is useful when at
    compile time *you* know that a certain function, member, or operation exists,
    but the *compiler* does not. This commonly occurs when you are interoperating
    with dynamic languages (such as IronPython) and COM as well as for scenarios in
    which you might otherwise use reflection.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A dynamic type is declared with the contextual keyword `dynamic`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE303]'
  prefs: []
  type: TYPE_PRE
- en: A dynamic type tells the compiler to relax. We expect the runtime type of `d`
    to have a `Quack` method. We just can’t prove it statically. Because `d` is dynamic,
    the compiler defers binding `Quack` to `d` until runtime. To understand what this
    means requires distinguishing between *static binding* and *dynamic binding*.
  prefs: []
  type: TYPE_NORMAL
- en: Static Binding Versus Dynamic Binding
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The canonical binding example is mapping a name to a specific function when
    compiling an expression. To compile the following expression, the compiler needs
    to find the implementation of the method named `Quack`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE304]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s suppose that the static type of `d` is `Duck`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE305]'
  prefs: []
  type: TYPE_PRE
- en: In the simplest case, the compiler does the binding by looking for a parameterless
    method named `Quack` on `Duck`. Failing that, the compiler extends its search
    to methods taking optional parameters, methods on base classes of `Duck`, and
    extension methods that take `Duck` as its first parameter. If no match is found,
    you’ll get a compilation error. Regardless of what method is bound, the bottom
    line is that the binding is done by the compiler, and the binding utterly depends
    on statically knowing the types of the operands (in this case, `d`). This makes
    it *static binding*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s change the static type of `d` to `object`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE306]'
  prefs: []
  type: TYPE_PRE
- en: 'Calling `Quack` gives us a compilation error, because although the value stored
    in `d` can contain a method called `Quack`, the compiler cannot know it, because
    the only information it has is the type of the variable, which in this case is
    `object`. But let’s now change the static type of `d` to `dynamic`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE307]'
  prefs: []
  type: TYPE_PRE
- en: A `dynamic` type is like `object`—it’s equally nondescriptive about a type.
    The difference is that it lets you use it in ways that aren’t known at compile
    time. A dynamic object binds at runtime based on its runtime type, not its compile-time
    type. When the compiler sees a dynamically bound expression (which in general
    is an expression that contains any value of type `dynamic`), it merely packages
    up the expression such that the binding can be done later at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: At runtime, if a dynamic object implements `IDynamicMetaObjectProvider`, that
    interface is used to perform the binding. If not, binding occurs in almost the
    same way as it would have had the compiler known the dynamic object’s runtime
    type. These two alternatives are called *custom binding* and *language binding*.
  prefs: []
  type: TYPE_NORMAL
- en: Custom Binding
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Custom binding occurs when a dynamic object implements `IDynamicMetaObjectProvider`
    (IDMOP). Although you can implement IDMOP on types that you write in C#, and that
    is useful to do, the more common case is that you have acquired an IDMOP object
    from a dynamic language that is implemented in .NET on the Dynamic Language Runtime
    (DLR), such as IronPython or IronRuby. Objects from those languages implicitly
    implement IDMOP as a means to directly control the meanings of operations performed
    on them.
  prefs: []
  type: TYPE_NORMAL
- en: 'We discuss custom binders in greater detail in [Chapter 19](ch19.html#dynamic_programming),
    but for now, let’s write a simple one to demonstrate the feature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE308]'
  prefs: []
  type: TYPE_PRE
- en: The `Duck` class doesn’t actually have a `Quack` method. Instead, it uses custom
    binding to intercept and interpret all method calls.
  prefs: []
  type: TYPE_NORMAL
- en: Language Binding
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Language binding occurs when a dynamic object does not implement `IDynamic​Me⁠taObjectProvider`.
    It is useful when working around imperfectly designed types or inherent limitations
    in the .NET type system (we explore more scenarios in [Chapter 19](ch19.html#dynamic_programming)).
    A typical problem when using numeric types is that they have no common interface.
    We have seen that we can bind methods dynamically; the same is true for operators:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE309]'
  prefs: []
  type: TYPE_PRE
- en: The benefit is obvious—you don’t need to duplicate code for each numeric type.
    However, you lose static type safety, risking runtime exceptions rather than compile-time
    errors.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Dynamic binding circumvents static type safety, but not runtime type safety.
    Unlike with reflection ([Chapter 18](ch18.html#reflection_and_metadata)), you
    can’t circumvent member accessibility rules with dynamic binding.
  prefs: []
  type: TYPE_NORMAL
- en: By design, language runtime binding behaves as similarly as possible to static
    binding, had the runtime types of the dynamic objects been known at compile time.
    In our previous example, the behavior of our program would be identical if we
    hardcoded `Mean` to work with the `int` type. The most notable exception in parity
    between static and dynamic binding is for extension methods, which we discuss
    in [“Uncallable Functions”](#uncallable_functions).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Dynamic binding also incurs a performance hit. Because of the DLR’s caching
    mechanisms, however, repeated calls to the same dynamic expression are optimized—allowing
    you to efficiently call dynamic expressions in a loop. This optimization brings
    the typical overhead for a simple dynamic expression on today’s hardware down
    to less than 100 ns.
  prefs: []
  type: TYPE_NORMAL
- en: RuntimeBinderException
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If a member fails to bind, a `RuntimeBinderException` is thrown. You can think
    of this like a compile-time error at runtime:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE310]'
  prefs: []
  type: TYPE_PRE
- en: The exception is thrown because the `int` type has no `Hello` method.
  prefs: []
  type: TYPE_NORMAL
- en: Runtime Representation of Dynamic
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There is a deep equivalence between the `dynamic` and `object` types. The runtime
    treats the following expression as `true`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE311]'
  prefs: []
  type: TYPE_PRE
- en: 'This principle extends to constructed types and array types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE312]'
  prefs: []
  type: TYPE_PRE
- en: 'Like an object reference, a dynamic reference can point to an object of any
    type (except pointer types):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE313]'
  prefs: []
  type: TYPE_PRE
- en: 'Structurally, there is no difference between an object reference and a dynamic
    reference. A dynamic reference simply enables dynamic operations on the object
    it points to. You can convert from `object` to `dynamic` to perform any dynamic
    operation you want on an `object`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE314]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Reflecting on a type exposing (public) `dynamic` members reveals that those
    members are represented as annotated `object`s. For example,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE315]'
  prefs: []
  type: TYPE_PRE
- en: 'is equivalent to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE316]'
  prefs: []
  type: TYPE_PRE
- en: This allows consumers of that type to know that `Foo` should be treated as dynamic
    while allowing languages that don’t support dynamic binding to fall back to `object`.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic Conversions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `dynamic` type has implicit conversions to and from all other types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE317]'
  prefs: []
  type: TYPE_PRE
- en: For the conversion to succeed, the runtime type of the dynamic object must be
    implicitly convertible to the target static type. The preceding example worked
    because an `int` is implicitly convertible to a `long`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example throws a `RuntimeBinderException` because an `int` is
    not implicitly convertible to a `short`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE318]'
  prefs: []
  type: TYPE_PRE
- en: var Versus dynamic
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `var` and `dynamic` types bear a superficial resemblance, but the difference
    is deep:'
  prefs: []
  type: TYPE_NORMAL
- en: '`var` says, “Let the *compiler* figure out the type.”'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dynamic` says, “Let the *runtime* figure out the type.”'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To illustrate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE319]'
  prefs: []
  type: TYPE_PRE
- en: 'The static type of a variable declared with `var` can be `dynamic`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE320]'
  prefs: []
  type: TYPE_PRE
- en: Dynamic Expressions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Fields, properties, methods, events, constructors, indexers, operators, and
    conversions can all be called dynamically.
  prefs: []
  type: TYPE_NORMAL
- en: 'Trying to consume the result of a dynamic expression with a `void` return type
    is prohibited—just as with a statically typed expression. The difference is that
    the error occurs at runtime:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE321]'
  prefs: []
  type: TYPE_PRE
- en: 'Expressions involving dynamic operands are typically themselves dynamic because
    the effect of absent type information is cascading:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE322]'
  prefs: []
  type: TYPE_PRE
- en: 'There are a couple of obvious exceptions to this rule. First, casting a dynamic
    expression to a static type yields a static expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE323]'
  prefs: []
  type: TYPE_PRE
- en: 'Second, constructor invocations always yield static expressions—even when called
    with dynamic arguments. In this example, `x` is statically typed to a `StringBuilder`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE324]'
  prefs: []
  type: TYPE_PRE
- en: In addition, there are a few edge cases for which an expression containing a
    dynamic argument is static, including passing an index to an array and delegate
    creation expressions.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic Calls Without Dynamic Receivers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The canonical use case for `dynamic` involves a dynamic *receiver*. This means
    that a dynamic object is the receiver of a dynamic function call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE325]'
  prefs: []
  type: TYPE_PRE
- en: 'However, you can also call statically known functions with dynamic arguments.
    Such calls are subject to dynamic overload resolution, and can include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Static methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Instance constructors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Instance methods on receivers with a statically known type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the following example, the particular `Foo` that gets dynamically bound
    is dependent on the runtime type of the dynamic argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE326]'
  prefs: []
  type: TYPE_PRE
- en: 'Because a dynamic receiver is not involved, the compiler can statically perform
    a basic check to see whether the dynamic call will succeed. It checks whether
    a function with the correct name and number of parameters exists. If no candidate
    is found, you get a compile-time error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE327]'
  prefs: []
  type: TYPE_PRE
- en: Static Types in Dynamic Expressions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It’s obvious that dynamic types are used in dynamic binding. It’s not so obvious
    that static types are also used—wherever possible—in dynamic binding. Consider
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE328]'
  prefs: []
  type: TYPE_PRE
- en: The call to `Foo(o,d)` is dynamically bound because one of its arguments, `d`,
    is `dynamic`. But because `o` is statically known, the binding—even though it
    occurs dynamically—will make use of that. In this case, overload resolution will
    pick the second implementation of `Foo` due to the static type of `o` and the
    runtime type of `d`. In other words, the compiler is “as static as it can possibly
    be.”
  prefs: []
  type: TYPE_NORMAL
- en: Uncallable Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Some functions cannot be called dynamically. You cannot call the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Extension methods (via extension method syntax)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Members of an interface, if you need to cast to that interface to do so
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Base members hidden by a subclass
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding why this is so is useful in understanding dynamic binding.
  prefs: []
  type: TYPE_NORMAL
- en: 'Dynamic binding requires two pieces of information: the name of the function
    to call and the object upon which to call the function. However, in each of the
    three uncallable scenarios, an *additional type* is involved, which is known only
    at compile time. As of this writing, there’s no way to specify these additional
    types dynamically.'
  prefs: []
  type: TYPE_NORMAL
- en: When calling extension methods, that additional type is implicit. It’s the static
    class on which the extension method is defined. The compiler searches for it given
    the `using` directives in your source code. This makes extension methods compile-time-only
    concepts because `using` directives melt away upon compilation (after they’ve
    done their job in the binding process in mapping simple names to namespace-qualified
    names).
  prefs: []
  type: TYPE_NORMAL
- en: 'When calling members via an interface, you specify that additional type via
    an implicit or explicit cast. There are two scenarios for which you might want
    to do this: when calling explicitly implemented interface members and when calling
    interface members implemented in a type internal to another assembly. We can illustrate
    the former with the following two types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE329]'
  prefs: []
  type: TYPE_PRE
- en: 'To call the `Test` method, we must cast to the `IFoo` interface. This is easy
    with static typing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE330]'
  prefs: []
  type: TYPE_PRE
- en: 'Now consider the situation with dynamic typing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE331]'
  prefs: []
  type: TYPE_PRE
- en: 'The implicit cast shown in bold tells the *compiler* to bind subsequent member
    calls on `f` to `IFoo` rather than `Foo`—in other words, to view that object through
    the lens of the `IFoo` interface. However, that lens is lost at runtime, so the
    DLR cannot complete the binding. The loss is illustrated as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE332]'
  prefs: []
  type: TYPE_PRE
- en: 'A similar situation arises when calling a hidden base member: you must specify
    an additional type via either a cast or the `base` keyword—and that additional
    type is lost at runtime.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Should you need to invoke interface members dynamically, a workaround is to
    use the Uncapsulator open source library, available on NuGet and GitHub. Uncapsulator
    was written by the author to address this problem, and leverages *custom binding*
    to provide a better dynamic than `dynamic`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE333]'
  prefs: []
  type: TYPE_PRE
- en: Uncapsulator also lets you cast to base types and interfaces by name, dynamically
    call static members, and access nonpublic members of a type.
  prefs: []
  type: TYPE_NORMAL
- en: Operator Overloading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can overload operators to provide more natural syntax for custom types.
    Operator overloading is most appropriately used for implementing custom structs
    that represent fairly primitive data types. For example, a custom numeric type
    is an excellent candidate for operator overloading.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following symbolic operators can be overloaded:'
  prefs: []
  type: TYPE_NORMAL
- en: '| `+` (unary) | `-` (unary) | `!` | `˜` | `++` |'
  prefs: []
  type: TYPE_TB
- en: '| `--` | `+` | `-` | `*` | `/` |'
  prefs: []
  type: TYPE_TB
- en: '| `%` | `&` | `&#124;` | `^` | `<<` |'
  prefs: []
  type: TYPE_TB
- en: '| `>>` | `==` | `!=` | `>` | `<` |'
  prefs: []
  type: TYPE_TB
- en: '| `>=` | `<=` |  |  |  |'
  prefs: []
  type: TYPE_TB
- en: 'The following operators are also overloadable:'
  prefs: []
  type: TYPE_NORMAL
- en: Implicit and explicit conversions (with the `implicit` and `explicit` keywords)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `true` and `false` *operators* (not *literals*)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following operators are indirectly overloaded:'
  prefs: []
  type: TYPE_NORMAL
- en: The compound assignment operators (e.g., `+=`, `/=`) are implicitly overridden
    by overriding the noncompound operators (e.g., `+`, `/`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The conditional operators `&&` and `||` are implicitly overridden by overriding
    the bitwise operators `&` and `|`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Operator Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You overload an operator by declaring an *operator function*. An operator function
    has the following rules:'
  prefs: []
  type: TYPE_NORMAL
- en: The name of the function is specified with the `operator` keyword followed by
    an operator symbol.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The operator function must be marked `static` and `public`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The parameters of the operator function represent the operands.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The return type of an operator function represents the result of an expression.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At least one of the operands must be the type in which the operator function
    is declared.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the following example, we define a struct called `Note` representing a musical
    note and then overload the `+` operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE334]'
  prefs: []
  type: TYPE_PRE
- en: 'This overload allows us to add an `int` to a `Note`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE335]'
  prefs: []
  type: TYPE_PRE
- en: 'Overloading an operator automatically overloads the corresponding compound
    assignment operator. In our example, because we overrode `+`, we can use `+=`,
    too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE336]'
  prefs: []
  type: TYPE_PRE
- en: 'Just as with methods and properties, C# allows operator functions comprising
    a single expression to be written more tersely with expression-bodied syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE337]'
  prefs: []
  type: TYPE_PRE
- en: Checked operators
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'From C# 11, when you declare an operator function, you can also declare a `checked`
    version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE338]'
  prefs: []
  type: TYPE_PRE
- en: 'The checked version will be called inside checked expressions or blocks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE339]'
  prefs: []
  type: TYPE_PRE
- en: Overloading Equality and Comparison Operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Equality and comparison operators are sometimes overridden when writing structs,
    and in rare cases when writing classes. Special rules and obligations come with
    overloading the equality and comparison operators, which we explain in [Chapter 6](ch06.html#dotnet_fundamentals).
    A summary of these rules is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Pairing
  prefs: []
  type: TYPE_NORMAL
- en: The C# compiler enforces operators that are logical pairs to both be defined.
    These operators are (`==` `!=`), (`<` `>`), and (`<=` `>=`).
  prefs: []
  type: TYPE_NORMAL
- en: '`Equals` and `GetHashCode`'
  prefs: []
  type: TYPE_NORMAL
- en: In most cases, if you overload (`==`) and (`!=`), you must override the `Equals`
    and `GetHashCode` methods defined on `object` in order to get meaningful behavior.
    The C# compiler will give a warning if you do not do this. (See [“Equality Comparison”](#equality_comparison-id00016)
    for more details.)
  prefs: []
  type: TYPE_NORMAL
- en: '`IComparable` and `IComparable<T>`'
  prefs: []
  type: TYPE_NORMAL
- en: If you overload (`< >`) and (`<= >=`), you should implement `IComparable` and
    `IComparable<T>`.
  prefs: []
  type: TYPE_NORMAL
- en: Custom Implicit and Explicit Conversions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Implicit and explicit conversions are overloadable operators. These conversions
    are typically overloaded to make converting between strongly related types (such
    as numeric types) concise and natural.
  prefs: []
  type: TYPE_NORMAL
- en: 'To convert between weakly related types, the following strategies are more
    suitable:'
  prefs: []
  type: TYPE_NORMAL
- en: Write a constructor that has a parameter of the type to convert from.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write `To*XXX*` and (static) `From*XXX*` methods to convert between types.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As explained in the discussion on types, the rationale behind implicit conversions
    is that they are guaranteed to succeed and not lose information during the conversion.
    Conversely, an explicit conversion should be required either when runtime circumstances
    will determine whether the conversion will succeed or if information might be
    lost during the conversion.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we define conversions between our musical `Note` type and
    a double (which represents the frequency in hertz of that note):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE340]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Following our own guidelines, this example might be better implemented with
    a `ToFrequency` method (and a static `FromFrequency` method) instead of implicit
    and explicit operators.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Custom conversions are ignored by the `as` and `is` operators:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE341]'
  prefs: []
  type: TYPE_PRE
- en: Overloading true and false
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `true` and `false` operators are overloaded in the extremely rare case
    of types that are Boolean “in spirit” but do not have a conversion to `bool`.
    An example is a type that implements three-state logic: by overloading `true`
    and `false`, such a type can work seamlessly with conditional statements and operators—namely,
    `if`, `do`, `while`, `for`, `&&`, `||`, and `?:`. The `System.Data.SqlTypes.SqlBoolean`
    struct provides this functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE342]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code is a reimplementation of the parts of `SqlBoolean` necessary
    to demonstrate the `true` and `false` operators:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE343]'
  prefs: []
  type: TYPE_PRE
- en: Static Polymorphism
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [“Calling Static Virtual/Abstract Interface Members”](ch18.html#calling_static_virtualsolidusabstract_i),
    we introduced an advanced feature whereby an interface can define `static virtual`
    or `static abstract` members, which are then implemented as static members by
    classes and structs. Later, in [“Generic Constraints”](ch03.html#generic_constraints)
    we showed that applying an interface constraint to a type parameter gives a method
    access to that interface’s members. In this section, we’ll demonstrate how this
    enables *static polymorphism*, allowing for features such as generic math.
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate, consider the following interface, which defines a static method
    to create a random instance of some type `T`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE344]'
  prefs: []
  type: TYPE_PRE
- en: 'Suppose that we wish to implement this interface in the following record:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE345]'
  prefs: []
  type: TYPE_PRE
- en: 'With the help of the `System.Random` class (whose `Next` method generates a
    random integer), we can implement the static `CreateRandom` method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE346]'
  prefs: []
  type: TYPE_PRE
- en: 'To call this method via the interface, we use a *constrained type parameter*.
    The following method creates an array of test data using this approach:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE347]'
  prefs: []
  type: TYPE_PRE
- en: 'This line of code demonstrates its use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE348]'
  prefs: []
  type: TYPE_PRE
- en: Our call to the static `CreateRandom` method in `CreateTestData` is *polymorphic*
    because it works not just with `Point`, but with any type that implements `ICreateRandom<T>`.
    This is different from *instance* polymorphism, because we don’t need an *instance*
    of `ICreateRandom<T>` on which to call `CreateRandom`; we call `CreateRandom`
    on the type itself.
  prefs: []
  type: TYPE_NORMAL
- en: Polymorphic Operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Because operators are essentially static functions (see [“Operator Overloading”](#operator_overloading)),
    operators can also be declared as static virtual interface members:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE349]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The *self-referencing* type constraint in this interface definition is necessary
    to satisfy the compiler’s rules for operator overloading. Recall that when defining
    an operator function, at least one of the operands must be the type in which the
    operator function is declared. In this example, our operands are of type `T`,
    whereas the containing type is `IAddable<T>`, so we require a self-referencing
    type constraint to allow `T` to be treated as `IAddable<T>`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s how we can implement the interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE350]'
  prefs: []
  type: TYPE_PRE
- en: 'With a constrained type parameter, we can then write a method that calls our
    addition operator polymorphically (with edge-case handling omitted for brevity):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE351]'
  prefs: []
  type: TYPE_PRE
- en: Our call to the `+` operator (via the `+=` operator) is polymorphic because
    it binds to `IAddable<T>`, not `Point`. Hence, our `Sum` method works with all
    types that implement `IAddable<T>`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, an interface such as `IAddable<T>` would be much more useful if
    it were defined in the .NET runtime, and if all .NET numeric types implemented
    it. Fortunately, this is indeed the case from .NET 7: the `System.Numerics` namespace
    includes (a more sophisticated version of) `IAddable`, along with many other arithmetic
    interfaces—most of which are encompassed by `INumber<TSelf>`.'
  prefs: []
  type: TYPE_NORMAL
- en: Generic Math
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before .NET 7, code that performed arithmetic had to be hardcoded to a particular
    numeric type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE352]'
  prefs: []
  type: TYPE_PRE
- en: '.NET 7 introduced the `INumber<TSelf>` interface to unify arithmetic operations
    across numeric types. This means that you can now write a generic version of the
    preceding method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE353]'
  prefs: []
  type: TYPE_PRE
- en: '`INumber<TSelf>` is implemented by all real and integral numeric types in .NET
    (as well as `char`) and can be thought of as an umbrella interface, comprising
    other more granular interfaces for each kind of arithmetic operation (addition,
    subtraction, multiplication, division, modulus calculation, comparison, and so
    on), as well as interfaces for parsing and formatting. Here’s one such interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE354]'
  prefs: []
  type: TYPE_PRE
- en: 'The `static abstract +` operator is what allows the `+=` operator to work inside
    our `Sum` method. Also note the use of `static virtual` on the checked operator:
    this provides a default fallback behavior for implementors that don’t provide
    a checked version of the addition operator.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `System.Numerics` namespace also contains interfaces that are not part
    of `INumber` for operations specific to certain kinds of numbers (such as floating-point).
    To compute a root mean square, for instance, we can add the `IRootFunctions<T>`
    interface to the constraint list to expose its static `RootN` method to `T`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE355]'
  prefs: []
  type: TYPE_PRE
- en: Unsafe Code and Pointers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: C# supports direct memory manipulation via pointers within blocks of code marked
    as `unsafe`. Pointer types are useful for interoperating with native APIs, for
    accessing memory outside the managed heap, and in implementing micro-optimizations
    in performance-critical hotspots.
  prefs: []
  type: TYPE_NORMAL
- en: Projects that include unsafe code must specify `<AllowUnsafeBlocks>true</AllowUnsafeBlocks>`
    in the project file.
  prefs: []
  type: TYPE_NORMAL
- en: Pointer Basics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For every value type or reference type *V*, there is a corresponding pointer
    type *V**. A pointer instance holds the address of a variable. Pointer types can
    be (unsafely) cast to any other pointer type. Following are the main pointer operators:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Operator | Meaning |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `&` | The *address-of* operator returns a pointer to the address of a variable.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `*` | The *dereference* operator returns the variable at the address of a
    pointer. |'
  prefs: []
  type: TYPE_TB
- en: '| `->` | The *pointer-to-member* operator is a syntactic shortcut, in which
    `x->y` is equivalent to `(*x).y`. |'
  prefs: []
  type: TYPE_TB
- en: In keeping with C, adding (or subtracting) an integer offset to a pointer generates
    another pointer. Subtracting one pointer from another generates a 64-bit integer
    (on both 64-bit and 32-bit platforms).
  prefs: []
  type: TYPE_NORMAL
- en: Unsafe Code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'By marking a type, type member, or statement block with the `unsafe` keyword,
    you’re permitted to use pointer types and perform C style pointer operations on
    memory within that scope. Here is an example of using pointers to quickly process
    a bitmap:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE356]'
  prefs: []
  type: TYPE_PRE
- en: Unsafe code can run faster than a corresponding safe implementation. In this
    case, the code would have required a nested loop with array indexing and bounds
    checking. An unsafe C# method can also be faster than calling an external C function
    given that there is no overhead associated with leaving the managed execution
    environment.
  prefs: []
  type: TYPE_NORMAL
- en: The fixed Statement
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `fixed` statement is required to pin a managed object, such as the bitmap
    in the previous example. During the execution of a program, many objects are allocated
    and deallocated from the heap. To avoid unnecessary waste or fragmentation of
    memory, the garbage collector moves objects around. Pointing to an object is futile
    if its address could change while referencing it, so the `fixed` statement tells
    the garbage collector to “pin” the object and not move it around. This can have
    an impact on the efficiency of the runtime, so you should use fixed blocks only
    briefly, and you should avoid heap allocation within the fixed block.
  prefs: []
  type: TYPE_NORMAL
- en: Within a `fixed` statement, you can get a pointer to any value type, an array
    of value types, or a string. In the case of arrays and strings, the pointer will
    actually point to the first element, which is a value type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Value types declared inline within reference types require the reference type
    to be pinned, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE357]'
  prefs: []
  type: TYPE_PRE
- en: We describe the `fixed` statement further in [“Mapping a Struct to Unmanaged
    Memory”](ch24.html#mapping_a_struct_to_unmanaged_memory).
  prefs: []
  type: TYPE_NORMAL
- en: The Pointer-to-Member Operator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In addition to the `&` and `*` operators, C# also provides the C++ style `->`
    operator, which you can use on structs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE358]'
  prefs: []
  type: TYPE_PRE
- en: The stackalloc Keyword
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can allocate memory in a block on the stack explicitly by using the `stackalloc`
    keyword. Because it is allocated on the stack, its lifetime is limited to the
    execution of the method, just as with any other local variable (whose life hasn’t
    been extended by virtue of being captured by a lambda expression, iterator block,
    or asynchronous function). The block can use the `[]` operator to index into memory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE359]'
  prefs: []
  type: TYPE_PRE
- en: 'In [Chapter 23](ch23.html#spanless_thantgreater_than_and-id00089), we describe
    how you can use `Span<T>` to manage stack-allocated memory without using the `unsafe`
    keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE360]'
  prefs: []
  type: TYPE_PRE
- en: Fixed-Size Buffers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `fixed` keyword has another use, which is to create fixed-size buffers
    within structs (this can be useful when calling an unmanaged function; see [Chapter 24](ch24.html#native_and_com_interoperabilit)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE361]'
  prefs: []
  type: TYPE_PRE
- en: 'Fixed-size buffers are not arrays: if `Buffer` were an array, it would consist
    of a reference to an object stored on the (managed) heap, rather than 30 bytes
    within the struct itself.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `fixed` keyword is also used in this example to pin the object on the heap
    that contains the buffer (which will be the instance of `UnsafeClass`). Hence,
    `fixed` means two different things: fixed in *size* and fixed in *place*. The
    two are often used together, in that a fixed-size buffer must be fixed in place
    to be used.'
  prefs: []
  type: TYPE_NORMAL
- en: void*
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A *void pointer* (`void*`) makes no assumptions about the type of the underlying
    data and is useful for functions that deal with raw memory. An implicit conversion
    exists from any pointer type to `void*`. A `void*` cannot be dereferenced, and
    arithmetic operations cannot be performed on void pointers. Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE362]'
  prefs: []
  type: TYPE_PRE
- en: Native-Sized Integers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `nint` and `nuint` *native-sized* integer types (introduced in C# 9) are
    sized to match the address space of the process at runtime (in practice, 32 or
    64 bits). Native-sized integers behave like standard integers, with full support
    for arithmetic operations and overflow checking:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE363]'
  prefs: []
  type: TYPE_PRE
- en: Native-sized integers can be assigned 32-bit integer constants (but not 64-bit
    integer constants, because these might overflow at runtime). You can use an explicit
    cast to convert to or from other integral types.
  prefs: []
  type: TYPE_NORMAL
- en: You can use native-sized integers to represent memory addresses or offsets without
    the use of pointers. `nuint` is also a natural type for representing the length
    of a memory block.
  prefs: []
  type: TYPE_NORMAL
- en: 'When working with pointers, native-sized integers can improve efficiency because
    the result of subtracting two pointers in C# is always a 64-bit integer (`long`),
    which is inefficient on 32-bit platforms. By first casting the pointers to `nint`,
    the result of a subtraction is also `nint` (which will be 32 bits on a 32-bit
    platform):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE364]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: A good example of the real-world use of `nint` and `nuint` in conjunction with
    pointers is in the implementation of `Buffer.MemoryCopy`. You can see this in
    the .NET source code for *Buffer.cs* on GitHub, or by decompiling the method in
    ILSpy. A simplified version has also been included in the LINQPad samples for
    *C# 12 in a Nutshell*.
  prefs: []
  type: TYPE_NORMAL
- en: Runtime handling when targeting .NET 7+
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For projects that target .NET 7 or above, `nint` and `nuint` act as synonyms
    for the underlying .NET types `System.IntPtr` and `System.UIntPtr` (in the same
    way that `int` acts as a synonym for `System.Int32`). This works because the `IntPtr`
    and `UIntPtr` types (which have existed since .NET Framework 1.0, but with limited
    functionality) were enhanced in .NET 7 to enable full arithmetic capabilities
    and overflow checking with the C# compiler.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The addition of checked arithmetic capability to `IntPtr`/`UIntPtr` is technically
    a breaking change. However, the effects are limited, because legacy code that
    relies on `IntPtr` not honoring `checked` blocks will not break when merely *run*
    under .NET 7+; to break, the project must also be *recompiled* with a .NET 7+
    target. This means that library authors need not worry about the breaking change
    until they release a new version that specifically targets .NET 7 or later.
  prefs: []
  type: TYPE_NORMAL
- en: Runtime handling when targeting .NET 6 or below
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For projects that target .NET 6 or below (or .NET Standard), `nint` and `nuint`
    still use `IntPtr` and `UIntPtr` as their underlying runtime types. However, because
    the legacy `IntPtr` and `UIntPtr` types lack support for most arithmetic operations,
    the compiler fills in the gaps, making the `nint`/`nuint` types behave as they
    would in .NET 7+ (including allowing `checked` operations). You can think of an
    `nint`/`nuint` variable as an `IntPtr`/`UIntPtr` wearing a special hat. This hat
    is recognized by the compiler to mean “please treat me as a modern `IntPtr`/`UIntPtr`.”
    This hat is naturally lost should you later cast to an `IntPtr`/`UIntPtr`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE365]'
  prefs: []
  type: TYPE_PRE
- en: Function Pointers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A *function pointer* (from C# 9) is like a delegate, but without the indirection
    of a delegate instance; instead, it points directly to a method. A function pointer
    can point only to static methods, lacks multicast capability, and requires an
    `unsafe` context (because it bypasses runtime type safety). Its main purpose is
    to simplify and optimize interop with unmanaged APIs (see [“Callbacks from Unmanaged
    Code”](ch24.html#callbacks_from_unmanaged_code)).
  prefs: []
  type: TYPE_NORMAL
- en: 'A function pointer type is declared as follows (with the return type appearing
    last):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE366]'
  prefs: []
  type: TYPE_PRE
- en: 'This matches a function with this signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE367]'
  prefs: []
  type: TYPE_PRE
- en: 'The `&` operator creates a function pointer from a method group. Here’s a complete
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE368]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, `functionPointer` is not an *object* upon which you can call
    a method such as `Invoke` (or with a reference to a `Target` object). Instead,
    it’s a variable that points directly to the target method’s address in memory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE369]'
  prefs: []
  type: TYPE_PRE
- en: 'Like any other pointer, it’s not subject to runtime type checking. The following
    treats our function’s return value as a `decimal` (which, being longer than an
    `int`, means that we incorporate some random memory into the output):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE370]'
  prefs: []
  type: TYPE_PRE
- en: '[SkipLocalsInit]'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When C# compiles a method, it emits a flag that instructs the runtime to initialize
    the method’s local variables to their default values (by zeroing the memory).
    From C# 9, you can ask the compiler not to emit this flag by applying the `[Ski⁠p​LocalsI⁠nit]`
    attribute to a method (in the `System.Runtime.CompilerServices` namespace):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE371]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also apply this attribute to a type—which is equivalent to applying
    it to all of the type’s methods—or even an entire module (the container for an
    assembly):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE372]'
  prefs: []
  type: TYPE_PRE
- en: In normal safe scenarios, `[SkipLocalsInit]` has little effect on functionality
    or performance, because C#’s definite assignment policy requires that you explicitly
    assign local variables before they can be read. This means that the JIT optimizer
    is likely to emit the same machine code, whether or not the attribute is applied.
  prefs: []
  type: TYPE_NORMAL
- en: 'In an unsafe context, however, use of `[SkipLocalsInit]` can usefully save
    the CLR from the overhead of initializing value-typed local variables, creating
    a small performance gain with methods that make extensive use of the stack (through
    a large `stackalloc`). The following example prints uninitialized memory when
    `[SkipLocalsInit]` is applied (instead of all zeros):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE373]'
  prefs: []
  type: TYPE_PRE
- en: 'Interestingly, you can achieve the same result in a “safe” context through
    the use of `Span<T>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE374]'
  prefs: []
  type: TYPE_PRE
- en: Consequently, use of `[SkipLocalsInit]` requires that you compile your project
    with `<AllowUnsafeBlocks>` set to true—even if none of your methods are marked
    as `unsafe`.
  prefs: []
  type: TYPE_NORMAL
- en: Preprocessor Directives
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Preprocessor directives supply the compiler with additional information about
    regions of code. The most common preprocessor directives are the conditional directives,
    which provide a way to include or exclude regions of code from compilation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE375]'
  prefs: []
  type: TYPE_PRE
- en: 'In this class, the statement in `Foo` is compiled as conditionally dependent
    upon the presence of the `DEBUG` symbol. If we remove the `DEBUG` symbol, the
    statement is not compiled. You can define preprocessor symbols within a source
    file (as we have done) or at a project level in the *.csproj* file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE376]'
  prefs: []
  type: TYPE_PRE
- en: 'With the `#if` and `#elif` directives, you can use the `||`, `&&`, and `!`
    operators to perform *or*, *and*, and *not* operations on multiple symbols. The
    following directive instructs the compiler to include the code that follows if
    the `TESTMODE` symbol is defined and the `DEBUG` symbol is not defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE377]'
  prefs: []
  type: TYPE_PRE
- en: Keep in mind, however, that you’re not building an ordinary C# expression, and
    the symbols upon which you operate have absolutely no connection to *variables*—static
    or otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: The `#error` and `#warning` symbols prevent accidental misuse of conditional
    directives by making the compiler generate a warning or error given an undesirable
    set of compilation symbols. [Table 4-1](#preprocessor_directives-id00086) lists
    the preprocessor directives.
  prefs: []
  type: TYPE_NORMAL
- en: Table 4-1\. Preprocessor directives
  prefs: []
  type: TYPE_NORMAL
- en: '| Preprocessor directive | Action |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `#define *symbol*` | Defines `*symbol*` |'
  prefs: []
  type: TYPE_TB
- en: '| `#undef *symbol*` | Undefines `*symbol*` |'
  prefs: []
  type: TYPE_TB
- en: '| `#if *symbol* [*operator symbol2*]...` | `*symbol*` to test |'
  prefs: []
  type: TYPE_TB
- en: '|  | `*operator*`s are `==`, `!=`, `&&`, and `&#124;&#124;` followed by `#else`,
    `#elif`, and `#endif` |'
  prefs: []
  type: TYPE_TB
- en: '| `#else` | Executes code to subsequent `#endif` |'
  prefs: []
  type: TYPE_TB
- en: '| `#elif *symbol* [*operator symbol2*]` | Combines `#else` branch and `#if`
    test |'
  prefs: []
  type: TYPE_TB
- en: '| `#endif` | Ends conditional directives |'
  prefs: []
  type: TYPE_TB
- en: '| `#warning *text*` | `*text*` of the warning to appear in compiler output
    |'
  prefs: []
  type: TYPE_TB
- en: '| `#error *text*` | `*text*` of the error to appear in compiler output |'
  prefs: []
  type: TYPE_TB
- en: '| `#error version` | Reports the compiler version and exits |'
  prefs: []
  type: TYPE_TB
- en: '| `#pragma warning [disable &#124; restore]` | Disables/restores compiler warning(s)
    |'
  prefs: []
  type: TYPE_TB
- en: '| `#line [ *number* ["*file*"] &#124; hidden]` | `*number*` specifies the line
    in source code (a column can also be specified from C# 10); `*file*` is the filename
    to appear in computer output; `hidden` instructs debuggers to skip over code from
    this point until the next `#line` directive |'
  prefs: []
  type: TYPE_TB
- en: '| `#region *name*` | Marks the beginning of an outline |'
  prefs: []
  type: TYPE_TB
- en: '| `#endregion` | Ends an outline region |'
  prefs: []
  type: TYPE_TB
- en: '| `#nullable *option*` | See [“Nullable reference types”](ch01.html#nullable_reference_types-id00030)
    |'
  prefs: []
  type: TYPE_TB
- en: Conditional Attributes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An attribute decorated with the `Conditional` attribute will be compiled only
    if a given preprocessor symbol is present:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE378]'
  prefs: []
  type: TYPE_PRE
- en: The compiler will incorporate the `[Test]` attributes only if the `DEBUG` symbol
    is in scope for *file2.cs*.
  prefs: []
  type: TYPE_NORMAL
- en: Pragma Warning
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The compiler generates a warning when it spots something in your code that seems
    unintentional. Unlike errors, warnings don’t ordinarily prevent your application
    from compiling.
  prefs: []
  type: TYPE_NORMAL
- en: Compiler warnings can be extremely valuable in spotting bugs. Their usefulness,
    however, is undermined when you get *false* warnings. In a large application,
    maintaining a good signal-to-noise ratio is essential if the “real” warnings are
    to be noticed.
  prefs: []
  type: TYPE_NORMAL
- en: 'To this effect, the compiler allows you to selectively suppress warnings by
    using the `#pragma warning` directive. In this example, we instruct the compiler
    not to warn us about the field `Message` not being used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE379]'
  prefs: []
  type: TYPE_PRE
- en: Omitting the number in the `#pragma warning` directive disables or restores
    all warning codes.
  prefs: []
  type: TYPE_NORMAL
- en: If you are thorough in applying this directive, you can compile with the `/warnaserror`
    switch—this instructs the compiler to treat any residual warnings as errors.
  prefs: []
  type: TYPE_NORMAL
- en: XML Documentation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A *documentation comment* is a piece of embedded XML that documents a type
    or member. A documentation comment comes immediately before a type or member declaration
    and starts with three slashes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE380]'
  prefs: []
  type: TYPE_PRE
- en: 'Multiline comments can be done like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE381]'
  prefs: []
  type: TYPE_PRE
- en: 'Or like this (notice the extra star at the start):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE382]'
  prefs: []
  type: TYPE_PRE
- en: 'If you add the following option to your *.csproj* file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE383]'
  prefs: []
  type: TYPE_PRE
- en: 'the compiler extracts and collates documentation comments into the specified
    XML file. This has two main uses:'
  prefs: []
  type: TYPE_NORMAL
- en: If placed in the same folder as the compiled assembly, tools such as Visual
    Studio and LINQPad automatically read the XML file and use the information to
    provide IntelliSense member listings to consumers of the assembly of the same
    name.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Third-party tools (such as Sandcastle and NDoc) can transform the XML file into
    an HTML help file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Standard XML Documentation Tags
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here are the standard XML tags that Visual Studio and documentation generators
    recognize:'
  prefs: []
  type: TYPE_NORMAL
- en: '`<summary>`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE384]'
  prefs: []
  type: TYPE_PRE
- en: Indicates the tool tip that IntelliSense should display for the type or member;
    typically a single phrase or sentence.
  prefs: []
  type: TYPE_NORMAL
- en: '`<remarks>`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE385]'
  prefs: []
  type: TYPE_PRE
- en: Additional text that describes the type or member. Documentation generators
    pick this up and merge it into the bulk of a type or member’s description.
  prefs: []
  type: TYPE_NORMAL
- en: '`<param>`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE386]'
  prefs: []
  type: TYPE_PRE
- en: Explains a parameter on a method.
  prefs: []
  type: TYPE_NORMAL
- en: '`<returns>`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE387]'
  prefs: []
  type: TYPE_PRE
- en: Explains the return value for a method.
  prefs: []
  type: TYPE_NORMAL
- en: '`<exception>`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE388]'
  prefs: []
  type: TYPE_PRE
- en: Lists an exception that a method can throw (`cref` refers to the exception type).
  prefs: []
  type: TYPE_NORMAL
- en: '`<example>`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE389]'
  prefs: []
  type: TYPE_PRE
- en: Denotes an example (used by documentation generators). This usually contains
    both description text and source code (source code is typically within a `<c>`
    or `<code>` tag).
  prefs: []
  type: TYPE_NORMAL
- en: '`<c>`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE390]'
  prefs: []
  type: TYPE_PRE
- en: Indicates an inline code snippet. This tag is usually used within an `<example>`
    block.
  prefs: []
  type: TYPE_NORMAL
- en: '`<code>`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE391]'
  prefs: []
  type: TYPE_PRE
- en: Indicates a multiline code sample. This tag is usually used within an `<example>`
    block.
  prefs: []
  type: TYPE_NORMAL
- en: '`<see>`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE392]'
  prefs: []
  type: TYPE_PRE
- en: Inserts an inline cross-reference to another type or member. HTML documentation
    generators typically convert this to a hyperlink. The compiler emits a warning
    if the type or member name is invalid. To refer to generic types, use curly braces;
    for example, `cref="Foo{T,U}"`.
  prefs: []
  type: TYPE_NORMAL
- en: '`<seealso>`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE393]'
  prefs: []
  type: TYPE_PRE
- en: Cross-references another type or member. Documentation generators typically
    write this into a separate “See Also” section at the bottom of the page.
  prefs: []
  type: TYPE_NORMAL
- en: '`<paramref>`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE394]'
  prefs: []
  type: TYPE_PRE
- en: References a parameter from within a `<summary>` or `<remarks>` tag.
  prefs: []
  type: TYPE_NORMAL
- en: '`<list>`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE395]'
  prefs: []
  type: TYPE_PRE
- en: Instructs documentation generators to emit a bulleted, numbered, or table-style
    list.
  prefs: []
  type: TYPE_NORMAL
- en: '`<para>`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE396]'
  prefs: []
  type: TYPE_PRE
- en: Instructs documentation generators to format the contents into a separate paragraph.
  prefs: []
  type: TYPE_NORMAL
- en: '`<include>`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE397]'
  prefs: []
  type: TYPE_PRE
- en: Merges an external XML file that contains documentation. The path attribute
    denotes an XPath query to a specific element in that file.
  prefs: []
  type: TYPE_NORMAL
- en: User-Defined Tags
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Little is special about the predefined XML tags recognized by the C# compiler,
    and you are free to define your own. The only special processing done by the compiler
    is on the `<param>` tag (in which it verifies the parameter name and that all
    the parameters on the method are documented) and the `cref` attribute (in which
    it verifies that the attribute refers to a real type or member and expands it
    to a fully qualified type or member ID). You can also use the `cref` attribute
    in your own tags; it is verified and expanded just as it is in the predefined
    `<exception>`, `<permission>`, `<see>`, and `<seealso>` tags.
  prefs: []
  type: TYPE_NORMAL
- en: Type or Member Cross-References
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Type names and type or member cross-references are translated into IDs that
    uniquely define the type or member. These names are composed of a prefix that
    defines what the ID represents and a signature of the type or member. Following
    are the member prefixes:'
  prefs: []
  type: TYPE_NORMAL
- en: '| XML type prefix | ID prefixes applied to… |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `N` | Namespace |'
  prefs: []
  type: TYPE_TB
- en: '| `T` | Type (class, struct, enum, interface, delegate) |'
  prefs: []
  type: TYPE_TB
- en: '| `F` | Field |'
  prefs: []
  type: TYPE_TB
- en: '| `P` | Property (includes indexers) |'
  prefs: []
  type: TYPE_TB
- en: '| `M` | Method (includes special methods) |'
  prefs: []
  type: TYPE_TB
- en: '| `E` | Event |'
  prefs: []
  type: TYPE_TB
- en: '| `!` | Error |'
  prefs: []
  type: TYPE_TB
- en: The rules describing how the signatures are generated are well documented, although
    fairly complex.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of a type and the IDs that are generated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE398]**'
  prefs: []
  type: TYPE_NORMAL
