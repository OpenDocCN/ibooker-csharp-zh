- en: Chapter 8\. Matching with Patterns
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章。模式匹配
- en: Historically, developers have implemented business rules with various logical
    checks and comparisons. Sometimes the rules are complex—naturally leading to code
    that’s difficult to write, read, and maintain. Think about how often you’ve encountered
    multibranch logic with multivariate comparisons and multiple levels of nesting.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 历来，开发人员用各种逻辑检查和比较实现业务规则。有时这些规则很复杂，自然而然地导致代码难以编写、阅读和维护。想想你多少次遇到多分支逻辑、多变量比较和多层嵌套的情况。
- en: To help ease this complexity, modern programming languages have begun introducing
    pattern matching—features of the language that help match facts to results with
    declarative syntax. In C#, pattern matching manifests as a growing list of features
    added in each new version, especially from C# 7 and later.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助简化这种复杂性，现代编程语言已经开始引入模式匹配——这些语言的特性通过声明性语法帮助将事实与结果匹配。在 C# 中，模式匹配体现为一个不断增长的功能列表，特别是从
    C# 7 开始。
- en: The theme of this chapter revolves around hotel scheduling and using patterns
    for business rules. The criteria is usually around a type of customer such as
    Bronze, Silver, or Gold, with Gold being the highest level because those customers
    have more points from more frequent hotel stays.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的主题围绕酒店调度和使用模式进行业务规则。标准通常围绕客户类型如铜牌、银牌或金牌展开，金牌客户由于更频繁的酒店住宿而获得更多积分，是最高级别。
- en: This chapter discusses pattern matching for properties, tuples, and types. There’s
    also a couple of sections on logical operations and how they enable and simplify
    multiconditional patterns. Surprisingly, C# had some form of pattern matching
    since v1.0\. The first section of this chapter discusses the `is` and `as` operators
    and shows the new enhancements to the `is` operator.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论了属性、元组和类型的模式匹配。还有一些关于逻辑操作的部分，它们支持和简化多条件模式。令人惊讶的是，C# 从 v1.0 开始就具有某种形式的模式匹配。本章的第一部分讨论了
    `is` 和 `as` 操作符，并展示了 `is` 操作符的新增强功能。
- en: 8.1 Converting Instances Safely
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 8.1 安全地转换实例
- en: Problem
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: Your legacy code is weakly typed, relies on procedural patterns, and needs to
    be refactored.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 您的遗留代码是弱类型的，依赖于过程式模式，并且需要重构。
- en: Solution
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Here’s an interface and implementing classes that produce results we’re looking
    for:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个接口及其实现类，用于生成我们正在寻找的结果：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Here’s a method representing data returned in legacy nontyped instances:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个代表返回的遗留非类型化实例数据的方法：
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'And this code processes the legacy collection:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 并且这段代码处理遗留集合：
- en: '[PRE2]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Here’s more modern code that returns a strongly typed collection:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有更现代的代码，返回一个强类型集合：
- en: '[PRE3]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'And this code processes the strongly typed collection:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 并且这段代码处理强类型集合：
- en: '[PRE4]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The `Main` methods call both the legacy and modern versions:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`Main` 方法调用旧版和现代版：'
- en: '[PRE5]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Discussion
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: The `as` and `is` operators appeared in C# 1; you’re probably aware of and/or
    have used them. To recap, the `is` operator tells whether an object’s type is
    the same as the type being matched. The `as` operator performs a conversion of
    a reference type object to a specified type. The `as` operator returns `null`
    if the converted instance isn’t the specified type. This example also demonstrates
    a recent C# addition that allows both type checking and conversion with the `is`
    operator.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`as` 和 `is` 操作符在 C# 1 中就已经出现了；您可能已经知道并/或者已经使用过它们。简单回顾一下，`is` 操作符告诉您一个对象的类型是否与正在匹配的类型相同。`as`
    操作符将引用类型对象转换为指定类型。如果转换后的实例不是指定的类型，则 `as` 操作符返回 `null`。这个例子还展示了最近 C# 添加的功能，允许使用
    `is` 操作符进行类型检查和转换。'
- en: Most of the code we write today uses generic collections and it’s increasingly
    unnecessary to use weakly typed collections. I’ll go out on a limb here and say
    that you might adopt a rule of thumb to use generic collections as a default,
    with the exception being when you can’t avoid using weakly typed collections.
    One important situation where you have to use weakly typed collections is when
    maintaining legacy code that already uses them. Generics weren’t added until C#
    2, so you might encounter some old code with weakly typed collections. Another
    example is when you have a library you need or want to use that uses weakly typed
    collections. In practical terms, you might not want to rewrite that code because
    of the time and resources required—especially if it’s already tested and working
    well.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们今天大部分编写的代码使用泛型集合，越来越不需要使用弱类型集合。我敢说，你可能会采纳一个经验法则，以泛型集合作为默认选择，除非无法避免使用弱类型集合。必须使用弱类型集合的一个重要情况是维护已经使用它们的遗留代码。泛型直到
    C# 2 才添加，因此你可能会遇到一些使用弱类型集合的旧代码。另一个例子是当你需要或希望使用使用弱类型集合的库时。实际上，你可能不想重写该代码，因为需要的时间和资源——特别是如果它已经经过测试且运行良好。
- en: In the solution, the `GetWeakTypedSchedules` method returns an `ArrayList`,
    which is a weakly typed collection because it only operates on instances of type
    `Object`. The `ProcessLegacyCode` method calls `GetWeakTypedSchedules` and shows
    how to use the `as` and `is` operators.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在解决方案中，`GetWeakTypedSchedules` 方法返回一个 `ArrayList`，这是一个弱类型集合，因为它仅对 `Object` 类型的实例进行操作。`ProcessLegacyCode`
    方法调用 `GetWeakTypedSchedules` 并展示了如何使用 `as` 和 `is` 运算符。
- en: The first `if` statement in the `foreach` loop uses the `is` operator to determine
    whether the object is an `IRoomSchedule`. If so, it uses a cast operator to get
    an `IRoomSchedule` instance and calls `GetSchedule`. You might ask why the `is`
    operator is necessary if we already know that the collection contains `IRoomSchedule`
    instances—why don’t we just go straight for the conversion? The problem is that
    there isn’t a guarantee of what the types in that collection are. What if a developer
    accidentally loads an object that isn’t `IRoomSchedule` into the collection? The
    `is` operator improves the reliability of the code.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个 `foreach` 循环中的第一个 `if` 语句使用 `is` 运算符来确定对象是否为 `IRoomSchedule`。如果是，它使用转型运算符获取
    `IRoomSchedule` 实例并调用 `GetSchedule`。如果我们已经知道集合包含 `IRoomSchedule` 实例，为什么还需要 `is`
    运算符呢？为什么不直接进行转换？问题在于，并不保证集合中的类型是什么。如果开发人员意外加载了一个不是 `IRoomSchedule` 的对象进入集合怎么办？`is`
    运算符提高了代码的可靠性。
- en: An alternative to the `is` operator is the `as` operator. In the solution, the
    `schedule as IRoomSchedule` performs the conversion. If the result isn’t `null`,
    the object is an `IRoomSchedule`. This approach could perform better because an
    `is` operation both checks the type and still requires a conversion, whereas the
    `as` operator only requires a conversion and a `null` check.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `is` 运算符相对的是 `as` 运算符。在解决方案中，`schedule as IRoomSchedule` 执行转换。如果结果不是 `null`，则对象是
    `IRoomSchedule`。这种方法可能性能更好，因为 `is` 操作既检查类型又需要转换，而 `as` 运算符只需要转换和 `null` 检查。
- en: The final `if` statement demonstrates the newer `is` operator syntax. It does
    both the type check and conversion, assigning the result to the `isRoomSchedule`
    variable. The `isRoomSchedule` variable is `null` if `schedule` wasn’t an `IRoomSchedule`,
    but since the `is` operator returned a `bool` result, we don’t need to do the
    extra `null` check.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个 `if` 语句演示了更新的 `is` 运算符语法。它既进行类型检查又进行转换，并将结果赋给 `isRoomSchedule` 变量。如果 `schedule`
    不是 `IRoomSchedule`，则 `isRoomSchedule` 变量为 `null`，但由于 `is` 运算符返回了一个 `bool` 结果，我们不需要额外的
    `null` 检查。
- en: The `GetStrongTypedSchedules` and `ProcessModernCode` show how you would probably
    want to write the code today. Notice how it has less ceremony because of the strong
    typing. Each class implements the same interface, and the collection is that interface,
    allowing you to write code that operates efficiently on every object.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetStrongTypedSchedules` 和 `ProcessModernCode` 展示了今天你可能想要编写的代码。请注意，由于强类型化，它具有更少的仪式感。每个类都实现了相同的接口，集合就是该接口，允许你编写有效地操作每个对象的代码。'
- en: This example also demonstrates that the new `is` operator can be useful in current
    code (not only legacy). In `ProcessModernCode`, even though all the objects implement
    `IRoomSchedule`, the `is` operator lets us check for `GoldSchedule` and do some
    extra processing.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子还展示了新的`is`运算符在当前代码中可以很有用（不仅限于旧代码）。在`ProcessModernCode`中，即使所有对象都实现了`IRoomSchedule`，`is`运算符也让我们能够检查`GoldSchedule`并进行一些额外处理。
- en: 8.2 Catching Filtered Exceptions
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 8.2 捕获筛选后的异常
- en: Problem
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You need to handle logic for the same exception type with different conditions.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要处理相同异常类型的不同条件逻辑。
- en: Solution
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'This is a demo class that throws exceptions:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个演示抛出异常的演示类：
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This `Main` method uses exception filters for clean processing:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`Main`方法使用异常过滤器来进行清晰的处理：
- en: '[PRE7]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Discussion
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: An interesting addition to C#, related to pattern matching, is the exception
    filter. As you know, `catch` blocks operate on the type of exception thrown. However,
    when the same exception type can be thrown for different reasons, sometimes it’s
    useful to be able to differentiate processing for each reason. While you could
    add `if` or `switch` statements in the `catch` block, filters offer a clean way
    to separate and simplify the different logic.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: C#中一个有趣的补充，与模式匹配相关，是异常过滤器。如你所知，`catch`块根据抛出的异常类型进行操作。然而，当同一类型的异常由于不同原因可能被抛出时，有时能够区分每个原因的处理方式会很有用。虽然你可以在`catch`块中添加`if`或`switch`语句，但过滤器提供了一种清晰分离和简化不同逻辑的方式。
- en: In the solution, we’re interested in filtering `ArgumentNullException`, depending
    on which parameter is `null`. The `ScheduleRoom` method checks each parameter
    and throws `ArgumentNullException` if either is `null`.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在解决方案中，我们希望根据参数是`null`来过滤`ArgumentNullException`。`ScheduleRoom`方法检查每个参数，如果任一参数为`null`，则抛出`ArgumentNullException`。
- en: The `Main` method wraps the call to `ScheduleRoom` in a `try`/`catch` block.
    This example has two `catch` blocks, each of type `ArgumentNullException`. The
    difference between the two is the filter, specified by the `when` clause. The
    parameter to `when` is a `bool` expression. In the solution, the expression compares
    the `ParamName` to the parameter name it’s designed to handle.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`Main`方法在`try`/`catch`块中包装对`ScheduleRoom`的调用。这个例子有两个`catch`块，每个均为`ArgumentNullException`类型。两者之间的区别在于过滤器，由`when`子句指定。`when`子句的参数是一个布尔表达式。在解决方案中，表达式比较了`ParamName`与其处理的参数名。'
- en: 8.3 Simplifying Switch Assignments
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 8.3 简化`switch`分配
- en: Problem
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to return a value, based on some criteria, but don’t want to return
    from every `switch` case.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 你想根据某些条件返回一个值，但不想从每一个`switch`分支中返回。
- en: Solution
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Here’s an interface and implementing classes that are results we’re looking
    for:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个接口及其实现类，是我们寻找的结果：
- en: '[PRE8]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This enum is used in upcoming logic:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这个枚举将在即将进行的逻辑中使用：
- en: '[PRE9]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This class shows the `switch` statement and new `switch` expression:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类展示了`switch`语句和新的`switch`表达式：
- en: '[PRE10]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The `Main` method tests the code:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`Main`方法测试代码：'
- en: '[PRE11]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Discussion
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: The `switch` statement has been around since C# 1, and a recent addition is
    a `switch` expression. The main syntactic features of the `switch` expression
    are a shorthand notation and the ability to assign a result to a variable. If
    you think about all the times you’ve used a `switch` statement, you might have
    noticed that producing a value or new instance was a common theme. The `switch`
    expression streamlines that theme and improves upon it with pattern matching.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`switch`语句从C# 1开始存在，而最近的增加是`switch`表达式。`switch`表达式的主要语法特性是一种简写表示法和将结果分配给变量的能力。如果你思考过你使用`switch`语句的所有情况，你可能会注意到产生值或新实例是一个常见主题。`switch`表达式简化了这个主题，并通过模式匹配进一步改进它。'
- en: 'The solution has two examples: a `switch` statement and a `switch` expression.
    Both rely on the `ScheduleType` enum for criteria and produce an `IRoomSchedule`
    type, based on that criteria.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案有两个例子：一个是`switch`语句，一个是`switch`表达式。两者都依赖于`ScheduleType`枚举来进行条件判断，并根据此条件生成一个`IRoomSchedule`类型的结果。
- en: The `CreateStatement` method uses a `switch` statement, with `case` clauses
    for each member of the `ScheduleType` enum. Notice how it returns the value from
    the method and that it requires normal block body syntax (with curly braces).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`CreateStatement`方法使用了`switch`语句，其中有针对`ScheduleType`枚举的每个成员的`case`分支。注意它如何从方法中返回值，以及它需要普通的块体语法（带有花括号）。'
- en: The `CreateExpression` method uses the new `switch` expression. Notice that
    the method can be command body (with arrow), returning the expression. Instead
    of a parameter in parentheses after the `switch` keyword, the parameter precedes
    the `switch` keyword. Also, instead of `case` clauses, case pattern matches precede
    an arrow, with the result expression after the arrow. The default case is the
    discard pattern, `_`.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`CreateExpression`方法使用了新的`switch`表达式。请注意，该方法可以是命令体（带箭头），返回表达式。与`switch`关键字后面的括号中的参数不同，参数位于`switch`关键字之前。此外，与`case`子句不同，案例模式匹配出现在箭头之前，箭头后的结果表达式。默认情况是丢弃模式`_`。'
- en: Whenever the parameter matches the case pattern, the `switch` expression returns
    the result. In the solution, the patterns are the values of the `ScheduleType`
    enum. The result of the `switch` expression is the result of the method because
    the command syntax of the method specifies the `switch` expression.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 每当参数与案例模式匹配时，`switch`表达式返回结果。在解决方案中，模式是`ScheduleType`枚举的值。`switch`表达式的结果是方法的结果，因为方法的命令语法指定了`switch`表达式。
- en: If you have a use case where there’s logic to process for each case, but don’t
    need to return, a classic `switch` statement might make more sense. However, if
    you can use pattern matching and need to return a value, the `switch` expression
    can be an excellent choice.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有一个用例，其中逻辑需要处理每个情况，但不需要返回值，那么经典的`switch`语句可能更合适。但是，如果您可以使用模式匹配并需要返回值，那么`switch`表达式可能是一个很好的选择。
- en: 8.4 Switching on Property Values
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 8.4 切换属性值
- en: Problem
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You need business rules based on strongly typed class properties.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要基于强类型类属性的业务规则。
- en: Solution
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Here’s a class with properties that we need to evaluate:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个具有我们需要评估的属性的类：
- en: '[PRE12]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This enum is the result of the evaluation:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这个枚举是评估的结果：
- en: '[PRE13]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This method gets the data we need:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法获取我们需要的数据：
- en: '[PRE14]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This method uses that data and returns an enum, based on matching pattern:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法使用该数据并根据匹配模式返回枚举：
- en: '[PRE15]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The `Main` method drives the program:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`Main`方法驱动程序：'
- en: '[PRE16]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Discussion
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: In the past, a `switch` statement matched cases with the value of a single parameter.
    Now, you can do parameter matching based on the values of properties in an object.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 以前，`switch`语句根据单个参数的值匹配情况。现在，您可以根据对象属性的值进行参数匹配。
- en: The solution uses an instance of the `Room` class as the parameter to a `switch`
    expression in the `AssignRoom` method. The pattern is an object with the properties
    of `Room` and the values to match. The result returned is based on which pattern
    the properties of the parameter match.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案使用`Room`类的实例作为`AssignRoom`方法中`switch`表达式的参数。模式是具有参数属性和匹配值的对象。返回的结果基于参数属性匹配哪种模式而确定。
- en: The goal of the program is to find an available room for a customer. The purpose
    of `AssignRoom` is to return the first room associated with a specific schedule
    type. That’s why `AssignRoom` compares `roomType` and `scheduleType`, returning
    if they match.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序的目标是为客户找到一个可用的房间。`AssignRoom`的目的是返回与特定调度类型关联的第一个房间。这就是为什么`AssignRoom`比较`roomType`和`scheduleType`，如果它们匹配，则返回的原因。
- en: Property pattern matching is a nice approach because it’s easy to read. This
    potentially translates into more maintainable code. One trade-off is that it can
    be verbose if you’re matching a lot of properties. The next recipe offers shorter
    syntax.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 属性模式匹配是一种很好的方法，因为它易于阅读。这可能会转化为更可维护的代码。一个权衡是，如果要匹配许多属性，则可能会很冗长。下一个配方提供了更短的语法。
- en: See Also
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '[Recipe 8.5, “Switching on Tuples”](#switching_on_tuples)'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '[配方 8.5，“切换元组”](#switching_on_tuples)'
- en: 8.5 Switching on Tuples
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 8.5 切换元组
- en: Problem
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You need business rules and prefer shorter syntax.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要基于业务规则，并且更喜欢更短的语法。
- en: Solution
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'This class is interesting because it has a deconstructor:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类很有趣，因为它有一个析构函数：
- en: '[PRE17]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Here’s an enum that this program will produce:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这是程序将生成的枚举：
- en: '[PRE18]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Here’s the data the program will work with:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这是程序将使用的数据：
- en: '[PRE19]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'And this method uses the tuple returned from the class deconstructor to determine
    which enum to return:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 并且这个方法使用从类析构函数返回的元组来确定要返回的枚举：
- en: '[PRE20]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The `Main` method drives the program:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`Main`方法驱动程序：'
- en: '[PRE21]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Discussion
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: Throughout this book, you’ve seen how useful tuples are for situations where
    you want to manage a set of values without all the ceremony of a custom type.
    The quick syntax of tuples makes them ideal for simple pattern matching.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，你已经看到了元组在管理一组值时有多么有用，而无需所有自定义类型的繁文缛节。元组的快速语法使它们成为简单模式匹配的理想选择。
- en: In this example, we do have a custom type, `Room`. Notice that `Room` has a
    custom deconstructor, which we’ll use in this solution. The `GetRooms` method
    returns a `List<Room>`. `AssignRooms` uses that collection. However, because of
    the deconstructor, we can use each room as a `switch` expression parameter, which
    is smart enough to use the deconstructor to produce a tuple for pattern matching.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们有一个自定义类型`Room`。注意`Room`有一个自定义的解构器，在这个解决方案中我们将使用它。`GetRooms`方法返回一个`List<Room>`。`AssignRooms`使用了那个集合。然而，由于解构器的存在，我们可以将每个房间用作`switch`表达式参数，它足够聪明以使用解构器生成用于模式匹配的元组。
- en: Except for using tuples through a deconstructor, this demo is the same as [Recipe
    8.4](#switching_on_property_values). In this example, the tuple offered a shorter
    syntax. The property pattern is more verbose but easier to read. One consideration
    is that if you’re matching scalar values, like `bool` or `int`, the property pattern
    documents better. If you’re matching strings or enums, a tuple might provide the
    best of both worlds in terms of readability and shorter syntax. Because the choice
    between the two approaches is situational, it’s best to evaluate trade-offs in
    each situation to see what makes sense to you.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 除了通过解构器使用元组外，这个演示与[Recipe 8.4](#switching_on_property_values)相同。在这个例子中，元组提供了更简洁的语法。属性模式更冗长但更易读。一个考虑因素是，如果你匹配标量值，比如`bool`或`int`，属性模式更好地记录了文档。如果你匹配字符串或枚举，元组可能在可读性和更短语法方面提供了最佳选择。因为两种方法之间的选择是情境性的，最好在每种情况下评估权衡，看看哪种对你更有意义。
- en: See Also
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '[Recipe 8.4, “Switching on Property Values”](#switching_on_property_values)'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '[Recipe 8.4，“基于属性值切换”](#switching_on_property_values)'
- en: 8.6 Switching on Position
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 8.6 位置切换
- en: Problem
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You need business rules based on values but don’t want to create a new single-use
    class.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要基于值的业务规则，但不想创建一个新的一次性类。
- en: Solution
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'This enum is the result we’ll look for:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这个枚举是我们将要寻找的结果：
- en: '[PRE22]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Here’s a class used for specifying decision criteria:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个用于指定决策标准的类：
- en: '[PRE23]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'These methods simulate getting data from two sources:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法模拟了从两个源获取数据的情况：
- en: '[PRE24]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This method joins those data sources to produce a list of tuples:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法将这些数据源连接起来，生成一个元组列表：
- en: '[PRE25]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This method shows the business logic based on positional pattern matching:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法展示了基于位置模式匹配的业务逻辑：
- en: '[PRE26]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The `Main` method drives the process:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`Main`方法驱动这个过程：'
- en: '[PRE27]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Discussion
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: The solution here is similar to [Recipe 8.5](#switching_on_tuples), in that
    it also uses tuples for pattern matching. This solution differs in that it explores
    the situation where you have two different sources of data, shown in `GetHotel1Rooms`
    and `GetHotel2Rooms`, simulating what would normally be database queries. This
    can happen when companies merge or form partnerships and their data is similar
    but not entirely alike.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的解决方案类似于[Recipe 8.5](#switching_on_tuples)，因为它也使用元组进行模式匹配。这个解决方案的不同之处在于它探讨了当你有两个不同数据源的情况，分别在`GetHotel1Rooms`和`GetHotel2Rooms`中展示，模拟了通常会是数据库查询的情况。这种情况可能发生在公司合并或形成合作伙伴关系时，它们的数据相似但并非完全相同。
- en: The `GetRooms` method shows how to use the LINQ `Union` operator to combine
    the two lists. Rather than create a new type for the combination of values we
    need, the method builds a collection of tuples.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetRooms`方法展示了如何使用LINQ的`Union`运算符来合并这两个列表。方法构建了一个元组集合，而不是为我们需要的值组合创建一个新类型。'
- en: When `AssignRooms` calls `GetRooms`, you don’t need a deconstructor on an object
    because you’re already working with tuples. This is a useful technique if you’re
    working with third-party types where you can’t modify their members.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 当`AssignRooms`调用`GetRooms`时，你不需要在对象上使用解构器，因为你已经在使用元组。如果你正在使用第三方类型而无法修改其成员，这是一种有用的技术。
- en: 'Inside of `AssignRoom`, the `switch` expression uses tuples for the match.
    What’s immediately noticeable here is the first parameter, representing the `Room.Number`
    property—there’s a discard symbol for each pattern. Clearly, this could have been
    omitted in `GetRooms`, but I wrote it that way to make a couple of points: value
    positions must match and every value is required.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在`AssignRoom`内部，`switch`表达式使用元组进行匹配。在这里立即引人注目的是第一个参数，表示`Room.Number`属性 - 每个模式都有一个丢弃符号。显然，这在`GetRooms`中可以被省略，但我以这种方式编写是为了阐明几个观点：值的位置必须匹配，并且每个值都是必需的。
- en: Tuple patterns require values to be in the proper positions (e.g., you can’t
    swap `Number` and `Size`). The position of each pattern value must match the corresponding
    tuple position. In contrast, property patterns can be in any order and differ
    between cases.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 元组模式要求值位于正确的位置（例如，不能交换`Number`和`Size`）。每个模式值的位置必须与相应元组位置匹配。相比之下，属性模式可以任意顺序且在不同情况下不同。
- en: For tuples, you must include a value for each position of the tuple. Therefore,
    even if you don’t use a position in a pattern, you must at least specify the discard
    parameter. Property patterns don’t have this restriction, allowing you to add
    or ignore whatever properties you want for the pattern.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 对于元组，您必须包括元组每个位置的值。因此，即使在模式中不使用位置，也必须至少指定丢弃参数。属性模式没有此限制，允许您添加或忽略模式中想要的任何属性。
- en: See Also
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '[Recipe 8.5, “Switching on Tuples”](#switching_on_tuples)'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '[8.5 "元组切换"](https://example.org/switching_on_tuples)的食谱'
- en: 8.7 Switching on Value Ranges
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 8.7 值范围切换
- en: Problem
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: Your business rules are continuous, rather than discrete.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 您的业务规则是连续的，而不是离散的。
- en: Solution
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Here’s an interface, as well as implementing classes that are results we’re
    looking for:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个接口，以及实现类，我们正在寻找的结果：
- en: '[PRE28]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This method uses relational pattern matching to produce results:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法使用关系模式匹配来生成结果：
- en: '[PRE29]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The `Main` method drives the process:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`Main`方法驱动整个过程：'
- en: '[PRE30]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Discussion
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: Previous sections of this chapter explored pattern matching based on discrete
    values. The pattern had to be exact to match. However, there are a lot of situations
    where values are continuous, rather than discrete. An example of this is the solution
    in this section, where hotel customers could have a range of points in their accounts.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的前几节探讨了基于离散值的模式匹配。模式必须精确匹配才能成功。但是，有很多情况下，值是连续的，而不是离散的。本节中的解决方案就是一个例子，酒店客户的积分范围可能各不相同。
- en: In the solution, customers with points from 0 to 4,999 are Bronze. Those with
    points from 5,000 to 19,999 are Silver. Those with 20,000 points or more are Gold.
    The `SilverPoints` and `GoldPoints` constants in the solution define the boundaries.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在解决方案中，积分从0到4,999的客户为青铜。积分从5,000到19,999的客户为银。积分达到或超过20,000的客户为金。解决方案中的`SilverPoints`和`GoldPoints`常量定义了边界。
- en: The `Main` method asks how many points a customer has and passes that value
    to `GetSchedule`. This value can vary, depending on how many times a person booked
    a room or used other hotel services. Because of this, `GetSchedule` uses a `switch`
    expression based on those points. Instead of using a discrete pattern for the
    match, `GetSchedule` uses relational operators.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`Main`方法询问客户的积分数，并将该值传递给`GetSchedule`。这个值可能会变化，这取决于一个人预订房间或使用其他酒店服务的次数。因此，`GetSchedule`根据这些积分使用`switch`表达式。而不是使用离散模式进行匹配，`GetSchedule`使用关系运算符。'
- en: The first pattern asks if `points` is equal to or higher than `GoldPoints`.
    If not, `points` must be less, and the code checks to see if the points are equal
    to or higher than `SilverPoints`. Since we already evaluated the `GoldPoints`
    case, it follows that the range is between `SilverPoints` and less than `GoldPoints`.
    The final case, less than `SilverPoints`, documents the meaning of Bronze, but
    you could have easily replaced that with a discard pattern because the other two
    cases handled every other possibility, and Bronze is all that’s left.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个模式询问`points`是否等于或高于`GoldPoints`。如果不是，`points`必须更少，并且代码检查是否等于或高于`SilverPoints`。由于我们已经评估了`GoldPoints`情况，所以这意味着范围在`SilverPoints`和`GoldPoints`之间。最后一个情况，低于`SilverPoints`，说明了青铜的含义，但您可以很容易地用丢弃模式替换它，因为其他两种情况处理了所有其他可能性，而青铜是唯一剩下的。
- en: 8.8 Switching with Complex Conditions
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 8.8 复杂条件切换
- en: Problem
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: Your business rules are multiconditional.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 您的业务规则是多条件的。
- en: Solution
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Here’s an interface, as well as implementing classes that are results we’re
    looking for:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个接口，以及实现类，我们正在寻找的结果：
- en: '[PRE31]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This class describes the criteria to use:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 本课程描述了使用的标准：
- en: '[PRE32]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This method generates simulated data with various values to exercise our logic:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法生成具有各种值的模拟数据，以演示我们的逻辑：
- en: '[PRE33]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Here’s a method using complex logic in a `switch` expression:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个使用`switch`表达式中复杂逻辑的方法：
- en: '[PRE34]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The `Main` method iterates through results:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`Main`方法遍历结果：'
- en: '[PRE35]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Discussion
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: Sometimes conditions are so complex that the techniques shown in earlier sections
    of this chapter are inadequate for solving the problem. An example is the solution
    in this section that requires multiple conditions involving more than one property.
    Here, we use a `switch` expression with `when` clauses to specify matches.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候条件非常复杂，无法通过本章前面展示的技术解决问题。例如，本节中的解决方案需要涉及多个属性的多个条件。在这里，我们使用`switch`表达式和`when`子句来指定匹配。
- en: This scenario is based on a `Customer` type, indicating number of points and
    whether the customer has a free upgrade. The free upgrade could have been from
    a contest or hotel promotion activity. When scheduling a room, we want to make
    sure that the customer gets a room commensurate with their point level. Additionally,
    if they have the free upgrade option, they receive a room that is upgraded to
    the next higher level. For simplicity, we’re conveniently ignoring whether Gold
    has a free upgrade.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 此场景基于`Customer`类型，指示点数数量以及客户是否有免费升级。免费升级可能来自于比赛或酒店促销活动。在安排房间时，我们希望确保客户获得与其点数水平相称的房间。此外，如果他们有免费升级选项，则会获得升级到下一个更高级别的房间。为简便起见，我们方便地忽略了金牌是否有免费升级。
- en: The `GetSchedule` method operates on an instance of `Customer`. Both the cases
    for Gold and Silver result in a room at that level. Additionally, the `||` operator
    says that if `customer` is at the next lower level, but `HasFreeUpgrade` is `true`,
    then the result is a room at this higher level.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetSchedule`方法操作`Customer`的一个实例。金牌和银牌的情况都会导致相应级别的房间。此外，`||`运算符表示，如果`customer`处于下一个较低级别，但`HasFreeUpgrade`为`true`，则结果是此较高级别的房间。'
- en: Using logic like this can get complex fast. Notice the use of newlines and other
    spacing to add symmetry and consistency to reading the result.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这样的逻辑会很快变得复杂。请注意使用换行和其他间距来增加结果的对称性和一致性以方便阅读。
- en: While this technique can help when the logic is a bit more complex than a discrete
    pattern match, you might want to consider a threshold where using `if` statements
    might be a better implementation. One consideration is maintenance, because breaking
    each piece of the logic out can help with debugging, whereas a single expression
    with multiple conditions might not be immediately obvious.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 当逻辑比离散模式匹配复杂时，这种技术可以帮助您。您可能希望考虑使用`if`语句的阈值作为更好的实现。一个考虑因素是维护，因为将每个逻辑片段分解出来有助于调试，而单个表达式具有多个条件可能不会立即明显。
- en: 8.9 Using Logical Conditions
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 8.9 使用逻辑条件
- en: Problem
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want multiconditional logic to be more readable.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望多条件逻辑更易读。
- en: Solution
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Here’s a class to use as criteria:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个作为标准使用的类：
- en: '[PRE36]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This method simulates a data source:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法模拟数据源：
- en: '[PRE37]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'This method implements business rules with conditional logic in a `switch`
    expression:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法在`switch`表达式中实现了业务规则和条件逻辑：
- en: '[PRE38]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The `Main` method drives this process:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`Main`方法驱动此过程：'
- en: '[PRE39]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Discussion
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: '[Recipe 8.8](#switching_with_complex_conditions) described how to add complex
    logic to `switch` expressions. By complex, I’m referring to multiple conditions
    involving two or more properties. This contrasts with simple pattern matching
    for previous sections of this chapter that used property and tuple patterns. Somewhere
    in between these contrasting approaches of simple and complex is a moderate approach
    where you need logic isolated within individual properties.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '[Recipe 8.8](#switching_with_complex_conditions) 描述了如何向`switch`表达式添加复杂逻辑。在这里，我指的是涉及两个或更多属性的多个条件。这与本章先前使用的属性和元组模式进行简单模式匹配形成对比。在这些对比方法之间的某处，是一个需要逻辑隔离在各个属性内的适度方法。'
- en: The properties of interest in this solution are the `Points` and `Month` of
    the `Customer` class. Similar to earlier sections, the `Points` property contributes
    to receiving a room for a customer that has at least a certain number of points.
    The other condition, `Month`, is the month when the customer wants to book the
    room. Because of seasonal supply and demand, some months leave the hotel with
    more open rooms. Therefore, this application provides incentives, based on points,
    for customers to book rooms in the months with more open rooms.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 此解决方案中感兴趣的属性是 `Customer` 类的 `Points` 和 `Month`。与前几节类似，`Points` 属性有助于为至少具有一定数量点数的客户预订房间。另一个条件
    `Month` 是客户想要预订房间的月份。由于季节性供需，一些月份会留给酒店更多的空房。因此，此应用程序根据积分提供激励，鼓励客户在空房较多的月份预订房间。
- en: In the solution, you can see that there are `GoldPoints` and `SilverPoints`
    constants to tell which level a customer is. Also, there are constants for `May`,
    `Sep`, and `Dec`—the busy months. The logic will be to give a discount in the
    months that are not busy.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在解决方案中，你可以看到 `GoldPoints` 和 `SilverPoints` 常量，用于确定客户的等级。同时，还有 `May`，`Sep` 和
    `Dec` 这些繁忙月份的常量。逻辑是在非繁忙月份给予折扣。
- en: 'The pattern for the `switch` expression in `GetDiscount` matches on two properties:
    `Points` and `Month`. Notice how this code doesn’t rely on an object deconstructor
    and the original parameter is a class, rather than a tuple. `GetDiscount` creates
    an inline tuple for the `switch` expression.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetDiscount` 方法的 `switch` 表达式的模式匹配基于两个属性：`Points` 和 `Month`。请注意，这段代码不依赖于对象解构，而原始参数是一个类，而不是元组。`GetDiscount`
    为 `switch` 表达式创建了一个内联元组。'
- en: The pattern itself relies on relational operators for `Points`, as in [Recipe
    8.7](#switching_on_value_ranges).
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 模式本身依赖于 `Points` 的关系运算符，就像 [Recipe 8.7](#switching_on_value_ranges) 中一样。
- en: 'The `Month` pattern uses the new C# 9 logical operators: `and`, `not`, and
    `or`. The first expression ensures the customer receives a discount during the
    winter months, between `Sep` and `May`, except for `Dec`. The second pattern says
    that a Gold customer still gets a discount in `Dec`, except that it’s 10% instead
    of 15%.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '`Month` 模式使用了新的 C# 9 逻辑运算符：`and`，`not` 和 `or`。第一个表达式确保客户在冬季月份（`Sep` 到 `May`
    之间，除了 `Dec`）期间享受折扣。第二个模式表示金牌客户在 `Dec` 仍然享受折扣，但是折扣从 15% 变为 10%。'
- en: The last pattern is logically equivalent to the first and uses DeMorgan’s Theorem.
    That is, it negates the whole result and swaps `and` with `or`. Because the last
    example applies `not` to the entire expression, it uses parentheses. In the first
    pattern, `not` applied to `Dec` only.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个模式在逻辑上等同于第一个模式，并使用了德摩根定理。也就是说，它否定了整个结果，并交换了 `and` 和 `or`。因为最后一个示例将 `not`
    应用于整个表达式，所以它使用了括号。而在第一个模式中，`not` 仅应用于 `Dec`。
- en: See Also
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '[Recipe 8.7, “Switching on Value Ranges”](#switching_on_value_ranges)'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '[Recipe 8.7，“在值范围上进行切换”](#switching_on_value_ranges)'
- en: '[Recipe 8.8, “Switching with Complex Conditions”](#switching_with_complex_conditions)'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '[Recipe 8.8，“使用复杂条件进行切换”](#switching_with_complex_conditions)'
- en: 8.10 Switching on Type
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 8.10 类型切换
- en: Problem
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You need the type of an object for decision making.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要对象的类型来做出决定。
- en: Solution
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Here’s an interface, as well as implementing classes that are results we’re
    looking for:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个接口，以及实现了我们需要的结果的类：
- en: '[PRE40]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The following types represent criteria:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 以下类型代表条件：
- en: '[PRE41]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'This method simulates a data source:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法模拟了一个数据源：
- en: '[PRE42]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Here’s a method that implements logic based on type pattern matching:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个根据类型模式匹配实现逻辑的方法：
- en: '[PRE43]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The `Main` method iterates through the data to exercise the pattern matching
    logic:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`Main` 方法通过数据迭代来执行模式匹配逻辑：'
- en: '[PRE44]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Discussion
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: It used to be that the only way to make a decision on type was to either use
    `if` statements or convert the object’s type to a `string` and use a `switch`
    statement with `string` cases. A popular ask for C# over the years was to allow
    a `switch` statement with type cases, and now we finally have it.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 过去，唯一能够根据类型做出决策的方式是使用 `if` 语句或将对象类型转换为 `string`，并使用带有 `string` 情况的 `switch`
    语句。多年来对 C# 的一个常见请求是允许使用类型 case 的 `switch` 语句，现在我们终于有了。
- en: The solution has a set of classes for `GoldCustomer`, `SilverCustomer`, and
    `BronzeCustomer`, each deriving from `Customer`. Our goal in this program is to
    schedule a room, based on the matching class type.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案包含一组类：`GoldCustomer`，`SilverCustomer` 和 `BronzeCustomer`，它们都是从 `Customer`
    派生的。我们在这个程序中的目标是根据匹配的类类型安排一个房间。
- en: The `GetSchedule` method does the scheduling by accepting an object of type
    `Customer`, and the `switch` expression has a pattern for each of the classes
    that derive from `Customer`. All you need to do is specify the name of each class
    and the `switch` expression matches based on the object type.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetSchedule` 方法通过接受一个类型为 `Customer` 的对象来进行调度，而 `switch` 表达式针对从 `Customer`
    派生的每个类都有一个模式。你只需要指定每个类的名称，`switch` 表达式会根据对象类型进行匹配。'
