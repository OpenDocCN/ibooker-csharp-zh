["```cs\npublic static Maybe<TOut> Bind<TIn, TOut>(this Maybe<TIn> @this, Func<TIn, TOut> f)\n{\n\ttry\n\t{\n\t\tMaybe<TOut> updatedValue = @this switch\n\t\t{\n\t\t\tSomething<TIn> s when !EqualityComparer<TIn>.Default.Equals(s.Value, default) =>\n\t\t\t\tnew Something<TOut>(f(s.Value)),\n\t\t\tSomething<TIn> _ => new Nothing<TOut>(),\n\t\t\tNothing<TIn> _ => new Nothing<TOut>(),\n\t\t\tError<TIn> e => new Error<TOut>(e.ErrorMessage),\n\t\t\t_ => new Error<TOut>(new Exception(\"New Maybe state that isn't coded for!: \" + @this.GetType()))\n\t\t};\n\t\treturn updatedValue;\n\t}\n\tcatch (Exception e)\n\t{\n\t\treturn new Error<TOut>(e);\n\t}\n}\n```", "```cs\npublic string MakeGreeting(int employeeId)\n{\n try\n {\n  var e = this.empRepo.GetById(employeeId);\n  if(e != null)\n  {\n   return \"Hello \" + e.Salutation + \" \" + e.Name\n  }\n\n  return \"Employee not found\";\n }\n\n catch(Exception e)\n {\n   return \"An error occurred: \" + e.Message;\n }\n}\n```", "```cs\npublic Maybe<string> MakeGreeting(int employeeId) =>\n new Something(employeeId)\n  .Bind(x => this.empRepo.GetById(x))\n  .Bind(x => \"Hello \" + x.Salutation + \" \" + x.Name);\n```", "```cs\npublic Interface IUserInterface\n{\n void WriteMessage(string s);\n}\n\n// Bit of magic here because it doesn't matter\nthis.UserInterface = Factory.MakeUserInterface();\n\nvar message = makeGreetingResult switch\n{\n Something s => s.Value,\n Nothing _ => \"Hi, but I've never heard of you.\",\n Error _ => \"An error occurred, try again\"\n};\n\nthis.UserInterface.WriteMessage(message);\n```", "```cs\npublic Interface IUserInterface\n{\n void WriteMessage(Maybe<string> s);\n}\n\n// Bit of magic here because it doesn't matter\nthis.UserInterface = Factory.MakeUserInterface();\n\nvar logonMessage = MakeGreeting(employeeId)\n .Bind(x => x + Environment.NewLine + MakeUserInfo(employeeId));\nthis.UserInterface.WriteMessage(logonMessage);\n```", "```cs\nvar returnValue = idValue.ToMaybe()\n  .Bind(transformationOne)\n  .Bind(transformationTwo)\n  .Bind(transformationThree);\n```", "```cs\nvar idMaybe = idValue.ToMaybe();\nvar transOne = idMaybe.Bind(x => transformationOne(x));\nvar transTwo = transOne.Bind(x => transformationTwo(x));\nvar returnValue = transTwo.Bind(x => transformationThree(x));\n```", "```cs\npublic static Maybe<TOut> Map<TIn, TOut>(this Maybe<TIn> @this, Func<TIn, TOut> f) => // Some implementation here\n\npublic static Maybe<TOut> Bind<TIn, TOut>(this Maybe<TIn> @this, Func<TIn, Maybe<TOut>> f) => // Some Other implementation here\n```", "```cs\npublic static Maybe<TOut> Bind<TIn, TOut>(this Maybe<TIn> @this, Func<TIn, Maybe<TOut>> f)\n{\n\ttry\n\t{\n\t\tvar returnValue = @this switch\n\t\t{\n\t\t\tSomething<TIn> s => f(s.Value),\n\t\t\t_ => new Nothing<TOut>()\n\t\t};\n\t\treturn returnValue;\n\t}\n\tcatch (Exception _)\n\t{\n\t\treturn new Nothing<TOut>();\n\t}\n}\n```", "```cs\npublic Interface CustomerDataRepo\n{\n Maybe<Customer> GetCustomerById(int customerId);\n}\n\npublic string DescribeCustomer(int customerId) =>\n new Something<int>(customerId)\n  .Bind(x => this.customerDataRepo.GetCustomerById(x))\n  .Map(x => \"Hello \" + x.Name);\n```", "```cs\n[Fact]\npublic Task primitive_types_should_not_default_to_nothing()\n{\n\tvar input = new Something<int>(0);\n\tvar output = input.Bind(x => x + 10);\n\t(output as Something<int>).Value.Should().Be(10);\n}\n```", "```cs\npublic static Maybe<TOut> Bind<TIn, TOut>(this Maybe<TIn> @this, Func<TIn, TOut> f)\n{\n\ttry\n\t{\n\t\tMaybe<TOut> updatedValue = @this switch\n\t\t{\n\t\t\tSomething<TIn> s when !EqualityComparer<TIn>.Default.Equals(s.Value, default) =>\n\t\t\t\tnew Something<TOut>(f(s.Value)),\n\t\t\t\t// This is the new line\n\t\t\tSomething<TIn> s when s.GetType().GetGenericArguments()[0].IsPrimitive => new Something<TOut>(f(s.Value)),\n\t\t\tSomething<TIn> _ => new Nothing<TOut>(),\n\t\t\tNothing<TIn> _ => new Nothing<TOut>(),\n\t\t\tError<TIn> e => new Error<TOut>(e.ErrorMessage),\n\t\t\t_ => new Error<TOut>(new Exception(\"New Maybe state that isn't coded for!: \" + @this.GetType()))\n\t\t};\n\t\treturn updatedValue;\n\t}\n\tcatch (Exception e)\n\t{\n\t\treturn new Error<TOut>(e);\n\t}\n}\n```", "```cs\nvar idMaybe = idValue.ToMaybe();\nvar transOne = idMaybe.Bind(x => transformationOne(x));\nif(transOne is Something<MyClass> s)\n{\n this.Logger.LogInformation(\"Processing item \" + s.Value.Id);\n}\nelse if (transOne is Nothing<MyClass>)\n{\n this.Logger.LogWarning(\"No record found for \" + idValue\");\n}\nelse if (transOne is Error<MyClass> e)\n{\n this.Logger.LogError(e, \"An error occurred for \" + idValue);\n}\n```", "```cs\npublic static class MaybeLoggingExtensions\n{\n public static Maybe<T> OnSomething(this Maybe<T> @this, Action<T> a)\n {\n  if(@this is Something<T>)\n  {\n   a(@this);\n  }\n\n  return @this;\n }\n\n public static Maybe<T> OnNothing(this Maybe<T> @this, Action a)\n {\n  if(@this is Nothing<T> _)\n  {\n   a();\n  }\n\n  return @this;\n }\n}\n\n public static Maybe<T> OnError(this Maybe<T> @this, Action<Exception> a)\n {\n  if(@this is Error<T> e)\n  {\n   a(e.CapturedError);\n  }\n\n  return @this;\n }\n```", "```cs\nvar idMaybe  idValue.ToMaybe();\nvar transOne = idMaybe.Bind(x => transformationOne(x))\n .OnSomething(x => this.Logger.LogInformation(\"Processing item \" + x.Id))\n .OnNothing(() => this.Logger.LogWarning(\"No record found for \" + idValue))\n .OnError(e => this.Logger.LogError(e, \"An error occurred for \" + idValue));\n```", "```cs\nvar idMaybe  idValue.ToMaybe();\nvar transOne = idMaybe.Bind(x => transformationOne(x))\n .OnNothing(() => this.Logger.LogWarning(\"Nothing happened one\");\nvar transTwo = transOne.Bind(x => transformationTwo(x))\n .OnNothing(() => this.Logger.LogWarning(\"Nothing happened two\");\nvar returnValue = transTwo.Bind(x => transformationThree(x))\n  .OnNothing(() => this.Logger.LogWarning(\"Nothing happened three\");\n```", "```cs\npublic class UnhandledNothing<T> : Nothing<T>\n{\n}\n\npublic class UnhandledError<T> : Error<T>\n{\n}\n```", "```cs\npublic static Maybe<TOut> Bind<TIn, TOut>(this Maybe<TIn> @this, Func<TIn, TOut> f)\n{\n\ttry\n\t{\n\t\tMaybe<TOut> updatedValue = @this switch\n\t\t{\n\t\t\tSomething<TIn> s when !EqualityComparer<TIn>.Default.Equals(s.Value, default) =>\n\t\t\t\tnew Something<TOut>(f(s.Value)),\n\t\t\tSomething<TIn> s when s.GetType().GetGenericArguments()[0].IsPrimitive => new Something<TOut>(f(s.Value)),\n\t\t\tSomething<TIn> _ => new UnhandledNothing<TOut>(),\n\t\t\tNothing<TIn> _ => new Nothing<TOut>(),\n\t\t\tUnhandledNothing<TIn> _ => new UnhandledNothing<TOut>(),\n\t\t\tError<TIn> e => new Error<TOut>(e.ErrorMessage),\n\t\t\tUnhandledError<TIn> e => new UnhandledError<TOut>(e.CapturedError),\n\t\t\t_ => new Error<TOut>(new Exception(\"New Maybe state that isn't coded for!: \" + @this.GetType()))\n\t\t};\n\t\treturn updatedValue;\n\t}\n\tcatch (Exception e)\n\t{\n\t\treturn new UnhandledError<TOut>(e);\n\t}\n}\n```", "```cs\npublic static class MaybeLoggingExtensions\n{\n\n public static Maybe<T> OnNothing(this Maybe<T> @this, Action a)\n {\n  if(@this is UnhandledNothing<T> _)\n  {\n   a();\n   return new Nothing<T>();\n  }\n\n  return @this;\n }\n}\n\n public static Maybe<T> OnError(this Maybe<T> @this, Action<Exception> a)\n {\n  if(@this is UnhandledError<T> e)\n  {\n   a(e.CapturedError);\n   return new Error<T>(e.CapturedError);\n  }\n\n  return @this;\n }\n```", "```cs\npublic static async Task<Maybe<TOut>> BindAsync<TIn, TOut>(this Maybe<TIn> @this, Func<TIn, Task<TOut>> f)\n{\n\ttry\n\t{\n\t\tMaybe<TOut> updatedValue = @this switch\n\t\t{\n\t\t\tSomething<TIn> s when EqualityComparer<TIn>.Default.Equals(s.Value, default) =>\n\t\t\t\tnew Something<TOut>(await f(s.Value)),\n\t\t\tSomething<TIn> _ => new Nothing<TOut>(),\n\t\t\tNothing<TIn> _ => new Nothing<TOut>(),\n\t\t\tError<TIn> e => new Error<TOut>(e.ErrorMessage),\n\t\t\t_ => new Error<TOut>(new Exception(\"New Maybe state that isn't coded for!: \" + @this.GetType()))\n\t\t};\n\t\treturn updatedValue;\n\t}\n\tcatch (Exception e)\n\t{\n\t\treturn new Error<TOut>(e);\n\t}\n}\n```", "```cs\npublic interface DataLoaderOne\n{\n\tMaybe<string> GetStringOne();\n}\n\npublic interface DataLoaderTwo\n{\n\tMaybe<string> GetStringTwo(string stringOne);\n}\n\npublic interface DataLoaderThree\n{\n\tMaybe<string> GetStringThree(string stringTwo);\n}\n```", "```cs\n\tvar finalString = dataLoaderOne.GetStringOne()\n\t\t.Bind(x => dataLoaderTwo.GetStringTwo(x))\n\t\t.Bind(x => dataLoaderThree.GetStringThree(x));\n```", "```cs\npublic static Maybe<TOut> Bind<TIn, TOut>(\n\tthis Maybe<Maybe<TIn>> @this, Func<TIn, TOut> f)\n{\n\ttry\n\t{\n\t\tvar returnValue = @this switch\n\t\t{\n\t\t\tSomething<Maybe<TIn>> s => s.Value.Bind(f),\n\t\t\tError<Maybe<TIn>> e => new Error<TOut>(e.ErrorMessage),\n\t\t\tNothing<Maybe<TIn>> => new Nothing<TOut>(),\n\t\t\t_ => new Error<TOut>(new Exception(\"New Maybe state that isn't coded for!: \" + @this.GetType()))\n\n\t\t};\n\t\treturn returnValue;\n\n\t}\n\tcatch (Exception e)\n\t{\n\t\treturn new Error<TOut>(e);\n\t}\n}\n```", "```cs\npublic static async Task<Maybe<TOut>> BindAsync<TIn, TOut>(this Maybe<Maybe<TIn>> @this, Func<TIn, Task<TOut>> f)\n{\n try\n {\n \tvar returnValue = await @this.Bind(async x =>\n\t{\n\t\t  var updatedValue = @this switch\n\t\t  {\n\t\t   Something<TIn> s when\n\t\t    EqualityComparer<TIn>.Default.Equals(s.Value, default(TIn))  =>\n\t\t     new Something<TOut>(await f(s.Value)),\n\t\t   Something<TIn> _ => new Nothing<TOut>(),\n\t\t   Nothing<TIn> _ => new Nothing<TOut>(),\n\t\t   Error<TIn> e => new Error<TOut>(e.CapturedError)\n\t\t  }\n\t\t  return updatedValue;\n\t});\n  return returnValue;\n }\n catch(Exception e)\n {\n  return new Error<TOut>(e);\n }\n}\n```", "```cs\nFunc<int, int> MultiplyByTwo = x => x * 2;\nvar input = 100;\nvar runFunctionOutput = MultiplyByTwo(input);\n\nvar monadOutput = new Something<int>(input).Bind(MultiplyByTwo);\n\n// runFunctionOutput and monadOutput.Value should both\n// be identical - 200 - to conform to the Left Identity Law.\n```", "```cs\nFunc<int,int> identityInt = (int x) => x;\nvar input = 200;\nvar result = new Something<int>(input).Bind(identityInt);\n// result = 200\n```", "```cs\nvar input = 100;\nvar op1 = (int x) => x * 2;\nvar op2 = (int x) => x + 100;\n\nvar versionOne = new Something<int>(input)\n .Bind(op1)\n .Bind(op2);\n\n // versionOne.Value = 100 * 2 + 100 = 300\n\n var versionTwo = new Something<int>(input)\n  .Bind(x => new Something<int>(x).Bind(op1)).Bind(op2);\n\n  // If we don't implement something to fulfill the\n  // associativity law, we'll end up with a type of\n  // Something<Something<int>>, where we want this to be\n  // the exact same type and value as versionOne\n```", "```cs\npublic string MakeOrderReport(string userName) =>\n (\n  Conn: this.connFactory.MakeDbConnection(),\n  userid\n )\n  .Bind(x => (\n   x.Conn,\n   Customer: this.customerRepo.GetCustomer(x.Conn, x.userName)\n  )\n  .Bind(x => (\n   x.Conn,\n   Order: this.orderRepo.GetCustomerOrders(x.Conn, x.Customer.Id)\n  ),\n  .Bind(x => this.Order.Items.First())\n  .Bind(x => string.Join(\"\\r\\n\", x));\n```", "```cs\nvar reader = new Reader<int, string>(e => e.ToString());\nvar result = reader.Run(100);\n```", "```cs\nvar reader = new Reader<int, int>(e => e * 100)\n .Bind(x => x / 50)\n .Bind(x => x.ToString());\n\nvar result = reader.Run(100);\n```", "```cs\npublic Customre GetCustomerData(string userName, IDbConnection db) =>\n new Reader(this.customerRepo.GetCustomer(userName, x))\n .Run(db);\n```", "```cs\npublic Reader<IdbConnection, User> GetCustomerData(string userName) =>\n  new Reader(this.customerRepo.GetCustomer(userName, x));\n```", "```cs\nvar dbConn = this.DbConnectionFactory.GetConnection();\n\nvar orders = this._customerRepo.GetCustomerData(\"simon.painter\")\n .Bind(X => x.OrderData.ToArray())\n .Run(dbConn);\n```", "```cs\npublic interface IDataStore\n{\n Reader<int,Customer> GetCustomerData();\n Reader<Guid,Product> GetProductData();\n Reader<int,IEnumerable<Order>> GetCustomerOrders();\n}\n```", "```cs\npublic class State<TS, TV>\n{\n\tpublic TS CurrentState { get; init; }\n\tpublic TV CurrentValue { get; init; }\n\tpublic State(TS s, TV v)\n\t{\n\t\tCurrentValue = v;\n\t\tCurrentState = s;\n\t}\n}\n```", "```cs\npublic static class StateMonadExtensions\n{\n\npublic static State<TS, TV> ToState<TS, TV>(this TS @this, TV value) =>\n\tnew(@this, value);\n\npublic static State<TS, TV> Update<TS, TV>(\n\t this State<TS, TV> @this,\n\t Func<TS, TS> f\n\t) => new(f(@this.CurrentState), @this.CurrentValue);\n}\n```", "```cs\npublic IEnumerable<Order> MakeOrderReport(string userName) =>\n this.connFactory.MakeDbConnection().ToState(userName)\n .Bind((s, x) => this.customerRepo.GetCustomer(s, x))\n .Bind((s, x) => this.orderRepo.GetCustomreOrders(s, x.Id))\n```", "```cs\npublic static State<TS, TV>Update<TS,TV>(\n this State<TS,TV> @this,\n Func<TS, TS> f\n) => new(@this.CurrentState, f(@this.CurrentState));\n```", "```cs\nvar result = 10.ToState(10)\n\t.Bind((s, x) => s * x)\n\t.Bind((s, x) => x - s) // s=10, x = 90\n\t.Update(s => s - 5) // s=5, x = 90\n\t.Bind((s, x) => x / 5); // s=5, x = 18\n```", "```cs\npublic class State<TS, TV>\n{\n\tpublic TS CurrentState { get; init; }\n\tpublic Maybe<TV> CurrentValue { get; init; }\n\tpublic State(TS s, TV v)\n\t{\n\t\tCurrentValue = new Something<TV>(v);\n\t\tCurrentState = s;\n\t}\n}\n}\n```", "```cs\npublic static State<TS, TNew> Bind<TS, TOld, TNew>(\n\tthis State<TS, TOld> @this, Func<TS, TOld, TNew> f) =>\n\tnew(@this.CurrentState, @this.CurrentValue.Bind(x => f(@this.CurrentState, x)));\n```", "```cs\npublic Maybe<IEnumerable<order>> MakeOrderReport(string userName) =>\n this.connFactory.MakeDbConnection().ToState(userName)\n .Bind((s, x) => this.customerRepo.GetCustomer(s, x)\n .Bind((s, x) => this.orderRepo.GetCustomerOrders(s, x.Id))\n```", "```cs\nvar op = x => x * 2;\nvar input = new [] { 100 };\n\nvar enumerableResult = input.Select(op);\nvar directResult = new [] { op(input.First()) };\n// both equal the same value - { 200 }\n```", "```cs\nvar op = x => x;\nvar input = new [] { 100 };\n\nvar enumerableResult = input.Select(op);\nvar directResult = new [] { op(input.First()) };\n// both equal the same value - { 100 }\n```", "```cs\nvar createEnumerable = (int x) => Enumerable.Range(0, x);\nvar input = new [] { 100, 200 }\nvar output = input.SelectMany(createEnumerable);\n// output = single dimension array with 300 elements\n```", "```cs\npublic Func<int> op = x => x * 2;\npublic async Task<int> asyncOp(int x) => await Task.FromResult(op(x));\n\nvar taskResult = await asyncOp(100);\nvar nonTaskResult = op(100);\n// The result is the same - 200\n```", "```cs\n// Notice the function is simply returning x back again unchanged this time.\npublic Func<int> op = x => x;\npublic async Task<int> asyncOp(int x) => await Task.FromResult(op(x));\n\nvar taskResult = await asyncOp(100);\nvar nonTaskResult = op(100);\n// The result is the same as the initial input - 100\n```", "```cs\nasync Task<int> op1(int x) => await Task.FromResult(10 * x);\nasync Task<int> pp2() => await Task.FromResult(100);\nvar result = await op1(await pp2());\n// result = 1,000\n```", "```cs\npublic interface IMappingSystem\n{\n Maybe<Address> GetAddress(Location l);\n}\n\npublic interface IRoutePlanner\n{\n Task<Maybe<Route>> DetermineRoute(Address a, Address b);\n}\n\npublic interface ITrafficMonitor\n{\n Maybe<TrafficAdvice> GetAdvice(Route r);\n}\n\npublic interface IPricingCalculator\n{\n decimal PriceRoute(Route r);\n}\n```", "```cs\npublic Maybe<decimal> DeterminePrice(Location from, Location to)\n{\n var addresses = this.mapping.GetAddress(from).Bind(x =>\n  (From: x,\n   To: this.mapping.GetAddress(to)));\n\n var route = await addresses.BindAsync (async x => await this.router.DetermineRoute(x.From, x,To));\n\n var trafficInfo = route.Bind(x => this.trafficAdvisor.GetAdvice(x));\n var hasRoadWorks = trafficInfo is Something<TrafficAdvice> s &&\n  s.Value.RoadworksOnRoute;\n\n var price = route.Bind(x => this.pricing.PriceRoute(x));\n var finalPrice = route.Bind(x => hasRoadWorks ? x *= 1.1 : x);\n\n return finalPrice;\n}\n```"]