- en: Chapter 10\. Memoization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are more advantages to pure functions than just producing predictable
    results. Granted that’s a good thing to have, but there’s another way to use that
    behavior to our advantage.
  prefs: []
  type: TYPE_NORMAL
- en: Memoization is somewhat like caching, specifically the `GetOrAdd` function from
    `MemoryCache`. What this does is takes a key value of some kind, and if that key
    is already present in the cache, it returns the object out. If it isn’t, then
    you need to pass in a function that will generate the required value.
  prefs: []
  type: TYPE_NORMAL
- en: Memoization works to the exact same principle, except its scope might not extend
    beyond a single calculation.
  prefs: []
  type: TYPE_NORMAL
- en: Where this is useful is in a multi-step calculation of some kind that might
    be recursive, or involve the same calculations being performed multiple times
    for some reason.
  prefs: []
  type: TYPE_NORMAL
- en: Maybe the best way to explain this is with an example…​
  prefs: []
  type: TYPE_NORMAL
- en: Bacon Numbers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Ever wanted an entertaining way to waste an afternoon or two? Have a look into
    Bacon Numbers. It’s based on the idea that Kevin Bacon is the center of the acting
    universe, connecting all actors together. Like all roads lead to Rome, all actors
    somehow connect at some level to Kevin Bacon^([1](ch10.html#idm45400847828272)).
    An actor’s Bacon number is the number of film connections you have to work through
    in order to reach Kevin Bacon. Let’s work through a few examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Kevin Bacon**: easy. Bacon number of 0, because he **is** the Big Bacon himself.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Tom Hanks**: Bacon number of 1\. He was with KB in one of my personal favorites,
    *Apollo 13*. Frequent Tom Hanks collaborator **Meg Ryan** is also 1, because she
    appeared with KB in *In The Cut*.'
  prefs: []
  type: TYPE_NORMAL
- en: '**David Tennant**: Bacon number of 2\. He appeared with **Colin Firth** in
    *St. Trinian’s 2*. Colin Firth appeared in *Where the Truth Lies* with Kevin Bacon.
    That’s 2 films before we find a connection, so a Bacon number of 2\. Believe it
    or not **Marilyn Monroe** also has a score of 2 due to KB appearing in *JFK* with
    **Jack Lemon**, who was also in *Some Like it Hot*.'
  prefs: []
  type: TYPE_NORMAL
- en: Bollywood superstar **Aamir Khan** has a bacon number of 3\. He was with living
    legend **Amitabh Bacchhan** in *Bollywood Talkies*. Amitabh was in *The Great
    Gatsby* with **Toby McGuire**. Toby McGuire was in *Beyond all Boundaries* with
    Kevin Bacon.
  prefs: []
  type: TYPE_NORMAL
- en: My Bacon number is Infinity! This is because I’ve never appeared in a film as
    an actor^([2](ch10.html#idm45400847816624)). Also, the holder of the highest Bacon
    number I’m aware of is **William Rufus Shafter**, an American Civil War general,
    who also appeared in a non-fiction film made in 1989, which still secures him
    a Bacon Number. It’s a whopping great 10!!
  prefs: []
  type: TYPE_NORMAL
- en: Right, hopefully you understand the rules.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s imagine you wanted to work out which out of these actors had the lowest
    Bacon Number programatically. Something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'There are any numbers of ways that GetBaconNumber could be calculated. Most
    likely using a web API of flim data of some kind. There are more advanced “shortest
    path” algorithms out there, but for the sake of simplicity I’ll say it’s something
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: Get all of Kevin Bacon’s films. Assign all actors in these films a bacon number
    of 1\. If the target actor (e.g. Tom Hanks) is among them, return an answer of
    1\. Otherwise continue
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Take each of the actors from the previous step (excluding Kevin Bacon himself),
    get a list of all of their flims not already checked. Assign all actors from these
    films not already assigned a number a value of 2.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: And so on in iterations, with each set of actors being assigned progressively
    higher values until we finally reach the target actor and return their number.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Since there’s an API at work to calculate these numbers, every actor whose filmography
    we download, or every film whose cast list we download, all have a significant
    cost in processing time.
  prefs: []
  type: TYPE_NORMAL
- en: Further to that, there is an awful lot of overlap between these actors and their
    films, so unless we step in and do something, we’re going to be checking the same
    film multiple times.
  prefs: []
  type: TYPE_NORMAL
- en: One option is to create a state object to pass into an Aggregate function of
    some kind. It’s an indefinite loop, so we’d also need to select one of the options
    for compromising on the functional principles and allowing a loop of this kind.
  prefs: []
  type: TYPE_NORMAL
- en: 'It might look something like this (N.B. I’ve made up the web API, so don’t
    expect this to work in a real application):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This is fine, but could be better. There’s a lot of boilerplate code that’s
    concerned with tracking whether or not an actor has already been checked or not.
    For instance, there are a lot of uses of Distinct.
  prefs: []
  type: TYPE_NORMAL
- en: With Memoization we get a generic version of the check, like a cache, but it
    exists within the scope of the calculation we’re performing, and doesn’t persist
    beyond it. If you do want the saved, calculated value to persist between calls
    to this function, then `MemoryCache` maybe a better choice.
  prefs: []
  type: TYPE_NORMAL
- en: 'I could create a Memoized function to get a list of films the aactors I listed
    above have been in, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: I called the same function there 4 times, and by rights it should have gone
    away to the film data respository and fetched a fresh copy of the data 4 times.
    In fact it did it only a single line when `kb1` was populated. Every time since
    then a copy of the same data was returned.
  prefs: []
  type: TYPE_NORMAL
- en: Note also, by the way, that the Memoized version and original version are on
    separate lines. That’s a limitation of C#. You can’t call an extension method
    on a function, only on a `Func` delegate, and the arrow function isn’t a `Func`
    until it has been stored in a variable.
  prefs: []
  type: TYPE_NORMAL
- en: Some functional languages have out-of-the-box support for Memoization, but F#
    doesn’t, oddly enough.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is an updated version of the Bacon Number calculation, this time taking
    advantage of the Memoization feature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Literally the only difference here is that we’ve created a local version of
    the call to get film data from a remote resource, then memoized it, and thereafter
    referenced only the memoized version. This means that there are guaranteed to
    be no wasteful repeat requests for data.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing Memoization in C#
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that you understand some of the basics, this is how you’d make a memoization
    function for a simple, single parameter function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This version of Memoize expects the “live data” function has only a single
    parameter of any type. To expect more parameters, further Memoize extension methods
    would be necessary, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Now, to make this work, I’ve assumed that `ToString()` returns something meaningful,
    meaning that most likely it’ll have to be a primitive type (like a `string` or
    `int`) in order to work. The `ToString()` method on a class tends to simply return
    a description of the *Type* of the class, not its properties.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you absolutely have to memoize classes as parameters, then some creativity
    is needed. The easiest way to keep it generic is probably to add parameters to
    the `Memoize` function which require the developer to provide a custom `ToString`
    function. Like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'you might call it like this, in that case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This is only possible though, if you keep your functions *Pure*. If there are
    side effects of any kind in your “live” func, then you might not necessariy get
    the results you expect. Depending on what those side effects are.
  prefs: []
  type: TYPE_NORMAL
- en: From a practical perspective, I wouldn’t be worried about adding logging into
    the “live” function, but I might be concerned if there were properties that were
    expected to be unique in every instance of the generated class.
  prefs: []
  type: TYPE_NORMAL
- en: There may be cases that you *want* the results to persist between calls to the
    `Memoize` function, in which case you’ll also need to add a MemoryCache parameter
    and pass in an instance from the outside world. I’m not convinced there are many
    circumstances where that’s a good idea, though.
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter we looked at Memoization, what it is and how to implement it.
    It’s a lightweight alternative to caching which can be used to drastically reduce
    the amount of time taken to complete a complex calculation with a lot of repetitive
    elements.
  prefs: []
  type: TYPE_NORMAL
- en: That’s it for theory now! This isn’t just the end of this chapter, but also
    of this entire part of the book.
  prefs: []
  type: TYPE_NORMAL
- en: Part one was a look at how to use functional ideas and out-of-the-box C# to
    improve your daily coding. Part two was a deeper dive into the actual theory behind
    Functional Programming and how to implement it with a little creative hacking
    about. Part three is going to be a little more philosophical, and to give you
    a few hints as to where to go next with what you’ve learned here with me.
  prefs: []
  type: TYPE_NORMAL
- en: Turn over, if you dare, to enter…​Part Three…​
  prefs: []
  type: TYPE_NORMAL
- en: ^([1](ch10.html#idm45400847828272-marker)) It probbaly isn’t true, sorry Mr.
    Bacon. I still love you, though!
  prefs: []
  type: TYPE_NORMAL
- en: ^([2](ch10.html#idm45400847816624-marker)) I wouldn’t say no, though. Anyone
    know a film director wanting to cast an aging, overweight, British tech-nerd?
    I probably couldn’t play James Bond, but I’m willing to give it a go!
  prefs: []
  type: TYPE_NORMAL
