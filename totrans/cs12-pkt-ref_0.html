<html><head></head><body><div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" class="pagenumrestart" data-pdf-bookmark="C# 12 Pocket Reference"><div class="chapter" id="chash_onetwo_pocket_reference">
<h1>C# 12 Pocket Reference</h1>
<p>C# is a general-purpose, type-safe, primarily object-oriented programming language, the goal of which is programmer productivity. To this end, the language balances simplicity, expressiveness, and performance. C# 12 is designed to work with the Microsoft <em>.NET 8</em> runtime (whereas C# 11 targets .NET 7, C# 10 targets .NET 6, and C# 7 targets Microsoft <em>.NET Framework</em> 4.6/4.7/4.8).</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p><a contenteditable="false" data-primary="code examples, obtaining and using" data-type="indexterm" id="id374"/>The programs and code snippets in this book mirror those in Chapters 2 through 4 of <em>C# 12 in a Nutshell</em> and are all available as interactive samples in <a href="http://www.linqpad.net"><em>LINQPad</em></a>. Working through these samples in conjunction with the book accelerates learning in that you can edit the samples and instantly see the results without needing to set up projects and solutions in Visual Studio.</p>
<p>To download the samples, click the Samples tab in LINQPad and then click “Download more samples.” LINQPad is free—go to <a href="http://www.linqpad.net"><em>www.linqpad.net</em></a>.</p>
</div>
<section data-type="sect1" data-pdf-bookmark="A First C# Program"><div class="sect1" id="a_first_chash_program">
<h1>A First C# Program</h1>
<p><a contenteditable="false" data-primary="C# (generally)" data-secondary="sample program" data-type="indexterm" id="ch1001.html0"/>Following is a program that multiplies 12 by 30 and prints the result, 360, to the screen. <a contenteditable="false" data-primary="// (double forward slash)" data-type="indexterm" id="id375"/><a contenteditable="false" data-primary="comment notation" data-type="indexterm" id="id376"/><a contenteditable="false" data-primary="double forward slash (//)" data-type="indexterm" id="id377"/>The double forward slash indicates that the remainder of a line is a <em>comment</em>:</p>
<pre data-type="programlisting">int x = 12 * 30;                  // Statement 1
System.Console.WriteLine (x);     // Statement 2</pre>
<p>Our program consists of two <em>statements</em>. <a contenteditable="false" data-primary="; (semicolon)" data-type="indexterm" id="id378"/><a contenteditable="false" data-primary="semicolon (;)" data-type="indexterm" id="id379"/><a contenteditable="false" data-primary="statements" data-secondary="basic program operation" data-type="indexterm" id="id380"/>Statements in C# execute sequentially and are terminated by a semicolon. The first statement computes the <em>expression</em> <code>12 * 30</code> and stores the result in a <em>variable</em>, named <code>x</code>, whose type is a 32-bit integer (<code>int</code>). <a contenteditable="false" data-primary="methods" data-secondary="basic program operation" data-type="indexterm" id="id381"/>The second statement calls the <code>WriteLine</code> <em>method</em> on a <em>class</em> called <code>Console</code>, which is defined in a <em>namespace</em> called <code>System</code>. This prints the variable <code>x</code> to a text window on the screen.</p>
<p><a contenteditable="false" data-primary="functions, basic program operation" data-type="indexterm" id="id382"/>A method performs a function; <a contenteditable="false" data-primary="classes" data-secondary="basic program operation" data-type="indexterm" id="id383"/>a class groups function members and data members to form an object-oriented building block. The <code>Console</code> class groups members that handle command-line input/output (I/O) functionality, such as the <code>WriteLine</code> method. A class is a kind of <em>type</em>, which we examine in <a data-type="xref" href="#type_basics">“Type Basics”</a>.</p>
<p><a contenteditable="false" data-primary=".NET Framework" data-primary-sortas="NET" data-secondary="namespaces in" data-type="indexterm" id="id384"/><a contenteditable="false" data-primary="namespaces" data-secondary="basic program operation" data-type="indexterm" id="id385"/>At the outermost level, types are organized into <em>namespaces</em>. Many commonly used types—including the <code>Console</code> class—reside in the <code>System</code> namespace. The .NET libraries are organized into nested namespaces. For example, the <code>System.Text</code> namespace contains types for handling text, and <code>System.IO</code> contains types for input/output.</p>
<p>Qualifying the <code>Console</code> class with the <code>System</code> namespace on every use adds clutter. <a contenteditable="false" data-primary="using directive" data-type="indexterm" id="id386"/>The <code>using</code> directive lets you avoid this clutter by <em>importing</em> a namespace:</p>
<pre data-type="programlisting"><strong>using System;</strong>            // Import the System namespace

int x = 12 * 30;
<strong>Console.WriteLine</strong> (x);   // No need to specify System</pre>
<p class="pagebreak-before">A basic form of code reuse is to write higher-level functions that call lower-level functions. We can <em>refactor</em> our program with a reusable <em>method</em> called <code>FeetToInches</code> that multiplies an integer by 12, as follows:</p>
<pre data-type="programlisting">using System;

Console.WriteLine (<strong>FeetToInches (30)</strong>);      // 360
Console.WriteLine (<strong>FeetToInches (100)</strong>);     // 1200

<strong>int FeetToInches (int feet)</strong>
<strong>{</strong>
<strong>  int inches = feet * 12;</strong>
<strong>  return inches;</strong>
<strong>}</strong></pre>
<p><a contenteditable="false" data-primary="{ } (curly braces)" data-type="indexterm" id="id387"/><a contenteditable="false" data-primary="braces" data-secondary="curly ({ })" data-type="indexterm" id="id388"/><a contenteditable="false" data-primary="curly braces ({ })" data-type="indexterm" id="id389"/><a contenteditable="false" data-primary="statements" data-secondary="statement blocks" data-type="indexterm" id="id390"/>Our method contains a series of statements surrounded by a pair of braces. This is called a <em>statement block</em>.</p>
<p>A method can receive <em>input</em> data from the caller by specifying <em>parameters</em> and <em>output</em> data back to the caller by specifying a <em>return type</em>. Our <code>FeetToInches</code> method has a parameter for inputting feet, and a return type for outputting inches:</p>
<pre data-type="programlisting"><strong>int</strong> FeetToInches (<strong>int feet</strong>)
...</pre>
<p><a contenteditable="false" data-primary="arguments" data-secondary="basic program operation" data-type="indexterm" id="id391"/>The <em>literals</em> <code>30</code> and <code>100</code> are the <em>arguments</em> passed to the <code>FeetToInches</code> method.</p>
<p>If a method doesn’t receive input, use empty parentheses. If it doesn’t return anything, use the <code>void</code> keyword:</p>
<pre data-type="programlisting">using System;
SayHello();

<strong>void</strong> SayHello<strong>()</strong>
{
  Console.WriteLine ("Hello, world");
}</pre>
<p>Methods are one of several kinds of functions in C#. <a contenteditable="false" data-primary="* (multiplication) operator" data-type="indexterm" id="id392"/><a contenteditable="false" data-primary="multiplication (*) operator" data-type="indexterm" id="id393"/>Another kind of function we used in our example program was the <code>*</code> <em>operator</em>, which performs multiplication. There are also <em>constructors</em>, <em>properties</em>, <em>events</em>, <em>indexers</em>, and <em>finalizers</em>.</p>
<section data-type="sect2" data-pdf-bookmark="Compilation"><div class="sect2" id="compilation">
<h2>Compilation</h2>
<p><a contenteditable="false" data-primary=".cs files" data-primary-sortas="cs" data-type="indexterm" id="id394"/><a contenteditable="false" data-primary=".NET Framework" data-primary-sortas="NET" data-secondary="assemblies in" data-type="indexterm" id="id395"/><a contenteditable="false" data-primary="assemblies" data-type="indexterm" id="id396"/><a contenteditable="false" data-primary="C# (generally)" data-secondary="compiler" data-type="indexterm" id="id397"/><a contenteditable="false" data-primary="compilation" data-secondary="basics of" data-type="indexterm" id="id398"/>The C# compiler compiles source code (a set of files with the <em>.cs</em> extension) into an <em>assembly</em>. An assembly is the unit of packaging and deployment in .NET. <a contenteditable="false" data-primary=".NET Framework" data-primary-sortas="NET" data-secondary="libraries in" data-type="indexterm" id="id399"/><a contenteditable="false" data-primary="applications" data-type="indexterm" id="id400"/><a contenteditable="false" data-primary="libraries" data-type="indexterm" id="id401"/>An assembly can be either an <em>application</em> or a <em>library</em>. A normal console or Windows application has an <em>entry point</em>, whereas a library does not. <a contenteditable="false" data-primary="referencing" data-type="indexterm" id="id402"/>The purpose of a library is to be called upon (<em>referenced</em>) by an application or by other libraries. .NET itself is a set of libraries (as well as a runtime environment).</p>
<p>Each of the programs in the preceding section began directly with a series of statements (called <em>top-level statements</em>). The presence of top-level statements implicitly creates an entry point for a console or Windows application. (Without top-level statements, a <em>Main method</em> denotes an application’s entry <span class="keep-together">point—see</span> <a data-type="xref" href="#symmetry_of_predefined_types_and_custom">“Symmetry of predefined types and custom types”</a>.)</p>
<p>To invoke the compiler, you can either use an integrated development environment (IDE) such as Visual Studio or Visual Studio Code, or call it manually from the command line. To manually compile a console application with .NET, first download the .NET 8 SDK, and then create a new project, as follows:</p>
<pre data-type="programlisting">dotnet new console -o MyFirstProgram
cd MyFirstProgram</pre>
<p>This creates a folder called <em>MyFirstProgram</em>, which contains a C# file called <em>Program.cs</em>, which you can then edit. To invoke the compiler, call <code>dotnet build</code> (or <code>dotnet run</code>, which will compile and then run the program). The output will be written to a subdirectory under <em>bin\debug</em>, which will include <em>MyFirstProgram.dll</em> (the output assembly) as well as <em>MyFirstProgram.exe</em> (which runs the compiled program directly).<a contenteditable="false" data-primary="" data-startref="ch1001.html0" data-type="indexterm" id="id403"/></p>
</div></section>
</div></section>
<section data-type="sect1" class="pagebreak-before" data-pdf-bookmark="Syntax"><div class="sect1" id="syntax">
<h1 class="less_space">Syntax</h1>
<p>C# syntax is inspired by C and C++ syntax. In this section, we describe C#’s elements of syntax, using the following program:</p>
<pre data-type="programlisting">using System;

int x = 12 * 30;
Console.WriteLine (x);</pre>
<section data-type="sect2" data-pdf-bookmark="Identifiers and Keywords"><div class="sect2" id="identifiers_and_keywords">
<h2>Identifiers and Keywords</h2>
<p><a contenteditable="false" data-primary="identifiers" data-type="indexterm" id="id404"/><em>Identifiers</em> are names that programmers choose for their classes, methods, variables, and so on. Here are the identifiers in our example program, in the order in which they appear:</p>
<pre data-type="programlisting">System   x   Console   WriteLine</pre>
<p>An identifier must be a whole word, essentially made up of Unicode characters starting with a letter or underscore. C# identifiers are case sensitive. <a contenteditable="false" data-primary="variables and parameters" data-secondary="naming parameters" data-type="indexterm" id="id405"/>By convention, parameters, <a contenteditable="false" data-primary="local variables" data-secondary="basic program operation" data-type="indexterm" id="id406"/><a contenteditable="false" data-primary="local variables" data-secondary="naming" data-type="indexterm" id="id407"/><a contenteditable="false" data-primary="private fields" data-type="indexterm" id="id408"/>local variables, and private fields should be in <em>camel case</em> (e.g., <code>myVariable</code>), and all other identifiers should be in <em>Pascal case</em> (e.g., <code>MyMethod</code>).</p>
<p><a contenteditable="false" data-primary="keywords" data-secondary="defined" data-type="indexterm" id="id409"/><em>Keywords</em> are names that mean something special to the compiler. There are two keywords in our example program, <code>using</code> and <code>int</code>.</p>
<p><a contenteditable="false" data-primary="reserved keywords" data-type="indexterm" id="id410"/>Most keywords are <em>reserved</em>, which means that you can’t use them as identifiers. Here is the full list of C# reserved <span class="keep-together">keywords</span>:</p>
<table class="border">
<tbody>
<tr>
<td><code>abstract</code><br/><code>as</code><br/><code>base</code><br/><code>bool</code><br/><code>break</code><br/><code>byte</code><br/><code>case</code><br/><code>catch</code><br/><code>char</code><br/><code>checked</code><br/><code>class</code><br/><code>const</code><br/><code>continue</code><br/><code>decimal</code><br/><code>default</code><br/><code>delegate</code><br/><code>do</code><br/><code>double</code><br/><code>else</code><br/><code>enum</code></td>
<td><code>event</code><br/><code>explicit</code><br/><code>extern</code><br/><code>false</code><br/><code>finally</code><br/><code>fixed</code><br/><code>float</code><br/><code>for</code><br/><code>foreach</code><br/><code>goto</code><br/><code>if</code><br/><code>implicit</code><br/><code>in</code><br/><code>int</code><br/><code>interface</code><br/><code>internal</code><br/><code>is</code><br/><code>lock</code><br/><code>long</code><br/><code>namespace</code></td>
<td><p><code>new</code><br/><code>null</code><br/><code>object</code><br/><code>operator</code><br/><code>out</code><br/><code>override</code><br/><code>params</code><br/><code>private</code><br/><code>protected</code><br/><code>public</code><br/><code>readonly</code><br/><code>record</code><br/><code>ref</code><br/><code>return</code><br/><code>sbyte</code><br/><code>sealed</code><br/><code>short</code><br/><code>sizeof</code><br/><code>stackalloc</code><br/><code>static</code></p>
</td>
<td><code>string</code><br/><code>struct</code><br/><code>switch</code><br/><code>this</code><br/><code>throw</code><br/><code>true</code><br/><code>try</code><br/><code>typeof</code><br/><code>uint</code><br/><code>ulong</code><br/><code>unchecked</code><br/><code>unsafe</code><br/><code>ushort</code><br/><code>using</code><br/><code>virtual</code><br/><code>void</code><br/><code>volatile</code><br/><code>while</code>
</td>
</tr>
</tbody>
</table>
<section data-type="sect3" data-pdf-bookmark="Avoiding conflicts"><div class="sect3" id="avoiding_conflicts">
<h3>Avoiding conflicts</h3>
<p><a contenteditable="false" data-primary="conflicts, avoiding in keywords" data-type="indexterm" id="id411"/><a contenteditable="false" data-primary="keywords" data-secondary="avoiding conflicts with" data-type="indexterm" id="id412"/>If you really want to use an identifier that clashes with a reserved keyword, you can do so by qualifying it with the <code>@</code> prefix. For instance:</p>
<pre data-type="programlisting">class class  {...}      // Illegal
class @class {...}      // Legal</pre>
<p><a contenteditable="false" data-primary="symbol" data-secondary="preceding identifiers" data-type="indexterm" id="id413"/>The <code>@</code> symbol doesn’t form part of the identifier itself. So <code>@myVariable</code> is the same as <code>myVariable</code>.</p>
</div></section>
<section data-type="sect3" data-pdf-bookmark="Contextual keywords"><div class="sect3" id="contextual_keywords">
<h3>Contextual keywords</h3>
<p><a contenteditable="false" data-primary="contextual keywords" data-type="indexterm" id="id414"/><a contenteditable="false" data-primary="keywords" data-secondary="contextual" data-type="indexterm" id="id415"/>Some keywords are <em>contextual</em>, meaning they can also be used as identifiers—without an <code>@</code> symbol. The contextual keywords are as follows:</p>
<table class="border">
<tbody>
<tr>
<td><code>add</code><br/><code>alias</code><br/><code>and</code><br/><code>ascending</code><br/><code>async</code><br/><code>await</code><br/><code>by</code><br/><code>descending</code><br/><code>dynamic</code><br/><code>equals</code></td>
<td><code>file</code><br/><code>from</code><br/><code>get</code><br/><code>global</code><br/><code>group</code><br/><code>init</code><br/><code>into</code><br/><code>join</code><br/><code>let</code><br/><code>managed</code></td>
<td><code>nameof</code><br/><code>nint</code><br/><code>not</code><br/><code>notnull</code><br/><code>nuint</code><br/><code>on</code><br/><code>or</code><br/><code>orderby</code><br/><code>partial</code><br/><code>remove</code></td>
<td><code>required</code><br/><code>select</code><br/><code>set</code><br/><code>unmanaged</code><br/><code>value</code><br/><code>var</code><br/><code>with</code><br/><code>when</code><br/><code>where</code><br/><code>yield</code></td>
</tr>
</tbody>
</table>
<p>With contextual keywords, ambiguity cannot arise within the context in which they are used.</p>
</div></section>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Literals, Punctuators, and Operators"><div class="sect2" id="literalscomma_punctuatorscomma_and_oper">
<h2>Literals, Punctuators, and Operators</h2>
<p><a contenteditable="false" data-primary="literals" data-type="indexterm" id="id416"/><em>Literals</em> are primitive pieces of data lexically embedded into the program. The literals we used in our example program are <code>12</code> and <code>30</code>. <a contenteditable="false" data-primary="punctuators" data-type="indexterm" id="id417"/><em>Punctuators</em> help demarcate the structure of the program. <a contenteditable="false" data-primary="; (semicolon)" data-type="indexterm" id="id418"/><a contenteditable="false" data-primary="semicolon (;)" data-type="indexterm" id="id419"/>An example is the semicolon, which terminates a statement. Statements can wrap multiple lines:</p>
<pre data-type="programlisting">Console.WriteLine
  (1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10);</pre>
<p><a contenteditable="false" data-primary="expressions and operators" data-secondary="operator syntax" data-type="indexterm" id="id420"/><a contenteditable="false" data-primary="expressions and operators" data-seealso="operators" data-type="indexterm" id="id421"/><a contenteditable="false" data-primary="operators" data-secondary="defined" data-type="indexterm" id="id422"/><a contenteditable="false" data-primary="operators" data-seealso="expressions and operators; specific operators" data-type="indexterm" id="id423"/>An <em>operator</em> transforms and combines expressions. <a contenteditable="false" data-primary="* (multiplication) operator" data-type="indexterm" id="id424"/><a contenteditable="false" data-primary="multiplication (*) operator" data-type="indexterm" id="id425"/>Most operators in C# are denoted with a symbol, such as the multiplication operator, <code>*</code>. Here are the operators in our program:</p>
<pre data-type="programlisting">=  *  .  ()</pre>
<p><a contenteditable="false" data-primary=". (period)" data-type="indexterm" id="id426"/><a contenteditable="false" data-primary="period (.)" data-type="indexterm" id="id427"/>A period denotes a member of something (or a decimal point with numeric literals). <a contenteditable="false" data-primary="( ) (parentheses)" data-secondary="method parameters" data-type="indexterm" id="id428"/><a contenteditable="false" data-primary="arguments" data-secondary="basic program operation" data-type="indexterm" id="id429"/><a contenteditable="false" data-primary="parentheses ( )" data-secondary="method parameters" data-type="indexterm" id="id430"/>Parentheses are used when declaring or calling a method; empty parentheses are used when the method accepts no arguments. <a contenteditable="false" data-primary="= (equals sign)" data-type="indexterm" id="id431"/><a contenteditable="false" data-primary="equals sign (=)" data-type="indexterm" id="id432"/>The equals sign performs <a contenteditable="false" data-primary="= (assignment) operator" data-type="indexterm" id="id433"/><a contenteditable="false" data-primary="assignment (=) operator" data-type="indexterm" id="id434"/><em>assignment</em> (<a contenteditable="false" data-primary="== (double equals sign)" data-type="indexterm" id="id435"/><a contenteditable="false" data-primary="double equals sign (==)" data-seealso="equality comparison [==] operator" data-type="indexterm" id="id436"/><a contenteditable="false" data-primary="equality comparison (==) operator" data-type="indexterm" id="id437"/>the double equals sign, <code>==</code>, performs equality comparison).</p>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Comments"><div class="sect2" id="comments">
<h2>Comments</h2>
<p><a contenteditable="false" data-primary="comment notation" data-type="indexterm" id="id438"/>C# offers two different styles of source code documentation: <em>single-line comments</em> and <em>multiline comments</em>. <a contenteditable="false" data-primary="// (double forward slash)" data-type="indexterm" id="id439"/><a contenteditable="false" data-primary="double forward slash (//)" data-type="indexterm" id="id440"/><a contenteditable="false" data-primary="single-line comments (//)" data-type="indexterm" id="id441"/>A single-line comment begins with a double forward slash and continues until the end of the line. For example:</p>
<pre data-type="programlisting">int x = 3;   // Comment about assigning 3 to x</pre>
<p><a contenteditable="false" data-primary="multiline comments (/* */)" data-type="indexterm" id="id442"/><a contenteditable="false" data-primary="types" data-secondary="values, variables, and constants" data-type="indexterm" id="id443"/>A multiline comment begins with <code>/*</code> and ends with <code>*/</code>. For example:</p>
<pre data-type="programlisting">int x = 3;   /* This is a comment that
                spans two lines */</pre>
<p>Comments can embed XML documentation tags (see <a data-type="xref" href="#xml_documentation">“XML Documentation”</a>).</p>
</div></section>
</div></section>
<section data-type="sect1" data-pdf-bookmark="Type Basics"><div class="sect1" id="type_basics">
<h1>Type Basics</h1>
<p>A <a contenteditable="false" data-primary="types" data-secondary="basics" data-type="indexterm" id="ch1001.html1"/><em>type</em> defines the blueprint for a value. In our example, we used two literals of type <code>int</code> with values 12 and 30. <a contenteditable="false" data-primary="variables and parameters" data-secondary="basic program operation" data-type="indexterm" id="id444"/>We also declared a <em>variable</em> of type <code>int</code> whose name was <code>x</code>.</p>
<p><a contenteditable="false" data-primary="variables and parameters" data-secondary="variables defined" data-type="indexterm" id="id445"/>A <em>variable</em> denotes a storage location that can contain different values over time. <a contenteditable="false" data-primary="constants" data-type="indexterm" id="id446"/>In contrast, a <em>constant</em> always represents the same value (more on this later).</p>
<p>All values in C# are an <em>instance</em> of a specific type. The meaning of a value, and the set of possible values a variable can have, is determined by its type.</p>
<section data-type="sect2" data-pdf-bookmark="Predefined Type Examples"><div class="sect2" id="predefined_type_examples">
<h2>Predefined Type Examples</h2>
<p><a contenteditable="false" data-primary="built-in types" data-type="indexterm" id="id447"/><a contenteditable="false" data-primary="predefined types" data-secondary="examples" data-type="indexterm" id="id448"/><a contenteditable="false" data-primary="types" data-secondary="predefined types" data-type="indexterm" id="id449"/>Predefined types (also called <em>built-in</em> types) are types that are specially supported by the compiler. The <code>int</code> type is a predefined type for representing the set of integers that fit into 32 bits of memory, from −2<sup>31</sup> to 2<sup>31</sup>−1. We can perform functions such as arithmetic with instances of the <code>int</code> type as follows:</p>
<pre data-type="programlisting">int x = 12 * 30;</pre>
<p><a contenteditable="false" data-primary="string type" data-type="indexterm" id="id450"/>Another predefined C# type is <code>string</code>. The <code>string</code> type repre<a contenteditable="false" data-primary="bool type" data-type="indexterm" id="id451"/>sents a sequence of characters, such as “.NET” or “<a href="http://oreilly.com"><em class="hyperlink">http://oreilly.com</em></a>. We can work with strings by calling functions on them, as follows:</p>
<pre data-type="programlisting">string message = "Hello world";
string upperMessage = message.ToUpper();
Console.WriteLine (upperMessage);      // HELLO WORLD

int x = 2022;
message = message + x.ToString();
Console.WriteLine (message);         // Hello world2022</pre>
<p><a contenteditable="false" data-primary="bool type" data-type="indexterm" id="id452"/>The predefined <code>bool</code> type has exactly two possible values: <code>true</code> and <code>false</code>. <a contenteditable="false" data-primary="if statements" data-type="indexterm" id="id453"/><a contenteditable="false" data-primary="statements" data-secondary="if statement" data-type="indexterm" id="id454"/>The <code>bool</code> type is commonly used to conditionally branch execution flow with an <code>if</code> statement. For example:</p>
<pre data-type="programlisting">bool simpleVar = false;
if (simpleVar)
  Console.WriteLine ("This will not print");

int x = 5000;
bool lessThanAMile = x &lt; 5280;
if (lessThanAMile)
  Console.WriteLine ("This will print");</pre>
<p><a contenteditable="false" data-primary=".NET Framework" data-primary-sortas="NET" data-secondary="System namespace in" data-type="indexterm" id="id455"/><a contenteditable="false" data-primary="System namespace" data-type="indexterm" id="id456"/>The <code>System</code> namespace in .NET contains many important types that are not predefined by C# (e.g., <code>DateTime</code>).</p>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Custom Type Examples"><div class="sect2" id="custom_type_examples">
<h2>Custom Type Examples</h2>
<p><a contenteditable="false" data-primary="custom types" data-type="indexterm" id="id457"/><a contenteditable="false" data-primary="types" data-secondary="custom types" data-type="indexterm" id="id458"/>Just as you can build complex functions from simple functions, you can build complex types from primitive types. In this example, we will define a custom type named <code>UnitConverter</code>—a class that serves as a blueprint for unit conversions:</p>
<pre data-type="programlisting">UnitConverter feetToInches = new UnitConverter (12);
UnitConverter milesToFeet = new UnitConverter (5280);

Console.WriteLine (feetToInches.Convert(30));   // 360
Console.WriteLine (feetToInches.Convert(100));  // 1200
Console.WriteLine (feetToInches.Convert
                    (milesToFeet.Convert(1)));  // 63360


<strong>public class UnitConverter</strong>
<strong>{</strong> 
<strong>  int ratio;                             // Field</strong>

<strong>  public UnitConverter (int unitRatio)   // Constructor</strong>
<strong>  {</strong>
<strong>    ratio = unitRatio;</strong>
<strong>  }</strong>

<strong>  public int Convert (int unit)          // Method</strong>
<strong>  {</strong>
<strong>    return unit * ratio;</strong>
<strong>  }</strong>
<strong>}</strong></pre>
<section data-type="sect3" data-pdf-bookmark="Members of a type"><div class="sect3" id="members_of_a_type">
<h3>Members of a type</h3>
<p><a contenteditable="false" data-primary="members of a type" data-type="indexterm" id="id459"/><a contenteditable="false" data-primary="types" data-secondary="members of a type" data-type="indexterm" id="id460"/>A type contains <em>data members</em> and <em>function members</em>. <a contenteditable="false" data-primary="data members" data-type="indexterm" id="id461"/><a contenteditable="false" data-primary="fields" data-type="indexterm" id="id462"/>The data member of <code>UnitConverter</code> is the <em>field</em> called <code>ratio</code>. <a contenteditable="false" data-primary="function members" data-type="indexterm" id="id463"/>The function members of <code>UnitConverter</code> are the <code>Convert</code> method and the <code>UnitConverter</code>’s <em>constructor</em>.</p>
</div></section>
<section data-type="sect3" data-pdf-bookmark="Symmetry of predefined types and custom types"><div class="sect3" id="symmetry_of_predefined_types_and_custom">
<h3>Symmetry of predefined types and custom types</h3>
<p><a contenteditable="false" data-primary="predefined types" data-secondary="symmetry with custom types" data-type="indexterm" id="id464"/><a contenteditable="false" data-primary="types" data-secondary="symmetry of predefined and custom types" data-type="indexterm" id="id465"/>A beautiful aspect of C# is that predefined types and custom types have few differences. <a contenteditable="false" data-primary="int type" data-type="indexterm" id="id466"/>The predefined <code>int</code> type serves as a blueprint for integers. It holds data—32 bits—and provides function members that use that data, such as <code>ToString</code>. Similarly, our custom <code>UnitConverter</code> type acts as a blueprint for unit conversions. It holds data—the ratio—and provides function members to use that data.</p>
</div></section>
<section data-type="sect3" data-pdf-bookmark="Constructors and instantiation"><div class="sect3" id="constructors_and_instantiation">
<h3>Constructors and instantiation</h3>
<p><a contenteditable="false" data-primary="constructors" data-secondary="instantiation and" data-type="indexterm" id="id467"/><a contenteditable="false" data-primary="instantiation" data-type="indexterm" id="id468"/><a contenteditable="false" data-primary="types" data-secondary="constructors and instantiation" data-type="indexterm" id="id469"/>Data is created by <em>instantiating</em> a type. You can instantiate predefined types simply by using a literal such as <code>12</code> or <code>"Hello world"</code>.</p>
<p><a contenteditable="false" data-primary="new operator" data-type="indexterm" id="id470"/>The <code>new</code> operator creates instances of a custom type. We started our program by creating two instances of the <code>UnitConverter</code> type. Immediately after the <code>new</code> operator instantiates an object, the object’s <em>constructor</em> is called to perform initialization. A constructor is defined like a method, except that the method name and return type are reduced to the name of the enclosing type:</p>
<pre data-type="programlisting">public UnitConverter (int unitRatio)   // Constructor
{
  ratio = unitRatio; 
}</pre>
</div></section>
<section data-type="sect3" data-pdf-bookmark="Instance versus static members"><div class="sect3" id="instance_versus_static_members">
<h3>Instance versus static members</h3>
<p><a contenteditable="false" data-primary="instance members" data-type="indexterm" id="id471"/><a contenteditable="false" data-primary="types" data-secondary="instance versus static members" data-type="indexterm" id="id472"/>The data members and function members that operate on the <em>instance</em> of the type are called <em>instance members</em>. <span class="keep-together"><code>UnitConverter</code>’s</span> <code>Convert</code> method and <code>int</code>’s <code>ToString</code> method are examples of instance members. By default, members are instance members.</p>
<p><a contenteditable="false" data-primary="static members" data-type="indexterm" id="id473"/>Data members and function members that don’t operate on the instance of the type can be marked as <code>static</code>. <a contenteditable="false" data-primary="constructors" data-secondary="type members" data-type="indexterm" id="id474"/>To refer to a static member from outside its type, you specify its <em>type</em> name rather than an <em>instance</em>. An example is the <code>WriteLine</code> method of the <code>Console</code> class. Because this is static, we call <code>Console.WriteLine()</code> and not <code>new Console().WriteLine()</code>.</p>
<p>In the following code, the instance field <code>Name</code> pertains to an instance of a particular <code>Panda</code>, whereas <code>Population</code> pertains to the set of all <code>Panda</code> instances. We create two instances of the <code>Panda</code>, print their names, and then print the total population:</p>
<pre data-type="programlisting">Panda p1 = new Panda ("Pan Dee");
Panda p2 = new Panda ("Pan Dah");

Console.WriteLine (p1.Name);      // Pan Dee
Console.WriteLine (p2.Name);      // Pan Dah

Console.WriteLine (<strong>Panda.Population</strong>);   // 2

public class Panda
{
  public string Name;             // Instance field
  public <strong>static</strong> int Population;   // Static field

  public Panda (string n)         // Constructor
  {
    Name = n;                     // Instance field
    <strong>Population = Population + 1</strong>;  // Static field
  }
}</pre>
<p>Attempting to evaluate <code>p1.Population</code> or <code>Panda.Name</code> will generate a compile-time error.</p>
</div></section>
<section data-type="sect3" data-pdf-bookmark="The public keyword"><div class="sect3" id="the_public_keyword">
<h3>The public keyword</h3>
<p><a contenteditable="false" data-primary="public keyword" data-type="indexterm" id="id475"/><a contenteditable="false" data-primary="types" data-secondary="public keyword" data-type="indexterm" id="id476"/>The <code>public</code> keyword exposes members to other classes. In this example, if the <code>Name</code> field in <code>Panda</code> was not marked as public, it would be private and could not be accessed from outside the class. Marking a member public is how a type communicates: “Here is what I want other types to see—everything else is my own private implementation details.” In object-oriented terms, we say that the public members <em>encapsulate</em> the private members of the class.</p>
</div></section>
<section data-type="sect3" data-pdf-bookmark="Creating a namespace"><div class="sect3" id="creating_a_namespace">
<h3>Creating a namespace</h3>
<p>Particularly with larger programs, it makes sense to organize types into namespaces. Here’s how to define the <code>Panda</code> class inside a namespace called <code>Animals</code>:</p>
<pre data-type="programlisting"><strong>namespace Animals</strong>
<strong>{</strong>
  public class Panda
  {
     ...
  }
<strong>}</strong></pre>
<p>We cover namespaces in detail in <a data-type="xref" href="#namespaces">“Namespaces”</a>.</p>
</div></section>
<section data-type="sect3" data-pdf-bookmark="Defining a Main method"><div class="sect3" id="defining_a_main_method">
<h3>Defining a Main method</h3>
<p>All of our examples so far have used top-level statements, a feature that was introduced in C# 9. Without top-level statements, a simple console or Windows application looks like this:</p>
<pre data-type="programlisting">using System;

<strong>class Program</strong>
<strong>{</strong>
  <strong>static void Main()</strong>   // Program entry point
  <strong>{</strong>
    int x = 12 * 30;
    Console.WriteLine (x);
  <strong>}</strong>
<strong>}</strong></pre>
<p>In the absence of top-level statements, C# looks for a static method called <code>Main</code>, which becomes the entry point. The <code>Main</code> method can be defined inside any class (and only one <code>Main</code> method can exist).</p>
<p>The <code>Main</code> method can optionally return an integer (rather than <code>void</code>) in order to return a value to the execution environment (where a nonzero value typically indicates an error). The <code>Main</code> method can also optionally accept an array of strings as a parameter (that will be populated with any arguments passed to the executable); for example:</p>
<pre data-type="programlisting">static int Main (string[] args) {...}</pre>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>An array (such as <code>string[]</code>) represents a fixed number of elements of a particular type. Arrays are specified by placing square brackets after the element type. We describe them in <a data-type="xref" href="#arrays">“Arrays”</a>.</p>
</div>
<p>(The <code>Main</code> method can also be declared <code>async</code> and return a <code>Task</code> or <code>Task&lt;int&gt;</code> in support of asynchronous programming—see <a data-type="xref" href="#asynchronous_functions">“Asynchronous Functions”</a>.)</p>
</div></section>
<section data-type="sect3" data-pdf-bookmark="Top-level statements"><div class="sect3" id="top_level_statements">
<h3>Top-level statements</h3>
<p>Top-level statements let you avoid the baggage of a static <code>Main</code> method and a containing class. A file with top-level statements comprises three parts, in this order:</p>
<ol class="pagebreak-before">
<li><p>(Optionally) <code>using</code> directives</p></li>
<li><p>A series of statements, optionally mixed with method <span class="keep-together">declarations</span></p></li>
<li><p>(Optionally) Type and namespace declarations</p></li>
</ol>
<p>Everything in Part 2 ends up inside a compiler-generated “main” method, inside a compiler-generated class. This means that the methods in your top-level statements become <em>local methods</em> (we describe the subtleties in <a data-type="xref" href="#local_methods">“Local methods”</a>). Top-level statements can optionally return an integer value to the caller, and access a “magic” variable of type <code>string[]</code> called <code>args</code>, corresponding to command-line arguments passed by the caller.</p>
<p>As a program can have only one entry point, there can be at most one file with top-level statements in a C# project.</p>
</div></section>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Types and Conversions"><div class="sect2" id="types_and_conversions">
<h2>Types and Conversions</h2>
<p><a contenteditable="false" data-primary="types" data-secondary="conversions" data-type="indexterm" id="id477"/>C# can convert between instances of compatible types. A conversion always creates a new value from an existing one. <a contenteditable="false" data-primary="conversions" data-secondary="implicit and explicit" data-type="indexterm" id="id478"/><a contenteditable="false" data-primary="explicit conversions" data-secondary="between instances of types" data-type="indexterm" id="id479"/><a contenteditable="false" data-primary="implicit conversions" data-secondary="between instances of types" data-type="indexterm" id="id480"/><span class="keep-together">Conversions</span> can be either <em>implicit</em> or <em>explicit</em>: implicit conversions happen automatically, whereas explicit conversions require a <em>cast</em>. In the following example, we <em>implicitly</em> convert an <code>int</code> to a <code>long</code> type (which has twice the bit capacity of an <code>int</code>) and <em>explicitly</em> cast an <code>int</code> to a <code>short</code> type (which has half the bit capacity of an <code>int</code>):</p>
<pre data-type="programlisting">int x = 12345;       // int is a 32-bit integer
long y = x;          // <strong>Implicit</strong> conversion to 64-bit int
short z = <strong>(short)</strong>x;  // <strong>Explicit</strong> conversion to 16-bit int</pre>
<p>In general, implicit conversions are allowed when the compiler can guarantee that they will always succeed without loss of information. Otherwise, you must perform an explicit cast to convert between compatible types.</p>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Value Types Versus Reference Types"><div class="sect2" id="value_types_versus_reference_types">
<h2>Value Types Versus Reference Types</h2>
<p><a contenteditable="false" data-primary="reference types" data-secondary="value types versus" data-type="indexterm" id="ch1001.html2"/><a contenteditable="false" data-primary="types" data-secondary="value types versus reference types" data-type="indexterm" id="ch1001.html3"/><a contenteditable="false" data-primary="value types" data-secondary="reference types versus" data-type="indexterm" id="ch1001.html4"/>C# types can be divided into <em>value types</em> and <em>reference types</em>.</p>
<p><em>Value types</em> comprise most built-in types (specifically, all numeric types, the <code>char</code> type, and the <code>bool</code> type) as well as custom <code>struct</code> and <code>enum</code> types. <em>Reference types</em> comprise all class, array, delegate, and interface types.</p>
<p>The fundamental difference between value types and reference types is how they are handled in memory.</p>
<section data-type="sect3" data-pdf-bookmark="Value types"><div class="sect3" id="value_types">
<h3>Value types</h3>
<p><a contenteditable="false" data-primary="value types" data-secondary="content of" data-type="indexterm" id="id481"/>The content of a <em>value type</em> variable or constant is simply a value. For example, the content of the built-in value type <code>int</code> is 32 bits of data.</p>
<p>You can define a custom value type with the <code>struct</code> keyword (see <a data-type="xref" href="#a_value_type_instance_in_memory">Figure 1</a>):</p>
<pre data-type="programlisting">public <strong>struct</strong> Point { public int X, Y; }</pre>
<figure><div id="a_value_type_instance_in_memory" class="figure">
<img src="Images/c12p_0101.png" alt="A value type instance in memory" width="402" height="148"/>
<h6><span class="label">Figure 1. </span>A value type instance in memory</h6>
</div></figure>
<p>The assignment of a value type instance always <em>copies</em> the instance. For example:</p>
<pre data-type="programlisting">Point p1 = new Point();
p1.X = 7;

Point p2 = p1;             // Assignment causes copy

Console.WriteLine (p1.X);  // 7
Console.WriteLine (p2.X);  // 7

p1.X = 9;                  // Change p1.X
Console.WriteLine (p1.X);  // 9
Console.WriteLine (p2.X);  // 7</pre>
<p><a data-type="xref" href="#assignment_copies_a_value_type_instance">Figure 2</a> shows that <code>p1</code> and <code>p2</code> have independent storage.</p>
<figure><div id="assignment_copies_a_value_type_instance" class="figure">
<img src="Images/c12p_0102.png" alt="Assignment copies a value type instance" width="382" height="160"/>
<h6><span class="label">Figure 2. </span>Assignment copies a value type instance</h6>
</div></figure>
</div></section>
<section data-type="sect3" data-pdf-bookmark="Reference types"><div class="sect3" id="reference_types">
<h3>Reference types</h3>
<p><a contenteditable="false" data-primary="reference types" data-secondary="content of" data-type="indexterm" id="id482"/>A reference type is more complex than a value type, having two parts: an <em>object</em> and the <em>reference</em> to that object. The content of a reference type variable or constant is a reference to an object that contains the value. Here is the <code>Point</code> type from our previous example rewritten as a class (see <a data-type="xref" href="#a_reference_type_instance_in_memory">Figure 3</a>):</p>
<pre data-type="programlisting">public <strong>class</strong> Point { public int X, Y; }</pre>
<figure><div id="a_reference_type_instance_in_memory" class="figure">
<img src="Images/c12p_0103.png" alt="A reference type instance in memory" width="686" height="280"/>
<h6><span class="label">Figure 3. </span>A reference type instance in memory</h6>
</div></figure>
<p>Assigning a reference type variable copies the reference, not the object instance. This allows multiple variables to refer to the same object—something that’s not ordinarily possible with value types. If we repeat the previous example, but with <code>Point</code> now a class, an operation via <code>p1</code> affects <code>p2</code>:</p>
<pre data-type="programlisting">Point p1 = new Point();
p1.X = 7;

Point p2 = p1;             // Copies p1 reference

Console.WriteLine (p1.X);  // 7
Console.WriteLine (p2.X);  // 7

p1.X = 9;                  // Change p1.X
Console.WriteLine (p1.X);  // 9
Console.WriteLine (p2.X);  // 9</pre>
<p><a data-type="xref" href="#assignment_copies_a_reference">Figure 4</a> shows that <code>p1</code> and <code>p2</code> are two references that point to the same object.</p>
<figure><div id="assignment_copies_a_reference" class="figure">
<img src="Images/c12p_0104.png" alt="Assignment copies a reference" width="445" height="278"/>
<h6><span class="label">Figure 4. </span>Assignment copies a reference</h6>
</div></figure>
</div></section>
<section data-type="sect3" data-pdf-bookmark="Null"><div class="sect3" id="null">
<h3>Null</h3>
<p><a contenteditable="false" data-primary="null reference" data-type="indexterm" id="id483"/><a contenteditable="false" data-primary="value types" data-secondary="null values and" data-type="indexterm" id="id484"/>A reference can be assigned the literal <code>null</code>, indicating that the reference points to no object. Assuming <code>Point</code> is a class:</p>
<pre data-type="programlisting">Point p = null;
Console.WriteLine (p == null);   // True</pre>
<p>Accessing a member of a null reference generates a runtime error:</p>
<pre data-type="programlisting">Console.WriteLine (p.X);   // NullReferenceException</pre>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p><a contenteditable="false" data-primary="NullReferenceException errors" data-type="indexterm" id="id485"/>In <a data-type="xref" href="#nullable_reference_types">“Nullable Reference Types”</a>, we describe a feature of C# that reduces accidental <code>NullReference​Excep⁠tion</code> errors.</p>
</div>
<p>In contrast, a value type cannot ordinarily have a null value:</p>
<pre data-type="programlisting">struct Point {...}
...
Point p = null;  // Compile-time error
int x = null;    // Compile-time error</pre>
<p>To work around this, C# has a special construct for representing value-type nulls—see <a data-type="xref" href="#nullable_value_types">“Nullable Value Types”</a>.<a contenteditable="false" data-primary="" data-startref="ch1001.html4" data-type="indexterm" id="id486"/><a contenteditable="false" data-primary="" data-startref="ch1001.html3" data-type="indexterm" id="id487"/><a contenteditable="false" data-primary="" data-startref="ch1001.html2" data-type="indexterm" id="id488"/></p>
</div></section>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Predefined Type Taxonomy"><div class="sect2" id="predefined_type_taxonomy">
<h2>Predefined Type Taxonomy</h2>
<p><a contenteditable="false" data-primary="predefined types" data-secondary="taxonomy" data-type="indexterm" id="id489"/><a contenteditable="false" data-primary="types" data-secondary="predefined type taxonomy" data-type="indexterm" id="id490"/>The predefined types in C# are as follows:</p>
<dl>
<dt>Value types</dt>
<dd><ul>
<li><p>Numeric:</p>
<ul class="list_style_type_none">
<li><p>Signed integer (<code>sbyte</code>, <code>short</code>, <code>int</code>, <code>long</code>)</p></li>
<li><p>Unsigned integer (<code>byte</code>, <code>ushort</code>, <code>uint</code>, <code>ulong</code>)</p></li>
<li><p>Real number (<code>float</code>, <code>double</code>, <code>decimal</code>)</p></li>
</ul></li>
<li><p>Logical (<code>bool</code>)</p></li>
<li><p>Character (<code>char</code>)</p></li>
</ul></dd>
<dt>Reference types</dt>
<dd><ul>
<li><p>String (<code>string</code>)</p></li>
<li><p>Object (<code>object</code>)</p></li>
</ul></dd>
</dl>
<p><a contenteditable="false" data-primary=".NET Framework" data-primary-sortas="NET" data-secondary="System namespace in" data-type="indexterm" id="id491"/><a contenteditable="false" data-primary="System namespace" data-type="indexterm" id="id492"/>Predefined types in C# alias .NET types in the <code>System</code> namespace. There is only a syntactic difference between these two statements:</p>
<pre data-type="programlisting">int i = 5;
System.Int32 i = 5;</pre>
<p>The set of predefined <em>value</em> types excluding <code>decimal</code> are known as <em>primitive types</em> in the Common Language Runtime (CLR). Primitive types are so called because they are supported directly via instructions in compiled code, which usually translates to direct support on the underlying processor.<a contenteditable="false" data-primary="" data-startref="ch1001.html1" data-type="indexterm" id="id493"/></p>
</div></section>
</div></section>
<section data-type="sect1" class="pagebreak-before" data-pdf-bookmark="Numeric Types"><div class="sect1" id="numeric_types">
<h1 class="less_space">Numeric Types</h1>
<p><a contenteditable="false" data-primary="numeric types" data-type="indexterm" id="ch1001.html5"/><a contenteditable="false" data-primary="value types" data-secondary="numeric types" data-type="indexterm" id="ch1001.html6"/>C# <a contenteditable="false" data-primary="numeric types" data-secondary="available in C#" data-type="indexterm" id="id494"/>has the following predefined numeric types:</p>
<table class="border">
<thead>
<tr>
<th>C# type</th>
<th>System type</th>
<th>Suffix</th>
<th>Size</th>
<th>Range</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Integral—signed</strong></td>
<td colspan="4"/>
</tr>
<tr>
<td><code>sbyte</code></td>
<td><code>SByte</code></td>
<td/>
<td>8 bits</td>
<td>–2<sup>7</sup> to 2<sup>7</sup>–1</td>
</tr>
<tr>
<td><code>short</code></td>
<td><code>Int16</code></td>
<td/>
<td>16 bits</td>
<td>–2<sup>15</sup> to 2<sup>15</sup>–1</td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>Int32</code></td>
<td/>
<td>32 bits</td>
<td>–2<sup>31</sup> to 2<sup>31</sup>–1</td>
</tr>
<tr>
<td><code>long</code></td>
<td><code>Int64</code></td>
<td><code>L</code></td>
<td>64 bits</td>
<td>–2<sup>63</sup> to 2<sup>63</sup>–1</td>
</tr>
<tr>
<td><code>nint</code></td>
<td><code>IntPtr</code></td>
<td/>
<td>32/64 bits</td>
<td/>
</tr>
<tr>
<td><strong>Integral—unsigned</strong></td>
<td colspan="4"/>
</tr>
<tr>
<td><code>byte</code></td>
<td><code>Byte</code></td>
<td/>
<td>8 bits</td>
<td>0 to 2<sup>8</sup>–1</td>
</tr>
<tr>
<td><code>ushort</code></td>
<td><code>UInt16</code></td>
<td/>
<td>16 bits</td>
<td>0 to 2<sup>16</sup>–1</td>
</tr>
<tr>
<td><code>uint</code></td>
<td><code>UInt32</code></td>
<td><code>U</code></td>
<td>32 bits</td>
<td>0 to 2<sup>32</sup>–1</td>
</tr>
<tr>
<td><code>ulong</code></td>
<td><code>UInt64</code></td>
<td><code>UL</code></td>
<td>64 bits</td>
<td>0 to 2<sup>64</sup>–1</td>
</tr>
<tr>
<td><code>nuint</code></td>
<td><code>UIntPtr</code></td>
<td/>
<td>32/64 bits</td>
<td/>
</tr>
<tr>
<td><strong>Real</strong></td>
<td colspan="4"/>
</tr>
<tr>
<td><code>float</code></td>
<td><code>Single</code></td>
<td><code>F</code></td>
<td>32 bits</td>
<td>± (~10<sup>–45</sup> to 10<sup>38</sup>)</td>
</tr>
<tr>
<td><code>double</code></td>
<td><code>Double</code></td>
<td><code>D</code></td>
<td>64 bits</td>
<td>± (~10<sup>–324</sup> to 10<sup>308</sup>)</td>
</tr>
<tr>
<td><code>decimal</code></td>
<td><code>Decimal</code></td>
<td><code>M</code></td>
<td>128 bits</td>
<td>± (~10<sup>–28</sup> to 10<sup>28</sup>)</td>
</tr>
</tbody>
</table>
<p><a contenteditable="false" data-primary="int type" data-type="indexterm" id="id495"/><a contenteditable="false" data-primary="integral types" data-secondary="int and long" data-type="indexterm" id="id496"/><a contenteditable="false" data-primary="long type" data-type="indexterm" id="id497"/>Of the <em>integral</em> types, <code>int</code> and <code>long</code> are first-class citizens and are favored by both C# and the runtime. The other integral types are typically used for interoperability or when space efficiency is paramount. The <code>nint</code> and <code>nuint</code> native-sized integer types are sized to match the address space of the process at runtime (32 or 64 bits). These types can be useful when working with pointers—we describe their nuances in Chapter 4 of <em>C# 12 in a Nutshell</em> (O’Reilly).</p>
<p><a contenteditable="false" data-primary="double type" data-type="indexterm" id="id498"/><a contenteditable="false" data-primary="float type" data-type="indexterm" id="id499"/><a contenteditable="false" data-primary="floating-point types" data-type="indexterm" id="id500"/><a contenteditable="false" data-primary="real number types" data-type="indexterm" id="id501"/>Of the <em>real</em> number types, <code>float</code> and <code>double</code> are called <em>floating-point types</em> and are typically used for scientific and graphical calculations. <a contenteditable="false" data-primary="decimal type" data-type="indexterm" id="id502"/>The <code>decimal</code> type is typically used for financial calculations where base-10-accurate arithmetic and high precision are required. (Technically, <code>decimal</code> is a floating-point type, too, although it’s not generally referred to as such.)</p>
<section data-type="sect2" data-pdf-bookmark="Numeric Literals"><div class="sect2" id="numeric_literals">
<h2>Numeric Literals</h2>
<p><a contenteditable="false" data-primary="numeric types" data-secondary="numeric literals" data-type="indexterm" id="id503"/><a contenteditable="false" data-primary="hexadecimal notation" data-type="indexterm" id="id504"/><em>Integral-typed literals</em> can use decimal, hexadecimal, or binary notation; hexadecimal is denoted with the <code>0x</code> prefix (e.g., <code>0x7f</code> is equivalent to <code>127</code>), and binary is denoted with the <code>0b</code> prefix. <a contenteditable="false" data-primary="real literals" data-type="indexterm" id="id505"/><em>Real literals</em> can use decimal or exponential notation such as <code>1E06</code>. Underscores may be inserted within (or before) a numeric literal to improve readability (e.g., <code>1_000_000</code>).</p>
<section data-type="sect3" data-pdf-bookmark="Numeric literal type inference"><div class="sect3" id="numeric_literal_type_inference">
<h3>Numeric literal type inference</h3>
<p><a contenteditable="false" data-primary="numeric types" data-secondary="numeric literal type inference" data-type="indexterm" id="id506"/><a contenteditable="false" data-primary="type inference" data-type="indexterm" id="id507"/>By default, the compiler <em>infers</em> a numeric literal to be either <code>double</code> or an integral type:</p>
<ul>
<li><p><a contenteditable="false" data-primary="E (exponential symbol)" data-type="indexterm" id="id508"/><a contenteditable="false" data-primary="exponential symbol (E)" data-type="indexterm" id="id509"/>If the literal contains a decimal point or the exponential symbol (<code>E</code>), it is a <code>double</code>.</p></li>
<li><p><a contenteditable="false" data-primary="uint type" data-type="indexterm" id="id510"/><a contenteditable="false" data-primary="ulong type" data-type="indexterm" id="id511"/>Otherwise, the literal’s type is the first type in this list that can fit the literal’s value: <code>int</code>, <code>uint</code>, <code>long</code>, and <code>ulong</code>.</p></li>
</ul>
<p>For example:</p>
<pre data-type="programlisting">Console.Write (       1.0.GetType());  // Double <em>(double)</em>
Console.Write (      1E06.GetType());  // Double <em>(double)</em>
Console.Write (         1.GetType());  // Int32  <em>(int)</em>
Console.Write (0xF0000000.GetType());  // UInt32 <em>(uint)</em>
Console.Write (0x100000000.GetType()); // Int64  <em>(long)</em></pre>
</div></section>
<section data-type="sect3" data-pdf-bookmark="Numeric suffixes"><div class="sect3" id="numeric_suffixes">
<h3>Numeric suffixes</h3>
<p><a contenteditable="false" data-primary="numeric types" data-secondary="numeric suffixes" data-type="indexterm" id="id512"/>The <em>numeric suffixes</em> listed in the preceding table explicitly define the type of a literal:</p>
<pre data-type="programlisting">decimal d = 3.5<strong>M</strong>;   // M = deci<strong>m</strong>al (case-insensitive)</pre>
<p>The suffixes <code>U</code> and <code>L</code> are rarely necessary because the <code>uint</code>, <code>long</code>, and <code>ulong</code> types can nearly always be either <em>inferred</em> or <em>implicitly converted</em> from <code>int</code>:</p>
<pre data-type="programlisting">long i = 5;     // Implicit conversion from int to long</pre>
<p><a contenteditable="false" data-primary="decimal notation" data-type="indexterm" id="id513"/>The <code>D</code> suffix is technically redundant in that all literals with a decimal point are inferred to be <code>double</code> (and you can always add a decimal point to a numeric literal). <a contenteditable="false" data-primary="F suffix" data-type="indexterm" id="id514"/><a contenteditable="false" data-primary="M suffix" data-type="indexterm" id="id515"/>The <code>F</code> and <code>M</code> suffixes are the most useful and are mandatory when you’re specifying fractional <code>float</code> or <code>decimal</code> literals. Without suffixes, the following would not compile because 4.5 would be inferred to be of type <code>double</code>, which has no implicit conversion to <code>float</code> or <code>decimal</code>:</p>
<pre data-type="programlisting">float f = 4.5F;       // Won't compile without suffix
decimal d = -1.23M;   // Won't compile without suffix</pre>
</div></section>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Numeric Conversions"><div class="sect2" id="numeric_conversions">
<h2>Numeric Conversions</h2>
<section data-type="sect3" data-pdf-bookmark="Integral-to-integral conversions"><div class="sect3" id="integral_to_integral_conversions">
<h3>Integral-to-integral conversions</h3>
<p><a contenteditable="false" data-primary="conversions" data-secondary="of numeric types" data-type="indexterm" id="id516"/><a contenteditable="false" data-primary="explicit conversions" data-secondary="integral to integral" data-type="indexterm" id="id517"/><a contenteditable="false" data-primary="implicit conversions" data-type="indexterm" id="id518"/><a contenteditable="false" data-primary="integral types" data-secondary="conversions" data-type="indexterm" id="id519"/><a contenteditable="false" data-primary="integral-to-integral conversions" data-type="indexterm" id="id520"/><a contenteditable="false" data-primary="numeric types" data-secondary="conversions" data-type="indexterm" id="id521"/><a contenteditable="false" data-primary="numeric types" data-secondary="numeric conversions" data-type="indexterm" id="id522"/><a contenteditable="false" data-primary="types" data-secondary="conversions" data-type="indexterm" id="id523"/>Integral conversions are <em>implicit</em> when the destination type can represent every possible value of the source type. Otherwise, an <em>explicit</em> conversion is required. For example:</p>
<pre data-type="programlisting">int x = 12345;       // int is a 32-bit integral type
long y = x;          // Implicit conversion to 64-bit int
short z = (short)x;  // Explicit conversion to 16-bit int</pre>
</div></section>
<section data-type="sect3" data-pdf-bookmark="Real-to-real conversions"><div class="sect3" id="real_to_real_conversions">
<h3>Real-to-real conversions</h3>
<p><a contenteditable="false" data-primary="real-to-real conversions" data-type="indexterm" id="id524"/>A <code>float</code> can be implicitly converted to a <code>double</code> because a <code>double</code> can represent every possible <code>float</code> value. The reverse conversion must be explicit.</p>
<p>Conversions between <code>decimal</code> and other real types must be explicit.</p>
</div></section>
<section data-type="sect3" data-pdf-bookmark="Real-to-integral conversions"><div class="sect3" id="real_to_integral_conversions">
<h3>Real-to-integral conversions</h3>
<p><a contenteditable="false" data-primary="real-to-integral conversions" data-type="indexterm" id="id525"/>Conversions from integral types to real types are implicit, whereas the reverse must be explicit. Converting from a floating-point to an integral type truncates any fractional portion; to perform rounding conversions, use the static <span class="keep-together"><code>System.Convert</code></span> class.</p>
<p>A caveat is that implicitly converting a large integral type to a floating-point type preserves <em>magnitude</em> but might occasionally lose <em>precision</em>:</p>
<pre data-type="programlisting">int i1 = 100000001;
float f = i1;      // Magnitude preserved, precision lost
int i2 = (int)f;   // 100000000</pre>
</div></section>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Arithmetic Operators"><div class="sect2" id="arithmetic_operators">
<h2>Arithmetic Operators</h2>
<p><a contenteditable="false" data-primary="/ (division operator)" data-type="indexterm" id="id526"/><a contenteditable="false" data-primary="− operator" data-type="indexterm" id="id527"/><a contenteditable="false" data-primary="% (remainder) operator" data-type="indexterm" id="id528"/><a contenteditable="false" data-primary="division operator (/)" data-type="indexterm" id="id529"/><a contenteditable="false" data-primary="remainder (%) operator" data-type="indexterm" id="id530"/><a contenteditable="false" data-primary="arithmetic operators" data-type="indexterm" id="ch1001.html7"/><a contenteditable="false" data-primary="numeric types" data-secondary="arithmetic operators" data-type="indexterm" id="ch1001.html8"/>The arithmetic operators (<code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>%</code>) are defined for all numeric types except the 8- and 16-bit integral types. The <code>%</code> operator evaluates the remainder after division.</p>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Increment and Decrement Operators"><div class="sect2" id="increment_and_decrement_operators">
<h2>Increment and Decrement Operators</h2>
<p><a contenteditable="false" data-primary="−− (decrement) operator" data-type="indexterm" id="id531"/><a contenteditable="false" data-primary="++ (increment) operator" data-type="indexterm" id="id532"/><a contenteditable="false" data-primary="decrement (−−) operator" data-type="indexterm" id="id533"/><a contenteditable="false" data-primary="increment (++) operator" data-type="indexterm" id="id534"/><a contenteditable="false" data-primary="numeric types" data-secondary="increment and decrement operators" data-type="indexterm" id="id535"/>The increment and decrement operators (<code>++</code>, <code>--</code>, respectively) increment and decrement numeric types by 1. The operator can either precede or follow the variable, depending on whether you want the variable to be updated <em>before</em> or <em>after</em> the expression is evaluated. For example:</p>
<pre data-type="programlisting">int x = 0;
Console.WriteLine (x++);   // Outputs 0; x is now 1
Console.WriteLine (++x);   // Outputs 2; x is now 2
Console.WriteLine (--x);   // Outputs 1; x is now 1</pre>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Specialized Integral Operations"><div class="sect2" id="specialized_integral_operations">
<h2>Specialized Integral Operations</h2>
<section data-type="sect3" data-pdf-bookmark="Division"><div class="sect3" id="division">
<h3>Division</h3>
<p><a contenteditable="false" data-primary="numeric types" data-secondary="specialized integral operations" data-type="indexterm" id="ch1001.html9"/><a contenteditable="false" data-primary="specialized integral operations" data-type="indexterm" id="ch1001.html10"/>Division operations on integral types always eliminate the remainder (round toward zero). Dividing by a variable whose value is zero generates a runtime error (a <code>DivideByZeroException</code>). Dividing by the <em>literal</em> or <em>constant</em> 0 generates a compile-time error.</p>
</div></section>
<section data-type="sect3" data-pdf-bookmark="Overflow"><div class="sect3" id="overflow">
<h3>Overflow</h3>
<p><a contenteditable="false" data-primary="arithmetic overflow checking" data-type="indexterm" id="id536"/><a contenteditable="false" data-primary="integral types" data-secondary="overflow" data-type="indexterm" id="id537"/><a contenteditable="false" data-primary="overflow" data-type="indexterm" id="id538"/>At runtime, arithmetic operations on integral types can overflow. By default, this happens silently—no exception is thrown, and the result exhibits wraparound behavior, as though the computation were done on a larger integer type and the extra significant bits discarded. For example, decrementing the minimum possible <code>int</code> value results in the maximum possible <code>int</code> value:</p>
<pre data-type="programlisting">int a = int.MinValue; a--;
Console.WriteLine (a == int.MaxValue); // True</pre>
</div></section>
<section data-type="sect3" data-pdf-bookmark="The checked and unchecked operators"><div class="sect3" id="the_checked_and_unchecked_operators">
<h3>The checked and unchecked operators</h3>
<p><a contenteditable="false" data-primary="checked operator" data-type="indexterm" id="id539"/><a contenteditable="false" data-primary="unchecked operator" data-type="indexterm" id="id540"/>The <code>checked</code> operator instructs the runtime to generate an <code>OverflowException</code> rather than overflowing silently when an integral-typed expression or statement exceeds the arithmetic limits of that type. The <code>checked</code> operator affects expressions with the <code>++</code>, <code>−−</code>, (unary) <code>−</code>, <code>+</code>, <code>−</code>, <code>*</code>, <code>/</code>, and explicit conversion operators between integral types. Overflow checking incurs a small performance cost.</p>
<p>You can use <code>checked</code> around either an expression or a statement block. For example:</p>
<pre data-type="programlisting">int a = 1000000, b = 1000000;

int c = <strong>checked</strong> (a * b);   // Checks just the expression

<strong>checked</strong>                    // Checks all expressions
<strong>{</strong>                          // in statement block
   c = a * b;
   ...
<strong>}</strong></pre>
<p><a contenteditable="false" data-primary="/checked+ command-line switch" data-type="indexterm" id="id541"/>You can make arithmetic overflow checking the default for all expressions in a program by compiling with the <code>/checked+</code> command-line switch (in Visual Studio, go to Advanced Build Settings). If you then need to disable overflow checking just for specific expressions or statements, you can do so with the <code>unchecked</code> operator.</p>
</div></section>
<section data-type="sect3" data-pdf-bookmark="Bitwise operators"><div class="sect3" id="bitwise_operators">
<h3>Bitwise operators</h3>
<p>C# supports the following bitwise operators:<a contenteditable="false" data-primary="" data-startref="ch1001.html10" data-type="indexterm" id="id542"/><a contenteditable="false" data-primary="" data-startref="ch1001.html9" data-type="indexterm" id="id543"/><a contenteditable="false" data-primary="" data-startref="ch1001.html8" data-type="indexterm" id="id544"/><a contenteditable="false" data-primary="" data-startref="ch1001.html7" data-type="indexterm" id="id545"/></p>
<table class="border">
<thead>
<tr>
<th>Operator</th>
<th>Meaning</th>
<th>Sample expression</th>
<th>Result</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>~</code></td>
<td>Complement</td>
<td><code>~0xfU</code></td>
<td><code>0xfffffff0U</code></td>
</tr>
<tr>
<td><code>&amp;</code></td>
<td>And</td>
<td><code>0xf0 &amp; 0x33</code></td>
<td><code>0x30</code></td>
</tr>
<tr>
<td><code>|</code></td>
<td>Or</td>
<td><code>0xf0 | 0x33</code></td>
<td><code>0xf3</code></td>
</tr>
<tr>
<td><code>^</code></td>
<td>Exclusive Or</td>
<td><code>0xff00 ^ 0x0ff0</code></td>
<td><code>0xf0f0</code></td>
</tr>
<tr>
<td><code>&lt;&lt;</code></td>
<td>Shift left</td>
<td><code>0x20 &lt;&lt; 2</code></td>
<td><code>0x80</code></td>
</tr>
<tr>
<td><code>&gt;&gt;</code></td>
<td>Shift right</td>
<td><code>0x20 &gt;&gt; 1</code></td>
<td><code>0x10</code></td>
</tr>
</tbody>
</table>
<p><a contenteditable="false" data-primary="&gt;&gt; (shift right) operator" data-type="indexterm" id="id546"/><a contenteditable="false" data-primary="&lt;&lt; (shift left) operator" data-type="indexterm" id="id547"/><a contenteditable="false" data-primary="∼ (complement) operator" data-type="indexterm" id="id548"/><a contenteditable="false" data-primary="∼ (tilde) symbol" data-type="indexterm" id="id549"/><a contenteditable="false" data-primary="^ (exclusive or) operator" data-type="indexterm" id="id550"/><a contenteditable="false" data-primary="| (OR operator)" data-type="indexterm" id="id551"/><a contenteditable="false" data-primary="bitwise operators" data-type="indexterm" id="id552"/><a contenteditable="false" data-primary="byte type" data-type="indexterm" id="id553"/><a contenteditable="false" data-primary="complement (∼) operator" data-type="indexterm" id="id554"/><a contenteditable="false" data-primary="exclusive or (^) operator" data-type="indexterm" id="id555"/><a contenteditable="false" data-primary="numeric types" data-secondary="bitwise operators" data-type="indexterm" id="id556"/><a contenteditable="false" data-primary="OR operator (|)" data-type="indexterm" id="id557"/><a contenteditable="false" data-primary="sbyte type" data-type="indexterm" id="id558"/><a contenteditable="false" data-primary="shift left (&lt;&lt;) operator" data-type="indexterm" id="id559"/><a contenteditable="false" data-primary="shift right (&gt;&gt;) operator" data-type="indexterm" id="id560"/><a contenteditable="false" data-primary="short type" data-type="indexterm" id="id561"/><a contenteditable="false" data-primary="tilde (∼) symbol" data-type="indexterm" id="id562"/><a contenteditable="false" data-primary="ushort type" data-type="indexterm" id="id563"/>From C# 11, there is also an <a contenteditable="false" data-primary="&gt;&gt;&gt; (unsigned shift-right operator)" data-type="indexterm" id="id564"/><a contenteditable="false" data-primary="unsigned shift-right operator (&gt;&gt;&gt;)" data-type="indexterm" id="id565"/>unsigned shift-right operator (<code>&gt;&gt;&gt;</code>). Whereas the shift-right operator <code>(&gt;&gt;</code>) replicates the high-order bit when operating on signed integers, the unsigned shift-right operator (<code>&gt;&gt;&gt;</code>) does not.</p>
</div></section>
</div></section>
<section data-type="sect2" data-pdf-bookmark="8- and 16-Bit Integral Types"><div class="sect2" id="eight_and_onesix_bit_integral_types">
<h2>8- and 16-Bit Integral Types</h2>
<p><a contenteditable="false" data-primary="8- and 16-bit integral types" data-primary-sortas="eight" data-type="indexterm" id="id566"/><a contenteditable="false" data-primary="implicit conversions" data-secondary="8- and 16-bit integral types" data-secondary-sortas="eight" data-type="indexterm" id="id567"/><a contenteditable="false" data-primary="integral types" data-secondary="8- and 16-bit" data-type="indexterm" id="id568"/><a contenteditable="false" data-primary="numeric types" data-secondary="8- and 16-bit integral types" data-secondary-sortas="eight" data-type="indexterm" id="id569"/>The 8- and 16-bit integral types are <code>byte</code>, <code>sbyte</code>, <code>short</code>, and <code>ushort</code>. These types lack their own arithmetic operators, so C# implicitly converts them to larger types as required. This can cause a compilation error when trying to assign the result back to a small integral type:</p>
<pre data-type="programlisting">short x = 1, y = 1;
short z = x + y;          // Compile-time error</pre>
<p>In this case, <code>x</code> and <code>y</code> are implicitly converted to <code>int</code> so that the addition can be performed. This means that the result is also an <code>int</code>, which cannot be implicitly cast back to a <code>short</code> (because it could cause loss of data). To make this compile, you must add an explicit cast:</p>
<pre data-type="programlisting">short z = (short) (x + y);   // OK</pre>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Special Float and Double Values"><div class="sect2" id="special_float_and_double_values">
<h2>Special Float and Double Values</h2>
<p><a contenteditable="false" data-primary="float type" data-type="indexterm" id="id570"/><a contenteditable="false" data-primary="floating-point types" data-type="indexterm" id="id571"/><a contenteditable="false" data-primary="numeric types" data-secondary="special float and double values" data-type="indexterm" id="id572"/>Unlike integral types, floating-point types have values that certain operations treat specially. <a contenteditable="false" data-primary="NaN (Not a Number)" data-type="indexterm" id="id573"/>These special values are NaN (Not a Number), +∞, −∞, and −0. <a contenteditable="false" data-primary="float class" data-type="indexterm" id="id574"/>The <code>float</code> and <code>double</code> classes have constants for NaN, +∞, and −∞ (as well as other values including <code>MaxValue</code>, <code>MinValue</code>, and <code>Epsilon</code>). For example:</p>
<pre data-type="programlisting">Console.Write (double.NegativeInfinity);   // -Infinity</pre>
<p>Dividing a nonzero number by zero results in an infinite value:</p>
<pre data-type="programlisting">Console.WriteLine ( 1.0 /  0.0);   //  Infinity
Console.WriteLine (−1.0 /  0.0);   // -Infinity
Console.WriteLine ( 1.0 / −0.0);   // -Infinity
Console.WriteLine (−1.0 / −0.0);   //  Infinity</pre>
<p>Dividing zero by zero, or subtracting infinity from infinity, results in a NaN:</p>
<pre data-type="programlisting">Console.Write ( 0.0 / 0.0);                 //  NaN
Console.Write ((1.0 / 0.0) − (1.0 / 0.0));  //  NaN</pre>
<p>When you use <code>==</code>, a NaN value is never equal to another value, even another NaN value. To test whether a value is NaN, you must use the <code>float.IsNaN</code> or <code>double.IsNaN</code> method:</p>
<pre data-type="programlisting">Console.WriteLine (0.0 / 0.0 == double.NaN);    // False
Console.WriteLine (double.IsNaN (0.0 / 0.0));   // True</pre>
<p>When you use <code>object.Equals</code>, however, two NaN values are equal:</p>
<pre data-type="programlisting">bool isTrue = object.Equals (0.0/0.0, double.NaN);</pre>
</div></section>
<section data-type="sect2" data-pdf-bookmark="double Versus decimal"><div class="sect2" id="double_versus_decimal">
<h2>double Versus decimal</h2>
<p><a contenteditable="false" data-primary="decimal class, double class versus" data-type="indexterm" id="id575"/><a contenteditable="false" data-primary="double class" data-type="indexterm" id="id576"/><a contenteditable="false" data-primary="double type" data-type="indexterm" id="id577"/><a contenteditable="false" data-primary="numeric types" data-secondary="double versus decimal" data-type="indexterm" id="id578"/><code>double</code> is useful for scientific computations (such as computing spatial coordinates). <a contenteditable="false" data-primary="decimal type" data-type="indexterm" id="id579"/><a contenteditable="false" data-primary="financial computations" data-type="indexterm" id="id580"/><code>decimal</code> is useful for financial computations and values that are manufactured rather than the result of real-world measurements. Here’s a summary of the differences:</p>
<table class="border">
<thead>
<tr>
<th>Feature</th>
<th>double</th>
<th>decimal</th>
</tr>
</thead>
<tbody>
<tr>
<td>Internal representation</td>
<td>Base 2</td>
<td>Base 10</td>
</tr>
<tr>
<td>Precision</td>
<td>15–16 significant figures</td>
<td>28–29 significant figures</td>
</tr>
<tr>
<td>Range</td>
<td>±(~10<sup>−324</sup> to ~10<sup>308</sup>)</td>
<td>±(~10<sup>−28</sup> to ~10<sup>28</sup>)</td>
</tr>
<tr>
<td>Special values</td>
<td>+0, −0, +∞, −∞, and NaN</td>
<td>None</td>
</tr>
<tr>
<td>Speed</td>
<td>Native to processor</td>
<td>Non-native to processor (about 10 times slower than <code>double</code>)</td>
</tr>
</tbody>
</table>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Real Number Rounding Errors"><div class="sect2" id="real_number_rounding_errors">
<h2>Real Number Rounding Errors</h2>
<p><a contenteditable="false" data-primary="numeric types" data-secondary="real number rounding errors" data-type="indexterm" id="id581"/><a contenteditable="false" data-primary="real number rounding errors" data-type="indexterm" id="id582"/><a contenteditable="false" data-primary="rounding errors" data-type="indexterm" id="id583"/><code>float</code> and <code>double</code> internally represent numbers in base 2. For this reason, most literals with a fractional component (which are in base 10) will not be represented precisely, making them bad for financial calculations. In contrast, <code>decimal</code> works in base 10 and so can precisely represent fractional numbers such as 0.1 (whose base-10 representation is nonrecurring).<a contenteditable="false" data-primary="" data-startref="ch1001.html6" data-type="indexterm" id="id584"/><a contenteditable="false" data-primary="" data-startref="ch1001.html5" data-type="indexterm" id="id585"/></p>
</div></section>
</div></section>
<section data-type="sect1" data-pdf-bookmark="Boolean Type and Operators"><div class="sect1" id="boolean_type_and_operators">
<h1>Boolean Type and Operators</h1>
<p>C#’s <code>bool</code> type (aliasing the <code>System.Boolean</code> type) is a logical value that can be assigned the literal <code>true</code> or <code>false</code>.</p>
<p>Although a Boolean value requires only one bit of storage, the runtime will use one byte of memory because this is the minimum chunk that the runtime and processor can efficiently work with. To avoid space inefficiency in the case of arrays, .NET provides a <code>BitArray</code> class in the <code>System​.Col⁠lections</code> namespace that is designed to use just one bit per Boolean value.</p>
<section data-type="sect2" data-pdf-bookmark="Equality and Comparison Operators"><div class="sect2" id="equality_and_comparison_operators">
<h2>Equality and Comparison Operators</h2>
<p><a contenteditable="false" data-primary="== (double equals sign)" data-type="indexterm" id="id586"/><a contenteditable="false" data-primary="!= (inequality) operator" data-type="indexterm" id="id587"/><a contenteditable="false" data-primary="bool type" data-type="indexterm" id="id588"/><a contenteditable="false" data-primary="Boolean operators" data-secondary="equality and comparison operators" data-type="indexterm" id="id589"/><a contenteditable="false" data-primary="comparison operators" data-type="indexterm" id="id590"/><a contenteditable="false" data-primary="double equals sign (==)" data-type="indexterm" id="id591"/><a contenteditable="false" data-primary="equality comparison (==) operator" data-type="indexterm" id="id592"/><a contenteditable="false" data-primary="inequality (!=) operator" data-type="indexterm" id="id593"/><code>==</code> and <code>!=</code> test for equality and inequality, respectively, of any type and always return a <code>bool</code> value. Value types typically have a very simple notion of equality:</p>
<pre data-type="programlisting">int x = 1, y = 2, z = 1;
Console.WriteLine (x == y);      // False
Console.WriteLine (x == z);      // True</pre>
<p>For reference types, equality, by default, is based on <em>reference</em>, as opposed to the actual <em>value</em> of the underlying object. Therefore, two instances of an object with identical data are not considered equal unless the <code>==</code> operator for that type is specially overloaded to that effect (see <a data-type="xref" href="#the_object_type">“The object Type”</a> and <a data-type="xref" href="#operator_overloading">“Operator Overloading”</a>).</p>
<p><a contenteditable="false" data-primary="&gt; (greater-than) operator" data-type="indexterm" id="id594"/><a contenteditable="false" data-primary="&gt;= (greater-than or equal to) operator" data-type="indexterm" id="id595"/><a contenteditable="false" data-primary="&lt; (less-than) operator" data-type="indexterm" id="id596"/><a contenteditable="false" data-primary="&lt;= operator" data-type="indexterm" id="id597"/><a contenteditable="false" data-primary="greater-than (&gt;) operator" data-type="indexterm" id="id598"/><a contenteditable="false" data-primary="greater-than or equal to (&gt;=) operator" data-type="indexterm" id="id599"/><a contenteditable="false" data-primary="less-than (&lt;) operator" data-type="indexterm" id="id600"/>The equality and comparison operators, <code>==</code>, <code>!=</code>, <code>&lt;</code>, <code>&gt;</code>, <code>&gt;=</code>, and <code>&lt;=</code>, work for all numeric types but should be used with caution with real numbers (see <a data-type="xref" href="#real_number_rounding_errors">“Real Number Rounding Errors”</a> in the previous section). The comparison operators also work on <code>enum</code> type members by comparing their underlying integral values.</p>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Conditional Operators"><div class="sect2" id="conditional_operators">
<h2>Conditional Operators</h2>
<p><a contenteditable="false" data-primary="&amp;&amp; (conditional and) operator" data-type="indexterm" id="id601"/><a contenteditable="false" data-primary="|| (conditional OR) operator" data-type="indexterm" id="id602"/><a contenteditable="false" data-primary="Boolean operators" data-secondary="conditional operators" data-type="indexterm" id="id603"/><a contenteditable="false" data-primary="conditional and (&amp;&amp;) operator" data-type="indexterm" id="id604"/><a contenteditable="false" data-primary="conditional operators" data-type="indexterm" id="id605"/><a contenteditable="false" data-primary="conditional OR (||) operator" data-type="indexterm" id="id606"/>The <code>&amp;&amp;</code> and <code>||</code> operators test for <em>and</em> and <em>or</em> conditions, respectively. <a contenteditable="false" data-primary="! (not) operator" data-type="indexterm" id="id607"/><a contenteditable="false" data-primary="not (!) operator" data-type="indexterm" id="id608"/>They are frequently used in conjunction with the <code>!</code> operator, which expresses <em>not</em>. In the following example, the <code>UseUmbrella</code> method returns <code>true</code> if it’s rainy or sunny (to protect us from the rain or the sun), as long as it’s not also windy (because umbrellas are useless in the wind):</p>
<pre data-type="programlisting">static bool UseUmbrella (bool rainy, bool sunny,
                         bool windy)
{
  return !windy &amp;&amp; (rainy || sunny);
}</pre>
<p>The <code>&amp;&amp;</code> and <code>||</code> operators <em>short-circuit</em> evaluation when possible. In the preceding example, if it is windy, the expression <code>(rainy || sunny)</code> is not even evaluated. <a contenteditable="false" data-primary="NullReferenceException errors" data-type="indexterm" id="id609"/>Short-circuiting is essential in allowing expressions such as the following to run without throwing a <code>NullReferenceException</code>:</p>
<pre data-type="programlisting">if (sb != null &amp;&amp; sb.Length &gt; 0) ...</pre>
<p><a contenteditable="false" data-primary="&amp; (AND) operator" data-type="indexterm" id="id610"/><a contenteditable="false" data-primary="| (OR operator)" data-type="indexterm" id="id611"/><a contenteditable="false" data-primary="AND (&amp;) operator" data-type="indexterm" id="id612"/><a contenteditable="false" data-primary="OR operator (|)" data-type="indexterm" id="id613"/>The <code>&amp;</code> and <code>|</code> operators also test for <em>and</em> and <em>or</em> conditions:</p>
<pre data-type="programlisting">return !windy &amp; (rainy | sunny);</pre>
<p>The difference is that they <em>do not short-circuit</em>. For this reason, they are rarely used in place of conditional operators.</p>
<p><a contenteditable="false" data-primary="ternary conditional operator" data-type="indexterm" id="id614"/>The ternary conditional operator (simply called the <em>conditional operator</em>) has the form <code>q ? a : b</code>, where if condition <code>q</code> is true, <code>a</code> is evaluated, otherwise <code>b</code> is evaluated. For example:</p>
<pre data-type="programlisting">static int Max (int a, int b)
{
  return (a &gt; b) ? a : b;
}</pre>
<p>The conditional operator is particularly useful in LINQ queries.</p>
</div></section>
</div></section>
<section data-type="sect1" data-pdf-bookmark="Strings and Characters"><div class="sect1" id="strings_and_characters">
<h1>Strings and Characters</h1>
<p><a contenteditable="false" data-primary="strings" data-type="indexterm" id="ch1001.html11"/>C#’s <code>char</code> type (aliasing the <code>System.Char</code> type) represents a Unicode character and occupies two bytes (UTF-16). A <code>char</code> literal is specified inside single quotes:</p>
<pre data-type="programlisting">char c = 'A';       // Simple character</pre>
<p><em>Escape sequences</em> express characters that cannot be expressed or interpreted literally. An escape sequence is a backslash followed by a character with a special meaning. For example:</p>
<pre data-type="programlisting">char newLine = '\n';
char backSlash = '\\';</pre>
<p><a contenteditable="false" data-primary="\ (backslash)" data-type="indexterm" id="id615"/><a contenteditable="false" data-primary="\ (double quote escape sequence)" data-type="indexterm" id="id616"/><a contenteditable="false" data-primary="\' (single quote escape sequence)" data-type="indexterm" id="id617"/><a contenteditable="false" data-primary="\\ (backslash escape sequence)" data-type="indexterm" id="id618"/><a contenteditable="false" data-primary="\0 (null escape sequence)" data-type="indexterm" id="id619"/><a contenteditable="false" data-primary="\a (alert escape sequence)" data-type="indexterm" id="id620"/><a contenteditable="false" data-primary="\b (backspace character)" data-type="indexterm" id="id621"/><a contenteditable="false" data-primary="\f (form feed character)" data-type="indexterm" id="id622"/><a contenteditable="false" data-primary="\n (newline character)" data-type="indexterm" id="id623"/><a contenteditable="false" data-primary="\r (carriage return character)" data-type="indexterm" id="id624"/><a contenteditable="false" data-primary="\t (horizontal tab character)" data-type="indexterm" id="id625"/><a contenteditable="false" data-primary="\u escape sequence" data-type="indexterm" id="id626"/><a contenteditable="false" data-primary="\v (vertical tab character)" data-type="indexterm" id="id627"/><a contenteditable="false" data-primary="\x escape sequence" data-type="indexterm" id="id628"/><a contenteditable="false" data-primary="backslash (\)" data-type="indexterm" id="id629"/><a contenteditable="false" data-primary="backspace (\b) character" data-type="indexterm" id="id630"/><a contenteditable="false" data-primary="carriage return (\r) character" data-type="indexterm" id="id631"/><a contenteditable="false" data-primary="escape sequences" data-type="indexterm" id="id632"/><a contenteditable="false" data-primary="form feed (\f) character" data-type="indexterm" id="id633"/><a contenteditable="false" data-primary="horizontal tab (\t) character" data-type="indexterm" id="id634"/><a contenteditable="false" data-primary="newline (\n) character" data-type="indexterm" id="id635"/><a contenteditable="false" data-primary="strings" data-secondary="escape sequences" data-type="indexterm" id="id636"/><a contenteditable="false" data-primary="vertical tab (\v) character" data-type="indexterm" id="id637"/>The escape sequence characters are as follows:</p>
<table class="border">
<thead>
<tr>
<th>Char</th>
<th>Meaning</th>
<th>Value</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>\'</code></td>
<td>Single quote</td>
<td><code>0x0027</code></td>
</tr>
<tr>
<td><code>\"</code></td>
<td>Double quote</td>
<td><code>0x0022</code></td>
</tr>
<tr>
<td><code>\\</code></td>
<td>Backslash</td>
<td><code>0x005C</code></td>
</tr>
<tr>
<td><code>\0</code></td>
<td>Null</td>
<td><code>0x0000</code></td>
</tr>
<tr>
<td><code>\a</code></td>
<td>Alert</td>
<td><code>0x0007</code></td>
</tr>
<tr>
<td><code>\b</code></td>
<td>Backspace</td>
<td><code>0x0008</code></td>
</tr>
<tr>
<td><code>\f</code></td>
<td>Form feed</td>
<td><code>0x000C</code></td>
</tr>
<tr>
<td><code>\n</code></td>
<td>New line</td>
<td><code>0x000A</code></td>
</tr>
<tr>
<td><code>\r</code></td>
<td>Carriage return</td>
<td><code>0x000D</code></td>
</tr>
<tr>
<td><code>\t</code></td>
<td>Horizontal tab</td>
<td><code>0x0009</code></td>
</tr>
<tr>
<td><code>\v</code></td>
<td>Vertical tab</td>
<td><code>0x000B</code></td>
</tr>
</tbody>
</table>
<p>The <code>\u</code> (or <code>\x</code>) escape sequence lets you specify any Unicode character via its four-digit hexadecimal code:</p>
<pre data-type="programlisting">char copyrightSymbol = '\u00A9';
char omegaSymbol     = '\u03A9';
char newLine         = '\u000A';</pre>
<p><a contenteditable="false" data-primary="char (character) type" data-type="indexterm" id="id638"/>An implicit conversion from a <code>char</code> to a numeric type works for the numeric types that can accommodate an unsigned <code>short</code>. For other numeric types, an explicit conversion is required.</p>
<section data-type="sect2" data-pdf-bookmark="String Type"><div class="sect2" id="string_type">
<h2>String Type</h2>
<p><a contenteditable="false" data-primary="strings" data-secondary="string type" data-type="indexterm" id="ch1001.html12"/>C#’s <code>string</code> type (aliasing the <code>System.String</code> type) represents an immutable (unmodifiable) sequence of Unicode characters. <a contenteditable="false" data-primary="&quot; (double quotes)" data-type="indexterm" id="id639"/><a contenteditable="false" data-primary="double quotes (&quot;)" data-type="indexterm" id="id640"/>A string literal is specified within double quotes:</p>
<pre data-type="programlisting">string a = "Heat";</pre>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p><a contenteditable="false" data-primary="== (equality comparison) operator" data-secondary="strings and" data-type="indexterm" id="id641"/><a contenteditable="false" data-primary="equality comparison (==) operator" data-secondary="strings and" data-type="indexterm" id="id642"/><code>string</code> is a reference type rather than a value type. Its equality operators, however, follow value type semantics:</p>
<pre data-type="programlisting">string a = "test", b = "test";
Console.Write (a == b);  // True</pre>
</div>
<p>The escape sequences that are valid for <code>char</code> literals also work within strings:</p>
<pre data-type="programlisting">string a = "Here's a tab:<strong>\t</strong>";</pre>
<p>The cost of this is that whenever you need a literal backslash, you must write it twice:</p>
<pre data-type="programlisting">string a1 = "\\\\server\\fileshare\\helloworld.cs";</pre>
<p><a contenteditable="false" data-primary="strings" data-secondary="verbatim string literals" data-type="indexterm" id="id643"/><a contenteditable="false" data-primary="symbol" data-secondary="verbatim string literals" data-type="indexterm" id="id644"/><a contenteditable="false" data-primary="verbatim string literals" data-type="indexterm" id="id645"/>To avoid this problem, C# allows <em>verbatim</em> string literals. A verbatim string literal is prefixed with <code>@</code> and does not support escape sequences. The following verbatim string is identical to the preceding one:</p>
<pre data-type="programlisting">string a2 = <strong>@</strong>"\\server\fileshare\helloworld.cs";</pre>
<p>A verbatim string literal can also span multiple lines. You can include the double-quote character in a verbatim literal by writing it twice.</p>
<section data-type="sect3" data-pdf-bookmark="Raw string literals (C# 11)"><div class="sect3" id="raw_string_literals_left_parenthesischa">
<h3>Raw string literals (C# 11)</h3>
<p><a contenteditable="false" data-primary="raw string literals" data-type="indexterm" id="id646"/><a contenteditable="false" data-primary="strings" data-secondary="raw string literals" data-type="indexterm" id="id647"/>Wrapping a string in three or more quote characters (<code>"""</code>) creates a <em>raw string literal</em>. Raw string literals can contain almost any character sequence, without escaping or doubling up:</p>
<pre data-type="programlisting">string raw = <strong>"""</strong>&lt;file path="c:\temp\test.txt"&gt;&lt;/file&gt;<strong>"""</strong>;</pre>
<p>Raw string literals make it easy to represent JSON, XML, and HTML literals, as well as regular expressions and source code. Should you need to include three (or more) quote characters in the string itself, you can do so by wrapping the string in four (or more) quote characters:</p>
<pre data-type="programlisting">string raw = <strong>""""</strong>We can include """ in this string.<strong>""""</strong>;</pre>
<p>Multiline raw string literals are subject to special rules. We can represent the string <code>"Line 1\r\nLine 2"</code> as follows:</p>
<pre data-type="programlisting">string multiLineRaw = <strong>"""</strong>
  Line 1
  Line 2
  <strong>"""</strong>;</pre>
<p>Notice that the opening and closing quotes must be on separate lines to the string content. Additionally:</p>
<ul>
<li><p>Whitespace following the <em>opening</em> <code>"""</code> (on the same line) is ignored.</p></li>
<li><p><a contenteditable="false" data-primary="common indentation" data-type="indexterm" id="id648"/>Whitespace preceding the <em>closing</em> <code>"""</code> (on the same line) is treated as <em>common indentation</em> and is removed from every line in the string. This lets you include indentation for source-code readability (as we did in our example) without that indentation becoming part of the string.</p></li>
</ul>
<p>Raw string literals can be interpolated, subject to special rules described in <a data-type="xref" href="#string_interpolation">“String interpolation”</a>.</p>
</div></section>
<section data-type="sect3" data-pdf-bookmark="String concatenation"><div class="sect3" id="string_concatenation">
<h3>String concatenation</h3>
<p><a contenteditable="false" data-primary="+ (concatenation) operator" data-type="indexterm" id="id649"/><a contenteditable="false" data-primary="concatenation (+) operator" data-type="indexterm" id="id650"/><a contenteditable="false" data-primary="strings" data-secondary="string concatenation" data-type="indexterm" id="id651"/>The <code>+</code> operator concatenates two strings:</p>
<pre data-type="programlisting">string s = "a" + "b";</pre>
<p>One of the operands can be a nonstring value, in which case <code>ToString</code> is called on that value. For example:</p>
<pre data-type="programlisting">string s = "a" + 5;  // a5</pre>
<p>Using the <code>+</code> operator repeatedly to build up a string can be inefficient; a better solution is to use the <code>System.Text.StringBuilder</code> type—this represents a mutable (editable) string and has methods to efficiently <code>Append</code>, <code>Insert</code>, <code>Remove</code>, and <code>Replace</code> substrings.</p>
</div></section>
<section data-type="sect3" data-pdf-bookmark="String interpolation"><div class="sect3" id="string_interpolation">
<h3>String interpolation</h3>
<p><a contenteditable="false" data-primary="$ (string interpolation) character" data-type="indexterm" id="id652"/><a contenteditable="false" data-primary="interpolated strings" data-type="indexterm" id="id653"/><a contenteditable="false" data-primary="string interpolation ($) character" data-type="indexterm" id="id654"/><a contenteditable="false" data-primary="strings" data-secondary="string interpolation" data-type="indexterm" id="id655"/>A string preceded with the <code>$</code> character is called an <em>interpolated string</em>. Interpolated strings can include expressions within braces:</p>
<pre data-type="programlisting">int x = 4;
Console.Write (<strong>$</strong>"A square has <strong>{x}</strong> sides");
// Prints: A square has 4 sides</pre>
<p>Any valid C# expression of any type can appear within the braces, and C# will convert the expression to a string by calling its <code>ToString</code> method or equivalent. <a contenteditable="false" data-primary="format strings" data-type="indexterm" id="id656"/>You can change the formatting by appending the expression with a colon and a <em>format string</em> (we describe format strings in Chapter 6 of <em>C# 12 in a Nutshell</em>):</p>
<pre data-type="programlisting">string s = $"15 in hex is {15<strong>:X2</strong>}";
// Evaluates to "15 in hex is 0F"</pre>
<p>From C# 10, interpolated strings can be constants, as long as the interpolated values are constants:</p>
<pre data-type="programlisting">const string greeting = "Hello";
const string message = $"{greeting}, world";</pre>
<p>From C# 11, interpolated strings are permitted to span multiple lines (whether standard or verbatim):</p>
<pre data-type="programlisting">string s = <strong>$</strong>"this interpolation spans <strong>{</strong>1 +
1<strong>}</strong> lines";</pre>
<p><a contenteditable="false" data-primary="raw string literals" data-type="indexterm" id="id657"/><a contenteditable="false" data-primary="strings" data-secondary="raw string literals" data-type="indexterm" id="id658"/>Raw string literals (from C# 11) can also be interpolated:</p>
<pre data-type="programlisting">string s = <strong>$</strong>"""The date and time is <strong>{</strong>DateTime.Now<strong>}</strong>""";</pre>
<p>To include a brace literal in an interpolated string:</p>
<ul>
<li><p>With standard and verbatim string literals, repeat the desired brace character.</p></li>
<li><p>With raw string literals, change the interpolation sequence by repeating the <code>$</code> prefix.</p></li>
</ul>
<p>Using two (or more) <code>$</code> characters in a raw string literal prefix changes the interpolation sequence from one brace to two (or more) braces. Consider the following string:</p>
<pre data-type="programlisting">$$"""{ "TimeStamp": "<strong>{{</strong>DateTime.Now<strong>}}</strong>" }"""</pre>
<p>This evaluates to:</p>
<pre data-type="programlisting">{ "TimeStamp": "01/01/2024 12:13:25 PM" }</pre>
</div></section>
<section data-type="sect3" data-pdf-bookmark="String comparisons"><div class="sect3" id="string_comparisons">
<h3>String comparisons</h3>
<p><a contenteditable="false" data-primary="comparisons, string" data-type="indexterm" id="id659"/><a contenteditable="false" data-primary="strings" data-secondary="string comparisons" data-type="indexterm" id="id660"/><code>string</code> does not support <code>&lt;</code> and <code>&gt;</code> operators for comparisons. You must instead use <code>string</code>’s <code>CompareTo</code> method, which returns a positive number, a negative number, or zero, depending on whether the first value comes after, before, or alongside the second value:</p>
<pre data-type="programlisting">Console.Write ("Boston".CompareTo ("Austin"));   // 1
Console.Write ("Boston".CompareTo ("Boston"));   // 0
Console.Write ("Boston".CompareTo ("Chicago"));  // -1</pre>
</div></section>
<section data-type="sect3" data-pdf-bookmark="Searching within strings"><div class="sect3" id="searching_within_strings">
<h3>Searching within strings</h3>
<p><a contenteditable="false" data-primary="searching within strings" data-type="indexterm" id="id661"/><a contenteditable="false" data-primary="strings" data-secondary="searching within" data-type="indexterm" id="id662"/><code>string</code>’s indexer returns a character at a specified position:</p>
<pre data-type="programlisting">Console.Write ("word"[2]);   // r</pre>
<p>The <code>IndexOf</code> and <code>LastIndexOf</code> methods search for a character within the string. The <code>Contains</code>, <code>StartsWith</code>, and <code>EndsWith</code> methods search for a substring within the string.</p>
</div></section>
<section data-type="sect3" data-pdf-bookmark="Manipulating strings"><div class="sect3" id="manipulating_strings">
<h3>Manipulating strings</h3>
<p><a contenteditable="false" data-primary="manipulating strings" data-type="indexterm" id="id663"/><a contenteditable="false" data-primary="strings" data-secondary="manipulating" data-type="indexterm" id="id664"/>Because <code>string</code> is immutable, all the methods that “manipulate” a string return a new one, leaving the original untouched:</p>
<ul>
<li><p><code>Substring</code> extracts a portion of a string.</p></li>
<li><p><code>Insert</code> and <code>Remove</code> insert and remove characters at a specified position.</p></li>
<li><p><code>PadLeft</code> and <code>PadRight</code> add whitespace.</p></li>
<li><p><code>TrimStart</code>, <code>TrimEnd</code>, and <code>Trim</code> remove whitespace.</p></li>
</ul>
<p>The <code>string</code> class also defines <code>ToUpper</code> and <code>ToLower</code> methods for changing case, a <code>Split</code> method to split a string into substrings (based on supplied delimiters), and a static <code>Join</code> method to join substrings back into a string.<a contenteditable="false" data-primary="" data-startref="ch1001.html12" data-type="indexterm" id="id665"/><a contenteditable="false" data-primary="" data-startref="ch1001.html11" data-type="indexterm" id="id666"/></p>
</div></section>
</div></section>
<section data-type="sect2" data-pdf-bookmark="UTF-8 Strings"><div class="sect2" id="utf_eight_strings">
<h2>UTF-8 Strings</h2>
<p><a contenteditable="false" data-primary="strings" data-secondary="UTF-8 string literals" data-type="indexterm" id="id667"/><a contenteditable="false" data-primary="UTF-8 string literals" data-type="indexterm" id="id668"/>From C# 11, you can use the <code>u8</code> suffix to create string literals encoded in UTF-8 rather than UTF-16. This feature is intended for advanced scenarios such as the low-level handling of JSON text in performance hotspots:</p>
<pre data-type="programlisting">ReadOnlySpan&lt;byte&gt; utf8 = "ab→cd"<strong>u8</strong>;
Console.WriteLine (utf8.Length);      // 7</pre>
<p>The underlying type is <code>ReadOnlySpan&lt;byte&gt;</code>, which we cover in Chapter 23 of <em>C# 12 in a Nutshell</em>. You can convert this to an array by calling the <code>ToArray()</code> method.</p>
</div></section>
</div></section>
<section data-type="sect1" data-pdf-bookmark="Arrays"><div class="sect1" id="arrays">
<h1>Arrays</h1>
<p><a contenteditable="false" data-primary="arrays" data-type="indexterm" id="ch1001.html13"/>An <a contenteditable="false" data-primary="types" data-secondary="arrays and" data-type="indexterm" id="id669"/><em>array</em> represents a fixed number of elements of a particular type. The elements in an array are always stored in a contiguous block of memory, providing highly efficient access.</p>
<p><a contenteditable="false" data-primary="[ ] (square brackets)" data-type="indexterm" id="id670"/><a contenteditable="false" data-primary="arrays" data-secondary="denoting" data-type="indexterm" id="id671"/><a contenteditable="false" data-primary="braces" data-secondary="square ([ ])" data-type="indexterm" id="id672"/><a contenteditable="false" data-primary="square brackets ([ ])" data-type="indexterm" id="id673"/>An array is denoted with square brackets after the element type. The following declares an array of five characters:</p>
<pre data-type="programlisting">char[] vowels = new char[5];</pre>
<p><a contenteditable="false" data-primary="arrays" data-secondary="indexing" data-type="indexterm" id="id674"/>Square brackets also <em>index</em> the array, accessing a particular element by position:</p>
<pre data-type="programlisting">vowels[0] = 'a'; vowels[1] = 'e'; vowels[2] = 'i';
vowels[3] = 'o'; vowels[4] = 'u';

Console.WriteLine (vowels [1]);      // e</pre>
<p>This prints “e” because array indexes start at 0. You can use a <code>for</code> loop statement to iterate through each element in the array. The <code>for</code> loop in this example cycles the integer <code>i</code> from <code>0</code> to <code>4</code>:</p>
<pre data-type="programlisting">for (int i = 0; i &lt; vowels.Length; i++)
  Console.Write (vowels [i]);            // aeiou</pre>
<p>Arrays also implement <code>IEnumerable&lt;T&gt;</code> (see <a data-type="xref" href="#enumeration_and_iterators">“Enumeration and Iterators”</a>), so you can also enumerate members with the <code>foreach</code> statement:</p>
<pre data-type="programlisting">foreach (char c in vowels) Console.Write (c);  // aeiou</pre>
<p>All array indexing is bounds-checked by the runtime. An <code>IndexOutOfRangeException</code> is thrown if you use an invalid index:</p>
<pre data-type="programlisting">vowels[5] = 'y';   // Runtime error</pre>
<p><a contenteditable="false" data-primary="arrays" data-secondary="Length property" data-type="indexterm" id="id675"/>The <code>Length</code> property of an array returns the number of elements in the array. After an array has been created, its length cannot be changed. The <code>System.Collection</code> namespace and subnamespaces provide higher-level data structures, such as dynamically sized arrays and dictionaries.</p>
<p><a contenteditable="false" data-primary="array initialization expression" data-type="indexterm" id="id676"/><a contenteditable="false" data-primary="arrays" data-secondary="initialization expressions" data-type="indexterm" id="id677"/>An <em>array initialization expression</em> lets you declare and populate an array in a single step:</p>
<pre data-type="programlisting">char[] vowels = new char[] {'a','e','i','o','u'};</pre>
<p>Or simply:</p>
<pre data-type="programlisting">char[] vowels = {'a','e','i','o','u'};</pre>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p><a contenteditable="false" data-primary="collection expressions" data-type="indexterm" id="id678"/>From C# 12, you can use square brackets instead of curly braces:</p>
<pre data-type="programlisting">char[] vowels = <strong>[</strong>'a','e','i','o','u'<strong>]</strong>;</pre>
<p>This is called a <em>collection expression</em> and has the advantage of also working when calling methods:</p>
<pre data-type="programlisting">Foo (['a','e','i','o','u']);
void Foo (char[] letters) { ... }</pre>
<p>Collection expressions also work with other collection types such as lists and sets—see <a data-type="xref" href="#collection_initializers_and_collection">“Collection Initializers and Collection Expressions”</a>.</p>
</div>
<p>All arrays inherit from the <code>System.Array</code> class, which defines common methods and properties for all arrays. This includes instance properties such as <code>Length</code> and <code>Rank</code>, and static methods to do the following:</p>
<ul class="pagebreak-before">
<li><p>Dynamically create an array (<code>CreateInstance</code>)</p></li>
<li><p>Get and set elements regardless of the array type (<code>GetValue</code>/<code>SetValue</code>)</p></li>
<li><p>Search a sorted array (<code>BinarySearch</code>) or an unsorted array (<code>IndexOf</code>, <code>LastIndexOf</code>, <code>Find</code>, <code>FindIndex</code>, <code>FindLastIndex</code>)</p></li>
<li><p>Sort an array (<code>Sort</code>)</p></li>
<li><p>Copy an array (<code>Copy</code>)</p></li>
</ul>
<section data-type="sect2" data-pdf-bookmark="Default Element Initialization"><div class="sect2" id="default_element_initialization">
<h2>Default Element Initialization</h2>
<p><a contenteditable="false" data-primary="arrays" data-secondary="default initialization" data-type="indexterm" id="id679"/><a contenteditable="false" data-primary="default element initialization" data-type="indexterm" id="id680"/><a contenteditable="false" data-primary="default values" data-secondary="initializing arrays with" data-type="indexterm" id="id681"/><a contenteditable="false" data-primary="initialization" data-secondary="array default elements" data-type="indexterm" id="id682"/>Creating an array always preinitializes the elements with default values. The default value for a type is the result of a bitwise zeroing of memory. For example, consider creating an array of integers. Because <code>int</code> is a value type, this allocates 1,000 integers in one contiguous block of memory. The default value for each element will be 0:</p>
<pre data-type="programlisting">int[] a = new int[1000];
Console.Write (a[123]);            // 0</pre>
<p>With reference type elements, the default value is <code>null</code>.</p>
<p>An array <em>itself</em> is always a reference type object, regardless of element type. For instance, the following is legal:</p>
<pre data-type="programlisting">int[] a = null;</pre>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Indices and Ranges"><div class="sect2" id="indices_and_ranges">
<h2>Indices and Ranges</h2>
<p><em>Indices and ranges</em> (from C# 8) simplify working with elements or portions of an array.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Indices and ranges also work with the CLR types <code>Span&lt;T&gt;</code> and <code>ReadOnlySpan&lt;T&gt;</code>, which provide efficient low-level access to managed or unmanaged memory.</p>
<p><a contenteditable="false" data-primary="index type" data-type="indexterm" id="id683"/>You can also make your own types work with indices and ranges by defining an indexer of type <code>Index</code> or <code>Range</code> (see <a data-type="xref" href="#indexers">“Indexers”</a>).</p>
</div>
<section data-type="sect3" data-pdf-bookmark="Indices"><div class="sect3" id="indices">
<h3>Indices</h3>
<p><a contenteditable="false" data-primary="^ (xor) operator" data-type="indexterm" id="id684"/><a contenteditable="false" data-primary="arrays" data-secondary="working with indices" data-type="indexterm" id="id685"/><a contenteditable="false" data-primary="indexing an array" data-type="indexterm" id="id686"/><a contenteditable="false" data-primary="xor (^) operator" data-type="indexterm" id="id687"/>Indices let you refer to elements relative to the <em>end</em> of an array, with the <code>^</code> operator. <code>^1</code> refers to the last element, <code>^2</code> refers to the second-to-last element, and so on:</p>
<pre data-type="programlisting">char[] vowels = new char[] {'a','e','i','o','u'};
char lastElement  = vowels[<strong>^1</strong>];   // 'u'
char secondToLast = vowels[<strong>^2</strong>];   // 'o'</pre>
<p>(<code>^0</code> equals the length of the array, so <code>vowels[^0]</code> generates an error.)</p>
<p>C# implements indices with the help of the <code>Index</code> type, so you can also do the following:</p>
<pre data-type="programlisting"><strong>Index</strong> first = <strong>0</strong>;
<strong>Index</strong> last = <strong>^1</strong>;
char firstElement = vowels [<strong>first</strong>];   // 'a'
char lastElement = vowels [<strong>last</strong>];     // 'u'</pre>
</div></section>
<section data-type="sect3" data-pdf-bookmark="Ranges"><div class="sect3" id="ranges">
<h3>Ranges</h3>
<p><a contenteditable="false" data-primary=".. operator" data-type="indexterm" id="id688"/><a contenteditable="false" data-primary="Range type" data-type="indexterm" id="id689"/><a contenteditable="false" data-primary="ranges" data-secondary="working with" data-type="indexterm" id="id690"/>Ranges let you “slice” an array with the <code>..</code> operator:</p>
<pre data-type="programlisting">char[] firstTwo =  vowels [..2];    // 'a', 'e'
char[] lastThree = vowels [2..];    // 'i', 'o', 'u'
char[] middleOne = vowels [2..3];   // 'i'</pre>
<p>The second number in the range is <em>exclusive</em>, so <code>..2</code> returns the elements <em>before</em> <code>vowels[2]</code>.</p>
<p>You can also use the <code>^</code> symbol in ranges. The following returns the last two characters:</p>
<pre data-type="programlisting">char[] lastTwo = vowels [^2..^0];    // 'o', 'u'</pre>
<p>(<code>^0</code> is valid here because the second number in the range is <em>exclusive</em>.)</p>
<p>C# implements ranges with the help of the <code>Range</code> type, so you can also do the following:</p>
<pre data-type="programlisting">Range firstTwoRange = 0..2;
char[] firstTwo = vowels [firstTwoRange];   // 'a', 'e'</pre>
</div></section>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Multidimensional Arrays"><div class="sect2" id="multidimensional_arrays">
<h2>Multidimensional Arrays</h2>
<p><a contenteditable="false" data-primary="arrays" data-secondary="multidimensional" data-type="indexterm" id="id691"/><a contenteditable="false" data-primary="multidimensional arrays" data-type="indexterm" id="id692"/>Multidimensional arrays come in two varieties: <em>rectangular</em> and <em>jagged</em>. Rectangular arrays represent an <em>n</em>-dimensional block of memory, and jagged arrays are arrays of arrays.</p>
<section data-type="sect3" data-pdf-bookmark="Rectangular arrays"><div class="sect3" id="rectangular_arrays">
<h3>Rectangular arrays</h3>
<p><a contenteditable="false" data-primary="arrays" data-secondary="rectangular" data-type="indexterm" id="id693"/><a contenteditable="false" data-primary="rectangular arrays" data-type="indexterm" id="id694"/>To declare rectangular arrays, use commas to separate each dimension. The following declares a rectangular two-dimensional array, where the dimensions are 3 × 3:</p>
<pre data-type="programlisting">int[,] matrix = new int [3, 3];</pre>
<p>The <code>GetLength</code> method of an array returns the length for a given dimension (starting at 0):</p>
<pre data-type="programlisting">for (int i = 0; i &lt; matrix.GetLength(0); i++)
  for (int j = 0; j &lt; matrix.GetLength(1); j++)
    matrix [i, j] = i * 3 + j;</pre>
<p>A rectangular array can be initialized as follows (to create an array identical to the previous example):</p>
<pre data-type="programlisting">int[,] matrix = <strong>new int[,]</strong>
{
  {0,1,2},
  {3,4,5},
  {6,7,8}
};</pre>
<p>(The code shown in boldface can be omitted in declaration statements such as this.)</p>
</div></section>
<section data-type="sect3" data-pdf-bookmark="Jagged arrays"><div class="sect3" id="jagged_arrays">
<h3>Jagged arrays</h3>
<p><a contenteditable="false" data-primary="arrays" data-secondary="jagged" data-type="indexterm" id="id695"/><a contenteditable="false" data-primary="jagged arrays" data-type="indexterm" id="id696"/>To declare jagged arrays, use successive square-bracket pairs for each dimension. Here is an example of declaring a jagged two-dimensional array, for which the outermost dimension <span class="keep-together">is 3</span>:</p>
<pre data-type="programlisting">int[][] matrix = new int[3][];</pre>
<p>The inner dimensions aren’t specified in the declaration because, unlike a rectangular array, each inner array can be an arbitrary length. Each inner array is implicitly initialized to null rather than an empty array. Each inner array must be created manually:</p>
<pre data-type="programlisting">for (int i = 0; i &lt; matrix.Length; i++)
{
  matrix[i] = new int [3];       // Create inner array
  for (int j = 0; j &lt; matrix[i].Length; j++)
    matrix[i][j] = i * 3 + j;
}</pre>
<p>A jagged array can be initialized as follows (to create an array identical to the previous example, but with an additional element at the end):</p>
<pre data-type="programlisting">int[][] matrix = <strong>new int[][]</strong>
{
  new <strong>int</strong>[] {0,1,2},
  new <strong>int</strong>[] {3,4,5},
  new <strong>int</strong>[] {6,7,8,9}
};</pre>
<p>(The code shown in boldface can be omitted in declaration statements such as this.)</p>
</div></section>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Simplified Array Initialization Expressions"><div class="sect2" id="simplified_array_initialization_express">
<h2>Simplified Array Initialization Expressions</h2>
<p><a contenteditable="false" data-primary="arrays" data-secondary="simplified initialization expressions" data-type="indexterm" id="id697"/><a contenteditable="false" data-primary="initialization" data-secondary="simplified expressions for arrays" data-type="indexterm" id="id698"/><a contenteditable="false" data-primary="new keyword" data-type="indexterm" id="id699"/><a contenteditable="false" data-primary="simplified array initialization expressions" data-type="indexterm" id="id700"/>We’ve already seen how to simplify array initialization expressions by omitting the <code>new</code> keyword and type declaration:</p>
<pre data-type="programlisting">char[] vowels = new char[] {'a','e','i','o','u'};
char[] vowels =            {'a','e','i','o','u'};
char[] vowels =            ['a','e','i','o','u'];</pre>
<p><a contenteditable="false" data-primary="var keyword" data-type="indexterm" id="id701"/>Another approach is to use the <code>var</code> keyword, which instructs the compiler to implicitly type a local variable. Here are some simple examples:</p>
<pre data-type="programlisting"><strong>var</strong> i = 3;           // i is implicitly of type int
<strong>var</strong> s = "sausage";   // s is implicitly of type string</pre>
<p>The same principle can be applied to arrays, except that it can be taken one stage further. By omitting the type qualifier after the <code>new</code> keyword, the compiler infers the array type:</p>
<pre data-type="programlisting">// Compiler infers char[]
<strong>var</strong> vowels = new[] {'a','e','i','o','u'};</pre>
<p>Here’s how we can apply this to multidimensional arrays:<a contenteditable="false" data-primary="" data-startref="ch1001.html13" data-type="indexterm" id="id702"/></p>
<pre data-type="programlisting">var rectMatrix = new[,]
{
  {0,1,2},
  {3,4,5},
  {6,7,8}
};
var jaggedMat = new int[][]
{
  new[] {0,1,2},
  new[] {3,4,5},
  new[] {6,7,8,9}
};</pre>
</div></section>
</div></section>
<section data-type="sect1" data-pdf-bookmark="Variables and Parameters"><div class="sect1" id="variables_and_parameters">
<h1>Variables and Parameters</h1>
<p><a contenteditable="false" data-primary="variables and parameters" data-secondary="purpose of variables" data-type="indexterm" id="id703"/><a contenteditable="false" data-primary="variables and parameters" data-secondary="types of variables" data-type="indexterm" id="id704"/>A <a contenteditable="false" data-primary="variables and parameters" data-type="indexterm" id="ch1001.html14"/><em>variable</em> represents a storage location that has a modifiable value. A variable can be a <em>local variable</em>, <em>parameter</em> (<em>value</em>, <em>ref</em>, <em>out</em>, or <em>in</em>), <em>field</em> (<em>instance</em> or <em>static</em>), or <em>array element</em>.</p>
<section data-type="sect2" data-pdf-bookmark="The Stack and the Heap"><div class="sect2" id="the_stack_and_the_heap">
<h2>The Stack and the Heap</h2>
<p><a contenteditable="false" data-primary="variables and parameters" data-secondary="stack and heap memory" data-type="indexterm" id="id705"/>The <em>stack</em> and the <em>heap</em> are the places where variables reside. Each has very different lifetime semantics.</p>
<section data-type="sect3" data-pdf-bookmark="Stack"><div class="sect3" id="stack">
<h3>Stack</h3>
<p><a contenteditable="false" data-primary="stack memory" data-type="indexterm" id="id706"/>The <em>stack</em> is a block of memory for storing local variables and parameters. The stack logically grows and shrinks as a method or function is entered and exited. Consider the following method (to avoid distraction, input argument checking is ignored):</p>
<pre data-type="programlisting">static int Factorial (int x)
{
  if (x == 0) return 1;
  return x * Factorial (x-1);
}</pre>
<p><a contenteditable="false" data-primary="methods" data-secondary="recursive methods" data-type="indexterm" id="id707"/><a contenteditable="false" data-primary="recursive methods" data-type="indexterm" id="id708"/>This method is <em>recursive</em>, meaning that it calls itself. Each time the method is entered, a new <code>int</code> is allocated on the stack, and each time the method exits, the <code>int</code> is deallocated.</p>
</div></section>
<section data-type="sect3" data-pdf-bookmark="Heap"><div class="sect3" id="heap">
<h3>Heap</h3>
<p><a contenteditable="false" data-primary="heap memory" data-type="indexterm" id="id709"/><a contenteditable="false" data-primary="object type" data-secondary="heap memory and" data-type="indexterm" id="id710"/><a contenteditable="false" data-primary="value types" data-secondary="heap memory and" data-type="indexterm" id="id711"/>The <em>heap</em> is the memory in which <em>objects</em> (i.e., reference type instances) reside. Whenever a new object is created, it is allocated on the heap, and a reference to that object is returned. During a program’s execution, the heap starts filling up as new objects are created. <a contenteditable="false" data-primary="garbage collection" data-type="indexterm" id="id712"/>The runtime has a garbage collector that periodically deallocates objects from the heap so your program does not run out of memory. An object is eligible for deallocation as soon as it’s not referenced by anything that is itself alive.</p>
<p>Value type instances (and object references) live wherever the variable was declared. If the instance was declared as a field within a class type, or as an array element, that instance lives on the heap.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>You can’t explicitly delete objects in C# as you can in <span class="keep-together">C++</span>. An unreferenced object is eventually collected by the garbage collector.</p>
</div>
<p>The heap also stores static fields and constants. Unlike objects allocated on the heap (which can be garbage-collected), these live until the application domain is torn down.</p>
</div></section>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Definite Assignment"><div class="sect2" id="definite_assignment">
<h2>Definite Assignment</h2>
<p><a contenteditable="false" data-primary="definite assignment policy" data-type="indexterm" id="id713"/><a contenteditable="false" data-primary="local variables" data-secondary="definite assignment policy" data-type="indexterm" id="id714"/><a contenteditable="false" data-primary="variables and parameters" data-secondary="definite assignment" data-type="indexterm" id="id715"/>C# enforces a definite assignment policy. In practice, this means that outside of an <code>unsafe</code> context, it’s impossible to access uninitialized memory. Definite assignment has three implications:</p>
<ul>
<li><p>Local variables must be assigned a value before they can be read.</p></li>
<li><p>Function arguments must be supplied when a method is called (unless marked optional—see <a data-type="xref" href="#optional_parameters">“Optional parameters”</a>).</p></li>
<li><p>All other variables (such as fields and array elements) are automatically initialized by the runtime.</p></li>
</ul>
<p>For example, the following code results in a compile-time error:</p>
<pre data-type="programlisting">int x;                   // x is a local variable
Console.WriteLine (x);   // Compile-time error</pre>
<p>The following, however, outputs <code>0</code>, because fields are implicitly assigned a default value (whether instance or static):</p>
<pre data-type="programlisting">Console.WriteLine (Test.X);   // 0
class Test { public static int X; }   // Field</pre>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Default Values"><div class="sect2" id="default_values">
<h2>Default Values</h2>
<p><a contenteditable="false" data-primary="default values" data-secondary="variables and" data-type="indexterm" id="id716"/><a contenteditable="false" data-primary="structs" data-secondary="default values in" data-type="indexterm" id="id717"/><a contenteditable="false" data-primary="variables and parameters" data-secondary="default values" data-type="indexterm" id="id718"/>All type instances have a default value. The default value for the predefined types is the result of a bitwise zeroing of memory and is <code>null</code> for reference types, <code>0</code> for numeric and enum types, <code>'\0'</code> for the <code>char</code> type, and <code>false</code> for the <code>bool</code> type.</p>
<p><a contenteditable="false" data-primary="default keyword" data-type="indexterm" id="id719"/>You can obtain the default value for any type by using the <code>default</code> keyword (this is particularly useful with generics, as you’ll see later). The default value in a custom value type (i.e., <code>struct</code>) is the same as the default value for each field defined by the custom type:</p>
<pre data-type="programlisting">Console.WriteLine (<strong>default (decimal)</strong>);   // 0
decimal d = <strong>default</strong>;</pre>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Parameters"><div class="sect2" id="parameters">
<h2>Parameters</h2>
<p>A method can have a sequence of parameters. Parameters define the set of arguments that must be provided for that method. In this example, the method <code>Foo</code> has a single parameter named <code>p</code>, of type <code>int</code>:</p>
<pre data-type="programlisting">Foo (8);                        // 8 is an <strong>argument</strong>
static void Foo (int p) {...}   // p is a <strong>parameter</strong></pre>
<p><a contenteditable="false" data-primary="variables and parameters" data-secondary="controlling parameters" data-type="indexterm" id="id720"/>You can control how parameters are passed with the <code>ref</code>, <code>out</code>, and <code>in</code> modifiers:</p>
<table class="border">
<thead>
<tr>
<th>Parameter modifier</th>
<th>Passed by</th>
<th>Variable must be definitely assigned</th>
</tr>
</thead>
<tbody>
<tr>
<td>None</td>
<td>Value</td>
<td>Going <em>in</em></td>
</tr>
<tr>
<td><code>ref</code></td>
<td>Reference</td>
<td>Going <em>in</em></td>
</tr>
<tr>
<td><code>in</code></td>
<td>Reference (read-only)</td>
<td>Going <em>in</em></td>
</tr>
<tr>
<td><code>out</code></td>
<td>Reference</td>
<td>Going <em>out</em></td>
</tr>
</tbody>
</table>
<section data-type="sect3" data-pdf-bookmark="Passing arguments by value"><div class="sect3" id="passing_arguments_by_value">
<h3>Passing arguments by value</h3>
<p><a contenteditable="false" data-primary="arguments" data-secondary="passing by value" data-type="indexterm" id="id721"/><a contenteditable="false" data-primary="parameters" data-secondary="passing arguments by value" data-type="indexterm" id="id722"/><a contenteditable="false" data-primary="passing" data-secondary="by value" data-type="indexterm" id="id723"/><a contenteditable="false" data-primary="variables and parameters" data-secondary="passing arguments by value" data-type="indexterm" id="id724"/>By default, arguments in C# are <em>passed by value</em>, which is by far the most common case. This means that a copy of the value is created when it is passed to the method:</p>
<pre data-type="programlisting">int x = 8;
Foo (x);                  // Make a copy of x
Console.WriteLine (x);    // x will still be 8

static void Foo (int p)
{
  p = p + 1;                // Increment p by 1
  Console.WriteLine (p);    // Write p to screen
}</pre>
<p>Assigning <code>p</code> a new value does not change the contents of <code>x</code>, because <code>p</code> and <code>x</code> reside in different memory locations.</p>
<p>Passing a reference type argument by value copies the <em>reference</em> but not the object. In the following example, <code>Foo</code> sees the same <code>StringBuilder</code> object we instantiated (<code>sb</code>) but has an independent <em>reference</em> to it. In other words, <code>sb</code> and <code>fooSB</code> are separate variables that reference the same <code>StringBuilder</code> object:</p>
<pre data-type="programlisting">StringBuilder sb = new StringBuilder();
Foo (sb);
Console.WriteLine (sb.ToString());    // test

static void Foo (StringBuilder fooSB)
{
  fooSB.Append ("test");
  fooSB = null;
}</pre>
<p>Because <code>fooSB</code> is a <em>copy</em> of a reference, setting it to <code>null</code> doesn’t make <code>sb</code> null. (If, however, <code>fooSB</code> was declared and called with the <code>ref</code> modifier, <code>sb</code> <em>would</em> become null.)</p>
</div></section>
<section data-type="sect3" data-pdf-bookmark="The ref modifier"><div class="sect3" id="the_ref_modifier">
<h3>The ref modifier</h3>
<p><a contenteditable="false" data-primary="arguments" data-secondary="passing by reference" data-type="indexterm" id="id725"/><a contenteditable="false" data-primary="parameters" data-secondary="ref modifier" data-type="indexterm" id="id726"/><a contenteditable="false" data-primary="passing" data-secondary="by reference" data-type="indexterm" id="id727"/><a contenteditable="false" data-primary="ref parameter modifier" data-type="indexterm" id="id728"/><a contenteditable="false" data-primary="variables and parameters" data-secondary="passing arguments by reference" data-type="indexterm" id="id729"/>To <em>pass by reference</em>, C# provides the <code>ref</code> parameter modifier. In the following example, <code>p</code> and <code>x</code> refer to the same memory locations:</p>
<pre data-type="programlisting">int x = 8;
Foo (<strong>ref</strong>  x);              // Ask Foo to deal
                           // directly with x
Console.WriteLine (x);     // x is now 9

static void Foo (<strong>ref</strong> int p)
{
  p = p + 1;               // Increment p by 1
  Console.WriteLine (p);   // Write p to screen
}</pre>
<p>Now assigning <code>p</code> a new value changes the contents of <code>x</code>. Notice how the <code>ref</code> modifier is required both when writing and calling the method. This makes it very clear what’s going on.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>A parameter can be passed by reference or by value, regardless of whether the parameter type is a reference type or a value type.</p>
</div>
</div></section>
<section data-type="sect3" data-pdf-bookmark="The out modifier"><div class="sect3" id="the_out_modifier">
<h3>The out modifier</h3>
<p><a contenteditable="false" data-primary="arguments" data-secondary="out arguments" data-type="indexterm" id="id730"/><a contenteditable="false" data-primary="out modifier" data-type="indexterm" id="id731"/><a contenteditable="false" data-primary="parameters" data-secondary="out modifier" data-type="indexterm" id="id732"/><a contenteditable="false" data-primary="variables and parameters" data-secondary="out modifier" data-type="indexterm" id="id733"/>An <code>out</code> argument is like a <code>ref</code> argument, except for the <span class="keep-together">following</span>:</p>
<ul>
<li><p>It need not be assigned before going into the function.</p></li>
<li><p>It must be assigned before it comes <em>out</em> of the function.</p></li>
</ul>
<p>The <code>out</code> modifier is most commonly used to get multiple return values back from a method.</p>
</div></section>
<section data-type="sect3" data-pdf-bookmark="Out variables and discards"><div class="sect3" id="out_variables_and_discards">
<h3>Out variables and discards</h3>
<p><a contenteditable="false" data-primary="out parameter modifier" data-type="indexterm" id="id734"/><a contenteditable="false" data-primary="variables and parameters" data-secondary="out variables and discards" data-type="indexterm" id="id735"/>From C# 7, you can declare variables on the fly when calling methods with <code>out</code> parameters:</p>
<pre data-type="programlisting">int.TryParse ("123", <strong>out int x</strong>);
Console.WriteLine (x);</pre>
<p>This is equivalent to:</p>
<pre data-type="programlisting">int x;
int.TryParse ("123", out x);
Console.WriteLine (x);</pre>
<p><a contenteditable="false" data-primary="discards" data-type="indexterm" id="id736"/>When calling methods with multiple <code>out</code> parameters, you can use an underscore to “discard” any in which you’re uninterested. Assuming <code>SomeBigMethod</code> has been defined with five <code>out</code> parameters, you can ignore all but the third, as follows:</p>
<pre data-type="programlisting">SomeBigMethod (out _, out _, out int x, out _, out _);
Console.WriteLine (x);</pre>
</div></section>
<section data-type="sect3" data-pdf-bookmark="The in modifier"><div class="sect3" id="the_in_modifier">
<h3>The in modifier</h3>
<p>From C# 7.2, you can prefix a parameter with the <code>in</code> modifier to prevent it from being modified within the method. This allows the compiler to avoid the overhead of copying the argument prior to passing it in, which can matter in the case of large custom value types (see <a data-type="xref" href="#structs">“Structs”</a>).</p>
</div></section>
<section data-type="sect3" data-pdf-bookmark="The params modifier"><div class="sect3" id="the_params_modifier">
<h3>The params modifier</h3>
<p><a contenteditable="false" data-primary="parameters" data-secondary="params modifier" data-type="indexterm" id="id737"/><a contenteditable="false" data-primary="params modifier" data-type="indexterm" id="id738"/><a contenteditable="false" data-primary="variables and parameters" data-secondary="params modifier" data-type="indexterm" id="id739"/>The <code>params</code> modifier, if applied to the last parameter of a method, allows the method to accept any number of arguments of a particular type. The parameter type must be declared as a (single-dimensional) array. For example:</p>
<pre data-type="programlisting">int Sum (params int[] ints)
{
  int sum = 0;
  for (int i = 0; i &lt; ints.Length; i++) sum += ints[i];
  return sum;
}</pre>
<p>You can call this as follows:</p>
<pre data-type="programlisting">Console.WriteLine (Sum (1, 2, 3, 4));    // 10</pre>
<p>If there are zero arguments in the <code>params</code> position, a zero-length array is created.</p>
<p><a contenteditable="false" data-primary="arguments" data-secondary="params argument" data-type="indexterm" id="id740"/>You can also supply a <code>params</code> argument as an ordinary array. The preceding call is semantically equivalent to:</p>
<pre data-type="programlisting">Console.WriteLine (Sum (new int[] { 1, 2, 3, 4 } ));</pre>
</div></section>
<section data-type="sect3" data-pdf-bookmark="Optional parameters"><div class="sect3" id="optional_parameters">
<h3>Optional parameters</h3>
<p><a contenteditable="false" data-primary="optional parameters" data-type="indexterm" id="id741"/><a contenteditable="false" data-primary="parameters" data-secondary="optional" data-type="indexterm" id="id742"/><a contenteditable="false" data-primary="variables and parameters" data-secondary="optional parameters" data-type="indexterm" id="id743"/>Methods, constructors, and indexers can declare <em>optional parameters</em>. <a contenteditable="false" data-primary="arguments" data-secondary="default arguments" data-type="indexterm" id="id744"/>A parameter is optional if it specifies a <em>default value</em> in its declaration:</p>
<pre data-type="programlisting">void Foo (int <strong>x = 23</strong>) { Console.WriteLine (x); }</pre>
<p>You can omit optional parameters when calling the method:</p>
<pre data-type="programlisting">Foo();     // 23</pre>
<p>The <em>default argument</em> of <code>23</code> is actually <em>passed</em> to the optional parameter <code>x</code>—the compiler bakes the value <code>23</code> into the compiled code at the <em>calling</em> side. The preceding call to <code>Foo</code> is semantically identical to</p>
<pre data-type="programlisting">Foo (23);</pre>
<p>because the compiler simply substitutes the default value of an optional parameter wherever it is used.</p>
<div data-type="warning" epub:type="warning"><h6>Warning</h6>
<p>Adding an optional parameter to a public method that’s called from another assembly requires recompilation of both assemblies—just as though the parameter were mandatory.</p>
</div>
<p>The default value of an optional parameter must be specified by a constant expression, a parameterless constructor of a value type, or a <code>default</code> expression. You cannot mark optional parameters with <code>ref</code> or <code>out</code>.</p>
<p>Mandatory parameters must occur <em>before</em> optional parameters in both the method declaration and the method call (the exception is with <code>params</code> arguments, which still always come last). In the following example, the explicit value of <code>1</code> is passed to <code>x</code>, and the default value of <code>0</code> is passed to <code>y</code>:</p>
<pre data-type="programlisting">Foo(1);    // 1, 0

void Foo (int x = 0, int y = 0)
{
  Console.WriteLine (x + ", " + y);
}</pre>
<p>You can do the converse (pass a default value to <code>x</code> and an explicit value to <code>y</code>) by combining optional parameters with <em>named arguments</em>.</p>
</div></section>
<section data-type="sect3" data-pdf-bookmark="Named arguments"><div class="sect3" id="named_arguments">
<h3>Named arguments</h3>
<p><a contenteditable="false" data-primary="arguments" data-secondary="named arguments" data-type="indexterm" id="id745"/><a contenteditable="false" data-primary="named arguments" data-type="indexterm" id="id746"/><a contenteditable="false" data-primary="parameters" data-secondary="named arguments" data-type="indexterm" id="id747"/><a contenteditable="false" data-primary="variables and parameters" data-secondary="named arguments" data-type="indexterm" id="id748"/>Rather than identifying an argument by position, you can identify an argument by name. For example:</p>
<pre data-type="programlisting">Foo (<strong>x:1, y:2</strong>);  // 1, 2

void Foo (int x, int y)
{
  Console.WriteLine (x + ", " + y);
}</pre>
<p>Named arguments can occur in any order. The following calls to <code>Foo</code> are semantically identical:</p>
<pre data-type="programlisting">Foo (x:1, y:2);
Foo (y:2, x:1);</pre>
<p>You can mix named and positional arguments, as long as the named arguments appear last:</p>
<pre data-type="programlisting">Foo (1, y:2);</pre>
<p>Named arguments are particularly useful in conjunction with optional parameters. For instance, consider the following method:</p>
<pre data-type="programlisting">void Bar (int a=0, int b=0, int c=0, int d=0) { ... }</pre>
<p>You can call this, supplying only a value for <code>d</code>, as follows:</p>
<pre data-type="programlisting">Bar (d:3);</pre>
<p>This is particularly useful when you’re calling COM APIs.</p>
</div></section>
</div></section>
<section data-type="sect2" data-pdf-bookmark="var—Implicitly Typed Local Variables"><div class="sect2" id="varem_dashimplicitly_typed_local_variab">
<h2>var—Implicitly Typed Local Variables</h2>
<p><a contenteditable="false" data-primary="implicitly typed local variables" data-type="indexterm" id="id749"/><a contenteditable="false" data-primary="local variables" data-secondary="implicitly typed" data-type="indexterm" id="id750"/><a contenteditable="false" data-primary="var keyword" data-type="indexterm" id="id751"/><a contenteditable="false" data-primary="variables and parameters" data-secondary="implicitly typed local variables" data-type="indexterm" id="id752"/>It is often the case that you declare and initialize a variable in one step. If the compiler is able to infer the type from the initialization expression, you can use the word <code>var</code> in place of the type declaration. For example:</p>
<pre data-type="programlisting"><strong>var</strong> x = "hello";
<strong>var</strong> y = new System.Text.StringBuilder();
<strong>var</strong> z = (float)Math.PI;</pre>
<p class="pagebreak-before">This is precisely equivalent to the following:</p>
<pre data-type="programlisting"><strong>string</strong> x = "hello";
<strong>System.Text.StringBuilder</strong> y = 
  new System.Text.StringBuilder();
<strong>float</strong> z = (float)Math.PI;</pre>
<p>Because of this direct equivalence, implicitly typed variables are statically typed. For example, the following generates a compile-time error:</p>
<pre data-type="programlisting">var x = 5;
x = "hello";    // Compile-time error; x is of type int</pre>
<p>In the section <a data-type="xref" href="#anonymous_types">“Anonymous Types”</a>, we describe a scenario in which the use of <code>var</code> is mandatory.</p>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Target-Typed new Expressions"><div class="sect2" id="target_typed_new_expressions">
<h2>Target-Typed new Expressions</h2>
<p><a contenteditable="false" data-primary="expressions and operators" data-secondary="target-typed new expressions" data-type="indexterm" id="id753"/><a contenteditable="false" data-primary="target-typed new expressions" data-type="indexterm" id="id754"/><a contenteditable="false" data-primary="variables and parameters" data-secondary="target-typed new expressions" data-type="indexterm" id="id755"/>Another way to reduce lexical repetition is with <em>target-typed</em> <code>new</code> <em>expressions</em> (from C# 9):</p>
<pre data-type="programlisting">StringBuilder sb1 = <strong>new()</strong>;
StringBuilder sb2 = <strong>new ("Test")</strong>;</pre>
<p>This is precisely equivalent to:</p>
<pre data-type="programlisting">StringBuilder sb1 = <strong>new StringBuilder()</strong>;
StringBuilder sb2 = <strong>new StringBuilder ("Test")</strong>;</pre>
<p>The principle is that you can call <code>new</code> without specifying a type name if the compiler is able to unambiguously infer it. Target-typed <code>new</code> expressions are particularly useful when the variable declaration and initialization are in different parts of your code. A common example is when you want to initialize a field in a constructor:</p>
<pre data-type="programlisting">class Foo
{
  <strong>System.Text.StringBuilder</strong> sb;
  
  public Foo (string initialValue)
  {
    sb = <strong>new (initialValue)</strong>;
  }
}</pre>
<p><a contenteditable="false" data-primary="" data-startref="ch1001.html14" data-type="indexterm" id="id756"/>Target-typed <code>new</code> expressions are also helpful in the following scenario:</p>
<pre data-type="programlisting">MyMethod (<strong>new ("test")</strong>);
void MyMethod (System.Text.StringBuilder sb) { ... }</pre>
</div></section>
</div></section>
<section data-type="sect1" data-pdf-bookmark="Expressions and Operators"><div class="sect1" id="expressions_and_operators">
<h1>Expressions and Operators</h1>
<p><a contenteditable="false" data-primary="expressions and operators" data-secondary="defined" data-type="indexterm" id="id757"/>An <a contenteditable="false" data-primary="expressions and operators" data-type="indexterm" id="ch1001.html15"/><em>expression</em> essentially denotes a value. The simplest kinds of expressions are constants (such as <code>123</code>) and variables (such as <code>x</code>). Expressions can be transformed and combined with operators. <a contenteditable="false" data-primary="operators" data-secondary="defined" data-type="indexterm" id="id758"/>An <em>operator</em> takes one or more input <em>operands</em> to output a new expression:</p>
<pre data-type="programlisting">12 * 30   // * is an operator; 12 and 30 are operands.</pre>
<p>Complex expressions can be built because an operand can itself be an expression, such as the operand <code>(12 * 30)</code> in the following example:</p>
<pre data-type="programlisting">1 + (12 * 30)</pre>
<p><a contenteditable="false" data-primary="expressions and operators" data-secondary="operator types" data-type="indexterm" id="id759"/>Operators in C# can be classed as <em>unary</em>, <em>binary</em>, or <em>ternary</em>, depending on the number of operands they work on (one, two, or three). The binary operators always use <em>infix</em> notation, in which the operator is placed <em>between</em> the two operands.</p>
<p><a contenteditable="false" data-primary="expressions and operators" data-secondary="primary operators" data-type="indexterm" id="id760"/><a contenteditable="false" data-primary="primary operators" data-type="indexterm" id="id761"/>Operators that are intrinsic to the basic plumbing of the language are called <em>primary</em>; an example is the method call operator. <a contenteditable="false" data-primary="expressions and operators" data-secondary="void expressions" data-type="indexterm" id="id762"/><a contenteditable="false" data-primary="void expressions" data-type="indexterm" id="id763"/>An expression that has no value is called a <em>void expression</em>:</p>
<pre data-type="programlisting">Console.WriteLine (1)</pre>
<p>Because a void expression has no value, you cannot use it as an operand to build more complex expressions:</p>
<pre data-type="programlisting">1 + Console.WriteLine (1)      // Compile-time error</pre>
<section data-type="sect2" data-pdf-bookmark="Assignment Expressions"><div class="sect2" id="assignment_expressions">
<h2>Assignment Expressions</h2>
<p><a contenteditable="false" data-primary="= (equals sign)" data-type="indexterm" id="id764"/><a contenteditable="false" data-primary="assignment (=) operator" data-type="indexterm" id="id765"/><a contenteditable="false" data-primary="assignment expressions" data-type="indexterm" id="id766"/><a contenteditable="false" data-primary="equals sign (=)" data-type="indexterm" id="id767"/><a contenteditable="false" data-primary="expressions and operators" data-secondary="assignment expressions" data-type="indexterm" id="id768"/>An <em>assignment expression</em> uses the <code>=</code> operator to assign the result of another expression to a variable. For example:</p>
<pre data-type="programlisting">x = x * 5</pre>
<p>An assignment expression is not a void expression. It actually carries the assignment value and so can be incorporated into another expression. In the following example, the expression assigns 2 to <code>x</code> and 10 to <code>y</code>:</p>
<pre data-type="programlisting">y = 5 * (x = 2)</pre>
<p>This style of expression can be used to initialize multiple <span class="keep-together">values</span>:</p>
<pre data-type="programlisting">a = b = c = d = 0</pre>
<p><a contenteditable="false" data-primary="compound assignment operators" data-type="indexterm" id="id769"/><a contenteditable="false" data-primary="expressions and operators" data-secondary="compound assignment operators" data-type="indexterm" id="id770"/>The <em>compound assignment operators</em> are syntactic shortcuts that combine assignment with another operator. For example:</p>
<pre data-type="programlisting">x *= 2    // equivalent to x = x * 2
x &lt;&lt;= 1   // equivalent to x = x &lt;&lt; 1</pre>
<p><a contenteditable="false" data-primary="−= operator" data-secondary="subtract from self operator" data-type="indexterm" id="id771"/><a contenteditable="false" data-primary="+= operator" data-secondary="add to self operator" data-type="indexterm" id="id772"/>(A subtle exception to this rule is with <em>events</em>, which we describe later: the <code>+=</code> and <code>-=</code> operators here are treated specially and map to the event’s <code>add</code> and <code>remove</code> accessors, respectively.)</p>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Operator Precedence and Associativity"><div class="sect2" id="operator_precedence_and_associativity">
<h2>Operator Precedence and Associativity</h2>
<p><a contenteditable="false" data-primary="associativity" data-type="indexterm" id="id773"/><a contenteditable="false" data-primary="expressions and operators" data-secondary="operator precedence and associativity" data-type="indexterm" id="id774"/><a contenteditable="false" data-primary="operators" data-secondary="precedence and associativity" data-type="indexterm" id="id775"/>When an expression contains multiple operators, <em>precedence</em> and <em>associativity</em> determine the order of their evaluation. Operators with higher precedence execute before operators of lower precedence. If the operators have the same precedence, the operator’s associativity determines the order of evaluation.</p>
<section data-type="sect3" data-pdf-bookmark="Precedence"><div class="sect3" id="precedence">
<h3>Precedence</h3>
<p><a contenteditable="false" data-primary="operator precedence" data-seealso="expressions and operators; individual operator types" data-type="indexterm" id="id776"/><a contenteditable="false" data-primary="precedence of operators" data-type="indexterm" id="id777"/>The expression <code>1 + 2 * 3</code> is evaluated as <code>1 + (2 * 3)</code> because <code>*</code> has a higher precedence than <code>+</code>.</p>
</div></section>
<section data-type="sect3" data-pdf-bookmark="Left-associative operators"><div class="sect3" id="left_associative_operators">
<h3>Left-associative operators</h3>
<p><a contenteditable="false" data-primary="binary operators" data-type="indexterm" id="id778"/><a contenteditable="false" data-primary="left-associative operators" data-type="indexterm" id="id779"/><a contenteditable="false" data-primary="operators" data-secondary="left-associative" data-type="indexterm" id="id780"/>Binary operators (except for assignment, lambda, and null-coalescing operators) are <em>left-associative</em>; in other words, they are evaluated from left to right. For example, the expression <code>8/4/2</code> is evaluated as <code>(8/4)/2</code> due to left associativity. Of course, you can insert your own parentheses to change evaluation order.</p>
</div></section>
<section data-type="sect3" data-pdf-bookmark="Right-associative operators"><div class="sect3" id="right_associative_operators">
<h3>Right-associative operators</h3>
<p><a contenteditable="false" data-primary="lambda operator" data-type="indexterm" id="id781"/><a contenteditable="false" data-primary="operators" data-secondary="right-associative" data-type="indexterm" id="id782"/><a contenteditable="false" data-primary="right-associative operators" data-type="indexterm" id="id783"/>The assignment and lambda operators, null-coalescing operator, and (ternary) conditional operator are <em>right-associative</em>; in other words, they are evaluated from right to left. Right associativity allows multiple assignments such as <code>x=y=3</code> to compile: it works by first assigning <code>3</code> to <code>y</code> and then assigning the result of that expression (<code>3</code>) to <code>x</code>.</p>
</div></section>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Operator Table"><div class="sect2" id="operator_table">
<h2>Operator Table</h2>
<p><a contenteditable="false" data-primary="expressions and operators" data-secondary="operator table" data-type="indexterm" id="id784"/><a contenteditable="false" data-primary="operators" data-secondary="in order of precedence" data-type="indexterm" id="id785"/>The following table lists C#’s operators in order of precedence. Operators listed under the same subheading have the same precedence. We explain user-overloadable operators in the section <a data-type="xref" href="#operator_overloading">“Operator Overloading”</a>.<a contenteditable="false" data-primary="" data-startref="ch1001.html15" data-type="indexterm" id="id786"/></p>
<table class="border">
<thead>
<tr>
<th>Operator symbol</th>
<th>Operator name</th>
<th>Example</th>
<th>Overloadable</th>
<th/>
</tr>
</thead>
<tbody>
<tr>
<td colspan="4"><strong>Primary (highest precedence)</strong></td>
<td/>
</tr>
<tr>
<td><code>.</code></td>
<td>Member access</td>
<td><code>x.y</code></td>
<td>No</td>
<td/>
</tr>
<tr>
<td><code>?.</code></td>
<td>Null-conditional</td>
<td><code>x?.y</code></td>
<td>No</td>
<td/>
</tr>
<tr>
<td><code>!</code> (postfix)</td>
<td>Null-forgiving</td>
<td><code>x!.y</code></td>
<td>No</td>
<td/>
</tr>
<tr>
<td><code>-&gt;</code></td>
<td>Pointer to struct (unsafe)</td>
<td><code>x-&gt;y</code></td>
<td>No</td>
<td/>
</tr>
<tr>
<td><code>()</code></td>
<td>Function call</td>
<td><code>x()</code></td>
<td>No</td>
<td/>
</tr>
<tr>
<td><code>[]</code></td>
<td>Array/index</td>
<td><code>a[x]</code></td>
<td>Via indexer</td>
<td/>
</tr>
<tr>
<td><code>++</code></td>
<td>Post-increment</td>
<td><code>x++</code></td>
<td>Yes</td>
<td/>
</tr>
<tr>
<td><code>--</code></td>
<td>Post-decrement</td>
<td><code>x--</code></td>
<td>Yes</td>
<td/>
</tr>
<tr>
<td><code>new</code></td>
<td>Create instance</td>
<td><code>new Foo()</code></td>
<td>No</td>
<td/>
</tr>
<tr>
<td><span class="keep-together"><code>stackalloc</code></span></td>
<td>Stack allocation</td>
<td><code>stackalloc(10)</code></td>
<td>No</td>
<td/>
</tr>
<tr>
<td><code>typeof</code></td>
<td>Get type from identifier</td>
<td><code>typeof(int)</code></td>
<td>No</td>
<td/>
</tr>
<tr>
<td><code>nameof</code></td>
<td>Get name of identifier</td>
<td><code>nameof(x)</code></td>
<td>No</td>
<td/>
</tr>
<tr>
<td><code>checked</code></td>
<td>Integral overflow check on</td>
<td><code>checked(x)</code></td>
<td>No</td>
<td/>
</tr>
<tr>
<td><code>unchecked</code></td>
<td>Integral overflow check off</td>
<td><code>unchecked(x)</code></td>
<td>No</td>
<td/>
</tr>
<tr>
<td><code>default</code></td>
<td>Default value</td>
<td><code>default(char)</code></td>
<td>No</td>
<td/>
</tr>
<tr>
<td><code>sizeof</code></td>
<td>Get size of struct</td>
<td><code>sizeof(int)</code></td>
<td>No</td>
<td/>
</tr>
<tr>
<td colspan="4"> <strong>Unary</strong></td>
<td/>
</tr>
<tr>
<td><code>await</code></td>
<td>Await</td>
<td><code>await myTask</code></td>
<td>No</td>
<td/>
</tr>
<tr>
<td><code>+</code></td>
<td>Positive value of</td>
<td><code>+x</code></td>
<td>Yes</td>
<td/>
</tr>
<tr>
<td><code>-</code></td>
<td>Negative value of</td>
<td><code>-x</code></td>
<td>Yes</td>
<td/>
</tr>
<tr>
<td><code>!</code></td>
<td>Not</td>
<td><code>!x</code></td>
<td>Yes</td>
<td/>
</tr>
<tr>
<td><code>~</code></td>
<td>Bitwise complement</td>
<td><code>~x</code></td>
<td>Yes</td>
<td/>
</tr>
<tr>
<td><code>++</code></td>
<td>Pre-increment</td>
<td><code>++x</code></td>
<td>Yes</td>
<td/>
</tr>
<tr>
<td><code>--</code></td>
<td>Pre-decrement</td>
<td><code>--x</code></td>
<td>Yes</td>
<td/>
</tr>
<tr>
<td><code>()</code></td>
<td>Cast</td>
<td><code>(int)x</code></td>
<td>No</td>
<td/>
</tr>
<tr>
<td><code>^</code></td>
<td>Index from end</td>
<td><code>array[^1]</code></td>
<td>No</td>
<td/>
</tr>
<tr>
<td><code>*</code></td>
<td>Value at address (unsafe)</td>
<td><code>*x</code></td>
<td>No</td>
<td/>
</tr>
<tr>
<td><code>&amp;</code></td>
<td>Address of value (unsafe)</td>
<td><code>&amp;x</code></td>
<td>No</td>
<td/>
</tr>
<tr>
<td colspan="4"> <strong>Range</strong></td>
<td/>
</tr>
<tr>
<td><code>..</code><br/><code>..^</code></td>
<td>Range of indices</td>
<td><code>x..y</code><br/><code>x..^y</code></td>
<td>No</td>
<td/>
</tr>
<tr>
<td class="pagebreak-before" colspan="4"> <strong>Switch and with</strong></td>
<td/>
</tr>
<tr>
<td><code>switch</code></td>
<td>Switch expression</td>
<td><code>num switch {</code><br/><code>  1 =&gt; true,</code><br/><code>  _ =&gt; false</code><br/><code>}</code></td>
<td>No</td>
<td/>
</tr>
<tr>
<td><code>with</code></td>
<td>With expression</td>
<td><code>rec with</code><br/><code>{ X = 123 }</code></td>
<td>No</td>
<td/>
</tr>
<tr>
<td colspan="4"> <strong>Multiplicative</strong></td>
<td/>
</tr>
<tr>
<td><code>*</code></td>
<td>Multiply</td>
<td><code>x * y</code></td>
<td>Yes</td>
<td/>
</tr>
<tr>
<td><code>/</code></td>
<td>Divide</td>
<td><code>x / y</code></td>
<td>Yes</td>
<td/>
</tr>
<tr>
<td><code>%</code></td>
<td>Remainder</td>
<td><code>x % y</code></td>
<td>Yes</td>
<td/>
</tr>
<tr>
<td colspan="4"> <strong>Additive</strong></td>
<td/>
</tr>
<tr>
<td><code>+</code></td>
<td>Add</td>
<td><code>x + y</code></td>
<td>Yes</td>
<td/>
</tr>
<tr>
<td><code>-</code></td>
<td>Subtract</td>
<td><code>x - y</code></td>
<td>Yes</td>
<td/>
</tr>
<tr>
<td colspan="4"> <strong>Shift</strong></td>
<td/>
</tr>
<tr>
<td><code>&lt;&lt;</code></td>
<td>Shift left</td>
<td><code>x &lt;&lt; 1</code></td>
<td>Yes</td>
<td/>
</tr>
<tr>
<td><code>&gt;&gt;</code></td>
<td>Shift right</td>
<td><code>x &gt;&gt; 1</code></td>
<td>Yes</td>
<td/>
</tr>
<tr>
<td><code>&gt;&gt;&gt;</code></td>
<td>Unsigned shift right</td>
<td><code>x &gt;&gt;&gt; 1</code></td>
<td>Yes</td>
<td/>
</tr>
<tr>
<td colspan="4"> <strong>Relational</strong></td>
<td/>
</tr>
<tr>
<td><code>&lt;</code></td>
<td>Less than</td>
<td><code>x &lt; y</code></td>
<td>Yes</td>
<td/>
</tr>
<tr>
<td><code>&gt;</code></td>
<td>Greater than</td>
<td><code>x &gt; y</code></td>
<td>Yes</td>
<td/>
</tr>
<tr>
<td><code>&lt;=</code></td>
<td>Less than or equal to</td>
<td><code>x &lt;= y</code></td>
<td>Yes</td>
<td/>
</tr>
<tr>
<td><code>&gt;=</code></td>
<td>Greater than or equal to</td>
<td><code>x &gt;= y</code></td>
<td>Yes</td>
<td/>
</tr>
<tr>
<td><code>is</code></td>
<td>Type is or is subclass of</td>
<td><code>x is y</code></td>
<td>No</td>
<td/>
</tr>
<tr>
<td><code>as</code></td>
<td>Type conversion</td>
<td><code>x as y</code></td>
<td>No</td>
<td/>
</tr>
<tr>
<td colspan="4"> <strong>Equality</strong></td>
<td/>
</tr>
<tr>
<td><code>==</code></td>
<td>Equals</td>
<td><code>x == y</code></td>
<td>Yes</td>
<td/>
</tr>
<tr>
<td><code>!=</code></td>
<td>Not equals</td>
<td><code>x != y</code></td>
<td>Yes</td>
<td/>
</tr>
<tr>
<td colspan="4"> <strong>Bitwise And</strong></td>
<td/>
</tr>
<tr>
<td><code>&amp;</code></td>
<td>And</td>
<td><code>x &amp; y</code></td>
<td>Yes</td>
<td/>
</tr>
<tr>
<td colspan="4"> <strong>Bitwise Xor</strong></td>
<td/>
</tr>
<tr>
<td><code>^</code></td>
<td>Exclusive Or</td>
<td><code>x ^ y</code></td>
<td>Yes</td>
<td/>
</tr>
<tr>
<td colspan="4"> <strong>Bitwise Or</strong></td>
<td/>
</tr>
<tr>
<td><code>|</code></td>
<td>Or</td>
<td><code>x | y</code></td>
<td>Yes</td>
<td/>
</tr>
<tr>
<td colspan="4"> <strong>Conditional And</strong></td>
<td/>
</tr>
<tr>
<td><code>&amp;&amp;</code></td>
<td>Conditional And</td>
<td><code>x &amp;&amp; y</code></td>
<td>Via <code>&amp;</code></td>
<td/>
</tr>
<tr>
<td colspan="4"> <strong>Conditional Or</strong></td>
<td/>
</tr>
<tr>
<td><code>||</code></td>
<td>Conditional Or</td>
<td><code>x || y</code></td>
<td>Via <code>|</code></td>
<td/>
</tr>
<tr>
<td colspan="4"> <strong>Null coalescing</strong></td>
<td/>
</tr>
<tr>
<td><code>??</code></td>
<td>Null coalescing</td>
<td><code>x ?? y</code></td>
<td>No</td>
<td/>
</tr>
<tr>
<td colspan="4"> <strong>Conditional (Ternary)</strong></td>
<td/>
</tr>
<tr>
<td><code>? :</code></td>
<td>Conditional</td>
<td><code>isTrue ? thenThis : elseThis</code></td>
<td>No</td>
<td/>
</tr>
<tr>
<td colspan="4"> <strong>Assignment and lambda (lowest precedence)</strong></td>
<td/>
</tr>
<tr>
<td><code>=</code></td>
<td>Assign</td>
<td><code>x = y</code></td>
<td>No</td>
<td/>
</tr>
<tr>
<td><code>*=</code></td>
<td>Multiply self by</td>
<td><code>x *= 2</code></td>
<td>Via <code>*</code></td>
<td/>
</tr>
<tr>
<td><code>/=</code></td>
<td>Divide self by</td>
<td><code>x /= 2</code></td>
<td>Via <code>/</code></td>
<td/>
</tr>
<tr>
<td><code>+=</code></td>
<td>Add to self</td>
<td><code>x += 2</code></td>
<td>Via <code>+</code></td>
<td/>
</tr>
<tr>
<td><code>-=</code></td>
<td>Subtract from self</td>
<td><code>x -= 2</code></td>
<td>Via <code>-</code></td>
<td/>
</tr>
<tr>
<td><code>&lt;&lt;=</code></td>
<td>Shift self left by</td>
<td><code>x &lt;&lt;= 2</code></td>
<td>Via <code>&lt;&lt;</code></td>
<td/>
</tr>
<tr>
<td><code>&gt;&gt;=</code></td>
<td>Shift self right by</td>
<td><code>x &gt;&gt;= 2</code></td>
<td>Via <code>&gt;&gt;</code></td>
<td/>
</tr>
<tr>
<td><code>&gt;&gt;&gt;=</code></td>
<td>Unsigned shift self right by</td>
<td><code>x &gt;&gt;&gt;= 2</code></td>
<td>Via <code>&gt;&gt;&gt;</code></td>
</tr>
<tr>
<td><code>&amp;=</code></td>
<td>And self by</td>
<td><code>x &amp;= 2</code></td>
<td>Via <code>&amp;</code></td>
<td/>
</tr>
<tr>
<td><code>^=</code></td>
<td>Exclusive-Or self by</td>
<td><code>x ^= 2</code></td>
<td>Via <code>^</code></td>
<td/>
</tr>
<tr>
<td><code>|=</code></td>
<td>Or self by</td>
<td><code>x |= 2</code></td>
<td>Via <code>|</code></td>
<td/>
</tr>
<tr>
<td><code>=&gt;</code></td>
<td>Lambda</td>
<td><code>x =&gt; x + 1</code></td>
<td>No</td>
<td/>
</tr>
</tbody>
</table>
</div></section>
</div></section>
<section data-type="sect1" data-pdf-bookmark="Null Operators"><div class="sect1" id="null_operators">
<h1>Null Operators</h1>
<p><a contenteditable="false" data-primary="expressions and operators" data-secondary="null operators" data-type="indexterm" id="ch1001.html16"/><a contenteditable="false" data-primary="null operators" data-type="indexterm" id="ch1001.html17"/>C# provides three operators to make it easier to work with nulls: the <em>null-coalescing operator</em>, the <em>null-conditional operator</em>, and the <em>null-coalescing assignment operator</em>.</p>
<section data-type="sect2" data-pdf-bookmark="Null-Coalescing Operator"><div class="sect2" id="null_coalescing_operator">
<h2>Null-Coalescing Operator</h2>
<p><a contenteditable="false" data-primary="?? (null-coalescing) operator" data-type="indexterm" id="id787"/><a contenteditable="false" data-primary="null-coalescing (??) operator" data-type="indexterm" id="id788"/>The <code>??</code> operator is the <em>null</em><em>-</em><em>coalescing operator</em>. It says, “If the operand to the left is non-null, give it to me; otherwise, give me another value.” For example:</p>
<pre data-type="programlisting">string s1 = null;
string s2 = s1 ?? "nothing"; // s2 evaluates to "nothing"</pre>
<p>If the lefthand expression is non-null, the righthand expression is never evaluated. The null-coalescing operator also works with nullable value types (see <a data-type="xref" href="#nullable_value_types">“Nullable Value Types”</a>).</p>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Null-Coalescing Assignment Operator"><div class="sect2" id="null_coalescing_assignment_operator">
<h2>Null-Coalescing Assignment Operator</h2>
<p><a contenteditable="false" data-primary="??= (null-coalescing assignment) operator" data-type="indexterm" id="id789"/><a contenteditable="false" data-primary="null-coalescing assignment (??=) operator" data-type="indexterm" id="id790"/>The <code>??=</code> operator (introduced in C# 8) is the <em>null-coalescing assignment operator</em>. It says, “If the operand to the left is null, assign the right operand to the left operand.” Consider the following:</p>
<pre data-type="programlisting">myVariable ??= someDefault;</pre>
<p>This is equivalent to:</p>
<pre data-type="programlisting">if (myVariable == null) myVariable = someDefault;</pre>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Null-Conditional Operator"><div class="sect2" id="null_conditional_operator">
<h2>Null-Conditional Operator</h2>
<p><a contenteditable="false" data-primary="?. (null-conditional) operator" data-type="indexterm" id="id791"/><a contenteditable="false" data-primary="Elvis (null-conditional) operator" data-type="indexterm" id="id792"/><a contenteditable="false" data-primary="null-conditional operator (?.)" data-type="indexterm" id="id793"/>The <code>?.</code> operator is the <em>null-conditional</em> or “Elvis” operator. It allows you to call methods and access members just like the standard dot operator, <a contenteditable="false" data-primary="NullReferenceException errors" data-type="indexterm" id="id794"/>except that if the operand on the left is null, the expression evaluates to null instead of throwing a <code>NullReferenceException</code>:</p>
<pre data-type="programlisting">System.Text.StringBuilder sb = null;
string s = sb<strong>?.</strong>ToString();   // No error; s is null</pre>
<p>The last line is equivalent to this:</p>
<pre data-type="programlisting">string s = (sb == null ? null : sb.ToString());</pre>
<p>Null-conditional expressions also work with indexers:</p>
<pre data-type="programlisting">string[] words = null;
string word = words?[1];   // word is null</pre>
<p>Upon encountering a null, the Elvis operator short-circuits the remainder of the expression. In the following example, <code>s</code> evaluates to null, even with a standard dot operator between <code>ToString()</code> and <code>ToUpper()</code>:</p>
<pre data-type="programlisting">System.Text.StringBuilder sb = null;
string s = sb<strong>?.</strong>ToString().ToUpper();   // No error</pre>
<p>Repeated use of Elvis is necessary only if the operand immediately to its left might be null. The following expression is robust to both <code>x</code> being null and <code>x.y</code> being null:</p>
<pre data-type="programlisting">x?.y?.z</pre>
<p>This is equivalent to the following (except that <code>x.y</code> is evaluated only once):</p>
<pre data-type="programlisting">x == null ? null 
          : (x.y == null ? null : x.y.z)</pre>
<p>The final expression must be capable of accepting a null. The following is illegal because <code>int</code> cannot accept a null:</p>
<pre data-type="programlisting">System.Text.StringBuilder sb = null;
<strong>int</strong> length = sb?.ToString().Length;   // Illegal</pre>
<p>We can fix this with the use of nullable value types (see <a data-type="xref" href="#nullable_value_types">“Nullable Value Types”</a>):</p>
<pre data-type="programlisting"><strong>int?</strong> length = sb?.ToString().Length;
// OK : int? can be null</pre>
<p>You can also use the null-conditional operator to call a void method:</p>
<pre data-type="programlisting">someObject<strong>?.</strong>SomeVoidMethod();</pre>
<p>If <code>someObject</code> is null, this becomes a “no-operation” rather than throwing a <code>NullReferenceException</code>.</p>
<p>The null-conditional operator can be used with the commonly used type members that we describe in <a data-type="xref" href="#classes">“Classes”</a>, including <em>methods</em>, <em>fields</em>, <em>properties</em>, and <em>indexers</em>. It also combines well with the null-coalescing operator:<a contenteditable="false" data-primary="" data-startref="ch1001.html17" data-type="indexterm" id="id795"/><a contenteditable="false" data-primary="" data-startref="ch1001.html16" data-type="indexterm" id="id796"/></p>
<pre data-type="programlisting">System.Text.StringBuilder sb = null;
string s = sb?.ToString() <strong>??</strong> "nothing";
// s evaluates to "nothing"</pre>
</div></section>
</div></section>
<section data-type="sect1" data-pdf-bookmark="Statements"><div class="sect1" id="statements">
<h1>Statements</h1>
<p><a contenteditable="false" data-primary="statements" data-type="indexterm" id="ch1001.html18"/>Functions comprise statements that execute sequentially in the textual order in which they appear. <a contenteditable="false" data-primary="{ } (curly braces)" data-type="indexterm" id="id797"/><a contenteditable="false" data-primary="braces" data-secondary="curly ({ })" data-type="indexterm" id="id798"/><a contenteditable="false" data-primary="curly braces ({ })" data-type="indexterm" id="id799"/><a contenteditable="false" data-primary="statements" data-secondary="statement blocks" data-type="indexterm" id="id800"/>A <em>statement block</em> is a series of statements appearing between braces (the <code>{}</code> tokens).</p>
<section data-type="sect2" data-pdf-bookmark="Declaration Statements"><div class="sect2" id="declaration_statements">
<h2>Declaration Statements</h2>
<p><a contenteditable="false" data-primary="declaration statements" data-type="indexterm" id="id801"/><a contenteditable="false" data-primary="statements" data-secondary="declaration statements" data-type="indexterm" id="id802"/>A variable declaration introduces a new variable, optionally initializing it with an expression. You can declare multiple variables of the same type in a comma-separated list. For example:</p>
<pre data-type="programlisting">bool rich = true, famous = false;</pre>
<p class="pagebreak-before">A constant declaration is like a variable declaration, except that it cannot be changed after it has been declared, and the initialization must occur with the declaration (more on this in <a data-type="xref" href="#constants">“Constants”</a>):</p>
<pre data-type="programlisting"><strong>const</strong> double c = 2.99792458E08;</pre>
<section data-type="sect3" data-pdf-bookmark="Local variable scope"><div class="sect3" id="local_variable_scope">
<h3>Local variable scope</h3>
<p><a contenteditable="false" data-primary="local variables" data-secondary="scope of" data-type="indexterm" id="id803"/>The scope of a local variable or local constant variable extends throughout the current block. You cannot declare another local variable with the same name in the current block or in any nested blocks.</p>
</div></section>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Expression Statements"><div class="sect2" id="expression_statements">
<h2>Expression Statements</h2>
<p><a contenteditable="false" data-primary="expression statements" data-type="indexterm" id="id804"/><a contenteditable="false" data-primary="statements" data-secondary="expression statements" data-type="indexterm" id="id805"/>Expression statements are expressions that are also valid statements. In practice, this means expressions that “do” something; in other words:</p>
<ul>
<li><p>Assign or modify a variable</p></li>
<li><p>Instantiate an object</p></li>
<li><p>Call a method</p></li>
</ul>
<p>Expressions that do none of these are not valid statements:</p>
<pre data-type="programlisting">string s = "foo";
s.Length;          // Illegal statement: does nothing!</pre>
<p>When you call a constructor or a method that returns a value, you’re not obliged to use the result. However, unless the constructor or method changes state, the statement is useless:</p>
<pre data-type="programlisting">new StringBuilder();     // Legal, but useless
x.Equals (y);            // Legal, but useless</pre>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Selection Statements"><div class="sect2" id="selection_statements">
<h2>Selection Statements</h2>
<p>Selection statements conditionally control the flow of program execution.</p>
<section data-type="sect3" data-pdf-bookmark="The if statement"><div class="sect3" id="the_if_statement">
<h3>The if statement</h3>
<p><a contenteditable="false" data-primary="if statements" data-type="indexterm" id="id806"/><a contenteditable="false" data-primary="selection statements" data-secondary="if statement" data-type="indexterm" id="id807"/><a contenteditable="false" data-primary="statements" data-secondary="if statement" data-type="indexterm" id="id808"/>An <code>if</code> statement executes a statement if a <code>bool</code> expression is true. For example:</p>
<pre data-type="programlisting">if (5 &lt; 2 * 3)
  Console.WriteLine ("true");       // true</pre>
<p>The statement can be a code block:</p>
<pre data-type="programlisting">if (5 &lt; 2 * 3)
{
  Console.WriteLine ("true");       // true
  Console.WriteLine ("...")
}</pre>
</div></section>
<section data-type="sect3" data-pdf-bookmark="The else clause"><div class="sect3" id="the_else_clause">
<h3>The else clause</h3>
<p><a contenteditable="false" data-primary="else clause" data-type="indexterm" id="id809"/><a contenteditable="false" data-primary="selection statements" data-secondary="else clause" data-type="indexterm" id="id810"/><a contenteditable="false" data-primary="statements" data-secondary="else clause" data-type="indexterm" id="id811"/>An <code>if</code> statement can optionally feature an <code>else</code> clause:</p>
<pre data-type="programlisting">if (2 + 2 == 5)
  Console.WriteLine ("Does not compute");
else
  Console.WriteLine ("False");        // False</pre>
<p>Within an <code>else</code> clause, you can nest another <code>if</code> statement:</p>
<pre data-type="programlisting">if (2 + 2 == 5)
  Console.WriteLine ("Does not compute");
else
<strong>  if (2 + 2 == 4)</strong>
<strong>    Console.WriteLine ("Computes");    // Computes</strong></pre>
</div></section>
<section data-type="sect3" data-pdf-bookmark="Changing the flow of execution with braces"><div class="sect3" id="changing_the_flow_of_execution_with_bra">
<h3>Changing the flow of execution with braces</h3>
<p><a contenteditable="false" data-primary="braces" data-secondary="changing the flow of execution with" data-type="indexterm" id="id812"/><a contenteditable="false" data-primary="selection statements" data-secondary="changing the flow of execution with braces" data-type="indexterm" id="id813"/><a contenteditable="false" data-primary="statements" data-secondary="changing flow of" data-type="indexterm" id="id814"/>An <code>else</code> clause always applies to the immediately preceding <code>if</code> statement in the statement block. For example:</p>
<pre data-type="programlisting">if (true)
  if (false)
    Console.WriteLine();
  else
    Console.WriteLine ("executes");</pre>
<p>This is semantically identical to the following:</p>
<pre data-type="programlisting">if (true)
{
  if (false)
    Console.WriteLine();
  else
    Console.WriteLine ("executes");
}</pre>
<p>You can change the execution flow by moving the braces:</p>
<pre data-type="programlisting">if (true)
{
  if (false)
    Console.WriteLine();
}
else
  Console.WriteLine ("does not execute");</pre>
<p>C# has no “elseif” keyword; however, the following pattern achieves the same result:</p>
<pre data-type="programlisting">if (age &gt;= 35)
  Console.WriteLine ("You can be president!");
<strong>else if</strong> (age &gt;= 21)
  Console.WriteLine ("You can drink!");
<strong>else if</strong> (age &gt;= 18)
  Console.WriteLine ("You can vote!");
else
  Console.WriteLine ("You can wait!");</pre>
</div></section>
<section data-type="sect3" data-pdf-bookmark="The switch statement"><div class="sect3" id="the_switch_statement">
<h3>The switch statement</h3>
<p><a contenteditable="false" data-primary="selection statements" data-secondary="switch statement" data-type="indexterm" id="id815"/><a contenteditable="false" data-primary="statements" data-secondary="switch statement" data-type="indexterm" id="id816"/><a contenteditable="false" data-primary="switch statements" data-type="indexterm" id="id817"/>Switch statements let you branch program execution based on a selection of possible values that a variable might have. Switch statements can result in cleaner code than multiple <code>if</code> statements because switch statements require an expression to be evaluated only once. For instance:</p>
<pre data-type="programlisting">static void ShowCard (int cardNumber)
{
  switch (cardNumber)
  {
    case 13:
      Console.WriteLine ("King");
      break;
    case 12:
      Console.WriteLine ("Queen");
      break;
    case 11:
      Console.WriteLine ("Jack");
      break;
    default:    // Any other cardNumber
      Console.WriteLine (cardNumber);
      break;
  }
}</pre>
<p>The values in each case expression must be constants, which restricts their allowable types to the built-in numeric types and the <code>bool</code>, <code>char</code>, <code>string</code>, and <code>enum</code> types. At the end of each <code>case</code> clause, you must say explicitly where execution is to go next with some kind of jump statement. Here are the options:</p>
<ul>
<li><p><code>break</code> (jumps to the end of the <code>switch</code> statement)</p></li>
<li><p><code>goto case <em>x</em></code> (jumps to another <code>case</code> clause)</p></li>
<li><p><code>goto default</code> (jumps to the <code>default</code> clause)</p></li>
<li><p>Any other jump statement—namely, <code>return</code>, <code>throw</code>, <span class="keep-together"><code>continue</code></span>, or <code>goto <em>label</em></code></p></li>
</ul>
<p>When more than one value should execute the same code, you can list the common <code>case</code>s sequentially:</p>
<pre data-type="programlisting">switch (cardNumber)
{
<strong>  case 13:</strong>
<strong>  case 12:</strong>
<strong>  case 11:</strong>
    Console.WriteLine ("Face card");
    break;
  default:
    Console.WriteLine ("Plain card");
    break;
}</pre>
<p>This feature of a <code>switch</code> statement can be pivotal in terms of producing cleaner code than multiple <code>if</code>-<code>else</code> statements.</p>
</div></section>
<section data-type="sect3" data-pdf-bookmark="Switching on types"><div class="sect3" id="switching_on_types">
<h3>Switching on types</h3>
<p><a contenteditable="false" data-primary="switching on types" data-type="indexterm" id="id818"/><a contenteditable="false" data-primary="types" data-secondary="switching on" data-type="indexterm" id="id819"/>From C# 7, you can switch on <em>type</em>:</p>
<pre data-type="programlisting">static void TellMeTheType (object x)
{
  switch (x)
  {
    case <strong>int i</strong>:
      Console.WriteLine ("It's an int!");
      break;
    case <strong>string s</strong>:
      Console.WriteLine (<strong>s.</strong>Length);      // We can use <strong>s</strong>
      break;
    case <strong>bool b when b == true</strong>:   // Fires when <strong>b</strong> is true
      Console.WriteLine ("True");
      break;
    case <strong>null:</strong>    // You can also switch on null
      Console.WriteLine ("null");
      break;
  }
}</pre>
<p>(The <code>object</code> type allows for a variable of any type—see <a data-type="xref" href="#inheritance">“Inheritance”</a> and <a data-type="xref" href="#the_object_type">“The object Type”</a>.)</p>
<p>Each <em>case</em> clause specifies a type upon which to match, and a variable upon which to assign the typed value if the match succeeds. Unlike with constants, there’s no restriction on what types you can use. <a contenteditable="false" data-primary="when clauses" data-type="indexterm" id="id820"/>The optional <code>when</code> clause specifies a condition that must be satisfied for the case to match.</p>
<p>The order of the case clauses is relevant when you’re switching on type (unlike when you’re switching on constants). An exception to this rule is the <code>default</code> clause, which is executed last, regardless of where it appears.</p>
<p>You can stack multiple case clauses. The <code>Console.WriteLine</code> in the following code will execute for any floating-point type greater than 1,000:</p>
<pre data-type="programlisting">  switch (x)
  {
<strong>    case float f when f &gt; 1000:</strong>
<strong>    case double d when d &gt; 1000:</strong>
<strong>    case decimal m when m &gt; 1000:</strong>
      Console.WriteLine ("<strong>f, d</strong> and <strong>m</strong> are out of scope");
      break;</pre>
<p>In this example, the compiler lets us consume the variables <code>f</code>, <code>d</code>, and <code>m</code>, <em>only</em> in the <code>when</code> clauses. When we call <code>Console.WriteLine</code>, it’s unknown as to which one of those three variables will be assigned, so the compiler puts all of them out of scope.</p>
</div></section>
<section data-type="sect3" data-pdf-bookmark="Switch expressions"><div class="sect3" id="switch_expressions">
<h3>Switch expressions</h3>
<p><a contenteditable="false" data-primary="expressions and operators" data-secondary="switch keyword in expressions" data-type="indexterm" id="id821"/><a contenteditable="false" data-primary="statements" data-secondary="switch expressions" data-type="indexterm" id="id822"/><a contenteditable="false" data-primary="switch expressions" data-type="indexterm" id="id823"/>From C# 8, you can also use <code>switch</code> in the context of an <em>expression</em>. Assuming <code>cardNumber</code> is of type <code>int</code>, the following illustrates its use:</p>
<pre data-type="programlisting">string cardName = cardNumber <strong>switch</strong>
{
  13 <strong>=&gt;</strong> "King"<strong>,</strong>
  12 <strong>=&gt;</strong> "Queen"<strong>,</strong>
  11 <strong>=&gt;</strong> "Jack"<strong>,</strong>
  <strong>_ =&gt;</strong> "Pip card"   // equivalent to 'default'
};</pre>
<p>Notice that the <code>switch</code> keyword appears <em>after</em> the variable name and that the case clauses are expressions (terminated by commas) rather than statements. You can also switch on multiple values (<em>tuples</em>):</p>
<pre data-type="programlisting">int cardNumber = 12; string suite = "spades";
string cardName = <strong>(cardNumber, suite)</strong> switch
{
  <strong>(13, "spades")</strong> =&gt; "King of spades",
  <strong>(13, "clubs")</strong> =&gt; "King of clubs",
  ...
};</pre>
</div></section>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Iteration Statements"><div class="sect2" id="iteration_statements">
<h2>Iteration Statements</h2>
<p><a contenteditable="false" data-primary="iteration statements" data-type="indexterm" id="id824"/><a contenteditable="false" data-primary="statements" data-secondary="iteration statements" data-type="indexterm" id="id825"/>C# enables a sequence of statements to execute repeatedly with the <code>while</code>, <code>do</code>-<code>while</code>, <code>for</code>, and <code>foreach</code> statements.</p>
<section data-type="sect3" data-pdf-bookmark="while and do-while loops"><div class="sect3" id="while_and_do_while_loops">
<h3>while and do-while loops</h3>
<p><a contenteditable="false" data-primary="while loops" data-type="indexterm" id="id826"/><code>while</code> loops repeatedly execute a body of code while a <code>bool</code> expression is true. The expression is tested <em>before</em> the body of the loop is executed. For example, the following writes <code>012</code>:</p>
<pre data-type="programlisting">int i = 0;
while (i &lt; 3)
{                         // Braces here are optional
  Console.Write (i++);
}</pre>
<p><a contenteditable="false" data-primary="do-while loops" data-type="indexterm" id="id827"/><code>do</code>-<code>while</code> loops differ in functionality from <code>while</code> loops only in that they test the expression <em>after</em> the statement block has executed (ensuring that the block is always executed at least once). Here’s the preceding example rewritten with a <code>do</code>-<code>while</code> loop:</p>
<pre data-type="programlisting">int i = 0;
do
{
  Console.WriteLine (i++);
}
while (i &lt; 3);</pre>
</div></section>
<section data-type="sect3" data-pdf-bookmark="for loops"><div class="sect3" id="for_loops">
<h3>for loops</h3>
<p><a contenteditable="false" data-primary="for loops" data-type="indexterm" id="id828"/><code>for</code> loops are like <code>while</code> loops with special clauses for <em>initialization</em> and <em>iteration</em> of a loop variable. A <code>for</code> loop contains three clauses as follows:</p>
<pre data-type="programlisting">for (<em>init-clause</em>; <em>condition-clause</em>; <em>iteration-clause</em>)
  <em>statement-or-statement-block</em></pre>
<p>The <em>init-clause</em> executes before the loop begins and typically initializes one or more <em>iteration</em> variables.</p>
<p>The <em>condition-clause</em> is a <code>bool</code> expression that is tested <em>before</em> each loop iteration. The body executes while this condition is true.</p>
<p>The <em>iteration-clause</em> is executed <em>after</em> each iteration of the body. It’s typically used to update the iteration variable.</p>
<p>For example, the following prints the numbers 0 through 2:</p>
<pre data-type="programlisting">for (int i = 0; i &lt; 3; i++)
  Console.WriteLine (i);</pre>
<p>The following prints the first 10 Fibonacci numbers (where each number is the sum of the previous two):</p>
<pre data-type="programlisting">for (int i = 0, prevFib = 1, curFib = 1; i &lt; 10; i++)
{
  Console.WriteLine (prevFib);
  int newFib = prevFib + curFib;
  prevFib = curFib; curFib = newFib;
}</pre>
<p>Any of the three parts of the <code>for</code> statement can be omitted. You can implement an infinite loop such as the following (though <code>while(true)</code> can be used instead):</p>
<pre data-type="programlisting">for (;;) Console.WriteLine ("interrupt me");</pre>
</div></section>
<section data-type="sect3" data-pdf-bookmark="foreach loops"><div class="sect3" id="foreach_loops">
<h3>foreach loops</h3>
<p><a contenteditable="false" data-primary="foreach loops" data-type="indexterm" id="id829"/>The <code>foreach</code> statement iterates over each element in an enumerable object. Most of the .NET types that represent a set or list of elements are enumerable. For example, both an array and a string are enumerable. Here is an example of enumerating over the characters in a string, from the first character through the last:</p>
<pre data-type="programlisting">foreach (char c in "beer")
  Console.Write (c + " ");   // b e e r</pre>
<p>We define enumerable objects in <a data-type="xref" href="#enumeration_and_iterators">“Enumeration and Iterators”</a>.</p>
</div></section>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Jump Statements"><div class="sect2" id="jump_statements">
<h2>Jump Statements</h2>
<p><a contenteditable="false" data-primary="jump statements" data-type="indexterm" id="id830"/><a contenteditable="false" data-primary="statements" data-secondary="jump statements" data-type="indexterm" id="id831"/>The C# jump statements are <code>break</code>, <code>continue</code>, <code>goto</code>, <code>return</code>, and <code>throw</code>. We cover the <code>throw</code> keyword in <a data-type="xref" href="#try_statements_and_exceptions">“try Statements and Exceptions”</a>.</p>
<section data-type="sect3" data-pdf-bookmark="The break statement"><div class="sect3" id="the_break_statement">
<h3>The break statement</h3>
<p><a contenteditable="false" data-primary="break statement" data-type="indexterm" id="id832"/>The <code>break</code> statement ends the execution of the body of an iteration or <code>switch</code> statement:</p>
<pre data-type="programlisting">int x = 0;
while (true)
{
  if (x++ &gt; 5) <strong>break</strong>;      // break from the loop
}
// execution continues here after break
...</pre>
</div></section>
<section data-type="sect3" data-pdf-bookmark="The continue statement"><div class="sect3" id="the_continue_statement">
<h3>The continue statement</h3>
<p><a contenteditable="false" data-primary="continue statement" data-type="indexterm" id="id833"/>The <code>continue</code> statement forgoes the remaining statements in the loop and makes an early start on the next iteration. The following loop <em>skips</em> even numbers:</p>
<pre data-type="programlisting">for (int i = 0; i &lt; 10; i++)
{
  if ((i % 2) == 0) <strong>continue</strong>;
  Console.Write (i + " ");      // 1 3 5 7 9
}</pre>
</div></section>
<section data-type="sect3" data-pdf-bookmark="The goto statement"><div class="sect3" id="the_goto_statement">
<h3>The goto statement</h3>
<p><a contenteditable="false" data-primary="goto statement" data-type="indexterm" id="id834"/>The <code>goto</code> statement transfers execution to a label (denoted with a colon suffix) within a statement block. The following iterates the numbers 1 through 5, mimicking a <code>for</code> loop:</p>
<pre data-type="programlisting">int i = 1;
<strong>startLoop:</strong>
if (i &lt;= 5)
{
  Console.Write (i + " ");   // 1 2 3 4 5
  i++;
<strong>  goto startLoop;</strong>
}</pre>
</div></section>
<section data-type="sect3" data-pdf-bookmark="The return statement"><div class="sect3" id="the_return_statement">
<h3>The return statement</h3>
<p><a contenteditable="false" data-primary="return statement" data-type="indexterm" id="id835"/>The <code>return</code> statement exits the method and must return an expression of the method’s return type if the method is nonvoid:</p>
<pre data-type="programlisting">decimal AsPercentage (decimal d)
{
  decimal p = d * 100m;
  return p;     // Return to calling method with value
}</pre>
<p>A <code>return</code> statement can appear anywhere in a method (except in a <code>finally</code> block) and can be used more than once.<a contenteditable="false" data-primary="" data-startref="ch1001.html18" data-type="indexterm" id="id836"/></p>
</div></section>
</div></section>
</div></section>
<section data-type="sect1" data-pdf-bookmark="Namespaces"><div class="sect1" id="namespaces">
<h1>Namespaces</h1>
<p><a contenteditable="false" data-primary="namespaces" data-secondary="defining" data-type="indexterm" id="id837"/>A <a contenteditable="false" data-primary="namespaces" data-type="indexterm" id="ch1001.html19"/><em>namespace</em> is a domain within which type names must be unique. Types are typically organized into hierarchical namespaces—both to avoid naming conflicts and to make type names easier to find. For example, the <code>RSA</code> type that handles public key encryption is defined within the following <span class="keep-together">namespace</span>:</p>
<pre data-type="programlisting">System.Security.Cryptography</pre>
<p>A namespace forms an integral part of a type’s name. The following code calls <code>RSA</code>’s <code>Create</code> method:</p>
<pre data-type="programlisting">System.Security.Cryptography.RSA rsa =
  System.Security.Cryptography.RSA.Create();</pre>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p><a contenteditable="false" data-primary=".dll files" data-primary-sortas="dll" data-type="indexterm" id="id838"/><a contenteditable="false" data-primary=".exe files" data-primary-sortas="exe" data-type="indexterm" id="id839"/>Namespaces are independent of assemblies, which are units of deployment such as an <em>.exe</em> or <em>.dll</em>.</p>
<p>Namespaces also have no impact on member accessibility—<code>public</code>, <code>internal</code>, <code>private</code>, and so on.</p>
</div>
<p><a contenteditable="false" data-primary="namespace keyword" data-type="indexterm" id="id840"/>The <code>namespace</code> keyword defines a namespace for types within that block. For example:</p>
<pre data-type="programlisting">namespace Outer.Middle.Inner
{
  class Class1 {}
  class Class2 {}
}</pre>
<p>The dots in the namespace indicate a hierarchy of nested namespaces. The code that follows is semantically identical to the preceding example:</p>
<pre data-type="programlisting">namespace Outer
{
  namespace Middle
  {
    namespace Inner
    {
      class Class1 {}
      class Class2 {}
    }
  }
}</pre>
<p><a contenteditable="false" data-primary="fully qualified names" data-type="indexterm" id="id841"/><a contenteditable="false" data-primary="namespaces" data-secondary="fully qualified names" data-type="indexterm" id="id842"/>You can refer to a type with its <em>fully qualified name</em>, which includes all namespaces from the outermost to the innermost. For example, you could refer to <code>Class1</code> in the preceding example as <code>Outer.Middle.Inner.Class1</code>.</p>
<p><a contenteditable="false" data-primary="global namespaces" data-type="indexterm" id="id843"/>Types not defined in any namespace are said to reside in the <em>global namespace</em>. The global namespace also includes top-level namespaces, such as <code>Outer</code> in our example.</p>
<section data-type="sect2" data-pdf-bookmark="File-Scoped Namespaces"><div class="sect2" id="file_scoped_namespaces">
<h2>File-Scoped Namespaces</h2>
<p><a contenteditable="false" data-primary="file-scoped namespaces" data-type="indexterm" id="id844"/><a contenteditable="false" data-primary="namespaces" data-secondary="file-scoped" data-type="indexterm" id="id845"/>Often, you will want all the types in a file to be defined in one namespace:</p>
<pre data-type="programlisting">namespace MyNamespace
{
  class Class1 {}
  class Class2 {}
}</pre>
<p>From C# 10, you can accomplish this with a <em>file-scoped <span class="keep-together">namespace</span></em>:</p>
<pre data-type="programlisting"><strong>namespace MyNamespace;</strong>  // Applies to everything below

class Class1 {}         // inside MyNamespace
class Class2 {}         // inside MyNamespace</pre>
<p>File-scoped namespaces reduce clutter and eliminate an unnecessary level of indentation.</p>
</div></section>
<section data-type="sect2" data-pdf-bookmark="The using Directive"><div class="sect2" id="the_using_directive">
<h2>The using Directive</h2>
<p><a contenteditable="false" data-primary="namespaces" data-secondary="using directive" data-type="indexterm" id="id846"/><a contenteditable="false" data-primary="using directive" data-type="indexterm" id="id847"/>The <code>using</code> directive <em>imports</em> a namespace and is a convenient way to refer to types without their fully qualified names. For example, you can refer to <code>Class1</code> in the preceding example as follows:</p>
<pre data-type="programlisting">using Outer.Middle.Inner;

<strong>Class1 c;    // Don't need fully qualified name</strong></pre>
<p>A <code>using</code> directive can be nested within a namespace itself to limit the scope of the directive.</p>
</div></section>
<section data-type="sect2" data-pdf-bookmark="The global using Directive"><div class="sect2" id="the_global_using_directive">
<h2>The global using Directive</h2>
<p><a contenteditable="false" data-primary="global using directive" data-type="indexterm" id="id848"/><a contenteditable="false" data-primary="namespaces" data-secondary="global using directive" data-type="indexterm" id="id849"/>From C# 10, if you prefix a <code>using</code> directive with the <code>global</code> keyword, the directive will apply to all files in the project or compilation unit:</p>
<pre data-type="programlisting"><strong>global</strong> using System;
<strong>global</strong> using System.Collection.Generic;</pre>
<p>This lets you centralize common imports and avoid repeating the same directives in every file.</p>
<p><code>global using</code> directives must precede nonglobal directives and cannot appear inside namespace declarations. The global directive can be used with <code>using static</code>.</p>
</div></section>
<section data-type="sect2" data-pdf-bookmark="using static"><div class="sect2" id="using_static">
<h2>using static</h2>
<p><a contenteditable="false" data-primary="namespaces" data-secondary="using static directive" data-type="indexterm" id="id850"/><a contenteditable="false" data-primary="using static directive" data-type="indexterm" id="id851"/>The <code>using static</code> directive imports a <em>type</em> rather than a namespace. All static members of that type can then be used without being qualified with the type name. In the following example, we call the <code>Console</code> class’s static <code>WriteLine</code> method:</p>
<pre data-type="programlisting"><strong>using static System.Console;</strong>

<strong>WriteLine</strong> ("Hello");</pre>
<p>The <code>using static</code> directive imports all accessible static members of the type, including fields, properties, and nested types. You can also apply this directive to enum types (see <a data-type="xref" href="#enums">“Enums”</a>), in which case their members are imported. Should an ambiguity arise between multiple static imports, the C# compiler is unable to infer the correct type from the context and will generate an error.</p>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Rules Within a Namespace"><div class="sect2" id="rules_within_a_namespace">
<h2>Rules Within a Namespace</h2>
<section data-type="sect3" data-pdf-bookmark="Name scoping"><div class="sect3" id="name_scoping">
<h3>Name scoping</h3>
<p><a contenteditable="false" data-primary="namespaces" data-secondary="name scoping" data-type="indexterm" id="id852"/>Names declared in outer namespaces can be used unqualified within inner namespaces. In this example, <code>Class1</code> does not need qualification within <code>Inner</code>:</p>
<pre data-type="programlisting">namespace Outer
{
  class Class1 {}

  namespace Inner
  {
    class Class2 : <strong>Class1</strong> {}
  }
}</pre>
<p>If you want to refer to a type in a different branch of your namespace hierarchy, you can use a partially qualified name. In the following example, we base <code>SalesReport</code> on <code>Common.ReportBase</code>:</p>
<pre data-type="programlisting">namespace MyTradingCompany
{
  namespace Common
  {
    class ReportBase {}
  }
  namespace ManagementReporting
  {
    class SalesReport : <strong>Common.ReportBase</strong> {}
  }
}</pre>
</div></section>
<section data-type="sect3" data-pdf-bookmark="Name hiding"><div class="sect3" id="name_hiding">
<h3>Name hiding</h3>
<p><a contenteditable="false" data-primary="namespaces" data-secondary="name hiding" data-type="indexterm" id="id853"/>If the same type name appears in both an inner and an outer namespace, the inner name wins. To refer to the type in the outer namespace, you must qualify its name.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>All type names are converted to fully qualified names at compile time. Intermediate Language (IL) code contains no unqualified or partially qualified names.</p>
</div>
</div></section>
<section data-type="sect3" data-pdf-bookmark="Repeated namespaces"><div class="sect3" id="repeated_namespaces">
<h3>Repeated namespaces</h3>
<p>You can repeat a namespace declaration, as long as the type names within the namespaces don’t conflict:</p>
<pre data-type="programlisting">namespace Outer.Middle.Inner { class Class1 {} }
namespace Outer.Middle.Inner { class Class2 {} }</pre>
<p>The classes can even span source files and assemblies.</p>
</div></section>
<section data-type="sect3" data-pdf-bookmark="The global:: qualifier"><div class="sect3" id="the_global_qualifier">
<h3>The global:: qualifier</h3>
<p><a contenteditable="false" data-primary="global:: qualifier" data-type="indexterm" id="id854"/><a contenteditable="false" data-primary="namespaces" data-secondary="global:: qualifier" data-type="indexterm" id="id855"/>Occasionally, a fully qualified type name might conflict with an inner name. You can force C# to use the fully qualified type name by prefixing it with <code>global::</code>, as follows:</p>
<pre data-type="programlisting"><strong>global::</strong>System.Text.StringBuilder sb;</pre>
</div></section>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Aliasing Types and Namespaces"><div class="sect2" id="aliasing_types_and_namespaces">
<h2>Aliasing Types and Namespaces</h2>
<p><a contenteditable="false" data-primary="aliasing" data-type="indexterm" id="id856"/><a contenteditable="false" data-primary="namespaces" data-secondary="aliasing types and" data-type="indexterm" id="id857"/><a contenteditable="false" data-primary="namespaces" data-secondary="importing" data-type="indexterm" id="id858"/><a contenteditable="false" data-primary="types" data-secondary="aliasing" data-type="indexterm" id="id859"/>Importing a namespace can result in type-name collision. Rather than importing the whole namespace, you can import just the specific types you need, giving each type an alias. For example:</p>
<pre data-type="programlisting">using PropertyInfo2 = System.Reflection.PropertyInfo;
class Program { PropertyInfo2 p; }</pre>
<p>An entire namespace can be aliased, as follows:<a contenteditable="false" data-primary="" data-startref="ch1001.html19" data-type="indexterm" id="id860"/></p>
<pre data-type="programlisting">using R = System.Reflection;
class Program { R.PropertyInfo p; }</pre>
<section data-type="sect3" data-pdf-bookmark="Alias any type (C# 12)"><div class="sect3" id="alias_any_type_left_parenthesischash_on">
<h3>Alias any type (C# 12)</h3>
<p><a contenteditable="false" data-primary="using directive" data-type="indexterm" id="id861"/>From C# 12, the <code>using</code> directive can alias any kind of type, including, for instance, arrays:</p>
<pre data-type="programlisting">using NumberList = double[];
NumberList numbers = { 2.5, 3.5 };</pre>
<p>You can also alias tuples (see <a data-type="xref" href="#tuples">“Tuples”</a>).</p>
</div></section>
</div></section>
</div></section>
<section data-type="sect1" data-pdf-bookmark="Classes"><div class="sect1" id="classes">
<h1>Classes</h1>
<p><a contenteditable="false" data-primary="classes" data-secondary="declaring" data-type="indexterm" id="id862"/>A <a contenteditable="false" data-primary="classes" data-type="indexterm" id="ch1001.html20"/><em>class</em> is the most common kind of reference type. The simplest possible class declaration is as follows:</p>
<pre data-type="programlisting">class Foo
{
}</pre>
<p>A more complex class optionally has the following:</p>
<table class="border">
<tbody>
<tr>
<td>Preceding the keyword <code>class</code></td>
<td><em>Attributes</em> and <em>class modifiers</em>. The non-nested class modifiers are <code>public</code>, <code>internal</code>, <code>abstract</code>, <code>sealed</code>, <code>static</code>, <code>unsafe</code>, and <code>partial</code>.</td>
</tr>
<tr>
<td>Following <code>Foo</code></td>
<td><em>Generic type parameters</em> and <em>constraints</em>, a <em>base class</em>, and <em>interfaces</em>.</td>
</tr>
<tr>
<td>Within the braces</td>
<td><em>Class members</em> (these are <em>methods</em>, <em>properties</em>, <em>indexers</em>, <em>events</em>, <em>fields</em>, <em>constructors</em>, <em>overloaded operators</em>, <em>nested types</em>, and a <em>finalizer</em>).</td>
</tr>
</tbody>
</table>
<section data-type="sect2" data-pdf-bookmark="Fields"><div class="sect2" id="fields">
<h2>Fields</h2>
<p><a contenteditable="false" data-primary="classes" data-secondary="fields in" data-type="indexterm" id="id863"/><a contenteditable="false" data-primary="fields" data-type="indexterm" id="id864"/>A <em>field</em> is a variable that is a member of a class or struct. For example:</p>
<pre data-type="programlisting">class Octopus
{
<strong>  string name;</strong>
<strong>  public int Age = 10;</strong>
}</pre>
<p>A field can have the <code>readonly</code> modifier to prevent it from being modified after construction. A read-only field can be assigned only in its declaration or within the enclosing type’s <span class="keep-together">constructor</span>.</p>
<p><a contenteditable="false" data-primary="initialization" data-secondary="fields" data-type="indexterm" id="id865"/>Field initialization is optional. An uninitialized field has a default value (<code>0</code>, <code>'\0'</code>, <code>null</code>, <code>false</code>). Field initializers run before constructors in the order in which they appear.</p>
<p>For convenience, you can declare multiple fields of the same type in a comma-separated list. This is a convenient way for all the fields to share the same attributes and field modifiers. For example:</p>
<pre data-type="programlisting">static readonly int legs = 8, eyes = 2;</pre>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Constants"><div class="sect2" id="constants">
<h2>Constants</h2>
<p><a contenteditable="false" data-primary="classes" data-secondary="constants in" data-type="indexterm" id="id866"/><a contenteditable="false" data-primary="constants" data-type="indexterm" id="id867"/>A <em>constant</em> is evaluated statically at compile time, and the compiler literally substitutes its value whenever used (rather like a macro in C++). A constant can be any of the built-in numeric types: <code>bool</code>, <code>char</code>, <code>string</code>, or an enum type.</p>
<p><a contenteditable="false" data-primary="const keyword" data-type="indexterm" id="id868"/>A constant is declared with the <code>const</code> keyword and must be initialized with a value. For example:</p>
<pre data-type="programlisting">public class Test
{
<strong>  public const string Message = "Hello World";</strong>
}</pre>
<p>A constant is much more restrictive than a <code>static readonly</code> field—both in the types you can use and in field initialization semantics. A constant also differs from a <code>static readonly</code> field in that the evaluation of the constant occurs at compile time. Constants can also be declared local to a method:</p>
<pre data-type="programlisting">static void Main()
{
  <strong>const</strong> double twoPI = 2 * System.Math.PI;
  ...
}</pre>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Methods"><div class="sect2" id="methods">
<h2>Methods</h2>
<p><a contenteditable="false" data-primary="classes" data-secondary="methods and" data-type="indexterm" id="id869"/><a contenteditable="false" data-primary="methods" data-secondary="purpose of" data-type="indexterm" id="id870"/>A <em>method</em> performs an action in a series of statements. A method can receive <em>input</em> data from the caller by specifying <em>parameters</em> and send <em>output</em> data back to the caller by specifying a <em>return type</em>. A method can specify a <code>void</code> return type, indicating that it doesn’t return any value to its caller. A method can also output data back to the caller via <code>ref</code> and <code>out</code> parameters.</p>
<p><a contenteditable="false" data-primary="signature method" data-type="indexterm" id="id871"/>A method’s <em>signature</em> must be unique within the type. A method’s signature comprises its name and parameter types in order (but not the parameter <em>names</em> nor the return type).</p>
<section data-type="sect3" data-pdf-bookmark="Expression-bodied methods"><div class="sect3" id="expression_bodied_methods">
<h3>Expression-bodied methods</h3>
<p><a contenteditable="false" data-primary="expression-bodied methods" data-type="indexterm" id="id872"/><a contenteditable="false" data-primary="methods" data-secondary="expression-bodied" data-type="indexterm" id="id873"/>A method that comprises a single expression, such as the <span class="keep-together">following</span>:</p>
<pre data-type="programlisting">int Foo (int x) { return x * 2; }</pre>
<p>can be written more tersely as an <em>expression-bodied method</em>. A fat arrow replaces the braces and <code>return</code> keyword:</p>
<pre data-type="programlisting">int Foo (int x) <strong>=&gt; x * 2;</strong></pre>
<p>Expression-bodied functions can also have a <code>void</code> return type:</p>
<pre data-type="programlisting">void Foo (int x) <strong>=&gt; Console.WriteLine (x);</strong></pre>
</div></section>
<section data-type="sect3" data-pdf-bookmark="Local methods"><div class="sect3" id="local_methods">
<h3>Local methods</h3>
<p><a contenteditable="false" data-primary="methods" data-secondary="local methods" data-type="indexterm" id="id874"/>You can define a method within another method:</p>
<pre data-type="programlisting">void WriteCubes()
{
  Console.WriteLine (Cube (3));

  int Cube (int value) =&gt; value * value * value;
}</pre>
<p><a contenteditable="false" data-primary="local methods" data-secondary="visibility of" data-type="indexterm" id="id875"/>The local method (<code>Cube</code>, in this case) is visible only to the enclosing method (<code>WriteCubes</code>). This simplifies the containing type and instantly signals to anyone looking at the code that <code>Cube</code> is used nowhere else. Local methods can access the local variables and parameters of the enclosing method. This has a number of consequences, which we describe in <a data-type="xref" href="#capturing_outer_variables">“Capturing Outer Variables”</a>.</p>
<p>Local methods can appear within other function kinds, such as property accessors, constructors, and so on, and even within other local methods. Local methods can be iterators or <span class="keep-together">asynchronous</span>.</p>
<p>Methods declared in top-level statements are implicitly local; we can demonstrate this as follows:</p>
<pre data-type="programlisting">int x = 3; Foo();
void Foo() =&gt; Console.WriteLine (x);  // We can access x</pre>
</div></section>
<section data-type="sect3" data-pdf-bookmark="Static local methods"><div class="sect3" id="static_local_methods">
<h3>Static local methods</h3>
<p><a contenteditable="false" data-primary="methods" data-secondary="static local methods" data-type="indexterm" id="id876"/><a contenteditable="false" data-primary="static local methods" data-type="indexterm" id="id877"/>Adding the <code>static</code> modifier to a local method (from C# 8) prevents it from seeing the local variables and parameters of the enclosing method. This helps to reduce coupling and prevents the local method from accidentally referring to variables in the containing method.</p>
</div></section>
<section data-type="sect3" data-pdf-bookmark="Overloading methods"><div class="sect3" id="overloading_methods">
<h3>Overloading methods</h3>
<div data-type="warning" epub:type="warning"><h6>Warning</h6>
<p><a contenteditable="false" data-primary="methods" data-secondary="overloading methods" data-type="indexterm" id="id878"/><a contenteditable="false" data-primary="overloading methods" data-seealso="operator overloading" data-type="indexterm" id="id879"/>Local methods cannot be overloaded. This means that methods declared in top-level statements (which are treated as local methods) cannot be overloaded.</p>
</div>
<p><a contenteditable="false" data-primary="types" data-secondary="overloading methods" data-type="indexterm" id="id880"/>A type can overload methods (have multiple methods with the same name) as long as the parameter types are different. For example, the following methods can all coexist in the same type:</p>
<pre data-type="programlisting">void Foo (int x);
void Foo (double x);
void Foo (int x, float y);
void Foo (float x, int y);</pre>
</div></section>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Instance Constructors"><div class="sect2" id="instance_constructors">
<h2>Instance Constructors</h2>
<p><a contenteditable="false" data-primary="classes" data-secondary="instance constructors" data-type="indexterm" id="id881"/><a contenteditable="false" data-primary="constructors" data-secondary="instance constructors" data-type="indexterm" id="id882"/><a contenteditable="false" data-primary="instance constructors" data-type="indexterm" id="id883"/>Constructors run initialization code on a class or struct. A constructor is defined like a method, except that the method name and return type are reduced to the name of the enclosing type:</p>
<pre data-type="programlisting">Panda p = new Panda ("Petey");   // Call constructor

public class Panda
{
  string name;              // Define field
<strong>  public Panda (string n)   // Define constructor</strong>
<strong>  {</strong>
<strong>    name = n;               // Initialization code</strong>
<strong>  }</strong>
}</pre>
<p>Single-statement constructors can be written as expression-bodied members:</p>
<pre data-type="programlisting">public Panda (string n) <strong>=&gt;</strong> name = n;</pre>
<p>A class or struct can overload constructors. <a contenteditable="false" data-primary="this keyword" data-type="indexterm" id="id884"/>One overload can call another, using the <code>this</code> keyword:</p>
<pre data-type="programlisting">public class Wine
{
  public Wine (decimal price) {...}

  public Wine (decimal price, int year) 
    <strong>: this (price)</strong> {...}
}</pre>
<p>When one constructor calls another, the <em>called constructor</em> executes first.</p>
<p>You can pass an <em>expression</em> into another constructor as follows:</p>
<pre data-type="programlisting">  public Wine (decimal price, DateTime year)
    : this (price,<strong> year.Year</strong>) {...}</pre>
<p>The expression itself cannot make use of the <code>this</code> reference, for example, to call an instance method. It can, however, call static methods.</p>
<section data-type="sect3" data-pdf-bookmark="Implicit parameterless constructors"><div class="sect3" id="implicit_parameterless_constructors">
<h3>Implicit parameterless constructors</h3>
<p><a contenteditable="false" data-primary="constructors" data-secondary="implicit parameterless" data-type="indexterm" id="id885"/><a contenteditable="false" data-primary="implicit parameterless constructors" data-type="indexterm" id="id886"/>For classes, the C# compiler automatically generates a parameterless public constructor if and only if you do not define any constructors. However, as soon as you define at least one constructor, the parameterless constructor is no longer automatically generated.</p>
</div></section>
<section data-type="sect3" data-pdf-bookmark="Nonpublic constructors"><div class="sect3" id="nonpublic_constructors">
<h3>Nonpublic constructors</h3>
<p><a contenteditable="false" data-primary="constructors" data-secondary="nonpublic constructors" data-type="indexterm" id="id887"/><a contenteditable="false" data-primary="nonpublic constructors" data-type="indexterm" id="id888"/>Constructors do not need to be public. A common reason to have a nonpublic constructor is to control instance creation via a static method call. The static method could be used to return an object from a pool rather than creating a new object or to return a specialized subclass chosen based on input arguments.</p>
</div></section>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Deconstructors"><div class="sect2" id="deconstructors">
<h2>Deconstructors</h2>
<p><a contenteditable="false" data-primary="classes" data-secondary="deconstructors" data-type="indexterm" id="id889"/><a contenteditable="false" data-primary="deconstructors" data-type="indexterm" id="id890"/>Whereas a constructor typically takes a set of values (as parameters) and assigns them to fields, a deconstructor (C# 7+) does the reverse and assigns fields back to a set of variables. A deconstruction method must be called <code>Deconstruct</code> and have one or more <code>out</code> parameters:</p>
<pre data-type="programlisting">class Rectangle
{
  public readonly float Width, Height;
  
  public Rectangle (float width, float height)
  {
    Width = width; Height = height;
  }
  
<strong>  public void Deconstruct (out float width,</strong>
<strong>                           out float height)</strong>
<strong>  {</strong>
<strong>    width = Width; height = Height;</strong>
<strong>  }</strong>
}</pre>
<p>To call the deconstructor, you use the following special syntax:</p>
<pre data-type="programlisting">var rect = new Rectangle (3, 4);
<strong>(float width, float height) = rect;</strong>
Console.WriteLine (width + " " + height);    // 3 4</pre>
<p>The second line is the deconstructing call. It creates two local variables and then calls the <code>Deconstruct</code> method. Our deconstructing call is equivalent to the following:</p>
<pre data-type="programlisting">rect.Deconstruct (out var width, out var height);</pre>
<p>Deconstructing calls allow implicit typing, so we could shorten our call to:</p>
<pre data-type="programlisting">(<strong>var</strong> width, <strong>var</strong> height) = rect;</pre>
<p>Or simply:</p>
<pre data-type="programlisting"><strong>var</strong> (width, height) = rect;</pre>
<p>If the variables into which you’re deconstructing are already defined, omit the types altogether; this is called a <em>deconstructing assignment</em>:</p>
<pre data-type="programlisting">(width, height) = rect;</pre>
<p>You can offer the caller a range of deconstruction options by overloading the <code>Deconstruct</code> method.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>The <code>Deconstruct</code> method can be an extension method (see <a data-type="xref" href="#extension_methods">“Extension Methods”</a>). This is a useful trick if you want to deconstruct types that you did not author.</p>
</div>
<p>From C# 10, you can mix and match existing and new variables when deconstructing:</p>
<pre data-type="programlisting">double x1 = 0;
(x1, double y2) = rect;</pre>
</div></section>
<section data-type="sect2" class="pagebreak-before" data-pdf-bookmark="Object Initializers"><div class="sect2" id="object_initializers">
<h2 class="less_space">Object Initializers</h2>
<p><a contenteditable="false" data-primary="classes" data-secondary="object initializers" data-type="indexterm" id="id891"/><a contenteditable="false" data-primary="initializers" data-secondary="object" data-type="indexterm" id="id892"/><a contenteditable="false" data-primary="object initializers" data-type="indexterm" id="id893"/><a contenteditable="false" data-primary="object type" data-secondary="object initializers" data-type="indexterm" id="id894"/>To simplify object initialization, the accessible fields or properties of an object can be initialized via an <em>object initializer</em> directly after construction. For example, consider the following class:</p>
<pre data-type="programlisting">public class Bunny
{
  public string Name;
  public bool LikesCarrots, LikesHumans;

  public Bunny () {}
  public Bunny (string n) =&gt; Name = n;
}</pre>
<p>Using object initializers, you can instantiate <code>Bunny</code> objects as follows:</p>
<pre data-type="programlisting">Bunny b1 = new Bunny {
                       Name="Bo",
                       LikesCarrots = true,
                       LikesHumans = false
                     };

Bunny b2 = new Bunny ("Bo") {
                              LikesCarrots = true,
                              LikesHumans = false
                            };</pre>
</div></section>
<section data-type="sect2" data-pdf-bookmark="The this Reference"><div class="sect2" id="the_this_reference">
<h2>The this Reference</h2>
<p><a contenteditable="false" data-primary="classes" data-secondary="this reference" data-type="indexterm" id="id895"/><a contenteditable="false" data-primary="this reference" data-type="indexterm" id="id896"/>The <code>this</code> reference refers to the instance itself. In the following example, the <code>Marry</code> method uses <code>this</code> to set the <code>partner</code>’s <code>mate</code> field:</p>
<pre data-type="programlisting">public class Panda
{
  public Panda Mate;

  public void Marry (Panda partner)
  {
    Mate = partner;
    partner.Mate = this;
  }
}</pre>
<p>The <code>this</code> reference also disambiguates a local variable or parameter from a field. For example:</p>
<pre data-type="programlisting">public class Test
{
  string name;
  public Test (string name) =&gt; this.name = name;
}</pre>
<p>The <code>this</code> reference is valid only within nonstatic members of a class or struct.</p>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Properties"><div class="sect2" id="properties">
<h2>Properties</h2>
<p><a contenteditable="false" data-primary="classes" data-secondary="properties" data-type="indexterm" id="ch1001.html21"/><a contenteditable="false" data-primary="properties" data-type="indexterm" id="ch1001.html22"/>Properties look like fields from the outside, but internally they contain logic, like methods do. For example, you can’t determine by looking at the following code whether <code>CurrentPrice</code> is a field or a property:</p>
<pre data-type="programlisting">Stock msft = new Stock();
msft.CurrentPrice = 30;
msft.CurrentPrice -= 3;
Console.WriteLine (msft.CurrentPrice);</pre>
<p><a contenteditable="false" data-primary="properties" data-secondary="declaring" data-type="indexterm" id="id897"/>A property is declared like a field but with a <code>get</code>/<code>set</code> block added. Here’s how to implement <code>CurrentPrice</code> as a property:</p>
<pre data-type="programlisting">public class Stock
{
  decimal currentPrice;  // The private "backing" field

  public decimal CurrentPrice    // The public property
  {
     get { return currentPrice; }
     set { currentPrice = value; }
  }
}</pre>
<p><a contenteditable="false" data-primary="properties" data-secondary="property accessors" data-type="indexterm" id="id898"/><code>get</code> and <code>set</code> denote property <em>accessors</em>. <a contenteditable="false" data-primary="get accessors" data-type="indexterm" id="id899"/>The <code>get</code> accessor runs when the property is read. It must return a value of the property’s type. <a contenteditable="false" data-primary="set accessors" data-type="indexterm" id="id900"/>The <code>set</code> accessor runs when the property is assigned. It has an implicit parameter named <code>value</code> of the property’s type that you typically assign to a private field (in this case, <code>currentPrice</code>).</p>
<p>Although properties are accessed in the same way as fields, they differ in that they give the implementer complete control over getting and setting its value. This control enables the implementer to choose whatever internal representation is needed, without exposing the internal details to the user of the property. In this example, the <code>set</code> method could throw an exception if <code>value</code> was outside a valid range of values.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Throughout this book, we use public fields to keep the examples free of distraction. In a real application, you would typically favor public properties over public fields to promote encapsulation.</p>
</div>
<p>A property is read-only if it specifies only a <code>get</code> accessor, and it is write-only if it specifies only a <code>set</code> accessor. Write-only properties are rarely used.</p>
<p>A property typically has a dedicated backing field to store the underlying data. However, it doesn’t need to; it can instead return a value computed from other data:</p>
<pre data-type="programlisting">decimal currentPrice, sharesOwned;

public decimal Worth
{
  get { return currentPrice * sharesOwned; }
}</pre>
<section data-type="sect3" data-pdf-bookmark="Expression-bodied properties"><div class="sect3" id="expression_bodied_properties">
<h3>Expression-bodied properties</h3>
<p><a contenteditable="false" data-primary="=&gt; (fat arrow) notation" data-secondary="expression-bodied properties" data-type="indexterm" id="id901"/><a contenteditable="false" data-primary="expression-bodied properties" data-type="indexterm" id="id902"/><a contenteditable="false" data-primary="fat arrow (=&gt;) notation" data-secondary="expression-bodied properties" data-type="indexterm" id="id903"/>You can declare a read-only property, such as the preceding one, more tersely as an <em>expression-bodied property</em>. A fat arrow replaces all the braces and the <code>get</code> and <code>return</code> keywords:</p>
<pre data-type="programlisting">public decimal Worth <strong>=&gt; currentPrice * sharesOwned;</strong></pre>
<p>From C# 7, <code>set</code> accessors can be expression-bodied too:</p>
<pre data-type="programlisting">public decimal Worth
{
  <strong>get =&gt; currentPrice * sharesOwned;</strong>
<strong>  set =&gt; sharesOwned = value / currentPrice;</strong>
}</pre>
</div></section>
<section data-type="sect3" data-pdf-bookmark="Automatic properties"><div class="sect3" id="automatic_properties">
<h3>Automatic properties</h3>
<p><a contenteditable="false" data-primary="automatic properties" data-type="indexterm" id="id904"/><a contenteditable="false" data-primary="properties" data-secondary="automatic" data-type="indexterm" id="id905"/><a contenteditable="false" data-primary="properties" data-secondary="expression-bodied" data-type="indexterm" id="id906"/>The most common implementation for a property is a getter and/or setter that simply reads and writes to a private field of the same type as the property. An <em>automatic property</em> declaration instructs the compiler to provide this implementation. We can improve the first example in this section by declaring <code>CurrentPrice</code> as an automatic property:</p>
<pre data-type="programlisting">public class Stock
{
  public decimal CurrentPrice { get; set; }
}</pre>
<p>The compiler automatically generates a private backing field of a compiler-generated name that cannot be referred to. The <code>set</code> accessor can be marked <code>private</code> or <code>protected</code> if you want to expose the property as read-only to other types.</p>
</div></section>
<section data-type="sect3" data-pdf-bookmark="Property initializers"><div class="sect3" id="property_initializers">
<h3>Property initializers</h3>
<p><a contenteditable="false" data-primary="initializers" data-secondary="property" data-type="indexterm" id="id907"/><a contenteditable="false" data-primary="properties" data-secondary="property initializers" data-type="indexterm" id="id908"/><a contenteditable="false" data-primary="property initializers" data-type="indexterm" id="id909"/>You can add a <em>property initializer</em> to automatic properties, just as with fields:</p>
<pre data-type="programlisting">public decimal CurrentPrice { get; set; } <strong>= 123</strong>;</pre>
<p>This gives <code>CurrentPrice</code> an initial value of 123. Properties with an initializer can be read-only:</p>
<pre data-type="programlisting">public int Maximum { get; } = 999;</pre>
<p>Just as with read-only fields, read-only automatic properties can also be assigned in the type’s constructor. This is useful in creating <em>immutable</em> (read-only) types.</p>
</div></section>
<section data-type="sect3" data-pdf-bookmark="get and set accessibility"><div class="sect3" id="get_and_set_accessibility">
<h3>get and set accessibility</h3>
<p><a contenteditable="false" data-primary="get and set accessibility" data-type="indexterm" id="id910"/><a contenteditable="false" data-primary="properties" data-secondary="get and set accessibility" data-type="indexterm" id="id911"/><a contenteditable="false" data-primary="set accessors" data-type="indexterm" id="id912"/>The <code>get</code> and <code>set</code> accessors can have different access levels. The typical use case for this is to have a <code>public</code> property with an <code>internal</code> or <code>private</code> access modifier on the setter:</p>
<pre data-type="programlisting">private decimal x;
public decimal X
{
  get         { return x;  }
  <strong>private</strong> set { x = Math.Round (value, 2); }
}</pre>
<p>Notice that you declare the property itself with the more permissive access level (<code>public</code>, in this case) and add the modifier to the accessor you want to be <em>less</em> accessible.</p>
</div></section>
<section data-type="sect3" data-pdf-bookmark="Init-only setters"><div class="sect3" id="init_only_setters">
<h3>Init-only setters</h3>
<p><a contenteditable="false" data-primary="init-only accessors" data-type="indexterm" id="ch1001.html23"/><a contenteditable="false" data-primary="properties" data-secondary="init-only accessors" data-type="indexterm" id="ch1001.html24"/>From C# 9, you can declare a property accessor with <code>init</code> instead of <code>set</code>:</p>
<pre data-type="programlisting">public class Note
{
  public int Pitch    { get; <strong>init</strong>; } = 20;
  public int Duration { get; <strong>init</strong>; } = 100;
}</pre>
<p>These <em>init-only</em> properties act like read-only properties, except that they can also be set via an object initializer:</p>
<pre data-type="programlisting">var note = new Note { <strong>Pitch = 50</strong> };</pre>
<p>After that, the property cannot be altered:</p>
<pre data-type="programlisting">note.Pitch = 200;  // Error – init-only setter!</pre>
<p>Init-only properties cannot even be set from inside their class, except via their property initializer, the constructor, or another init-only accessor.</p>
<p>The alternative to init-only properties is to have read-only properties that you populate via a constructor:</p>
<pre class="pagebreak-before" data-type="programlisting">  public Note (<strong>int pitch = 20, int duration = 100</strong>)
  {
<strong>    Pitch = pitch; Duration = duration;</strong>
  }</pre>
<p>Should the class be part of a public library, this approach makes versioning difficult, in that adding an optional parameter to the constructor at a later date breaks binary compatibility with consumers (whereas adding a new init-only property breaks nothing).</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Init-only properties have another significant advantage, which is that they allow for nondestructive mutation when used in conjunction with records (see <a data-type="xref" href="#records">“Records”</a>).</p>
</div>
<p>Just as with ordinary <code>set</code> accessors, init-only accessors can provide an implementation:</p>
<pre data-type="programlisting">public class Point
{
  readonly int _x;
  public int X { get =&gt; _x; <strong>init =&gt; _x = value;</strong> }
  ...</pre>
<p>Notice that the <code>_x</code> field is read-only: init-only setters are permitted to modify <code>readonly</code> fields in their own class. (Without this feature, <code>_x</code> would need to be writable, and the class would fail at being internally immutable.)<a contenteditable="false" data-primary="" data-startref="ch1001.html24" data-type="indexterm" id="id913"/><a contenteditable="false" data-primary="" data-startref="ch1001.html23" data-type="indexterm" id="id914"/><a contenteditable="false" data-primary="" data-startref="ch1001.html22" data-type="indexterm" id="id915"/><a contenteditable="false" data-primary="" data-startref="ch1001.html21" data-type="indexterm" id="id916"/></p>
</div></section>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Indexers"><div class="sect2" id="indexers">
<h2>Indexers</h2>
<p><a contenteditable="false" data-primary="classes" data-secondary="indexers" data-type="indexterm" id="id917"/>Indexers provide a natural syntax for accessing elements in a class or struct that encapsulate a list or dictionary of values. Indexers are similar to properties but are accessed via an index argument rather than a property name. The <code>string</code> class has an indexer that lets you access each of its <code>char</code> values via an <code>int</code> index:</p>
<pre data-type="programlisting">string s = "hello";
Console.WriteLine (s[0]); // 'h'
Console.WriteLine (s[3]); // 'l'</pre>
<p><a contenteditable="false" data-primary="indexers" data-secondary="syntax for using" data-type="indexterm" id="id918"/>The syntax for using indexers is like that for using arrays, except that the index argument(s) can be of any type(s). You can call indexers null-conditionally by inserting a question mark before the square bracket (see <a data-type="xref" href="#null_operators">“Null Operators”</a>):</p>
<pre data-type="programlisting">string s = null;
Console.WriteLine (s<strong>?</strong>[0]);  // Writes nothing; no error.</pre>
<section data-type="sect3" data-pdf-bookmark="Implementing an indexer"><div class="sect3" id="implementing_an_indexer">
<h3>Implementing an indexer</h3>
<p><a contenteditable="false" data-primary="indexers" data-secondary="implementing" data-type="indexterm" id="id919"/>To write an indexer, define a property called <code>this</code>, specifying the arguments in square brackets. For example:</p>
<pre data-type="programlisting">class Sentence
{
  string[] words = "The quick brown fox".Split();

<strong>  public string this [int wordNum]      // indexer</strong>
<strong>  {</strong> 
<strong>    get { return words [wordNum];  }</strong>
<strong>    set { words [wordNum] = value; }</strong>
<strong>  }</strong>
}</pre>
<p>Here’s how we could use this indexer:</p>
<pre data-type="programlisting">Sentence s = new Sentence();
Console.WriteLine (s[3]);       // fox
s[3] = "kangaroo";
Console.WriteLine (s[3]);       // kangaroo</pre>
<p>A type can declare multiple indexers, each with parameters of different types. An indexer can also take more than one parameter:</p>
<pre data-type="programlisting">public string this [int arg1, string arg2]
{
  get { ... }  set { ... }
}</pre>
<p>If you omit the <code>set</code> accessor, an indexer becomes read-only, and expression-bodied syntax can be used to shorten its <span class="keep-together">definition</span>:</p>
<pre data-type="programlisting">public string this [int wordNum] =&gt; words [wordNum];</pre>
</div></section>
<section data-type="sect3" data-pdf-bookmark="Using indices and ranges with indexers"><div class="sect3" id="using_indices_and_ranges_with_indexers">
<h3>Using indices and ranges with indexers</h3>
<p><a contenteditable="false" data-primary="indexers" data-secondary="using indices and ranges with" data-type="indexterm" id="id920"/><a contenteditable="false" data-primary="ranges" data-secondary="using indices and ranges with indexers" data-type="indexterm" id="id921"/>You can support indices and ranges (see <a data-type="xref" href="#indices_and_ranges">“Indices and Ranges”</a>) in your own classes by defining an indexer with a parameter type of <code>Index</code> or <code>Range</code>. We could extend our previous example by adding the following indexers to the <code>Sentence</code> class:</p>
<pre data-type="programlisting">  public string this [Index index] =&gt; words [index];
  public string[] this [Range range] =&gt; words [range];</pre>
<p>This then enables the following:</p>
<pre data-type="programlisting">Sentence s = new Sentence();
Console.WriteLine (s [^1]);         // fox  
string[] firstTwoWords = s [..2];   // (The, quick)</pre>
</div></section>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Primary Constructors (C# 12)"><div class="sect2" id="primary_constructors_left_parenthesisch">
<h2>Primary Constructors (C# 12)</h2>
<p><a contenteditable="false" data-primary="constructors" data-secondary="primary" data-type="indexterm" id="ch01.html0"/><a contenteditable="false" data-primary="primary constructors" data-type="indexterm" id="ch01.html1"/>From C# 12, <a contenteditable="false" data-primary="parameter lists" data-type="indexterm" id="id922"/>you can include a parameter list directly after a class (or struct) declaration:</p>
<pre data-type="programlisting">class Person (<strong>string firstName, string lastName</strong>)
{
  public void Print() =&gt;
    Console.WriteLine (<strong>firstName</strong> + " " + <strong>lastName</strong>);
}</pre>
<p>This instructs the compiler to automatically build a <em>primary constructor</em> using the <em>primary constructor parameters</em> (<code>firstName</code> and <code>lastName</code>) so that we can instantiate our class as follows:</p>
<pre data-type="programlisting">Person p = <strong>new Person ("Alice", "Jones")</strong>;
p.Print();    // Alice Jones</pre>
<p>Primary constructors are useful for prototyping and other simple scenarios. The alternative would be to define fields to store <code>firstName</code> and <code>lastName</code> and then write a constructor to populate them.</p>
<p>The constructor that C# builds is called primary because any additional constructors that you choose to (explicitly) write must invoke it:</p>
<pre data-type="programlisting">class Person (<strong>string firstName, string lastName</strong>)
{
  public Person (string first, string last, int age)
    : <strong>this (first, last)</strong>  // Must call primary constructor
<strong>  { ... }</strong>
}</pre>
<p>This ensures that primary constructor parameters are <em>always populated</em>.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>C# also provides <em>records</em>, which we cover in <a data-type="xref" href="#records">“Records”</a>. Records also support primary constructors; however, the compiler takes an extra step with records and generates (by default) a public init-only property for each primary constructor parameter.</p>
</div>
<p>Primary constructors are best suited to simple scenarios due to the following limitations:</p>
<ul>
<li><p>You cannot add extra initialization code to a primary <span class="keep-together">constructor</span>.</p></li>
<li><p>Although it’s easy to expose a primary constructor parameter as a public property, you cannot easily incorporate validation logic unless the property is read-only.</p></li>
</ul>
<p>Primary constructors displace the default parameterless constructor that C# would otherwise generate.</p>
<section data-type="sect3" data-pdf-bookmark="Primary constructor semantics"><div class="sect3" id="primary_constructor_semantics">
<h3>Primary constructor semantics</h3>
<p><a contenteditable="false" data-primary="primary constructors" data-secondary="semantics" data-type="indexterm" id="id923"/>To understand how primary constructors work, consider how an ordinary constructor behaves:</p>
<pre data-type="programlisting">class Person
{
  public Person (<strong>string firstName, string lastName</strong>)
  {
 <em>   ... do something with firstName, lastName</em>
  }
}</pre>
<p>When the code inside this constructor finishes executing, parameters <code>firstName</code> and <code>lastName</code> disappear out of scope and cannot be subsequently accessed. In contrast, a primary constructor’s parameters do <em>not</em> disappear out of scope and can be subsequently accessed from anywhere within the class, for the life of the object.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Primary constructor parameters are special C# constructs, not <em>fields</em>, although the compiler does end up generating hidden fields behind the scenes to store their values if necessary.</p>
</div>
</div></section>
<section data-type="sect3" data-pdf-bookmark="Primary constructors and field/property initializers"><div class="sect3" id="primary_constructors_and_fieldsoliduspr">
<h3>Primary constructors and field/property initializers</h3>
<p><a contenteditable="false" data-primary="initializers" data-secondary="field" data-type="indexterm" id="id924"/><a contenteditable="false" data-primary="initializers" data-secondary="property" data-type="indexterm" id="id925"/><a contenteditable="false" data-primary="primary constructors" data-secondary="field/property initializers" data-type="indexterm" id="id926"/>The accessibility of primary constructor parameters extends to field and property initializers. In the following example, we use field and property initializers to assign <code>firstName</code> to a public field and <code>lastName</code> to a public property:</p>
<pre data-type="programlisting">class Person (string firstName, string lastName)
{
  public readonly string FirstName = <strong>firstName</strong>;
  public string LastName { get; } = <strong>lastName</strong>;
}</pre>
</div></section>
<section data-type="sect3" data-pdf-bookmark="Masking primary constructor parameters"><div class="sect3" id="masking_primary_constructor_parameters">
<h3>Masking primary constructor parameters</h3>
<p><a contenteditable="false" data-primary="primary constructors" data-secondary="masking primary constructor parameters" data-type="indexterm" id="id927"/>Fields (or properties) can reuse primary constructor parameter names:</p>
<pre data-type="programlisting">class Person (string firstName, string lastName)
{
  readonly string firstName =<strong> firstName</strong>;
  readonly string lastName =<strong> lastName</strong>;
}</pre>
<p>In this scenario, the field or property takes precedence, thereby masking the primary constructor parameter, <em>except</em> on the righthand side of field and property initializers (shown in <span class="keep-together">boldface</span>).</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Just like ordinary parameters, primary constructor parameters are writable. Masking them with a same-named <code>readonly</code> field (as in our example) effectively protects them from subsequent modification.</p>
</div>
</div></section>
<section data-type="sect3" data-pdf-bookmark="Validating primary constructor parameters"><div class="sect3" id="validating_primary_constructor_paramete">
<h3>Validating primary constructor parameters</h3>
<p><a contenteditable="false" data-primary="primary constructors" data-secondary="validating primary constructor parameters" data-type="indexterm" id="id928"/>In <a data-type="xref" href="#throw_expressions">“throw expressions”</a>, we will describe how to throw exceptions when encountering scenarios such as invalid data. Here’s a preview to illustrate how this can be used with primary constructors to validate <code>lastName</code> upon construction, ensuring that it cannot be null:</p>
<pre data-type="programlisting">new Person ("Alice", null);   // throws exception

class Person (string firstName, string lastName)
{
  <strong>readonly string lastName = (lastName == null)</strong>
<strong>    ? throw new ArgumentNullException ("lastName")</strong>
<strong>    : lastName</strong>;
}</pre>
<p>(Remember that code within a field or property initializer executes when the object is constructed—not when the field or property is accessed.) The same technique can also expose <code>lastName</code> as a public read-only property:<a contenteditable="false" data-primary="" data-startref="ch01.html1" data-type="indexterm" id="id929"/><a contenteditable="false" data-primary="" data-startref="ch01.html0" data-type="indexterm" id="id930"/></p>
<pre data-type="programlisting">public string LastName { get; } = (lastName == null)
  ? throw new ArgumentNullException ("lastName")
  : lastName;</pre>
</div></section>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Static Constructors"><div class="sect2" id="static_constructors">
<h2>Static Constructors</h2>
<p><a contenteditable="false" data-primary="classes" data-secondary="static constructors" data-type="indexterm" id="id931"/><a contenteditable="false" data-primary="constructors" data-secondary="static constructors" data-type="indexterm" id="id932"/><a contenteditable="false" data-primary="static constructors" data-type="indexterm" id="id933"/>A static constructor executes once per <em>type</em>, rather than once per <em>instance</em>. A type can define only one static constructor, and it must be parameterless and have the same name as the type:</p>
<pre data-type="programlisting">class Test
{
  static Test() { Console.Write ("Type Initialized"); }
}</pre>
<p>The runtime automatically invokes a static constructor just prior to the type being used. Two things trigger this: instantiating the type and accessing a static member in the type.</p>
<div data-type="warning" epub:type="warning"><h6>Warning</h6>
<p>If a static constructor throws an unhandled exception, that type becomes <em>unusable</em> for the life of the application.</p>
</div>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p><a contenteditable="false" data-primary="module initializers" data-type="indexterm" id="id934"/>From C# 9, you can also define <em>module initializers</em>, which execute once per assembly (when the assembly is first loaded). To define a module initializer, write a static void method and then apply the <code>[ModuleInitializer]</code> attribute to that method:</p>
<pre class="small" data-type="programlisting">[System.Runtime.CompilerServices.ModuleInitializer]
internal static void InitAssembly()
{
  ...
}</pre>
</div>
<p>Static field initializers run just <em>before</em> the static constructor is called. If a type has no static constructor, static field initializers will execute just prior to the type being used—or <em>anytime earlier</em> at the whim of the runtime.</p>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Static Classes"><div class="sect2" id="static_classes">
<h2>Static Classes</h2>
<p><a contenteditable="false" data-primary="classes" data-secondary="static classes" data-type="indexterm" id="id935"/><a contenteditable="false" data-primary="static classes" data-type="indexterm" id="id936"/>A class marked as <code>static</code> cannot be instantiated or subclassed, and must be composed solely of static members. The <code>Sys⁠tem.​Console</code> and <code>System.Math</code> classes are good examples of static classes.</p>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Finalizers"><div class="sect2" id="finalizers">
<h2>Finalizers</h2>
<p><a contenteditable="false" data-primary="∼ symbol (finalizers)" data-type="indexterm" id="id937"/><a contenteditable="false" data-primary="classes" data-secondary="finalizers" data-type="indexterm" id="id938"/><a contenteditable="false" data-primary="finalizers" data-type="indexterm" id="id939"/><a contenteditable="false" data-primary="garbage collection" data-type="indexterm" id="id940"/><a contenteditable="false" data-primary="tilde (∼) symbol" data-type="indexterm" id="id941"/><em>Finalizers</em> are class-only methods that execute before the garbage collector reclaims the memory for an unreferenced object. The syntax for a finalizer is the name of the class prefixed with the <code>~</code> symbol:</p>
<pre data-type="programlisting">class Class1
{
  ~Class1() { ... }
}</pre>
<p>C# translates a finalizer into a method that overrides the <code>Finalize</code> method in the <code>object</code> class. We discuss garbage collection and finalizers fully in Chapter 12 of <em>C# 12 in a Nutshell</em>.</p>
<p>Single-statement finalizers can be written with expression-bodied syntax.</p>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Partial Types and Methods"><div class="sect2" id="partial_types_and_methods">
<h2>Partial Types and Methods</h2>
<p><a contenteditable="false" data-primary="classes" data-secondary="partial types and methods" data-type="indexterm" id="id942"/><a contenteditable="false" data-primary="methods" data-secondary="partial types and methods" data-type="indexterm" id="id943"/><a contenteditable="false" data-primary="partial types" data-type="indexterm" id="id944"/><a contenteditable="false" data-primary="types" data-secondary="partial" data-type="indexterm" id="id945"/><em>Partial types</em> allow a type definition to be split—typically across multiple files. A common scenario is for a partial class to be autogenerated from some other source (e.g., a Visual Studio template) and for that class to be augmented with additional hand-authored methods. For example:</p>
<pre data-type="programlisting">// PaymentFormGen.cs - autogenerated
partial class PaymentForm { ... }

// PaymentForm.cs - hand-authored
partial class PaymentForm { ... }</pre>
<p>Each participant must have the <code>partial</code> declaration.</p>
<p>Participants cannot have conflicting members. A constructor with the same parameters, for instance, cannot be repeated. Partial types are resolved entirely by the compiler, which means that each participant must be available at compile time and must reside in the same assembly.</p>
<p>A base class can be specified on a single participant or on multiple participants (as long as the base class that you specify is the same). In addition, each participant can independently specify interfaces to implement. We cover base classes and interfaces in <a data-type="xref" href="#inheritance">“Inheritance”</a> and <a data-type="xref" href="#interfaces">“Interfaces”</a>.</p>
<section data-type="sect3" data-pdf-bookmark="Partial methods"><div class="sect3" id="partial_methods">
<h3>Partial methods</h3>
<p><a contenteditable="false" data-primary="partial methods" data-type="indexterm" id="id946"/>A partial type can contain <em>partial methods</em>. These let an autogenerated partial type provide customizable hooks for manual authoring. For example:</p>
<pre data-type="programlisting">partial class PaymentForm    // In autogenerated file
{
<strong>  partial void ValidatePayment (decimal amount);</strong>
}

partial class PaymentForm    // In hand-authored file
{
<strong>  partial void ValidatePayment (decimal amount)</strong>
<strong>  {</strong>
<strong>    if (amount &gt; 100) Console.Write ("Expensive!");</strong>
<strong>  }</strong>
}</pre>
<p>A partial method consists of two parts: a <em>definition</em> and an <em>implementation</em>. The definition is typically written by a code generator, and the implementation is typically manually authored. If an implementation is not provided, the definition of the partial method is compiled away (as is the code that calls it). This allows autogenerated code to be liberal in providing hooks, without having to worry about bloat. Partial methods must be <code>void</code> and are implicitly <code>private</code>.</p>
</div></section>
<section data-type="sect3" data-pdf-bookmark="Extended partial methods"><div class="sect3" id="extended_partial_methods">
<h3>Extended partial methods</h3>
<p><a contenteditable="false" data-primary="extended partial methods" data-type="indexterm" id="id947"/><a contenteditable="false" data-primary="methods" data-secondary="extended partial methods" data-type="indexterm" id="id948"/><em>Extended partial methods</em> (from C# 9) are designed for the reverse code generation scenario, where a programmer defines hooks that a code generator implements. An example of where this might occur is with <em>source generators</em>, a Roslyn feature that lets you feed the compiler an assembly that automatically generates portions of your code.</p>
<p>A partial method declaration is <em>extended</em> if it begins with an accessibility modifier:</p>
<pre data-type="programlisting">public partial class Test
{
  <strong>public</strong> partial void M1();   // Extended partial method
  <strong>private</strong> partial void M2();  // Extended partial method
}</pre>
<p>The presence of the accessibility modifier doesn’t just affect accessibility: it tells the compiler to treat the declaration <span class="keep-together">differently</span>.</p>
<p>Extended partial methods <em>must</em> have implementations; they do not melt away if unimplemented. In this example, both <code>M1</code> and <code>M2</code> must have implementations because they each specify accessibility modifiers (<code>public</code> and <code>private</code>).</p>
<p>Because they cannot melt away, extended partial methods can return any type and can include <code>out</code> parameters.</p>
</div></section>
</div></section>
<section data-type="sect2" data-pdf-bookmark="The nameof Operator"><div class="sect2" id="the_nameof_operator">
<h2>The nameof Operator</h2>
<p><a contenteditable="false" data-primary="classes" data-secondary="nameof operator" data-type="indexterm" id="id949"/><a contenteditable="false" data-primary="nameof operator" data-type="indexterm" id="id950"/>The <code>nameof</code> operator returns the name of any symbol (type, member, variable, and so on) as a string:</p>
<pre data-type="programlisting">int count = 123;
string name = <strong>nameof</strong> (count);       // name is "count"</pre>
<p>Its advantage over simply specifying a string is that of static type checking. Tools such as Visual Studio can understand the symbol reference, so if you rename the symbol in question, all of its references will be renamed too.</p>
<p>To specify the name of a type member such as a field or property, include the type as well. This works with both static and instance members:</p>
<pre data-type="programlisting">string name = nameof (StringBuilder.Length);</pre>
<p>This evaluates to <code>"Length"</code>. To return <code>"StringBuilder.Length"</code>, you would do this:<a contenteditable="false" data-primary="" data-startref="ch1001.html20" data-type="indexterm" id="id951"/></p>
<pre data-type="programlisting">nameof(StringBuilder)+"."+nameof(StringBuilder.Length);</pre>
</div></section>
</div></section>
<section data-type="sect1" data-pdf-bookmark="Inheritance"><div class="sect1" id="inheritance">
<h1>Inheritance</h1>
<p><a contenteditable="false" data-primary="inheritance" data-type="indexterm" id="ch1001.html25"/>A <a contenteditable="false" data-primary="inheritance" data-secondary="basics of" data-type="indexterm" id="id952"/>class can <em>inherit</em> from another class to extend or customize the original class. Inheriting from a class lets you reuse the functionality in that class instead of building it from scratch. A class can inherit from only a single class but can itself be inherited by many classes, thus forming a class hierarchy. In this example, we begin by defining a class called <code>Asset</code>:</p>
<pre data-type="programlisting">public class Asset { public string Name; }</pre>
<p>Next, we define classes called <code>Stock</code> and <code>House</code>, which will inherit from <code>Asset</code>. <code>Stock</code> and <code>House</code> get everything an <code>Asset</code> has, plus any additional members that they define:</p>
<pre class="pagebreak-before" data-type="programlisting">public class Stock <strong>: Asset</strong>   // inherits from Asset
{
  public long SharesOwned;
}

public class House <strong>: Asset</strong>   // inherits from Asset
{
  public decimal Mortgage;
}</pre>
<p>Here’s how we can use these classes:</p>
<pre data-type="programlisting">Stock msft = new Stock { Name="MSFT",
                         SharesOwned=1000 };

Console.WriteLine (msft.Name);         // MSFT
Console.WriteLine (msft.SharesOwned);  // 1000

House mansion = new House { Name="Mansion",
                            Mortgage=250000 };

Console.WriteLine (mansion.Name);      // Mansion
Console.WriteLine (mansion.Mortgage);  // 250000</pre>
<p><a contenteditable="false" data-primary="derived classes" data-type="indexterm" id="id953"/><a contenteditable="false" data-primary="subclasses" data-secondary="inheritance" data-type="indexterm" id="id954"/>The <em>subclasses</em>, <code>Stock</code> and <code>House</code>, inherit the <code>Name</code> field from the <em>base class</em>, <code>Asset</code>.</p>
<p>Subclasses are also called <em>derived classes</em>.</p>
<section data-type="sect2" data-pdf-bookmark="Polymorphism"><div class="sect2" id="polymorphism">
<h2>Polymorphism</h2>
<p><a contenteditable="false" data-primary="inheritance" data-secondary="polymorphic behavior" data-type="indexterm" id="id955"/><a contenteditable="false" data-primary="polymorphic behavior" data-type="indexterm" id="id956"/>References are <em>polymorphic</em>. This means a variable of type <em>x</em> can refer to an object that subclasses <em>x</em>. For instance, consider the following method:</p>
<pre data-type="programlisting">public static void Display (Asset asset)
{
  System.Console.WriteLine (asset.Name);
}</pre>
<p>This method can display both a <code>Stock</code> and a <code>House</code> because they are both <code>Asset</code>s. Polymorphism works on the basis that subclasses (<code>Stock</code> and <code>House</code>) have all the features of their base class (<code>Asset</code>). The converse, however, is not true. If <code>Display</code> were rewritten to accept a <code>House</code>, you could not pass in an <code>Asset</code>.</p>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Casting and Reference Conversions"><div class="sect2" id="casting_and_reference_conversions">
<h2>Casting and Reference Conversions</h2>
<p><a contenteditable="false" data-primary="conversions" data-secondary="casting and reference conversions" data-type="indexterm" id="id957"/><a contenteditable="false" data-primary="inheritance" data-secondary="casting and reference conversions" data-type="indexterm" id="id958"/><a contenteditable="false" data-primary="reference conversion" data-type="indexterm" id="id959"/>An object reference can be:</p>
<ul>
<li><p>Implicitly <em>upcast</em> to a base class reference</p></li>
<li><p>Explicitly <em>downcast</em> to a subclass reference</p></li>
</ul>
<p><a contenteditable="false" data-primary="casting" data-secondary="upcasting and downcasting" data-type="indexterm" id="id960"/><a contenteditable="false" data-primary="casting" data-seealso="boxing" data-type="indexterm" id="id961"/>Upcasting and downcasting between compatible reference types performs <em>reference conversions</em>: a new reference is created that points to the <em>same</em> object. An upcast always succeeds; a downcast succeeds only if the object is suitably typed.</p>
<section data-type="sect3" data-pdf-bookmark="Upcasting"><div class="sect3" id="upcasting">
<h3>Upcasting</h3>
<p><a contenteditable="false" data-primary="upcasting" data-type="indexterm" id="id962"/>An upcast operation creates a base class reference from a subclass reference. For example:</p>
<pre data-type="programlisting">Stock msft = new Stock();    // From previous example
<strong>Asset a = msft;              // Upcast</strong></pre>
<p>After the upcast, variable <code>a</code> still references the same <code>Stock</code> object as variable <code>msft</code>. The object being referenced is not itself altered or converted:</p>
<pre data-type="programlisting">Console.WriteLine (a == msft);        // True</pre>
<p>Although <code>a</code> and <code>msft</code> refer to the same object, <code>a</code> has a more restrictive view on that object:</p>
<pre data-type="programlisting">Console.WriteLine (a.Name);         // OK
Console.WriteLine (a.SharesOwned);  // Compile-time error</pre>
<p>The last line generates a compile-time error because the variable <code>a</code> is of type <code>Asset</code>, even though it refers to an object of type <code>Stock</code>. To get to its <code>SharesOwned</code> field, you must <em>downcast</em> the <code>Asset</code> to a <code>Stock</code>.</p>
</div></section>
<section data-type="sect3" data-pdf-bookmark="Downcasting"><div class="sect3" id="downcasting">
<h3>Downcasting</h3>
<p><a contenteditable="false" data-primary="downcasting" data-type="indexterm" id="id963"/>A downcast operation creates a subclass reference from a base class reference. For example:</p>
<pre data-type="programlisting">Stock msft = new Stock();
Asset a = msft;                      // Upcast
<strong>Stock s = (Stock)a;                  // Downcast</strong>
Console.WriteLine (s.SharesOwned);   // &lt;No error&gt;
Console.WriteLine (s == a);          // True
Console.WriteLine (s == msft);       // True</pre>
<p>As with an upcast, only references are affected—not the underlying object. A downcast requires an explicit cast because it can potentially fail at runtime:</p>
<pre data-type="programlisting">House h = new House();
Asset a = h;          // Upcast always succeeds
Stock s = (Stock)a;   // Downcast fails: <strong>a</strong> is not a Stock</pre>
<p>If a downcast fails, an <code>InvalidCastException</code> is thrown. This is an example of <em>runtime type checking</em> (see <a data-type="xref" href="#static_and_runtime_type_checking">“Static and Runtime Type Checking”</a>).</p>
</div></section>
<section data-type="sect3" data-pdf-bookmark="The as operator"><div class="sect3" id="the_as_operator">
<h3>The as operator</h3>
<p><a contenteditable="false" data-primary="as operator" data-type="indexterm" id="id964"/><a contenteditable="false" data-primary="casting" data-secondary="as operator" data-type="indexterm" id="id965"/>The <code>as</code> operator performs a downcast that evaluates to <code>null</code> (rather than throwing an exception) if the downcast fails:</p>
<pre data-type="programlisting">Asset a = new Asset();
Stock s = a as Stock;   // s is null; no exception thrown</pre>
<p>This is useful when you’re going to subsequently test whether the result is <code>null</code>:</p>
<pre data-type="programlisting"><strong>if (s != null)</strong> Console.WriteLine (s.SharesOwned);</pre>
<p>The <code>as</code> operator cannot perform <em>custom conversions</em> (see <a data-type="xref" href="#operator_overloading">“Operator Overloading”</a>), and it cannot do numeric conversions.</p>
</div></section>
<section data-type="sect3" data-pdf-bookmark="The is operator"><div class="sect3" id="the_is_operator">
<h3>The is operator</h3>
<p><a contenteditable="false" data-primary="casting" data-secondary="is operator" data-type="indexterm" id="id966"/><a contenteditable="false" data-primary="is operator" data-type="indexterm" id="id967"/>The <code>is</code> operator tests whether a reference conversion would succeed—in other words, whether an object derives from a specified class (or implements an interface). It is often used to test before downcasting:</p>
<pre data-type="programlisting">if (a is Stock) Console.Write (((Stock)a).SharesOwned);</pre>
<p>The <code>is</code> operator also evaluates to true if an unboxing conversion would succeed (see <a data-type="xref" href="#the_object_type">“The object Type”</a>). However, it does not consider custom or numeric conversions.</p>
<p>From C# 7, you can introduce a variable while using the <code>is</code> operator:</p>
<pre data-type="programlisting">if (a is <strong>Stock s</strong>)
  Console.WriteLine (<strong>s.</strong>SharesOwned);</pre>
<p>The variable that you introduce is available for “immediate” consumption and remains in scope outside the <code>is</code> expression:</p>
<pre data-type="programlisting">if (a is <strong>Stock s</strong> &amp;&amp; <strong>s.</strong>SharesOwned &gt; 100000)
  Console.WriteLine ("Wealthy");
else
<strong>  s = new Stock();   // s is in scope</strong>

<strong>Console.WriteLine (s.SharesOwned);  // Still in scope</strong></pre>
<p>The <code>is</code> operator works with other patterns introduced in recent versions of C#. For a full discussion, see <a data-type="xref" href="#patterns">“Patterns”</a>.</p>
</div></section>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Virtual Function Members"><div class="sect2" id="virtual_function_members">
<h2>Virtual Function Members</h2>
<p><a contenteditable="false" data-primary="inheritance" data-secondary="virtual function members" data-type="indexterm" id="id968"/><a contenteditable="false" data-primary="virtual function members" data-type="indexterm" id="id969"/>A function marked as <code>virtual</code> can be <em>overridden</em> by subclasses wanting to provide a specialized implementation. Methods, properties, indexers, and events can all be declared <code>virtual</code>:</p>
<pre data-type="programlisting">public class Asset
{
  public string Name;
  public <strong>virtual</strong> decimal Liability =&gt; 0;
}</pre>
<p>(<code>Liability =&gt; 0</code> is a shortcut for <code>{ get { return 0; } }</code>. See <a data-type="xref" href="#expression_bodied_properties">“Expression-bodied properties”</a> for more details on this syntax.) A subclass overrides a virtual method by applying the <code>override</code> modifier:</p>
<pre data-type="programlisting">public class House : Asset
{
  public decimal Mortgage;

  public <strong>override</strong> decimal Liability =&gt; Mortgage;
}</pre>
<p>By default, the <code>Liability</code> of an <code>Asset</code> is <code>0</code>. A <code>Stock</code> does not need to specialize this behavior. However, the <code>House</code> specializes the <code>Liability</code> property to return the value of the <code>Mortgage</code>:</p>
<pre data-type="programlisting">House mansion = new House { Name="Mansion",
                            Mortgage=250000 };
Asset a = mansion;
Console.WriteLine (mansion.Liability);  // 250000
Console.WriteLine (a.Liability);        // 250000</pre>
<p>The signatures, return types, and accessibility of the virtual and overridden methods must be identical. An overridden method can call its base class implementation via the <code>base</code> keyword (see <a data-type="xref" href="#the_base_keyword">“The base Keyword”</a>).</p>
<section data-type="sect3" data-pdf-bookmark="Covariant returns"><div class="sect3" id="covariant_returns">
<h3>Covariant returns</h3>
<p><a contenteditable="false" data-primary="covariant returns" data-type="indexterm" id="id970"/>From C# 9, you can override a method (or property <code>get</code> accessor) such that it returns a <em>more derived</em> (subclassed) type. For example, you can write a <code>Clone</code> method in the <code>Asset</code> class that returns an <code>Asset</code> and override that method in the <code>House</code> class such that it returns a <code>House</code>.</p>
<p>This is permitted because it does not break the contract that <code>Clone</code> must return an <code>Asset</code>: it returns a <code>House</code>, which <em>is</em> an <code>Asset</code> (and more).</p>
</div></section>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Abstract Classes and Abstract Members"><div class="sect2" id="abstract_classes_and_abstract_members">
<h2>Abstract Classes and Abstract Members</h2>
<p><a contenteditable="false" data-primary="abstract classes" data-type="indexterm" id="id971"/><a contenteditable="false" data-primary="classes" data-secondary="abstract" data-type="indexterm" id="id972"/><a contenteditable="false" data-primary="inheritance" data-secondary="abstract classes and members" data-type="indexterm" id="id973"/>A class declared as <em>abstract</em> can never be instantiated. Instead, only its concrete <em>subclasses</em> can be instantiated.</p>
<p><a contenteditable="false" data-primary="abstract members" data-type="indexterm" id="id974"/>Abstract classes are able to define <em>abstract members</em>. Abstract members are like virtual members, except they don’t provide a default implementation. That implementation must be <span class="keep-together">provided</span> by the subclass, unless that subclass is also declared abstract:</p>
<pre data-type="programlisting">public <strong>abstract</strong> class Asset
{
  // Note empty implementation
  public <strong>abstract</strong> decimal NetValue { get; }
}</pre>
<p>Subclasses override abstract members just as though they were virtual.</p>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Hiding Inherited Members"><div class="sect2" id="hiding_inherited_members">
<h2>Hiding Inherited Members</h2>
<p><a contenteditable="false" data-primary="hiding inherited members" data-type="indexterm" id="id975"/><a contenteditable="false" data-primary="inheritance" data-secondary="hiding inherited members" data-type="indexterm" id="id976"/>A base class and a subclass can define identical members. For example:</p>
<pre data-type="programlisting">public class A      { public int Counter = 1; }
public class B : A  { public int Counter = 2; }</pre>
<p>The <code>Counter</code> field in class <code>B</code> is said to <em>hide</em> the <code>Counter</code> field in class <code>A</code>. Usually, this happens by accident, when a member is added to the base type <em>after</em> an identical member was added to the subtype. For this reason, the compiler generates a warning and then resolves the ambiguity as follows:</p>
<ul>
<li><p>References to <code>A</code> (at compile time) bind to <code>A.Counter</code>.</p></li>
<li><p>References to <code>B</code> (at compile time) bind to <code>B.Counter</code>.</p></li>
</ul>
<p>Occasionally, you want to hide a member deliberately, in which case you can apply the <code>new</code> modifier to the member in the subclass. The <code>new</code> modifier does nothing more than suppress the compiler warning that would otherwise result:</p>
<pre data-type="programlisting">public class A     { public     int Counter = 1; }
public class B : A { public <strong>new</strong> int Counter = 2; }</pre>
<p>The <code>new</code> modifier communicates your intent to the compiler—and other programmers—that the duplicate member is not an accident.</p>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Sealing Functions and Classes"><div class="sect2" id="sealing_functions_and_classes">
<h2>Sealing Functions and Classes</h2>
<p><a contenteditable="false" data-primary="classes" data-secondary="sealing" data-type="indexterm" id="id977"/><a contenteditable="false" data-primary="inheritance" data-secondary="sealing functions and classes" data-type="indexterm" id="id978"/><a contenteditable="false" data-primary="sealed keyword" data-type="indexterm" id="id979"/><a contenteditable="false" data-primary="sealing functions and classes" data-type="indexterm" id="id980"/>An overridden function member can <em>seal</em> its implementation with the <code>sealed</code> keyword to prevent it from being overridden by further subclasses. In our earlier virtual function member example, we could have sealed <code>House</code>’s implementation of <span class="keep-together"><code>Liability</code></span>, preventing a class that derives from <code>House</code> from overriding <code>Liability</code>, as follows:</p>
<pre data-type="programlisting">public <strong>sealed</strong> override decimal Liability { get { ... } }</pre>
<p>You can also apply the <code>sealed</code> modifier to the class itself, to prevent subclassing.</p>
</div></section>
<section data-type="sect2" data-pdf-bookmark="The base Keyword"><div class="sect2" id="the_base_keyword">
<h2>The base Keyword</h2>
<p><a contenteditable="false" data-primary="base keyword" data-type="indexterm" id="id981"/><a contenteditable="false" data-primary="inheritance" data-secondary="base keyword" data-type="indexterm" id="id982"/>The <code>base</code> keyword is similar to the <code>this</code> keyword. It serves two essential purposes: accessing an overridden function member from the subclass and calling a base class constructor (see the next section).</p>
<p>In this example, <code>House</code> uses the <code>base</code> keyword to access <code>Asset</code>’s implementation of <code>Liability</code>:</p>
<pre data-type="programlisting">public class House : Asset
{
  ...
  public override decimal Liability 
    =&gt; <strong>base.</strong>Liability + Mortgage;
}</pre>
<p>With the <code>base</code> keyword, we access <code>Asset</code>’s <code>Liability</code> property <em>nonvirtually</em>. This means that we will always access <code>Asset</code>’s version of this property, regardless of the instance’s actual runtime type.</p>
<p>The same approach works if <code>Liability</code> is <em>hidden</em> rather than <em>overridden</em>. (You can also access hidden members by casting to the base class before invoking the function.)</p>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Constructors and Inheritance"><div class="sect2" id="constructors_and_inheritance">
<h2>Constructors and Inheritance</h2>
<p><a contenteditable="false" data-primary="constructors" data-secondary="inheritance and" data-type="indexterm" id="id983"/><a contenteditable="false" data-primary="inheritance" data-secondary="constructors and" data-type="indexterm" id="id984"/><a contenteditable="false" data-primary="initialization" data-secondary="constructor and field initialization order" data-type="indexterm" id="id985"/><a contenteditable="false" data-primary="subclasses" data-secondary="constructors" data-type="indexterm" id="id986"/>A subclass must declare its own constructors. For example, assume we define <code>Baseclass</code> and <code>Subclass</code> as follows:</p>
<pre data-type="programlisting">public class Baseclass
{
  public int X;
  public Baseclass () { }
  public Baseclass (int x) =&gt; X = x;
}
public class Subclass : Baseclass { }</pre>
<p>The following is then illegal:</p>
<pre data-type="programlisting">Subclass s = new Subclass (123);</pre>
<p><code>Subclass</code> must “redefine” any constructors that it wants to expose. In doing so, it can call any of the base class’s constructors with the <code>base</code> keyword:</p>
<pre data-type="programlisting">public class Subclass : Baseclass
{
  public Subclass (int x) <strong>: base (x)</strong> { ... }
}</pre>
<p>The <code>base</code> keyword works rather like the <code>this</code> keyword, except that it calls a constructor in the base class. Base class constructors always execute first; this ensures that <em>base</em> initialization occurs before <em>specialized</em> initialization.</p>
<p>If a constructor in a subclass omits the <code>base</code> keyword, the base type’s <em>parameterless</em> constructor is implicitly called (if the base class has no accessible parameterless constructor, the compiler generates an error).</p>
<section data-type="sect3" data-pdf-bookmark="Required members (C# 11)"><div class="sect3" id="required_members_left_parenthesischash">
<h3>Required members (C# 11)</h3>
<p><a contenteditable="false" data-primary="constructors" data-secondary="required members" data-type="indexterm" id="id987"/><a contenteditable="false" data-primary="required members" data-type="indexterm" id="id988"/>The requirement for subclasses to invoke a constructor in the base class can become burdensome in large class hierarchies if there are many constructors with many parameters. Sometimes, the best solution is to avoid constructors altogether and rely solely on object initializers to set fields or properties <span class="keep-together">during</span> construction. To help with this, you can mark a field or property as <code>required</code> (from C# 11):</p>
<pre data-type="programlisting">public class Asset
{
  public <strong>required</strong> string Name;
}</pre>
<p>A required member <em>must</em> be populated via an object initializer when constructed:</p>
<pre data-type="programlisting">Asset a1 = new Asset { Name="House" };  // OK
Asset a2 = new Asset();                 // Error</pre>
<p>Should you wish to also write a constructor, you can apply the <code>[SetsRequiredMembers]</code> attribute to bypass the required member restriction for that constructor:</p>
<pre data-type="programlisting">public class Asset
{
  public <strong>required</strong> string Name;

  public Asset() { }
    
  <strong>[</strong>System.Diagnostics.CodeAnalysis<strong>.SetsRequiredMembers]</strong>
  public Asset (string n) =&gt; Name = n;
}</pre>
</div></section>
<section data-type="sect3" data-pdf-bookmark="Constructor and field initialization order"><div class="sect3" id="constructor_and_field_initialization_or">
<h3>Constructor and field initialization order</h3>
<p><a contenteditable="false" data-primary="constructors" data-secondary="field initialization order and" data-type="indexterm" id="id989"/>When an object is instantiated, initialization takes place in the following order:</p>
<ol>
<li><p>From subclass to base class:</p>
<ol type="a">
<li><p>Fields are initialized.</p></li>
<li><p>Arguments to base class constructor calls are evaluated.</p></li>
</ol></li>
<li><p>From base class to subclass:</p>
<ol type="a" start="3">
<li><p>Constructor bodies execute.</p></li>
</ol></li>
</ol>
</div></section>
<section data-type="sect3" data-pdf-bookmark="Inheritance with primary constructors"><div class="sect3" id="inheritance_with_primary_constructors">
<h3>Inheritance with primary constructors</h3>
<p><a contenteditable="false" data-primary="inheritance" data-secondary="primary constructors" data-type="indexterm" id="id990"/><a contenteditable="false" data-primary="primary constructors" data-secondary="inheritance with" data-type="indexterm" id="id991"/>Classes with primary constructors can subclass with the following syntax:</p>
<pre data-type="programlisting">class Baseclass (int x) {...}
class Subclass (int x, int y) : <strong>Baseclass (x)</strong> {...}</pre>
</div></section>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Overloading and Resolution"><div class="sect2" id="overloading_and_resolution">
<h2>Overloading and Resolution</h2>
<p><a contenteditable="false" data-primary="inheritance" data-secondary="overloading and resolution" data-type="indexterm" id="id992"/><a contenteditable="false" data-primary="methods" data-secondary="overloading methods" data-type="indexterm" id="id993"/><a contenteditable="false" data-primary="overloading methods" data-type="indexterm" id="id994"/>Inheritance has an interesting impact on method overloading. Consider the following two overloads:</p>
<pre data-type="programlisting">static void Foo (Asset a) { }
static void Foo (House h) { }</pre>
<p>When an overload is called, the most specific type has <span class="keep-together">precedence</span>:</p>
<pre data-type="programlisting">House h = new House (...);
Foo(h);                      // Calls Foo(House)</pre>
<p>The particular overload to call is determined statically (at compile time) rather than at runtime. The following code calls <code>Foo(Asset)</code>, even though the runtime type of <code>a</code> is <code>House</code>:</p>
<pre data-type="programlisting">Asset a = new House (...);
Foo(a);                      // Calls Foo(Asset)</pre>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>If you cast <code>Asset</code> to <code>dynamic</code> (see <a data-type="xref" href="#dynamic_binding">“Dynamic Binding”</a>), the decision as to which overload to call is deferred until runtime and is based on the object’s actual type.<a contenteditable="false" data-primary="" data-startref="ch1001.html25" data-type="indexterm" id="id995"/></p>
</div>
</div></section>
</div></section>
<section data-type="sect1" class="pagebreak-before" data-pdf-bookmark="The object Type"><div class="sect1" id="the_object_type">
<h1 class="less_space">The object Type</h1>
<p><a contenteditable="false" data-primary="object type" data-secondary="uses for" data-type="indexterm" id="id996"/><code>object</code> <a contenteditable="false" data-primary="object type" data-type="indexterm" id="ch1001.html26"/>(<code>System.Object</code>) is the ultimate base class for all types. Any type can be implicitly upcast to <code>object</code>.</p>
<p>To illustrate how this is useful, consider a general-purpose <em>stack</em>. A stack is a data structure based on the principle of LIFO—“last in, first out.” A stack has two operations: <em>push</em> an object on the stack and <em>pop</em> an object off the stack. Here is a simple implementation that can hold up to 10 objects:</p>
<pre data-type="programlisting">public class Stack
{
  int position;
  <strong>object</strong>[] data = new object[10];
  public void Push (<strong>object</strong> o) { data[position++] = o; }
  public <strong>object</strong> Pop() { return data[--position]; }
}</pre>
<p>Because <code>Stack</code> works with the object type, we can <code>Push</code> and <code>Pop</code> instances of <em>any type</em> to and from the <code>Stack</code>:</p>
<pre data-type="programlisting">Stack stack = new Stack();
stack.Push ("sausage");
string s = (string) stack.Pop();   // Downcast
Console.WriteLine (s);             // sausage</pre>
<p><code>object</code> is a reference type, by virtue of being a class. Despite this, value types, such as <code>int</code>, can also be cast to and from <code>object</code>. To make this possible, the CLR must perform some special work to bridge the underlying differences between value and reference types. This process is called <em>boxing</em> and <em>unboxing</em>.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>In <a data-type="xref" href="#generics">“Generics”</a>, we describe how to improve our <code>Stack</code> class to better handle stacks with same-typed elements.</p>
</div>
<section data-type="sect2" data-pdf-bookmark="Boxing and Unboxing"><div class="sect2" id="boxing_and_unboxing">
<h2>Boxing and Unboxing</h2>
<p><a contenteditable="false" data-primary="boxing" data-secondary="defined" data-type="indexterm" id="id997"/><a contenteditable="false" data-primary="object type" data-secondary="boxing and unboxing" data-type="indexterm" id="id998"/><a contenteditable="false" data-primary="unboxing" data-secondary="object type" data-type="indexterm" id="id999"/>Boxing is the act of casting a value type instance to a reference type instance. The reference type can be either the <code>object</code> class or an interface (see <a data-type="xref" href="#interfaces">“Interfaces”</a>). In this example, we box an <code>int</code> into an object:</p>
<pre data-type="programlisting">int x = 9;
object obj = x;           // Box the int</pre>
<p>Unboxing reverses the operation by casting the object back to the original value type:</p>
<pre data-type="programlisting">int y = (int)obj;         // Unbox the int</pre>
<p>Unboxing requires an explicit cast. The runtime checks that the stated value type matches the actual object type, throwing an <code>InvalidCastException</code> if the check fails. For instance, the following throws an exception because <code>long</code> does not exactly match <code>int</code>:</p>
<pre data-type="programlisting">object obj = 9;       // 9 is inferred to be of type int
long x = (long) obj;  // InvalidCastException</pre>
<p>The following succeeds, however:</p>
<pre data-type="programlisting">object obj = 9;
long x = (int) obj;</pre>
<p>As does this:</p>
<pre data-type="programlisting">object obj = 3.5;      // 3.5 inferred to be type double
int x = (int) (double) obj;    // x is now 3</pre>
<p><a contenteditable="false" data-primary="conversions" data-secondary="numeric conversions" data-type="indexterm" id="id1000"/><a contenteditable="false" data-primary="numeric conversions" data-type="indexterm" id="id1001"/>In the last example, <code>(double)</code> performs an <em>unboxing</em>, and then <code>(int)</code> performs a <em>numeric conversion</em>.</p>
<p>Boxing <em>copies</em> the value type instance into the new object, and unboxing <em>copies</em> the contents of the object back into a value type instance:</p>
<pre data-type="programlisting">int i = 3;
object boxed = i;
i = 5;
Console.WriteLine (boxed);    // 3</pre>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Static and Runtime Type Checking"><div class="sect2" id="static_and_runtime_type_checking">
<h2>Static and Runtime Type Checking</h2>
<p><a contenteditable="false" data-primary="object type" data-secondary="static and runtime type checking" data-type="indexterm" id="id1002"/><a contenteditable="false" data-primary="runtime type checking" data-type="indexterm" id="id1003"/><a contenteditable="false" data-primary="static type checking" data-type="indexterm" id="id1004"/><a contenteditable="false" data-primary="type checking" data-type="indexterm" id="id1005"/>C# checks types both statically (at compile time) and at runtime.</p>
<p>Static type checking enables the compiler to verify the correctness of your program without running it. The following code will fail because the compiler enforces static typing:</p>
<pre data-type="programlisting">int x = "5";</pre>
<p>Runtime type checking is performed by the CLR when you downcast via a reference conversion or unboxing:</p>
<pre data-type="programlisting">object y = "5";
int z = (int) y;       // Runtime error, downcast failed</pre>
<p>Runtime type checking is possible because each object on the heap internally stores a little type token. You can retrieve this token by calling the <code>GetType</code> method of <code>object</code>.</p>
</div></section>
<section data-type="sect2" data-pdf-bookmark="The GetType Method and typeof Operator"><div class="sect2" id="the_gettype_method_and_typeof_operator">
<h2>The GetType Method and typeof Operator</h2>
<p><a contenteditable="false" data-primary="GetType method" data-type="indexterm" id="id1006"/><a contenteditable="false" data-primary="object type" data-secondary="GetType method and typeof operator" data-type="indexterm" id="id1007"/><a contenteditable="false" data-primary="object type" data-secondary="typeof operator" data-type="indexterm" id="id1008"/><a contenteditable="false" data-primary="typeof operator" data-type="indexterm" id="id1009"/>All types in C# are represented at runtime with an instance of <code>System.Type</code>. There are two basic ways to get a <code>System.Type</code> object: call <code>GetType</code> on the instance or use the <code>typeof</code> operator on a type name. <code>GetType</code> is evaluated at runtime; <code>typeof</code> is evaluated statically at compile time.</p>
<p><code>System.Type</code> has properties for such things as the type’s name, assembly, base type, and so on. For example:</p>
<pre data-type="programlisting">int x = 3;

Console.Write (x.GetType().Name);               // Int32
Console.Write (typeof(int).Name);               // Int32
Console.Write (x.GetType().FullName);    // System.Int32
Console.Write (x.GetType() == typeof(int));     // True</pre>
<p><code>System.Type</code> also has methods that act as a gateway to the runtime’s reflection model—we describe this fully in <em>C# 12 in a Nutshell</em>.</p>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Object Member Listing"><div class="sect2" id="object_member_listing">
<h2>Object Member Listing</h2>
<p><a contenteditable="false" data-primary="object type" data-secondary="object member listing" data-type="indexterm" id="id1010"/>Here are all the members of <code>object</code>:</p>
<pre data-type="programlisting">public extern Type GetType();
public virtual bool Equals (object obj);
public static bool Equals (object objA, object objB);
public static bool ReferenceEquals (object objA,
                                    object objB);
public virtual int GetHashCode();
public virtual string ToString();
protected virtual void Finalize();
protected extern object MemberwiseClone();</pre>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Equals, ReferenceEquals, and GetHashCode"><div class="sect2" id="equalscomma_referenceequalscomma_and_ge">
<h2>Equals, ReferenceEquals, and GetHashCode</h2>
<p><a contenteditable="false" data-primary="Equals method" data-type="indexterm" id="id1011"/><a contenteditable="false" data-primary="object type" data-secondary="Equals, ReferenceEquals, and GetHashCode" data-type="indexterm" id="id1012"/>The <code>Equals</code> method in the <code>object</code> class is similar to the <code>==</code> operator except that <code>Equals</code> is virtual, whereas <code>==</code> is static. The following example illustrates the difference:</p>
<pre data-type="programlisting">object x = 3;
object y = 3;
Console.WriteLine (x == y);        // False
Console.WriteLine (x.Equals (y));  // True</pre>
<p>Because <code>x</code> and <code>y</code> have been cast to the <code>object</code> type, the compiler statically binds to <code>object</code>’s <code>==</code> operator, which uses <em>reference type</em> semantics to compare two instances. (And because <code>x</code> and <code>y</code> are boxed, they are represented in separate memory locations and so are unequal.) The virtual <code>Equals</code> method, however, defers to the <code>Int32</code> type’s <code>Equals</code> method, which uses <em>value type</em> semantics in comparing two values.</p>
<p>The static <code>object.Equals</code> method simply calls the virtual <code>Equals</code> method on the first argument—after checking that the arguments are not null:</p>
<pre data-type="programlisting">object x = null, y = 3;
bool error = x.Equals (y);        // Runtime error!
bool ok = object.Equals (x, y);   // OK (false)</pre>
<p><a contenteditable="false" data-primary="ReferenceEquals method" data-type="indexterm" id="id1013"/><code>ReferenceEquals</code> forces a reference type equality comparison (this is occasionally useful on reference types for which the <code>==</code> operator has been overloaded to do otherwise).</p>
<p><a contenteditable="false" data-primary="GetHashCode method" data-type="indexterm" id="id1014"/><code>GetHashCode</code> emits a hash code suitable for use with hashtable-based dictionaries such as <code>System.Collections.Generic.Dictionary</code> and <code>System.Collections.Hashtable</code>.</p>
<p>To customize a type’s equality semantics, you must at a minimum override <code>Equals</code> and <code>GetHashCode</code>. You would also usually overload the <code>==</code> and <code>!=</code> operators. For an example of how to do both, see <a data-type="xref" href="#operator_overloading">“Operator Overloading”</a>.</p>
</div></section>
<section data-type="sect2" data-pdf-bookmark="The ToString Method"><div class="sect2" id="the_tostring_method">
<h2>The ToString Method</h2>
<p><a contenteditable="false" data-primary="object type" data-secondary="ToString method" data-type="indexterm" id="id1015"/><a contenteditable="false" data-primary="ToString method" data-type="indexterm" id="id1016"/>The <code>ToString</code> method returns the default textual representation of a type instance. The <code>ToString</code> method is overridden by all built-in types:</p>
<pre data-type="programlisting">string s1 = 1.ToString();      // s1 is "1"
string s2 = true.ToString();   // s2 is "True"</pre>
<p>You can override the <code>ToString</code> method on custom types as follows:<a contenteditable="false" data-primary="" data-startref="ch1001.html26" data-type="indexterm" id="id1017"/></p>
<pre data-type="programlisting">public override string ToString() =&gt; "Foo";</pre>
</div></section>
</div></section>
<section data-type="sect1" data-pdf-bookmark="Structs"><div class="sect1" id="structs">
<h1>Structs</h1>
<p><a contenteditable="false" data-primary="classes" data-secondary="structs versus" data-type="indexterm" id="id1018"/><a contenteditable="false" data-primary="structs" data-secondary="classes versus" data-type="indexterm" id="id1019"/>A <a contenteditable="false" data-primary="structs" data-type="indexterm" id="ch1001.html27"/><em>struct</em> is similar to a class, with the following key differences:</p>
<ul>
<li><p>A struct is a value type, whereas a class is a reference type.</p></li>
<li><p>A struct does not support inheritance (other than implicitly deriving from <code>object</code>, or more precisely, <code>System.ValueType</code>).</p></li>
</ul>
<p>A struct can have all the members that a class can, except for a finalizer, and virtual or protected members.</p>
<div data-type="warning" epub:type="warning"><h6>Warning</h6>
<p>Prior to C# 10, structs were further prohibited from defining field initializers and parameterless constructors. Although this prohibition has now been relaxed—primarily for the benefit of record structs (see <a data-type="xref" href="#records">“Records”</a>)—it’s worth thinking carefully before defining these constructs, as they can result in confusing behavior that we’ll describe in <a data-type="xref" href="#struct_construction_semantics">“Struct Construction Semantics”</a>.</p>
</div>
<p><a contenteditable="false" data-primary="structs" data-secondary="appropriate use of" data-type="indexterm" id="id1020"/>A struct is appropriate when value type semantics are desirable. Good examples are numeric types, where it is more natural for assignment to copy a value rather than a reference. Because a struct is a value type, each instance does not require instantiation of an object on the heap (and subsequent collection); this can incur useful savings when you’re creating many instances of a type.</p>
<p>As with any value type, a struct can end up on the heap indirectly, either through boxing or by appearing as a field in a class. If we were to instantiate <code>SomeClass</code> in the following example, field <code>Y</code> would refer to a struct on the heap:</p>
<pre data-type="programlisting">struct SomeStruct { public int X;        }
class SomeClass   { public <strong>SomeStruct</strong> Y; }</pre>
<p>Similarly, if you were to declare an array of <code>SomeStruct</code>, the instance would reside on the heap (because arrays are reference types), although the entire array would require only a single memory allocation.</p>
<p>From C# 7.2, you can apply the <code>ref</code> modifier to a struct to ensure that it can be used only in ways that will place it on the stack. This enables further compiler optimizations as well as allowing for the <a href="https://oreil.ly/kCark"><code>Span&lt;T&gt;</code> type</a>.</p>
<section data-type="sect2" data-pdf-bookmark="Struct Construction Semantics"><div class="sect2" id="struct_construction_semantics">
<h2>Struct Construction Semantics</h2>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p><a contenteditable="false" data-primary="structs" data-secondary="construction semantics of" data-type="indexterm" id="id1021"/>Prior to C# 11, every field in a struct had to be explicitly assigned in the constructor (or field initializer). This restriction has now been relaxed.</p>
</div>
<p>In addition to any constructors that you define, a struct always has an implicit parameterless constructor that performs a bitwise-zeroing of its fields (setting them to their default <span class="keep-together">values</span>):</p>
<pre data-type="programlisting">Point p = new Point();     // p.x and p.y will be 0
struct Point { int x, y; }</pre>
<p>Even when you define a parameterless constructor of your own, the implicit parameterless constructor still exists, and it can be accessed via the <code>default</code> keyword:</p>
<pre data-type="programlisting">Point p1 = new Point();    // p1.x and p1.y will be 1
Point p2 = <strong>default</strong>;        // <strong>p2.x and p2.y will be 0</strong>

struct Point
{
  int x = 1; int y;
  public Point() =&gt; y = 1;
}</pre>
<p>In this example, we initialized <code>x</code> to 1 via a field initializer, and we initialized <code>y</code> to 1 via the parameterless constructor. And yet with the <code>default</code> keyword, we were still able to create a <code>Point</code> that bypassed both initializations. The default constructor can be accessed other ways, too, as the following example illustrates:</p>
<pre data-type="programlisting">var points = new Point[10];   // Each point will be (0,0)
var test = new Test();        // test.p will be (0,0)
class Test { Point p; }</pre>
<p>A good strategy with structs is to design them such that their <code>default</code> value is a valid state, thereby making initialization redundant.</p>
</div></section>
<section data-type="sect2" data-pdf-bookmark="readonly Structs and Functions"><div class="sect2" id="readonly_structs_and_functions">
<h2>readonly Structs and Functions</h2>
<p><a contenteditable="false" data-primary="readonly modifier" data-type="indexterm" id="id1022"/><a contenteditable="false" data-primary="structs" data-secondary="readonly structs and functions" data-type="indexterm" id="id1023"/>You can apply the <code>readonly</code> modifier to a struct to enforce that all fields are <code>readonly</code>; this aids in declaring intent as well as allowing the compiler more optimization freedom:</p>
<pre data-type="programlisting"><strong>readonly</strong> struct Point
{
  public readonly int X, Y;   // X and Y must be readonly
}</pre>
<p>If you need to apply <code>readonly</code> at a more granular level, you can apply the <code>readonly</code> modifier (from C# 8) to a struct’s <em>functions</em>. This ensures that if the function attempts to modify any field, a compile-time error is generated:</p>
<pre data-type="programlisting">struct Point
{
  public int X, Y;
  public <strong>readonly</strong> void ResetX() =&gt; X = 0;  // Error!
}</pre>
<p>If a <code>readonly</code> function calls a non-<code>readonly</code> function, the compiler generates a warning (and defensively copies the struct to avoid the possibility of a mutation).<a contenteditable="false" data-primary="" data-startref="ch1001.html27" data-type="indexterm" id="id1024"/></p>
</div></section>
</div></section>
<section data-type="sect1" data-pdf-bookmark="Access Modifiers"><div class="sect1" id="access_modifiers">
<h1>Access Modifiers</h1>
<p><a contenteditable="false" data-primary="access modifiers" data-type="indexterm" id="ch1001.html28"/>To promote <a contenteditable="false" data-primary="encapsulation" data-type="indexterm" id="id1025"/>encapsulation, a type or type member can limit its <em>accessibility</em> to other types and other assemblies by adding an <a contenteditable="false" data-primary="access modifiers" data-secondary="types of" data-type="indexterm" id="id1026"/><em>access modifier</em> to the declaration:</p>
<dl>
<dt><code>public</code></dt>
<dd><a contenteditable="false" data-primary="public keyword" data-type="indexterm" id="id1027"/>Fully accessible. This is the implicit accessibility for members of an enum or interface.</dd>
<dt><code>internal</code></dt>
<dd><a contenteditable="false" data-primary="internal access modifier" data-type="indexterm" id="id1028"/>Accessible only within the containing assembly or friend assemblies. This is the default accessibility for non-nested types.</dd>
<dt><code>private</code></dt>
<dd><a contenteditable="false" data-primary="private keyword" data-type="indexterm" id="id1029"/>Accessible only within the containing type. This is the default accessibility for members of a class or struct.</dd>
<dt><code>protected</code></dt>
<dd><a contenteditable="false" data-primary="protected access modifier" data-type="indexterm" id="id1030"/>Accessible only within the containing type or subclasses.</dd>
<dt><code>protected internal</code></dt>
<dd><a contenteditable="false" data-primary="protected internal access modifier" data-type="indexterm" id="id1031"/>The <em>union</em> of <code>protected</code> and <code>internal</code> accessibility (this is more <em>permissive</em> than <code>protected</code> or <code>internal</code> alone in that it makes a member more accessible in two ways).</dd>
<dt><code>private protected</code></dt>
<dd><a contenteditable="false" data-primary="private protected access modifier" data-type="indexterm" id="id1032"/>The <em>intersection</em> of <code>protected</code> and <code>internal</code> accessibility (this is more <em>restrictive</em> than <code>protected</code> or <code>internal</code> alone).</dd>
<dt><code>file</code> (from C# 11)</dt>
<dd><a contenteditable="false" data-primary="file access modifier" data-type="indexterm" id="id1033"/>Accessible only from within the same file. Intended for use by <em>source generators</em> (see <a data-type="xref" href="#extended_partial_methods">“Extended partial methods”</a>). This modifier can be applied only to type declarations.</dd>
</dl>
<p>In the following example, <code>Class2</code> is accessible from outside its assembly; <code>Class1</code> is not:</p>
<pre data-type="programlisting">class Class1 {}         // Class1 is internal (default)
<strong>public</strong> class Class2 {}</pre>
<p><code>ClassB</code> exposes field <code>x</code> to other types in the same assembly; <code>ClassA</code> does not:</p>
<pre data-type="programlisting">class ClassA { int x;          }  // x is private
class ClassB { <strong>internal</strong> int x; }</pre>
<p>When you’re overriding a base class function, accessibility must be identical on the overridden function. The compiler prevents any inconsistent use of access modifiers—for example, a subclass itself can be less accessible than a base class but not more.</p>
<section data-type="sect2" data-pdf-bookmark="Friend Assemblies"><div class="sect2" id="friend_assemblies">
<h2>Friend Assemblies</h2>
<p><a contenteditable="false" data-primary="access modifiers" data-secondary="friend assemblies" data-type="indexterm" id="id1034"/><a contenteditable="false" data-primary="friend assemblies" data-type="indexterm" id="id1035"/><a contenteditable="false" data-primary="LINQ (Language Integrated Query)" data-secondary="friend assemblies" data-type="indexterm" id="id1036"/>You can expose <code>internal</code> members to other <em>friend</em> assemblies by adding the <code>System.Runtime.CompilerServices.InternalsVisibleTo</code> assembly attribute, specifying the name of the friend assembly as follows:</p>
<pre data-type="programlisting">[assembly: InternalsVisibleTo ("Friend")]</pre>
<p>If the friend assembly is signed with a strong name, you must specify its <em>full</em> 160-byte public key. You can extract this key via a Language Integrated Query (LINQ)—an interactive example is given in LINQPad’s free sample library for <em>C# 12 in a Nutshell</em>, under Chapter 3, “Access Modifiers.”</p>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Accessibility Capping"><div class="sect2" id="accessibility_capping">
<h2>Accessibility Capping</h2>
<p><a contenteditable="false" data-primary="access modifiers" data-secondary="accessibility capping" data-type="indexterm" id="id1037"/><a contenteditable="false" data-primary="accessibility capping" data-type="indexterm" id="id1038"/><a contenteditable="false" data-primary="capping, accessibility" data-type="indexterm" id="id1039"/>A type caps the accessibility of its declared members. The most common example of capping is when you have an <code>internal</code> type with <code>public</code> members. For example:</p>
<pre data-type="programlisting">class C { public void Foo() {} }</pre>
<p><code>C</code>’s (default) <code>internal</code> accessibility caps <code>Foo</code>’s accessibility, effectively making <code>Foo internal</code>. A common reason <code>Foo</code> would be marked <code>public</code> is to make for easier refactoring, should <code>C</code> later be changed to <code>public</code>.<a contenteditable="false" data-primary="" data-startref="ch1001.html28" data-type="indexterm" id="id1040"/></p>
</div></section>
</div></section>
<section data-type="sect1" data-pdf-bookmark="Interfaces"><div class="sect1" id="interfaces">
<h1>Interfaces</h1>
<p><a contenteditable="false" data-primary="classes" data-secondary="interfaces versus" data-type="indexterm" id="id1041"/><a contenteditable="false" data-primary="interfaces" data-secondary="classes versus" data-type="indexterm" id="id1042"/>An <a contenteditable="false" data-primary="interfaces" data-type="indexterm" id="ch1001.html29"/><em>interface</em> is similar to a class but only <em>specifies behavior</em> and does not hold state (data). Consequently:</p>
<ul>
<li><p>Interface members are <em>all implicitly abstract</em>. (There are exceptions to this rule that we will describe in <a data-type="xref" href="#default_interface_members">“Default Interface Members”</a> and <a data-type="xref" href="#static_interface_members">“Static Interface Members”</a>.)</p></li>
<li class="pagebreak-before"><p>A class (or struct) can implement <em>multiple</em> interfaces. In contrast, a class can inherit from only a <em>single</em> class, and a struct cannot inherit at all (aside from deriving from <code>System.ValueType</code>).</p></li>
</ul>
<p><a contenteditable="false" data-primary="interfaces" data-secondary="declaring" data-type="indexterm" id="id1043"/>An interface declaration is like a class declaration, but it (normally) provides no implementation for its members, because all its members are implicitly abstract. These members will be implemented by the classes and structs that implement the interface. An interface can contain only methods, properties, events, and indexers, which not coincidentally are precisely the members of a class that can be abstract.</p>
<p>Here is a slightly simplified version of the <code>IEnumerator</code> interface, defined in <code>System.Collections</code>:</p>
<pre data-type="programlisting">public <strong>interface</strong> IEnumerator
{
  bool MoveNext();
  object Current { get; }
  void Reset();
}</pre>
<p>Interface members are always implicitly public and cannot declare an access modifier. Implementing an interface means providing a <code>public</code> implementation for all of its members:</p>
<pre data-type="programlisting">internal class Countdown : IEnumerator
{
  int count = 6;
  public bool MoveNext()  =&gt; count-- &gt; 0 ;
  public object Current   =&gt; count;
  public void Reset()     =&gt; count = 6;
}</pre>
<p>You can implicitly cast an object to any interface that it <span class="keep-together">implements</span>:</p>
<pre data-type="programlisting"><strong>IEnumerator e</strong> = new Countdown();
while (e.MoveNext())
  Console.Write (e.Current + " ");  // 5 4 3 2 1 0</pre>
<section data-type="sect2" class="pagebreak-before" data-pdf-bookmark="Extending an Interface"><div class="sect2" id="extending_an_interface">
<h2 class="less_space">Extending an Interface</h2>
<p><a contenteditable="false" data-primary="interfaces" data-secondary="extending" data-type="indexterm" id="id1044"/>Interfaces can derive from other interfaces. For instance:</p>
<pre data-type="programlisting">public interface IUndoable             { void Undo(); }
public interface IRedoable : IUndoable { void Redo(); }</pre>
<p><code>IRedoable</code> “inherits” all the members of <code>IUndoable</code>.</p>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Explicit Interface Implementation"><div class="sect2" id="explicit_interface_implementation">
<h2>Explicit Interface Implementation</h2>
<p><a contenteditable="false" data-primary="explicit interface implementation" data-type="indexterm" id="id1045"/><a contenteditable="false" data-primary="interfaces" data-secondary="explicit implementation" data-type="indexterm" id="id1046"/>Implementing multiple interfaces can sometimes result in a collision between member signatures. You can resolve such collisions by <em>explicitly implementing</em> an interface member. For example:</p>
<pre data-type="programlisting">interface I1 { void Foo(); }
interface I2 { int Foo();  }

public class Widget : I1, I2
{
  public void Foo()   // Implicit implementation
  {
    Console.Write ("Widget's implementation of I1.Foo");
  }

  int <strong>I2.Foo</strong>()   // Explicit implementation of I2.Foo
  {
    Console.Write ("Widget's implementation of I2.Foo");
    return 42;
  }
}</pre>
<p>Because both <code>I1</code> and <code>I2</code> have conflicting <code>Foo</code> signatures, <code>Widget</code> explicitly implements <code>I2</code>’s <code>Foo</code> method. This lets the two methods coexist in one class. The only way to call an explicitly implemented member is to cast to its interface:</p>
<pre data-type="programlisting">Widget w = new Widget();
w.Foo();           // Widget's implementation of <strong>I1</strong>.Foo
((I1)w).Foo();     // Widget's implementation of <strong>I1</strong>.Foo
((I2)w).Foo();     // Widget's implementation of <strong>I2</strong>.Foo</pre>
<p>Another reason to explicitly implement interface members is to hide members that are highly specialized and distracting to a type’s normal use case. For example, a type that implements <code>ISerializable</code> would typically want to avoid flaunting its <span class="keep-together"><code>ISerializable</code></span> members unless explicitly cast to that <span class="keep-together">interface</span>.</p>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Implementing Interface Members Virtually"><div class="sect2" id="implementing_interface_members_virtuall">
<h2>Implementing Interface Members Virtually</h2>
<p><a contenteditable="false" data-primary="interfaces" data-secondary="implementing members virtually" data-type="indexterm" id="id1047"/>An implicitly implemented interface member is, by default, sealed. It must be marked <code>virtual</code> or <code>abstract</code> in the base class in order to be overridden: calling the interface member through either the base class or the interface then calls the subclass’s implementation.</p>
<p>An explicitly implemented interface member cannot be marked <code>virtual</code>, nor can it be overridden in the usual manner. It can, however, be <em>reimplemented</em>.</p>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Reimplementing an Interface in a Subclass"><div class="sect2" id="reimplementing_an_interface_in_a_subcla">
<h2>Reimplementing an Interface in a Subclass</h2>
<p><a contenteditable="false" data-primary="interfaces" data-secondary="reimplementing in subclasses" data-type="indexterm" id="id1048"/><a contenteditable="false" data-primary="reimplementing an interface" data-type="indexterm" id="id1049"/><a contenteditable="false" data-primary="subclasses" data-secondary="reimplementing interfaces in" data-type="indexterm" id="id1050"/>A subclass can <em>reimplement</em> any interface member already implemented by a base class. Reimplementation hijacks a member implementation (when called through the interface) and works whether or not the member is <code>virtual</code> in the base class.</p>
<p>In the following example, <code>TextBox</code> implements <code>IUndoable.Undo</code> explicitly, and so it cannot be marked as <code>virtual</code>. To “override” it, <code>RichTextBox</code> must reimplement <code>IUndoable</code>’s <code>Undo</code> method:</p>
<pre data-type="programlisting">public interface IUndoable { void Undo(); }

public class TextBox : IUndoable
{
  void IUndoable.Undo()
    =&gt; Console.WriteLine ("TextBox.Undo");
}

public class RichTextBox : TextBox<strong>, IUndoable</strong>
{
  public new void Undo()
    =&gt; Console.WriteLine ("RichTextBox.Undo");
}</pre>
<p class="pagebreak-before">Calling the reimplemented member through the interface calls the subclass’s implementation:</p>
<pre data-type="programlisting">RichTextBox r = new RichTextBox();
r.Undo();                 // RichTextBox.Undo
((IUndoable)r).Undo();    // RichTextBox.Undo</pre>
<p>In this case, <code>TextBox</code> implements the <code>Undo</code> method explicitly. If <code>TextBox</code> instead implemented the <code>Undo</code> method implicitly, <code>RichTextBox</code> could still reimplement the method, but the effects would be nonpervasive in that calling the member through the base class would invoke the base implementation:</p>
<pre data-type="programlisting">RichTextBox r = new RichTextBox();
((TextBox)r).Undo();      // <strong>TextBox.Undo</strong></pre>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Default Interface Members"><div class="sect2" id="default_interface_members">
<h2>Default Interface Members</h2>
<p><a contenteditable="false" data-primary="default interface members" data-type="indexterm" id="id1051"/><a contenteditable="false" data-primary="interfaces" data-secondary="default members" data-type="indexterm" id="id1052"/>From C# 8, you can add a default implementation to an interface member, making it optional to implement:</p>
<pre data-type="programlisting">interface ILogger
{
  void Log (string text) <strong>=&gt; Console.WriteLine (text);</strong>
}</pre>
<p>This is advantageous if you wish to add a member to an interface defined in a popular library without breaking (potentially thousands of) implementations.</p>
<p>Default implementations are always explicit, so if a class implementing <code>ILogger</code> fails to define a <code>Log</code> method, the only way to call it is through the interface:</p>
<pre data-type="programlisting">class Logger : ILogger { }
...
(<strong>(ILogger)</strong>new Logger()).Log ("message");</pre>
<p>This prevents a problem of multiple implementation inheritance: if the same default member is added to two interfaces that a class implements, there is never an ambiguity as to which member is called.</p>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Static Interface Members"><div class="sect2" id="static_interface_members">
<h2>Static Interface Members</h2>
<p><a contenteditable="false" data-primary="interfaces" data-secondary="static members" data-type="indexterm" id="ch01.html2"/><a contenteditable="false" data-primary="static interface members" data-type="indexterm" id="ch01.html3"/>An interface can also declare static members. There are two kinds of static interface members:</p>
<ul>
<li><p>Static nonvirtual interface members</p></li>
<li><p>Static virtual/abstract interface members</p></li>
</ul>
<section data-type="sect3" data-pdf-bookmark="Static nonvirtual interface members"><div class="sect3" id="static_nonvirtual_interface_members">
<h3>Static nonvirtual interface members</h3>
<p><a contenteditable="false" data-primary="static interface members" data-secondary="nonvirtual" data-type="indexterm" id="id1053"/>Static nonvirtual interface members exist mainly to help with writing default interface members. They are not implemented by classes or structs; instead, they are consumed directly. Along with methods, properties, events, and indexers, static nonvirtual members permit fields, which are typically accessed from code inside default member implementations:</p>
<pre data-type="programlisting">interface ILogger
{
  void Log (string text) =&gt; 
    Console.WriteLine (<strong>Prefix</strong> + text);

  <strong>static string Prefix</strong> = ""; 
}</pre>
<p>Static nonvirtual interface members are public by default, so they can be accessed from the outside:</p>
<pre data-type="programlisting"><strong>ILogger.Prefix</strong> = "File log: ";</pre>
<p>You can restrict this by adding an accessibility modifier (such as <code>private</code>, <code>protected</code>, or <code>internal</code>).</p>
<p>Instance fields are (still) prohibited. This is in line with the principle of interfaces, which is to define <em>behavior</em>, not <em>state</em>.</p>
</div></section>
<section data-type="sect3" data-pdf-bookmark="Static virtual/abstract interface members"><div class="sect3" id="static_virtualsolidusabstract_interface">
<h3>Static virtual/abstract interface members</h3>
<p><a contenteditable="false" data-primary="static interface members" data-secondary="virtual/abstract" data-type="indexterm" id="id1054"/><a contenteditable="false" data-primary="static virtual members" data-type="indexterm" id="id1055"/><a contenteditable="false" data-primary="static abstract members" data-type="indexterm" id="id1056"/>Static virtual/abstract interface members (from C# 11) are marked with <code>static abstract</code> or <code>static virtual</code> and enable <em>static polymorphism</em>, an advanced feature that we will discuss fully in <a data-type="xref" href="#static_polymorphism">“Static Polymorphism”</a>:</p>
<pre data-type="programlisting">interface ITypeDescribable
{
  <strong>static abstract</strong> string Description { get; }
  <strong>static virtual</strong> string Category =&gt; null;
}</pre>
<p>An implementing class or struct must implement static abstract members and can optionally implement static virtual members:</p>
<pre data-type="programlisting">class CustomerTest : ITypeDescribable
{
  public static string Description =&gt; "Customer tests";
  public static string Category    =&gt; "Unit testing";
}</pre>
<p>In addition to methods, properties, and events, operators and conversions are also legal targets for static virtual interface members (see <a data-type="xref" href="#operator_overloading">“Operator Overloading”</a>). Static virtual interface members are called through a constrained type parameter; we will demonstrate this in <a data-type="xref" href="#static_polymorphism">“Static Polymorphism”</a> and <a data-type="xref" href="#generic_math">“Generic Math”</a>, after covering generics.<a contenteditable="false" data-primary="" data-startref="ch01.html3" data-type="indexterm" id="id1057"/><a contenteditable="false" data-primary="" data-startref="ch01.html2" data-type="indexterm" id="id1058"/><a contenteditable="false" data-primary="" data-startref="ch1001.html29" data-type="indexterm" id="id1059"/></p>
</div></section>
</div></section>
</div></section>
<section data-type="sect1" data-pdf-bookmark="Enums"><div class="sect1" id="enums">
<h1>Enums</h1>
<p><a contenteditable="false" data-primary="enums" data-type="indexterm" id="ch1001.html30"/>An  <a contenteditable="false" data-primary="enums" data-secondary="purpose of" data-type="indexterm" id="id1060"/><em>enum</em> is a special value type that lets you specify a group of named numeric constants. For example:</p>
<pre data-type="programlisting">public enum BorderSide { Left, Right, Top, Bottom }</pre>
<p>We can use this enum type as follows:</p>
<pre data-type="programlisting">BorderSide topSide = BorderSide.Top;
bool isTop = (topSide == BorderSide.Top);   // true</pre>
<p>Each enum member has an underlying integral-type value. By default, the underlying values are of type <code>int</code>, and the enum members are assigned the constants <code>0</code>, <code>1</code>, <code>2</code>... (in their declaration order). You may specify an alternative integral type, as follows:</p>
<pre data-type="programlisting">public enum BorderSide : <strong>byte</strong> { Left,Right,Top,Bottom }</pre>
<p>You may also specify an explicit integer value for each member:</p>
<pre data-type="programlisting">public enum BorderSide : byte
 { Left<strong>=1</strong>, Right<strong>=2</strong>, Top<strong>=10</strong>, Bottom<strong>=11</strong> }</pre>
<p>The compiler also lets you explicitly assign <em>some</em> of the enum members. The unassigned enum members keep incrementing from the last explicit value. The preceding example is equivalent to:</p>
<pre data-type="programlisting">public enum BorderSide : byte
 { Left=1, Right, Top=10, Bottom }</pre>
<section data-type="sect2" data-pdf-bookmark="Enum Conversions"><div class="sect2" id="enum_conversions">
<h2>Enum Conversions</h2>
<p><a contenteditable="false" data-primary="conversions" data-secondary="enums" data-type="indexterm" id="id1061"/><a contenteditable="false" data-primary="enums" data-secondary="converting" data-type="indexterm" id="id1062"/>You can convert an <code>enum</code> instance to and from its underlying integral value with an explicit cast:</p>
<pre data-type="programlisting">int i = (int) BorderSide.Left;
BorderSide side = (BorderSide) i;
bool leftOrRight = (int) side &lt;= 2;</pre>
<p>You can also explicitly cast one enum type to another; the translation then uses the members’ underlying integral values.</p>
<p>The numeric literal <code>0</code> is treated specially in that it does not require an explicit cast:</p>
<pre data-type="programlisting">BorderSide b = 0;    // No cast required
if (b == 0) ...</pre>
<p>In this particular example, <code>BorderSide</code> has no member with an integer value of <code>0</code>. This does not generate an error: a limitation of enums is that the compiler and CLR do not prevent the assignment of integrals whose values fall outside the range of members:</p>
<pre data-type="programlisting">BorderSide b = (BorderSide) 12345;
Console.WriteLine (b);              // 12345</pre>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Flags Enums"><div class="sect2" id="flags_enums">
<h2>Flags Enums</h2>
<p><a contenteditable="false" data-primary="enums" data-secondary="combining members" data-type="indexterm" id="id1063"/><a contenteditable="false" data-primary="enums" data-secondary="flags" data-type="indexterm" id="id1064"/><a contenteditable="false" data-primary="flags enums" data-type="indexterm" id="id1065"/>You can combine enum members. To prevent ambiguities, members of a combinable enum require explicitly assigned values, typically in powers of two. For example:</p>
<pre data-type="programlisting">[Flags]
public enum BorderSides
 { None=0, Left=1, Right=2, Top=4, Bottom=8 }</pre>
<p><a contenteditable="false" data-primary="&amp; (AND) operator" data-type="indexterm" id="id1066"/><a contenteditable="false" data-primary="| (OR operator)" data-type="indexterm" id="id1067"/><a contenteditable="false" data-primary="AND (&amp;) operator" data-type="indexterm" id="id1068"/><a contenteditable="false" data-primary="OR operator (|)" data-type="indexterm" id="id1069"/>By convention, a combinable enum type is given a plural rather than singular name. To work with combined enum values, you use bitwise operators, such as <code>|</code> and <code>&amp;</code>. These operate on the underlying integral values:</p>
<pre data-type="programlisting">BorderSides leftRight =
  BorderSides.Left | BorderSides.Right;

if ((leftRight &amp; BorderSides.Left) != 0)
  Console.WriteLine ("Includes Left");   // Includes Left

string formatted = leftRight.ToString(); // "Left, Right"

BorderSides s = BorderSides.Left;
s |= BorderSides.Right;
Console.WriteLine (s == leftRight);      // True</pre>
<p><a contenteditable="false" data-primary="Flags attribute" data-type="indexterm" id="id1070"/>The <code>Flags</code> attribute should be applied to combinable enum types; if you fail to do this, calling <code>ToString</code> on an <code>enum</code> instance emits a number rather than a series of names.</p>
<p>For convenience, you can include combination members within an enum declaration itself:</p>
<pre data-type="programlisting">[Flags] public enum BorderSides
{
  None=0,
  Left=1, Right=2, Top=4, Bottom=8,
<strong>  LeftRight = Left | Right,</strong> 
<strong>  TopBottom = Top  | Bottom,</strong>
<strong>  All       = LeftRight | TopBottom</strong>
}</pre>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Enum Operators"><div class="sect2" id="enum_operators">
<h2>Enum Operators</h2>
<p><a contenteditable="false" data-primary="enums" data-secondary="operators for" data-type="indexterm" id="id1071"/>The operators that work with enums are:</p>
<pre data-type="programlisting">=   ==   !=   &lt;   &gt;   &lt;=   &gt;=   +   -   ^  &amp;  |   ˜
+=  -=   ++   --   sizeof</pre>
<p>The bitwise, arithmetic, and comparison operators return the result of processing the underlying integral values. Addition is permitted between an enum and an integral type, but not between two enums.<a contenteditable="false" data-primary="" data-startref="ch1001.html30" data-type="indexterm" id="id1072"/></p>
</div></section>
</div></section>
<section data-type="sect1" data-pdf-bookmark="Nested Types"><div class="sect1" id="nested_types">
<h1>Nested Types</h1>
<p><a contenteditable="false" data-primary="nested types" data-type="indexterm" id="id1073"/><a contenteditable="false" data-primary="types" data-secondary="nested" data-type="indexterm" id="id1074"/>A <em>nested type</em> is declared within the scope of another type. For example:</p>
<pre data-type="programlisting">public class TopLevel
{
  public class Nested { }               // Nested class
  public enum Color { Red, Blue, Tan }  // Nested enum
}</pre>
<p>A nested type has the following features:</p>
<ul>
<li><p>It can access the enclosing type’s private members and everything else the enclosing type can access.</p></li>
<li><p>It can be declared with the full range of access modifiers, rather than just <code>public</code> and <code>internal</code>.</p></li>
<li><p>The default accessibility for a nested type is <code>private</code> rather than <code>internal</code>.</p></li>
<li><p>Accessing a nested type from outside the enclosing type requires qualification with the enclosing type’s name (like when you’re accessing static members).</p></li>
</ul>
<p>For example, to access <code>Color.Red</code> from outside our <code>TopLevel</code> class, you’d need to do this:</p>
<pre data-type="programlisting">TopLevel.Color color = TopLevel.Color.Red;</pre>
<p>All types can be nested; however, only classes and structs can nest.</p>
</div></section>
<section data-type="sect1" data-pdf-bookmark="Generics"><div class="sect1" id="generics">
<h1>Generics</h1>
<p><a contenteditable="false" data-primary="generics" data-secondary="inheritance versus" data-type="indexterm" id="id1075"/>C# <a contenteditable="false" data-primary="generics" data-type="indexterm" id="ch1001.html31"/>has two separate mechanisms for writing code that are reusable across different types: <em>inheritance</em> and <em>generics</em>. Whereas inheritance expresses reusability with a base type, generics express reusability with a “template” that contains <span class="keep-together">“placeholder”</span> types. <a contenteditable="false" data-primary="type safety, increasing with generics" data-type="indexterm" id="id1076"/>Generics, when compared to inheritance, can <em>increase type safety</em> and <em>reduce casting and boxing</em>.</p>
<section data-type="sect2" data-pdf-bookmark="Generic Types"><div class="sect2" id="generic_types">
<h2>Generic Types</h2>
<p><a contenteditable="false" data-primary="arguments" data-secondary="type arguments" data-type="indexterm" id="id1077"/><a contenteditable="false" data-primary="generics" data-secondary="purpose of generic types" data-type="indexterm" id="id1078"/><a contenteditable="false" data-primary="inheritance" data-secondary="generics versus" data-type="indexterm" id="id1079"/><a contenteditable="false" data-primary="type arguments" data-type="indexterm" id="id1080"/><a contenteditable="false" data-primary="type parameters" data-type="indexterm" id="id1081"/><a contenteditable="false" data-primary="variables and parameters" data-secondary="type parameters" data-type="indexterm" id="id1082"/>A <em>generic type</em> declares <em>type parameters</em>—placeholder types to be filled in by the consumer of the generic type, which supplies the <em>type arguments</em>. Here is a generic type, <code>Stack&lt;T&gt;</code>, designed to stack instances of type <code>T</code>. <code>Stack&lt;T&gt;</code> declares a single type parameter <code>T</code>:</p>
<pre data-type="programlisting">public class Stack<strong>&lt;T&gt;</strong>
{
  int position;
  <strong>T</strong>[] data = new <strong>T</strong>[100];
  public void Push (<strong>T</strong> obj) =&gt; data[position++] = obj;
  public <strong>T</strong> Pop()           =&gt; data[--position];
}</pre>
<p>We can use <code>Stack&lt;T&gt;</code> as follows:</p>
<pre data-type="programlisting">var stack = new Stack<strong>&lt;int&gt;</strong>();
stack.Push (5);
stack.Push (10);
int x = stack.Pop();        // x is 10
int y = stack.Pop();        // y is 5</pre>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p><a contenteditable="false" data-primary="boxing" data-secondary="reducing with generics" data-type="indexterm" id="id1083"/><a contenteditable="false" data-primary="casting" data-secondary="reducing with generics" data-type="indexterm" id="id1084"/>Notice that no downcasts are required in the last two lines, avoiding the possibility of a runtime error and eliminating the overhead of boxing/unboxing. This makes our generic stack superior to a nongeneric stack that uses <code>object</code> in place of <code>T</code> (see <a data-type="xref" href="#the_object_type">“The object Type”</a> for an example).</p>
</div>
<p><code>Stack&lt;int&gt;</code> fills in the type parameter <code>T</code> with the type argument <code>int</code>, implicitly creating a type on the fly (the synthesis occurs at runtime). <code>Stack&lt;int&gt;</code> effectively has the following definition (substitutions appear in bold, with the class name hashed out to avoid confusion):</p>
<pre data-type="programlisting">public class ###
{
  int position;
  <strong>int</strong>[] data = new <strong>int</strong>[100];
  public void Push (<strong>int</strong> obj) =&gt; data[position++] = obj;
  public <strong>int</strong> Pop()           =&gt; data[--position];
}</pre>
<p>Technically, we say that <code>Stack&lt;T&gt;</code> is an <em>open type</em>, whereas <code>Stack&lt;int&gt;</code> is a <em>closed type</em>. At runtime, all generic type instances are closed—with the placeholder types filled in.</p>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Generic Methods"><div class="sect2" id="generic_methods">
<h2>Generic Methods</h2>
<p><a contenteditable="false" data-primary="generics" data-secondary="generic methods" data-type="indexterm" id="id1085"/><a contenteditable="false" data-primary="methods" data-secondary="generic methods" data-type="indexterm" id="id1086"/>A <em>generic method</em> declares type parameters within the signature of a method. With generic methods, many fundamental algorithms can be implemented in a general-purpose way. Here is a generic method that swaps the contents of two variables of any type <code>T</code>:</p>
<pre data-type="programlisting">static void Swap&lt;T&gt; (ref T a, ref T b)
{
  T temp = a; a = b; b = temp;
}</pre>
<p>You can use <code>Swap&lt;T&gt;</code> as follows:</p>
<pre data-type="programlisting">int x = 5, y = 10;
Swap (ref x, ref y);</pre>
<p>Generally, there is no need to supply type arguments to a generic method, because the compiler can implicitly infer the type. If there is ambiguity, generic methods can be called with the type arguments as follows:</p>
<pre data-type="programlisting">Swap<strong>&lt;int&gt;</strong> (ref x, ref y);</pre>
<p class="pagebreak-before">Within a generic <em>type</em>, a method is not classed as generic unless it <em>introduces</em> type parameters (with the angle bracket syntax). The <code>Pop</code> method in our generic stack merely consumes the type’s existing type parameter, <code>T</code>, and is not classed as a generic method.</p>
<p>Methods and types are the only constructs that can introduce type parameters. Properties, indexers, events, fields, constructors, operators, and so on cannot declare type parameters, although they can partake in any type parameters already declared by their enclosing type. In our generic stack example, for instance, we could write an indexer that returns a generic item:</p>
<pre data-type="programlisting">public T this [int index] { get { return data[index]; } }</pre>
<p>Similarly, constructors can partake in existing type parameters but cannot <em>introduce</em> them.</p>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Declaring Type Parameters"><div class="sect2" id="declaring_type_parameters">
<h2>Declaring Type Parameters</h2>
<p><a contenteditable="false" data-primary="generics" data-secondary="declaring type parameters" data-type="indexterm" id="id1087"/><a contenteditable="false" data-primary="type parameters" data-type="indexterm" id="id1088"/>Type parameters can be introduced in the declaration of classes, structs, interfaces, delegates (see <a data-type="xref" href="#delegates">“Delegates”</a>), and methods. You can specify multiple type parameters by separating them with commas:</p>
<pre data-type="programlisting">class Dictionary&lt;TKey, TValue&gt; {...}</pre>
<p>To instantiate:</p>
<pre data-type="programlisting">var myDict = new Dictionary&lt;int,string&gt;();</pre>
<p>Generic type names and method names can be overloaded as long as the number of type parameters differs. For example, the following three type names do not conflict:</p>
<pre data-type="programlisting">class A {}
class A&lt;T&gt; {}
class A&lt;T1,T2&gt; {}</pre>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>By convention, generic types and methods with a <em>single</em> type parameter name their parameter <code>T</code>, as long as the intent of the parameter is clear. With <em>multiple</em> type parameters, each parameter has a more descriptive name (prefixed by <code>T</code>).</p>
</div>
</div></section>
<section data-type="sect2" data-pdf-bookmark="typeof and Unbound Generic Types"><div class="sect2" id="typeof_and_unbound_generic_types">
<h2>typeof and Unbound Generic Types</h2>
<p><a contenteditable="false" data-primary="generics" data-secondary="typeof and unbound generic types" data-type="indexterm" id="id1089"/><a contenteditable="false" data-primary="typeof operator" data-type="indexterm" id="id1090"/><a contenteditable="false" data-primary="unbound generic types" data-type="indexterm" id="id1091"/>Open generic types do not exist at runtime: open generic types are closed as part of compilation. However, it is possible for an <em>unbound</em> generic type to exist at runtime—purely as a <code>Type</code> object. The only way to specify an unbound generic type in C# is with the <code>typeof</code> operator:</p>
<pre data-type="programlisting">class A&lt;T&gt; {}
class A&lt;T1,T2&gt; {}
...

Type a1 = <strong>typeof (A&lt;&gt;)</strong>;   // <em>Unbound</em> type
Type a2 = <strong>typeof (A&lt;,&gt;)</strong>;  // Indicates 2 type args
Console.Write (a2.GetGenericArguments().Count());  // 2</pre>
<p>You can also use the <code>typeof</code> operator to specify a closed type:</p>
<pre data-type="programlisting">Type a3 = typeof (A&lt;int,int&gt;);</pre>
<p>It can specify an open type as well (which is closed at runtime):</p>
<pre data-type="programlisting">class B&lt;T&gt; { void X() { Type t = typeof (T); } }</pre>
</div></section>
<section data-type="sect2" data-pdf-bookmark="The default Generic Value"><div class="sect2" id="the_default_generic_value">
<h2>The default Generic Value</h2>
<p><a contenteditable="false" data-primary="default keyword" data-type="indexterm" id="id1092"/><a contenteditable="false" data-primary="default values" data-secondary="for generic type parameter" data-type="indexterm" id="id1093"/><a contenteditable="false" data-primary="generics" data-secondary="default generic value" data-type="indexterm" id="id1094"/>You can use the <code>default</code> keyword to get the default value for a generic type parameter. The default value for a reference type is <code>null</code>, and the default value for a value type is the result of bitwise-zeroing the type’s fields:</p>
<pre class="pagebreak-before" data-type="programlisting">static void Zap&lt;T&gt; (T[] array)
{
  for (int i = 0; i &lt; array.Length; i++)
<strong>    array[i] = default(T);</strong>
}</pre>
<p>From C# 7.1, you can omit the type argument for cases in which the compiler is able to infer it:</p>
<pre data-type="programlisting"><strong>   array[i] = default;</strong></pre>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Generic Constraints"><div class="sect2" id="generic_constraints">
<h2>Generic Constraints</h2>
<p><a contenteditable="false" data-primary="constraints" data-type="indexterm" id="ch01.html4"/><a contenteditable="false" data-primary="generics" data-secondary="generic constraints" data-type="indexterm" id="ch01.html5"/>By default, a type parameter can be substituted with any type whatsoever. <em>Constraints</em> can be applied to a type parameter to require more specific type arguments. There are eight kinds of constraints:</p>
<pre data-type="programlisting">where <em>T</em> : <em>base-class</em>  // Base class constraint
where <em>T</em> : <em>interface</em>   // Interface constraint
where <em>T</em> : class       // Reference type constraint
where <em>T</em> : class?      // (See "Nullable Reference Types")
where <em>T</em> : struct      // Value type constraint
where <em>T</em> : unmanaged   // Unmanaged constraint
where <em>T</em> : new()       // Parameterless constructor
                      // constraint
where <em>U</em> : <em>T</em>           // Naked type constraint
where <em>T</em> : notnull     // Non-nullable value type
                      // or non-nullable reference type</pre>
<p>In the following example, <code>GenericClass&lt;T,U&gt;</code> requires <code>T</code> to derive from (or be identical to) <code>SomeClass</code> and implement <code>Interface1</code>, and requires <code>U</code> to provide a parameterless constructor:</p>
<pre data-type="programlisting">class     SomeClass {}
interface Interface1 {}

class GenericClass&lt;T,U&gt; where T : SomeClass, Interface1
                        where U : new()
{ ... }</pre>
<p>Constraints can be applied wherever type parameters are defined, whether in methods or in type definitions.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>A <em>constraint</em> is a <em>restriction</em>; however, the main purpose of type parameter constraints is to enable things that would otherwise be prohibited.</p>
<p>For instance, the constraint <code>T:Foo</code> lets you treat instances of <code>T</code> as <code>Foo</code>, and the constraint <code>T:new()</code> lets you construct new instances of <code>T</code>.</p>
</div>
<p><a contenteditable="false" data-primary="base class constraints" data-type="indexterm" id="id1095"/>A <em>base class constraint</em> specifies that the type parameter must subclass (or match) a particular class; an <em>interface constraint</em> specifies that the type parameter must implement that interface. These constraints allow instances of the type parameter to be implicitly converted to that class or interface.</p>
<p><a contenteditable="false" data-primary="class constraints" data-type="indexterm" id="id1096"/><a contenteditable="false" data-primary="structs" data-secondary="struct constraints" data-type="indexterm" id="id1097"/>The <em>class constraint</em> and <em>struct constraint</em> specify that <code>T</code> must be a reference type or a (non-nullable) value type, respectively. The unmanaged constraint is a stronger version of a struct constraint: <code>T</code> must be a simple value type or a struct that is (recursively) free of any reference types. <a contenteditable="false" data-primary="parameterless constructor constraint" data-type="indexterm" id="id1098"/>The <em>parameterless constructor constraint</em> requires <code>T</code> to have a public parameterless constructor and allows you to call <code>new()</code> on <code>T</code>:</p>
<pre data-type="programlisting">static void Initialize&lt;T&gt; (T[] array) <strong>where T : new()</strong>
{
  for (int i = 0; i &lt; array.Length; i++)
    array[i] = <strong>new T()</strong>;
}</pre>
<p><a contenteditable="false" data-primary="naked type constraint" data-type="indexterm" id="id1099"/>The <em>naked type constraint</em> requires one type parameter to derive from (or match) another type parameter.<a contenteditable="false" data-primary="" data-startref="ch01.html5" data-type="indexterm" id="id1100"/><a contenteditable="false" data-primary="" data-startref="ch01.html4" data-type="indexterm" id="id1101"/></p>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Subclassing Generic Types"><div class="sect2" id="subclassing_generic_types">
<h2>Subclassing Generic Types</h2>
<p><a contenteditable="false" data-primary="classes" data-secondary="subclassing generic types" data-type="indexterm" id="id1102"/><a contenteditable="false" data-primary="generics" data-secondary="subclassing generic types" data-type="indexterm" id="id1103"/><a contenteditable="false" data-primary="subclasses" data-secondary="generic types and" data-type="indexterm" id="id1104"/>A generic class can be subclassed just like a nongeneric class. The subclass can leave the base class’s type parameters open, as in the following example:</p>
<pre class="pagebreak-before" data-type="programlisting">class Stack&lt;T&gt;                   {...}
class SpecialStack&lt;T&gt; : Stack&lt;T&gt; {...}</pre>
<p>Or the subclass can close the generic type parameters with a concrete type:</p>
<pre data-type="programlisting">class IntStack : Stack&lt;<strong>int</strong>&gt;  {...}</pre>
<p>A subtype can also introduce fresh type arguments:</p>
<pre data-type="programlisting">class List&lt;T&gt;                     {...}
class KeyedList&lt;T<strong>,TKey</strong>&gt; : List&lt;T&gt; {...}</pre>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Self-Referencing Generic Declarations"><div class="sect2" id="self_referencing_generic_declarations">
<h2>Self-Referencing Generic Declarations</h2>
<p><a contenteditable="false" data-primary="generics" data-secondary="self-referencing generic declarations" data-type="indexterm" id="id1105"/>A type can name <em>itself</em> as the concrete type when closing a type argument:</p>
<pre data-type="programlisting">public interface IEquatable&lt;T&gt; { bool Equals (T obj); }

public class <strong>Balloon</strong> : IEquatable&lt;<strong>Balloon</strong>&gt;
{
  public bool Equals (Balloon b) { ... }
}</pre>
<p>The following are also legal:</p>
<pre data-type="programlisting">class Foo&lt;T&gt; where T : IComparable&lt;T&gt; { ... }
class Bar&lt;T&gt; where T : Bar&lt;T&gt; { ... }</pre>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Static Data"><div class="sect2" id="static_data">
<h2>Static Data</h2>
<p><a contenteditable="false" data-primary="generics" data-secondary="static data" data-type="indexterm" id="id1106"/><a contenteditable="false" data-primary="static data" data-type="indexterm" id="id1107"/>Static data is unique for each closed type:</p>
<pre data-type="programlisting">Console.WriteLine (++Bob&lt;int&gt;.Count);     // 1
Console.WriteLine (++Bob&lt;int&gt;.Count);     // 2
Console.WriteLine (++Bob&lt;string&gt;.Count);  // 1
Console.WriteLine (++Bob&lt;object&gt;.Count);  // 1

class Bob&lt;T&gt; { public static int Count; }</pre>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Covariance"><div class="sect2" id="covariance">
<h2>Covariance</h2>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p><a contenteditable="false" data-primary="covariance" data-secondary="generics" data-type="indexterm" id="id1108"/><a contenteditable="false" data-primary="generics" data-secondary="covariance" data-type="indexterm" id="id1109"/>Covariance and contravariance are advanced concepts. The motivation behind their introduction into C# was to allow generic interfaces and generics (in particular, those defined in .NET, such as <code>IEnumerable&lt;T&gt;</code>) to work <em>more as you’d expect</em>. You can benefit from this without understanding the details behind covariance and contravariance.</p>
</div>
<p>Assuming <code>A</code> is convertible to <code>B</code>, <code>X</code> has a covariant type parameter if <code>X&lt;A&gt;</code> is convertible to <code>X&lt;B&gt;</code>.</p>
<p><a contenteditable="false" data-primary="conversions" data-secondary="implicit reference conversion" data-type="indexterm" id="id1110"/><a contenteditable="false" data-primary="convertibility" data-type="indexterm" id="id1111"/><a contenteditable="false" data-primary="implicit conversions" data-type="indexterm" id="id1112"/><a contenteditable="false" data-primary="reference conversion" data-type="indexterm" id="id1113"/>(With C#’s notion of variance, <em>convertible</em> means convertible via an <em>implicit reference conversion</em>—such as <code>A</code> <em>subclassing</em> <code>B</code>, or <code>A</code> <em>implementing</em> <code>B</code>. Numeric conversions, boxing conversions, and custom conversions are not included.)</p>
<p>For instance, type <code>IFoo&lt;T&gt;</code> has a covariant <code>T</code> if the following is legal:</p>
<pre data-type="programlisting">IFoo&lt;string&gt; s = ...;
<strong>IFoo&lt;object&gt; b = s;</strong></pre>
<p>Interfaces (and delegates) permit covariant type parameters. To illustrate, suppose that the <code>Stack&lt;T&gt;</code> class that we wrote at the beginning of this section implements the following interface:</p>
<pre data-type="programlisting">public interface IPoppable&lt;<strong>out</strong> T&gt; { T Pop(); }</pre>
<p>The <code>out</code> modifier on <code>T</code> indicates that <code>T</code> is used only in <em>output positions</em> (e.g., return types for methods) and flags the type parameter as <em>covariant</em>, permitting the following code:</p>
<pre data-type="programlisting">// Assuming that Bear subclasses Animal:
var bears = new Stack&lt;Bear&gt;();
bears.Push (new Bear());

// Because bears implements IPoppable&lt;Bear&gt;,
// we can convert it to IPoppable&lt;Animal&gt;:
<strong>IPoppable&lt;Animal&gt; animals = bears;   // Legal</strong>
Animal a = animals.Pop();</pre>
<p>The cast from <code>bears</code> to <code>animals</code> is permitted by the compiler—by virtue of the interface’s type parameter being covariant.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>The <code>IEnumerator&lt;T&gt;</code> and <code>IEnumerable&lt;T&gt;</code> interfaces (see <a data-type="xref" href="#enumeration_and_iterators">“Enumeration and Iterators”</a>) are marked with a covariant <code>T</code>. This allows you to cast <code>IEnumerable&lt;string&gt;</code> to <code>IEnumerable&lt;object&gt;</code>, for instance.</p>
</div>
<p>The compiler will generate an error if you use a covariant type parameter in an <em>input</em> position (e.g., a parameter to a method or a writable property). The purpose of this limitation is to guarantee compile-time type safety. For instance, it prevents us from adding a <code>Push(T)</code> method to that interface, which consumers could abuse with the seemingly benign operation of pushing a camel onto an <code>IPoppable&lt;Animal&gt;</code> (remember that the underlying type in our example is a stack of bears). To define a <code>Push(T)</code> method, <code>T</code> must in fact be <em>contravariant</em>.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>C# supports covariance (and contravariance) only for elements with <em>reference conversions</em>—not <em>boxing conversions</em>. So, if you wrote a method that accepted a parameter of type <code>IPoppable&lt;object&gt;</code>, you could call it with <code>IPoppable&lt;string&gt;</code> but not <code>IPoppable&lt;int&gt;</code>.</p>
</div>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Contravariance"><div class="sect2" id="contravariance">
<h2>Contravariance</h2>
<p><a contenteditable="false" data-primary="contravariance" data-secondary="generics" data-type="indexterm" id="id1114"/><a contenteditable="false" data-primary="generics" data-secondary="contravariance" data-type="indexterm" id="id1115"/>We previously saw that, assuming that <code>A</code> allows an implicit reference conversion to <code>B</code>, a type <code>X</code> has a covariant type parameter if <code>X&lt;A&gt;</code> allows a reference conversion to <code>X&lt;B&gt;</code>. A type is <em>contravariant</em> when you can convert in the reverse direction—from <code>X&lt;B&gt;</code> to <code>X&lt;A&gt;</code>. This is supported on interfaces and delegates when the type parameter appears only in <em>input</em> positions, designated with the <code>in</code> modifier. Extending our previous example, if the <code>Stack&lt;T&gt;</code> class implements the following interface:</p>
<pre data-type="programlisting">public interface IPushable&lt;<strong>in</strong> T&gt; { void Push (T obj); }</pre>
<p>we can legally do this:</p>
<pre data-type="programlisting">IPushable&lt;Animal&gt; animals = new Stack&lt;Animal&gt;();
<strong>IPushable&lt;Bear&gt; bears = animals;    // Legal</strong>
bears.Push (new Bear());</pre>
<p>Mirroring covariance, the compiler will report an error if you try to use a contravariant type parameter in an output position (e.g., as a return value or in a readable property).<a contenteditable="false" data-primary="" data-startref="ch1001.html31" data-type="indexterm" id="id1116"/></p>
</div></section>
</div></section>
<section data-type="sect1" data-pdf-bookmark="Delegates"><div class="sect1" id="delegates">
<h1>Delegates</h1>
<p><a contenteditable="false" data-primary="delegates" data-type="indexterm" id="ch1001.html32"/>A <em>delegate</em> wires up a method caller to its target method at runtime. <a contenteditable="false" data-primary="delegates" data-secondary="aspects of" data-type="indexterm" id="id1117"/>There are two aspects to a delegate: <em>type</em> and <em>instance</em>. <a contenteditable="false" data-primary="delegate type" data-type="indexterm" id="id1118"/>A <em>delegate type</em> defines a <em>protocol</em> to which the caller and target will conform, comprising a list of parameter types and a return type. <a contenteditable="false" data-primary="delegate instance" data-type="indexterm" id="id1119"/>A <em>delegate instance</em> is an object that refers to one (or more) target methods conforming to that protocol.</p>
<p>A delegate instance literally acts as a delegate for the caller: the caller invokes the delegate, and then the delegate calls the target method. This indirection decouples the caller from the target method.</p>
<p>A delegate type declaration is preceded by the keyword <code>delegate</code>, but otherwise it resembles an (abstract) method declaration. For example:</p>
<pre data-type="programlisting">delegate int Transformer (int x);</pre>
<p>To create a delegate instance, you can assign a method to a delegate variable:</p>
<pre data-type="programlisting"><strong>Transformer t = Square;</strong>  // Create delegate instance
int result = <strong>t(3);</strong>       // Invoke delegate
Console.Write (result);  // 9

int Square (int x) =&gt; x * x;</pre>
<p>Invoking a delegate is just like invoking a method (because the delegate’s purpose is merely to provide a level of indirection):</p>
<pre data-type="programlisting">t(3);</pre>
<p>The statement <code>Transformer t = Square</code> is shorthand for the following:</p>
<pre data-type="programlisting">Transformer t = new Transformer (Square);</pre>
<p>And <code>t(3)</code> is shorthand for this:</p>
<pre data-type="programlisting">t.Invoke (3);</pre>
<p><a contenteditable="false" data-primary="callbacks" data-secondary="delegates versus" data-type="indexterm" id="id1120"/><a contenteditable="false" data-primary="delegates" data-secondary="callbacks versus" data-type="indexterm" id="id1121"/>A delegate is similar to a <em>callback</em>, a general term that captures constructs such as C function pointers.</p>
<section data-type="sect2" data-pdf-bookmark="Writing Plug-In Methods with Delegates"><div class="sect2" id="writing_plug_in_methods_with_delegates">
<h2>Writing Plug-In Methods with Delegates</h2>
<p><a contenteditable="false" data-primary="delegates" data-secondary="writing plug-in methods with" data-type="indexterm" id="id1122"/><a contenteditable="false" data-primary="plug-in methods" data-type="indexterm" id="id1123"/>A delegate variable is assigned a method at runtime. This is useful for writing plug-in methods. In this example, we have a utility method named <code>Transform</code> that applies a transform to each element in an integer array. The <code>Transform</code> method has a delegate parameter for specifying a plug-in transform:</p>
<pre data-type="programlisting">int[] values = { 1, 2, 3 };
Transform (values, <strong>Square</strong>);  // Hook in the Square method

foreach (int i in values)
  Console.Write (i + "  ");  // 1   4   9

void Transform (int[] values, <strong>Transformer t</strong>)
{
  for (int i = 0; i &lt; values.Length; i++)
    values[i] = t (values[i]);
}

int Square (int x) =&gt; x * x;

delegate int Transformer (int x);</pre>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Instance and Static Method Targets"><div class="sect2" id="instance_and_static_method_targets">
<h2>Instance and Static Method Targets</h2>
<p><a contenteditable="false" data-primary="delegates" data-secondary="instance and static method targets" data-type="indexterm" id="id1124"/><a contenteditable="false" data-primary="instance methods" data-type="indexterm" id="id1125"/>A delegate’s target method can be a local, static, or instance method.</p>
<p>When an <em>instance</em> method is assigned to a delegate object, the latter must maintain a reference not only to the method but also to the <em>instance</em> to which the method belongs. The <span class="keep-together"><code>System.Delegate</code></span> class’s <code>Target</code> property represents this instance (and will be null for a delegate referencing a static method).</p>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Multicast Delegates"><div class="sect2" id="multicast_delegates">
<h2>Multicast Delegates</h2>
<p><a contenteditable="false" data-primary="delegates" data-secondary="multicast delegates" data-type="indexterm" id="id1126"/><a contenteditable="false" data-primary="multicast delegates" data-type="indexterm" id="id1127"/>All delegate instances have <em>multicast</em> capability. This means that a delegate instance can reference not just a single target method but also a list of target methods. The <code>+</code> and <code>+=</code> operators combine delegate instances. For example:</p>
<pre data-type="programlisting">SomeDelegate d = SomeMethod1;
d += SomeMethod2;</pre>
<p>The last line is functionally the same as this one:</p>
<pre data-type="programlisting">d = d + SomeMethod2;</pre>
<p>Invoking <code>d</code> will now call both <code>SomeMethod1</code> and <code>SomeMethod2</code>. Delegates are invoked in the order in which they are added.</p>
<p><a contenteditable="false" data-primary="− operator" data-type="indexterm" id="id1128"/><a contenteditable="false" data-primary="−= operator" data-secondary="remove delegate instance" data-type="indexterm" id="id1129"/>The <code>-</code> and <code>-=</code> operators remove the right delegate operand from the left delegate operand. For example:</p>
<pre data-type="programlisting">d -= SomeMethod1;</pre>
<p>Invoking <code>d</code> will now cause only <code>SomeMethod2</code> to be invoked.</p>
<p><a contenteditable="false" data-primary="+= operator" data-secondary="delegate instances" data-type="indexterm" id="id1130"/>Calling <code>+</code> or <code>+=</code> on a delegate variable with a <code>null</code> value is legal, as is calling <code>-=</code> on a delegate variable with a single target (which will result in the delegate instance being <code>null</code>).</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p><a contenteditable="false" data-primary="immutability" data-type="indexterm" id="id1131"/>Delegates are <em>immutable</em>, so when you call <code>+=</code> or <code>-=</code>, you’re in fact creating a <em>new</em> delegate instance and assigning it to the existing variable.</p>
</div>
<p>If a multicast delegate has a nonvoid return type, the caller receives the return value from the last method to be invoked. The preceding methods are still called, but their return values are discarded. In most scenarios in which multicast delegates are used, they have <code>void</code> return types, so this subtlety does not arise.</p>
<p>All delegate types implicitly derive from <code>System.MulticastDelegate</code>, which inherits from <code>System.Delegate</code>. C# compiles <code>+</code>, <code>-</code>, <code>+=</code>, and <code>-=</code> operations made on a delegate to the static <code>Combine</code> and <code>Remove</code> methods of the <code>System.Delegate</code> class.</p>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Generic Delegate Types"><div class="sect2" id="generic_delegate_types">
<h2>Generic Delegate Types</h2>
<p><a contenteditable="false" data-primary="delegates" data-secondary="generic delegate types" data-type="indexterm" id="id1132"/><a contenteditable="false" data-primary="generics" data-secondary="generic delegate types" data-type="indexterm" id="id1133"/>A delegate type can contain generic type parameters. For <span class="keep-together">example</span>:</p>
<pre data-type="programlisting">public delegate T Transformer&lt;T&gt; (T arg);</pre>
<p>Here’s how we could use this delegate type:</p>
<pre data-type="programlisting"><strong>Transformer&lt;double&gt;</strong> s = Square;
Console.WriteLine (s (3.3));        // 10.89

double Square (double x) =&gt; x * x;</pre>
</div></section>
<section data-type="sect2" data-pdf-bookmark="The Func and Action Delegates"><div class="sect2" id="the_func_and_action_delegates">
<h2>The Func and Action Delegates</h2>
<p>With generic delegates, it becomes possible to write a small set of delegate types that are so general they can work for methods of any return type and any (reasonable) number of arguments. <a contenteditable="false" data-primary="Action delegate" data-type="indexterm" id="id1134"/><a contenteditable="false" data-primary="delegates" data-secondary="func and action delegates" data-type="indexterm" id="id1135"/><a contenteditable="false" data-primary="func delegate" data-type="indexterm" id="id1136"/>These delegates are the <code>Func</code> and <code>Action</code> delegates, <a contenteditable="false" data-primary="System namespace" data-type="indexterm" id="id1137"/>defined in the <code>System</code> namespace (the <code>in</code> and <code>out</code> annotations indicate <em>variance</em>, which we cover in the context of delegates shortly):</p>
<pre data-type="programlisting">delegate TResult Func &lt;out TResult&gt; ();
delegate TResult Func &lt;in T, out TResult&gt; (T arg);
delegate TResult Func &lt;in T1, in T2, out TResult&gt;
 (T1 arg1, T2 arg2);
<em>... and so on, up to T16</em>

delegate void Action ();
delegate void Action &lt;in T&gt; (T arg);
delegate void Action &lt;in T1, in T2&gt; (T1 arg1, T2 arg2);
<em>... and so on, up to T16</em></pre>
<p>These delegates are extremely general. The <code>Transformer</code> delegate in our previous example can be replaced with a <code>Func</code> delegate that takes a single argument of type <code>T</code> and returns a same-typed value:</p>
<pre data-type="programlisting">public static void Transform&lt;T&gt; (
  T[] values, <strong>Func&lt;T,T&gt; transformer</strong>)
{
  for (int i = 0; i &lt; values.Length; i++)
    values[i] = transformer (values[i]);
}</pre>
<p>The only practical scenarios not covered by these delegates are <code>ref</code>/<code>out</code> and pointer parameters.</p>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Delegate Compatibility"><div class="sect2" id="delegate_compatibility">
<h2>Delegate Compatibility</h2>
<p><a contenteditable="false" data-primary="delegates" data-secondary="delegate compatibility" data-type="indexterm" id="id1138"/>Delegate types are all incompatible with one another, even if their signatures are the same:</p>
<pre data-type="programlisting">delegate void D1(); delegate void D2();
...
D1 d1 = Method1;
D2 d2 = d1;            // Compile-time error</pre>
<p>The following, however, is permitted:</p>
<pre data-type="programlisting">D2 d2 = <strong>new</strong> D2 (d1);</pre>
<p>Delegate instances are considered equal if they have the same type and method target(s). For multicast delegates, the order of the method targets is significant.</p>
<section data-type="sect3" data-pdf-bookmark="Return type variance"><div class="sect3" id="return_type_variance">
<h3>Return type variance</h3>
<p><a contenteditable="false" data-primary="covariance" data-secondary="delegate return type variance" data-type="indexterm" id="id1139"/><a contenteditable="false" data-primary="delegates" data-secondary="parameter variance" data-type="indexterm" id="id1140"/><a contenteditable="false" data-primary="delegates" data-secondary="return type variance" data-type="indexterm" id="id1141"/><a contenteditable="false" data-primary="polymorphic behavior" data-type="indexterm" id="id1142"/><a contenteditable="false" data-primary="return type variance" data-type="indexterm" id="id1143"/>When you call a method, you might get back a type that is more specific than what you asked for. This is ordinary polymorphic behavior. In keeping with this, a delegate target method might return a more specific type than described by the delegate. This is <em>covariance</em>:</p>
<pre data-type="programlisting">ObjectRetriever o = new ObjectRetriever (RetrieveString);
object result = o();
Console.WriteLine (result);      // hello

string RetrieveString() =&gt; "hello";

delegate object ObjectRetriever();</pre>
<p>The <code>ObjectRetriever</code> expects to get back an <code>object</code>, but an <code>object</code> <em>subclass</em> will also do because delegate return types are <em>covariant</em>.</p>
</div></section>
<section data-type="sect3" data-pdf-bookmark="Parameter variance"><div class="sect3" id="parameter_variance">
<h3>Parameter variance</h3>
<p><a contenteditable="false" data-primary="contravariance" data-secondary="delegate" data-type="indexterm" id="id1144"/>When you call a method, you can supply arguments that have more specific types than the parameters of that method. This is ordinary polymorphic behavior. In keeping with this, a delegate target method may have <em>less</em> specific parameter types than described by the delegate. This is called <em>contravariance</em>:</p>
<pre data-type="programlisting">StringAction sa = new StringAction (ActOnObject);
sa ("hello");

void ActOnObject (object o) =&gt; Console.WriteLine (o);

delegate void StringAction (string s);</pre>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>The standard event pattern is designed to help you take advantage of delegate parameter contravariance through its use of the common <code>EventArgs</code> base class. For example, you can have a single method invoked by two different delegates, one passing a <code>MouseEventArgs</code> and the other passing a <code>KeyEventArgs</code>.</p>
</div>
</div></section>
<section data-type="sect3" data-pdf-bookmark="Type parameter variance for generic delegates"><div class="sect3" id="type_parameter_variance_for_generic_del">
<h3>Type parameter variance for generic delegates</h3>
<p><a contenteditable="false" data-primary="contravariance" data-secondary="type parameter variance for generic delegates" data-type="indexterm" id="id1145"/><a contenteditable="false" data-primary="covariance" data-secondary="type parameter variance for generic delegates" data-type="indexterm" id="id1146"/><a contenteditable="false" data-primary="delegates" data-secondary="type parameter variance for generic delegates" data-type="indexterm" id="id1147"/><a contenteditable="false" data-primary="generics" data-secondary="type parameter variance" data-type="indexterm" id="id1148"/><a contenteditable="false" data-primary="parameter variance" data-type="indexterm" id="id1149"/><a contenteditable="false" data-primary="parameters" data-secondary="delegate parameter variance" data-type="indexterm" id="id1150"/>We saw in <a data-type="xref" href="#generics">“Generics”</a> how type parameters can be covariant and contravariant for generic interfaces. The same capability also exists for generic delegates. If you’re defining a generic delegate type, it’s a good practice to do the following:</p>
<ul>
<li><p>Mark a type parameter used only on the return value as covariant (<code>out</code>)</p></li>
<li><p>Mark any type parameters used only on parameters as contravariant (<code>in</code>)</p></li>
</ul>
<p>Doing so allows conversions to work naturally by respecting inheritance relationships between types. The following delegate (defined in the <code>System</code> namespace) is covariant for <code>TResult</code>:</p>
<pre data-type="programlisting">delegate TResult Func&lt;<strong>out</strong> TResult&gt;();</pre>
<p>This allows:</p>
<pre data-type="programlisting">Func&lt;string&gt; x = ...;
Func&lt;object&gt; y = x;</pre>
<p>The following delegate (defined in the <code>System</code> namespace) is contravariant for <code>T:</code></p>
<pre data-type="programlisting">delegate void Action&lt;<strong>in</strong> T&gt; (T arg);</pre>
<p>This allows:<a contenteditable="false" data-primary="" data-startref="ch1001.html32" data-type="indexterm" id="id1151"/></p>
<pre data-type="programlisting">Action&lt;object&gt; x = ...;
Action&lt;string&gt; y = x;</pre>
</div></section>
</div></section>
</div></section>
<section data-type="sect1" data-pdf-bookmark="Events"><div class="sect1" id="events">
<h1>Events</h1>
<p><a contenteditable="false" data-primary="events" data-type="indexterm" id="ch1001.html33"/>When you’re using delegates, <a contenteditable="false" data-primary="events" data-secondary="broadcasters and subscribers" data-type="indexterm" id="id1152"/>two emergent roles commonly appear: <em>broadcaster</em> and <em>subscriber</em>. The <em>broadcaster</em> is a type that contains a delegate field. <a contenteditable="false" data-primary="broadcasters" data-type="indexterm" id="id1153"/>The broadcaster decides when to broadcast, by invoking the delegate. <a contenteditable="false" data-primary="subscribers" data-type="indexterm" id="id1154"/>The <em>subscribers</em> are the method target recipients. A subscriber decides when to start and stop listening, by calling <code>+=</code> and <code>-=</code> on the broadcaster’s delegate. <a contenteditable="false" data-primary="−= operator" data-secondary="event subscription" data-type="indexterm" id="id1155"/><a contenteditable="false" data-primary="+= operator" data-secondary="event subscription" data-type="indexterm" id="id1156"/>A subscriber does not know about, or interfere with, other subscribers.</p>
<p>Events are a language feature that formalizes this pattern. An <code>event</code> is a construct that exposes just the subset of delegate features required for the broadcaster/subscriber model. The main purpose of events is to <em>prevent subscribers from interfering with one another</em>.</p>
<p><a contenteditable="false" data-primary="events" data-secondary="declaring" data-type="indexterm" id="id1157"/>The easiest way to declare an event is to put the <code>event</code> keyword in front of a delegate member:</p>
<pre data-type="programlisting">public class Broadcaster
{
  public <strong>event</strong> ProgressReporter Progress;
}</pre>
<p>Code within the <code>Broadcaster</code> type has full access to <code>Progress</code> and can treat it as a delegate. Code outside of <code>Broadcaster</code> can perform only <code>+=</code> and <code>-=</code> operations on the <code>Progress</code> event.</p>
<p>In the following example, the <code>Stock</code> class fires its <code>PriceChanged</code> event every time the <code>Price</code> of the <code>Stock</code> changes:</p>
<pre data-type="programlisting">public delegate void PriceChangedHandler
 (decimal oldPrice, decimal newPrice);

public class Stock
{
  string symbol; decimal price;

  public Stock (string symbol) =&gt; this.symbol = symbol;

<strong>  public event PriceChangedHandler PriceChanged;</strong>

  public decimal Price
  {
    get =&gt; price;
    set
    {
      if (price == value) return;
      // Fire event if invocation list isn't empty:
      if (PriceChanged != null)
<strong>        PriceChanged (price, value);</strong>
      price = value;
    }
  }
}</pre>
<p>If we remove the <code>event</code> keyword from our example so that <code>PriceChanged</code> becomes an ordinary delegate field, our example would give the same results. However, <code>Stock</code> would be less robust in that subscribers could do the following things to interfere with one another:</p>
<ul>
<li><p>Replace other subscribers by reassigning <code>PriceChanged</code> (instead of using the <code>+=</code> operator)</p></li>
<li><p>Clear all subscribers (by setting <code>PriceChanged</code> to <code>null</code>)</p></li>
<li><p>Broadcast to other subscribers by invoking the delegate</p></li>
</ul>
<p>Events can be virtual, overridden, abstract, or sealed. They can also be static.</p>
<section data-type="sect2" data-pdf-bookmark="Standard Event Pattern"><div class="sect2" id="standard_event_pattern">
<h2>Standard Event Pattern</h2>
<p><a contenteditable="false" data-primary=".NET Framework" data-primary-sortas="NET" data-secondary="standard event pattern in" data-type="indexterm" id="id1158"/><a contenteditable="false" data-primary="events" data-secondary="standard event pattern" data-type="indexterm" id="id1159"/>In almost all cases in which events are defined in the .NET library, their definition adheres to a standard pattern designed to provide consistency across library and user code. Here’s the preceding example refactored with this pattern:</p>
<pre data-type="programlisting">public class PriceChangedEventArgs <strong>: EventArgs</strong>
{
  public readonly decimal LastPrice, NewPrice;

  public PriceChangedEventArgs (decimal lastPrice,
                                decimal newPrice)
  {
    LastPrice = lastPrice; NewPrice = newPrice;
  }
}

public class Stock
{
  string symbol; decimal price;

  public Stock (string symbol) =&gt; this.symbol = symbol;

  public event <strong>EventHandler&lt;PriceChangedEventArgs&gt;</strong>
               PriceChanged;

<strong>  protected virtual void OnPriceChanged</strong>
<strong>                        (PriceChangedEventArgs e) =&gt;</strong>
    // Shortcut for invoking PriceChanged if not null:
<strong>    PriceChanged?.Invoke (this, e);</strong>
  
  public decimal Price
  {
    get { return price; }
    set
    {
      if (price == value) return;
<strong>      OnPriceChanged (new PriceChangedEventArgs (price,</strong>
<strong>                                                 value));</strong>
      price = value;
    }  
  }
}</pre>
<p>At the core of the standard event pattern is <code>System.EventArgs</code>, a predefined .NET class with no members (other than the static <code>Empty</code> field). <code>EventArgs</code> is a base class for conveying information for an event. In this example, we subclass <code>EventArgs</code> to convey the old and new prices when a <code>PriceChanged</code> event is fired.</p>
<p>The generic <code>System.EventHandler</code> delegate is also part of .NET and is defined as follows:</p>
<pre data-type="programlisting">public delegate void EventHandler&lt;TEventArgs&gt;
  (object source, TEventArgs e)</pre>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Before C# 2.0 (when generics were added to the language), the solution was to instead write a custom event-handling delegate for each <code>EventArgs</code> type as follows:</p>
<pre data-type="programlisting">delegate void PriceChangedHandler
  (object sender,
   PriceChangedEventArgs e);</pre>
<p>For historical reasons, most events within the .NET libraries use delegates defined in this way.</p>
</div>
<p>A protected virtual method named <code>On</code><em>-</em><code><em>event-name</em></code> centralizes firing of the event. This allows subclasses to fire the event (which is usually desirable) and also allows subclasses to insert code before and after the event is fired.</p>
<p>Here’s how we could use our <code>Stock</code> class:</p>
<pre data-type="programlisting">Stock stock = new Stock ("THPW");
stock.Price = 27.10M;

stock.PriceChanged += stock_PriceChanged;
stock.Price = 31.59M;

static void stock_PriceChanged
  (object sender, PriceChangedEventArgs e)
{
  if ((e.NewPrice - e.LastPrice) / e.LastPrice &gt; 0.1M)
    Console.WriteLine ("Alert, 10% price increase!");
}</pre>
<p>For events that don’t carry additional information, .NET also provides a nongeneric <code>EventHandler</code> delegate. We can demonstrate this by rewriting our <code>Stock</code> class such that the <code>PriceChanged</code> event fires <em>after</em> the price changes. This means that no additional information need be transmitted with the event:</p>
<pre data-type="programlisting">public class Stock
{
  string symbol; decimal price;

  public Stock (string symbol) =&gt; this.symbol = symbol;

  public event <strong>EventHandler</strong> PriceChanged;

<strong>  protected virtual void OnPriceChanged (EventArgs e) =&gt;</strong>
<strong>    PriceChanged?.Invoke (this, e);</strong>
  
  public decimal Price
  {
    get =&gt; price;
    set
    {
      if (price == value) return;
      price = value;
      OnPriceChanged (<strong>EventArgs.Empty</strong>);      
    }  
  }
}</pre>
<p>Note that we also used the <code>EventArgs.Empty</code> property—this saves instantiating an instance of <code>EventArgs</code>.</p>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Event Accessors"><div class="sect2" id="event_accessors">
<h2>Event Accessors</h2>
<p><a contenteditable="false" data-primary="−= operator" data-secondary="custom event accessor" data-type="indexterm" id="id1160"/><a contenteditable="false" data-primary="+= operator" data-secondary="custom event accessor" data-type="indexterm" id="id1161"/><a contenteditable="false" data-primary="accessors, event" data-type="indexterm" id="id1162"/><a contenteditable="false" data-primary="events" data-secondary="event accessors" data-type="indexterm" id="id1163"/><a contenteditable="false" data-primary="implicit conversions" data-secondary="event accessors" data-type="indexterm" id="id1164"/>An event’s <em>accessors</em> are the implementations of its <code>+=</code> and <code>-=</code> functions. By default, accessors are implemented implicitly by the compiler. Consider this event declaration:</p>
<pre data-type="programlisting">public event EventHandler PriceChanged;</pre>
<p>The compiler converts this to the following:</p>
<ul>
<li><p>A private delegate field</p></li>
<li><p>A public pair of event accessor functions, whose implementations forward the <code>+=</code> and <code>-=</code> operations to the private delegate field</p></li>
</ul>
<p>You can take over this process by defining <em>explicit</em> event accessors. Here’s a manual implementation of the <code>PriceChanged</code> event from our previous example:</p>
<pre data-type="programlisting">EventHandler priceChanged;   // Private delegate
public event EventHandler PriceChanged
{
<strong>  add    { priceChanged += value; }</strong>
<strong>  remove { priceChanged -= value; }</strong>
}</pre>
<p>This example is functionally identical to C#’s default accessor implementation (except that C# also ensures thread safety around updating the delegate). By defining event accessors ourselves, we instruct C# not to generate default field and accessor logic.</p>
<p>With explicit event accessors, you can apply more complex strategies to the storage and access of the underlying delegate. This is useful when the event accessors are merely relays for another class that is broadcasting the event, or when explicitly implementing an interface that declares an event:<a contenteditable="false" data-primary="" data-startref="ch1001.html33" data-type="indexterm" id="id1165"/></p>
<pre data-type="programlisting">public interface IFoo { event EventHandler Ev; }
class Foo : IFoo
{
  EventHandler ev;
  event EventHandler IFoo.Ev
  {
    add { ev += value; } remove { ev -= value; }
  }
}</pre>
</div></section>
</div></section>
<section data-type="sect1" data-pdf-bookmark="Lambda Expressions"><div class="sect1" id="lambda_expressions">
<h1>Lambda Expressions</h1>
<p><a contenteditable="false" data-primary="lambda expressions" data-secondary="basics of" data-type="indexterm" id="id1166"/><a contenteditable="false" data-primary="lambda expressions" data-type="indexterm" id="ch1001.html34"/>A <em>lambda expression</em> is an unnamed method written in place of a delegate instance. The compiler immediately converts the lambda expression to either of the following:</p>
<ul>
<li><p>A delegate instance.</p></li>
<li><p><a contenteditable="false" data-primary="expression trees" data-type="indexterm" id="id1167"/>An <em>expression tree</em>, of type <code>Expression&lt;TDelegate&gt;</code>, representing the code inside the lambda expression in a traversable object model. This allows the lambda expression to be interpreted later at runtime (we describe the process in Chapter 8 of <em>C# 12 in a Nutshell</em>).</p></li>
</ul>
<p class="pagebreak-before"><a contenteditable="false" data-primary="=&gt; (fat arrow) notation" data-secondary="lambda expressions" data-type="indexterm" id="id1168"/><a contenteditable="false" data-primary="fat arrow (=&gt;) notation" data-secondary="lambda expressions" data-type="indexterm" id="id1169"/>In the following example, <code>x =&gt; x * x</code> is a lambda expression:</p>
<pre data-type="programlisting">Transformer sqr = <strong>x =&gt; x * x</strong>;
Console.WriteLine (sqr(3));    // 9

delegate int Transformer (int i);</pre>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Internally, the compiler resolves lambda expressions of this type by writing a private method and moving the expression’s code into that method.</p>
</div>
<p><a contenteditable="false" data-primary="( ) (parentheses)" data-secondary="in lambda expressions" data-type="indexterm" id="id1170"/><a contenteditable="false" data-primary="parentheses ( )" data-secondary="in lambda expressions" data-type="indexterm" id="id1171"/>A lambda expression has the following form:</p>
<pre data-type="programlisting">(<em>parameters</em>) =&gt; <em>expression-or-statement-block</em></pre>
<p>For convenience, you can omit the parentheses if and only if there is exactly one parameter of an inferable type.</p>
<p>In our example, there is a single parameter, <code>x</code>, and the expression is <code>x * x</code>:</p>
<pre data-type="programlisting">x =&gt; x * x;</pre>
<p>Each parameter of the lambda expression corresponds to a delegate parameter, and the type of the expression (which can be <code>void</code>) corresponds to the return type of the delegate.</p>
<p>In our example, <code>x</code> corresponds to parameter <code>i</code>, and the expression <code>x * x</code> corresponds to the return type <code>int</code>, therefore making it compatible with the <code>Transformer</code> delegate.</p>
<p><a contenteditable="false" data-primary="statements" data-secondary="statement blocks" data-type="indexterm" id="id1172"/>A lambda expression’s code can be a <em>statement block</em> instead of an expression. We can rewrite our example as follows:</p>
<pre data-type="programlisting">x =&gt; { return x * x; };</pre>
<p>Lambda expressions are used most commonly with the <code>Func</code> and <code>Action</code> delegates, so you will most often see our earlier expression written as follows:</p>
<pre data-type="programlisting">Func&lt;int,int&gt; sqr = x =&gt; x * x;</pre>
<p>The compiler can usually <em>infer</em> the type of lambda parameters contextually. When this is not the case, you can specify parameter types explicitly:</p>
<pre data-type="programlisting">Func&lt;int,int&gt; sqr = (<strong>int</strong> x) =&gt; x * x;</pre>
<p>Here’s an example of an expression that accepts two <span class="keep-together">parameters</span>:</p>
<pre data-type="programlisting">Func&lt;string,string,int&gt; totalLength = 
 (s1, s2) =&gt; s1.Length + s2.Length;

int total = totalLength ("hello", "world");  // total=10;</pre>
<p>Assuming <code>Clicked</code> is an event of type <code>EventHandler</code>, the following attaches an event handler via a lambda expression:<a contenteditable="false" data-primary="" data-startref="ch1001.html34" data-type="indexterm" id="id1173"/></p>
<pre data-type="programlisting">obj.Clicked += (sender,args) =&gt; Console.Write ("Click");</pre>
<p>Here’s an example of an expression that takes zero arguments:</p>
<pre data-type="programlisting">Func&lt;string&gt; greeter = () =&gt; "Hello, world";</pre>
<p>From C# 10, the compiler permits implicit typing with lambda expressions that can be resolved via the <code>Func</code> and <code>Action</code> delegates, so we can shorten this statement to:</p>
<pre data-type="programlisting"><strong>var</strong> greeter = () =&gt; "Hello, world";</pre>
<p>If the lambda expression has arguments, you must specify their types in order to use <code>var</code>:</p>
<pre data-type="programlisting"><strong>var</strong> sqr = (int x) =&gt; x * x;</pre>
<p>The compiler infers <code>sqr</code> to be of type <code>Func&lt;int,int&gt;</code>.</p>
<section data-type="sect2" data-pdf-bookmark="Default Lambda Parameters (C# 12)"><div class="sect2" id="default_lambda_parameters_left_parenthe">
<h2>Default Lambda Parameters (C# 12)</h2>
<p><a contenteditable="false" data-primary="lambda expressions" data-secondary="default parameters" data-type="indexterm" id="id1174"/><a contenteditable="false" data-primary="optional parameters" data-type="indexterm" id="id1175"/><a contenteditable="false" data-primary="parameters" data-secondary="lambda" data-type="indexterm" id="id1176"/>Just as ordinary methods can have optional parameters:</p>
<pre data-type="programlisting">void Print (string <strong>info = ""</strong>) =&gt; Console.Write (info);</pre>
<p>so, too, can lambda expressions:</p>
<pre data-type="programlisting">var print = (string <strong>info = ""</strong>) =&gt; Console.Write (info);

print ("Hello");
print ();</pre>
<p>This feature is useful with libraries such as ASP.NET Minimal API.</p>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Capturing Outer Variables"><div class="sect2" id="capturing_outer_variables">
<h2>Capturing Outer Variables</h2>
<p><a contenteditable="false" data-primary="lambda expressions" data-secondary="capturing outer variables" data-type="indexterm" id="id1177"/><a contenteditable="false" data-primary="local variables" data-secondary="capturing outer variables" data-type="indexterm" id="id1178"/><a contenteditable="false" data-primary="outer variables" data-type="indexterm" id="id1179"/><a contenteditable="false" data-primary="variables and parameters" data-secondary="capturing outer variables" data-type="indexterm" id="id1180"/>A lambda expression can reference any variables that are accessible where the lambda expression is defined. These are called <em>outer variables</em> and can include local variables, parameters, and fields:</p>
<pre data-type="programlisting">int <strong>factor</strong> = 2;
Func&lt;int, int&gt; multiplier = n =&gt; n * <strong>factor</strong>;
Console.WriteLine (multiplier (3));           // 6</pre>
<p><a contenteditable="false" data-primary="captured variables" data-type="indexterm" id="id1181"/>Outer variables referenced by a lambda expression are called <em>captured variables</em>. <a contenteditable="false" data-primary="closures" data-type="indexterm" id="id1182"/>A lambda expression that captures variables is called a <em>closure</em>. Captured variables are evaluated when the delegate is actually <em>invoked</em>, not when the variables were <span class="keep-together"><em>captured</em></span>:</p>
<pre data-type="programlisting">int factor = 2;
Func&lt;int, int&gt; multiplier = n =&gt; n * factor;
<strong>factor = 10;</strong>
Console.WriteLine (multiplier (3));           // 30</pre>
<p>Lambda expressions can themselves update captured variables:</p>
<pre data-type="programlisting">int seed = 0;
Func&lt;int&gt; natural = () =&gt; seed++;
Console.WriteLine (natural());           // 0
Console.WriteLine (natural());           // 1
Console.WriteLine (seed);                // 2</pre>
<p>Captured variables have their lifetimes extended to that of the delegate. In the following example, the local variable <code>seed</code> would ordinarily disappear from scope when <code>Natural</code> finished executing. But because <code>seed</code> has been <em>captured</em>, its lifetime is extended to that of the capturing delegate, <code>natural</code>:</p>
<pre data-type="programlisting">Func&lt;int&gt; natural = Natural();
Console.WriteLine (natural());      // 0
Console.WriteLine (natural());      // 1

static Func&lt;int&gt; Natural()
{
  int seed = 0;
  return () =&gt; seed++;      // Returns a <em>closure</em>
}</pre>
<p>Variables can also be captured by anonymous methods and local methods. The rules for captured variables, in these cases, are the same.</p>
<section data-type="sect3" data-pdf-bookmark="Static lambdas"><div class="sect3" id="static_lambdas">
<h3>Static lambdas</h3>
<p><a contenteditable="false" data-primary="lambda expressions" data-secondary="static lambdas" data-type="indexterm" id="id1183"/><a contenteditable="false" data-primary="static keyword" data-type="indexterm" id="id1184"/><a contenteditable="false" data-primary="static lambdas" data-type="indexterm" id="id1185"/>From C# 9, you can ensure that a lambda expression, local function, or anonymous method doesn’t capture state by applying the <code>static</code> keyword. This can be useful in micro-optimization scenarios to prevent the (potentially unintentional) memory allocation and cleanup of a closure. For example, we can apply the static modifier to a lambda expression as follows:</p>
<pre data-type="programlisting">Func&lt;int, int&gt; multiplier = <strong>static</strong> n =&gt; n * 2;</pre>
<p>If we later tried to modify the lambda expression such that it captured a local variable, the compiler will generate an error. This feature is more useful in local methods (because a lambda expression itself incurs a memory allocation). In the following example, the <code>Multiply</code> method cannot access the <code>factor</code> <span class="keep-together">variable</span>:</p>
<pre data-type="programlisting">void Foo()
{
  int factor = 123;
<strong>  static</strong> int Multiply (int x) =&gt; x * 2;
}</pre>
<p>Applying <code>static</code> here is also arguably useful as a documentation tool, indicating a reduced level of coupling. Static lambdas can still access static variables and constants (because these do not require a closure).</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>The <code>static</code> keyword acts merely as a <em>check</em>; it has no effect on the IL that the compiler produces. Without the <code>static</code> keyword, the compiler does not generate a closure unless it needs to (and even then, it has tricks to mitigate the cost).</p>
</div>
</div></section>
<section data-type="sect3" data-pdf-bookmark="Capturing iteration variables"><div class="sect3" id="capturing_iteration_variables">
<h3>Capturing iteration variables</h3>
<p><a contenteditable="false" data-primary="iteration variables" data-type="indexterm" id="id1186"/><a contenteditable="false" data-primary="lambda expressions" data-secondary="capturing iteration variables" data-type="indexterm" id="id1187"/><a contenteditable="false" data-primary="variables and parameters" data-secondary="capturing iteration variables" data-type="indexterm" id="id1188"/>When you capture an iteration variable in a <code>for</code> loop, C# treats the iteration variable as though it were declared <em>outside</em> the loop. This means that the <em>same</em> variable is captured in each iteration. The following program writes <code>333</code> instead of <code>012</code>:</p>
<pre data-type="programlisting">Action[] actions = new Action[3];

for (int i = 0; i &lt; 3; i++)
  actions [i] = () =&gt; <strong>Console.Write (i)</strong>;

foreach (Action a in actions) a();     // 333</pre>
<p>Each closure (shown in boldface) captures the same variable, <code>i</code>. (This actually makes sense when you consider that <code>i</code> is a variable whose value persists between loop iterations; you can even explicitly change <code>i</code> within the loop body if you want.) The consequence is that when the delegates are later invoked, each delegate sees <code>i</code>’s value at the time of <em>invocation</em>—which is 3. The solution, if we want to write <code>012</code>, is to assign the iteration variable to a local variable that is scoped <em>within</em> the loop:</p>
<pre data-type="programlisting">Action[] actions = new Action[3];
for (int i = 0; i &lt; 3; i++)
{
  int <strong>loopScopedi = i</strong>;
  actions [i] = () =&gt; Console.Write (<strong>loopScopedi</strong>);
}
foreach (Action a in actions) a();     // 012</pre>
<p>This causes the closure to capture a <em>different</em> variable on each iteration.</p>
<p><a contenteditable="false" data-primary="foreach loops" data-type="indexterm" id="id1189"/>Note that (from C# 5) the iteration variable in a <code>foreach</code> loop is implicitly local, so you can safely close over it without needing a temporary variable.</p>
</div></section>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Lambda Expressions Versus Local Methods"><div class="sect2" id="lambda_expressions_versus_local_methods">
<h2>Lambda Expressions Versus Local Methods</h2>
<p><a contenteditable="false" data-primary="lambda expressions" data-secondary="local methods versus" data-type="indexterm" id="id1190"/><a contenteditable="false" data-primary="local methods" data-secondary="lambda expressions versus" data-type="indexterm" id="id1191"/>The functionality of local methods (see <a data-type="xref" href="#local_methods">“Local methods”</a>) overlaps with that of lambda expressions. Local methods have the advantages of allowing for recursion and avoiding the clutter of specifying a delegate. Avoiding the indirection of a delegate also makes them slightly more efficient, and they can access local variables of the containing method without the compiler having to “hoist” the captured variables into a hidden class.</p>
<p>However, in many cases you <em>need</em> a delegate, most commonly when calling a higher-order function (i.e., a method with a delegate-typed parameter):</p>
<pre data-type="programlisting">public void Foo (<strong>Func&lt;int,bool&gt;</strong> predicate) { ... }</pre>
<p>In such cases, you need a delegate anyway, and it’s precisely in these cases that lambda expressions are usually terser and cleaner.</p>
</div></section>
</div></section>
<section data-type="sect1" data-pdf-bookmark="Anonymous Methods"><div class="sect1" id="anonymous_methods">
<h1>Anonymous Methods</h1>
<p><a contenteditable="false" data-primary="anonymous methods" data-secondary="lambda expressions versus" data-type="indexterm" id="id1192"/><a contenteditable="false" data-primary="lambda expressions" data-secondary="anonymous methods versus" data-type="indexterm" id="id1193"/><a contenteditable="false" data-primary="methods" data-secondary="anonymous" data-type="indexterm" id="id1194"/>Anonymous methods are a C# 2.0 feature that has been mostly subsumed by lambda expressions. An anonymous method is like a lambda expression except that it lacks implicitly typed parameters, expression syntax (an anonymous method must always be a statement block), and the ability to compile to an expression tree. <a contenteditable="false" data-primary="anonymous methods" data-secondary="writing" data-type="indexterm" id="id1195"/>To write an anonymous method, you include the <code>delegate</code> keyword followed (optionally) by a <a contenteditable="false" data-primary="anonymous methods" data-secondary="parameter declarations and" data-type="indexterm" id="id1196"/>parameter declaration and then a method body. For example:</p>
<pre data-type="programlisting">Transformer sqr = <strong>delegate (int x) {return x * x;}</strong>;
Console.WriteLine (sqr(3));         // 9

delegate int Transformer (int i);</pre>
<p>The first line is semantically equivalent to the following lambda expression:</p>
<pre data-type="programlisting">Transformer sqr =       <strong>(int x) =&gt; {return x * x;}</strong>;</pre>
<p>Or simply:</p>
<pre data-type="programlisting">Transformer sqr =            <strong>x  =&gt; x * x</strong>;</pre>
<p>A unique feature of anonymous methods is that you can omit the parameter declaration entirely—even if the delegate expects it. This can be useful in declaring events with a default empty handler:</p>
<pre data-type="programlisting">public event EventHandler Clicked = delegate { };</pre>
<p>This avoids the need for a null check before firing the event. The following is also legal (notice the lack of parameters):</p>
<pre data-type="programlisting">Clicked += delegate { Console.Write ("clicked"); };</pre>
<p>Anonymous methods capture outer variables in the same way lambda expressions do.</p>
</div></section>
<section data-type="sect1" data-pdf-bookmark="try Statements and Exceptions"><div class="sect1" id="try_statements_and_exceptions">
<h1>try Statements and Exceptions</h1>
<p><a contenteditable="false" data-primary="try statements and exceptions" data-secondary="basics of" data-type="indexterm" id="id1197"/>A <a contenteditable="false" data-primary="try statements and exceptions" data-type="indexterm" id="ch1001.html35"/><code>try</code> statement specifies a code block subject to error-handling or cleanup code. <a contenteditable="false" data-primary="catch blocks" data-type="indexterm" id="id1198"/><a contenteditable="false" data-primary="finally blocks" data-type="indexterm" id="id1199"/><a contenteditable="false" data-primary="try blocks" data-type="indexterm" id="id1200"/>The <code>try</code> <em>block</em> must be followed by one or more <code>catch</code> <em>blocks</em> and/or a <code>finally</code> <em>block</em>. The <code>catch</code> block executes when an error is thrown in the <code>try</code> block. The <code>finally</code> block executes after execution leaves the <code>try</code> block (or if present, the <code>catch</code> block) to perform cleanup code, whether or not an exception was thrown.</p>
<p>A <code>catch</code> block has access to an <code>Exception</code> object that contains information about the error. You use a <code>catch</code> block to either compensate for the error or <em>rethrow</em> the exception. You rethrow an exception if you merely want to log the problem, or if you want to rethrow a new, higher-level exception type.</p>
<p>A <code>finally</code> block adds determinism to your program by always executing no matter what. It’s useful for cleanup tasks such as closing network connections.</p>
<p>A <code>try</code> statement looks like this:</p>
<pre data-type="programlisting">try
{
  ... // exception may get thrown within execution of
      // this block
}
catch (ExceptionA ex)
{
  ... // handle exception of type ExceptionA
}
catch (ExceptionB ex)
{
  ... // handle exception of type ExceptionB
}
finally
{
  ... // cleanup code
}</pre>
<p>Consider the following code:</p>
<pre data-type="programlisting">int x = 3, y = 0;
Console.WriteLine (x / y);</pre>
<p>Because <code>y</code> is zero, the runtime throws a <code>DivideByZeroException</code> and our program terminates. We can prevent this by catching the exception as follows:</p>
<pre data-type="programlisting"><strong>try</strong>
<strong>{</strong>
  int x = 3, y = 0;
  Console.WriteLine (x / y);
<strong>}</strong>
<strong>catch (DivideByZeroException)</strong>
<strong>{</strong>
  Console.Write ("y cannot be zero. ");
<strong>}</strong>
// Execution resumes here after exception...</pre>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>This is a simple example to illustrate exception handling. We could deal with this particular scenario better in practice by checking explicitly for the divisor being zero before calling <code>Calc</code>.</p>
<p>Exceptions are relatively expensive to handle, taking hundreds of clock cycles.</p>
</div>
<p>When an exception is thrown within a <code>try</code> statement, the CLR performs a test:</p>
<p><em>Does the</em> <code>try</code><em> statement have any compatible</em> <code>catch</code><em> blocks?</em></p>
<ul>
<li><p>If so, execution jumps to the compatible <code>catch</code> block, followed by the <code>finally</code> block (if present), and then execution continues normally.</p></li>
<li><p>If not, execution jumps directly to the <code>finally</code> block (if present), and then the CLR looks up the call stack for other <code>try</code> blocks and, if found, repeats the test.</p></li>
</ul>
<p>If no function in the call stack takes responsibility for the exception, an error dialog is displayed to the user and the program terminates.</p>
<section data-type="sect2" data-pdf-bookmark="The catch Clause"><div class="sect2" id="the_catch_clause">
<h2>The catch Clause</h2>
<p><a contenteditable="false" data-primary="catch clause" data-type="indexterm" id="id1201"/><a contenteditable="false" data-primary="try statements and exceptions" data-secondary="catch clause" data-type="indexterm" id="id1202"/>A <code>catch</code> clause specifies what type of exception to catch. <a contenteditable="false" data-primary="System.Exception" data-type="indexterm" id="id1203"/>This must be either <code>System.Exception</code> or a subclass of <code>System.Exception</code>. Catching <code>System.Exception</code> catches all possible errors. This is useful when:</p>
<ul>
<li><p>Your program can potentially recover regardless of the specific exception type.</p></li>
<li><p>You plan to rethrow the exception (perhaps after logging it).</p></li>
<li><p>Your error handler is the last resort, prior to termination of the program.</p></li>
</ul>
<p>More typically, though, you catch <em>specific exception types</em> in order to avoid having to deal with circumstances for which your handler wasn’t designed (e.g., an <code>OutOfMemoryException</code>).</p>
<p>You can handle multiple exception types with multiple <code>catch</code> clauses:</p>
<pre data-type="programlisting">try
{
  DoSomething();
}
catch (IndexOutOfRangeException ex) { ... }
catch (FormatException ex)          { ... }
catch (OverflowException ex)        { ... }</pre>
<p>Only one <code>catch</code> clause executes for a given exception. If you want to include a safety net to catch more general exceptions (such as <code>System.Exception</code>), you must put the more specific handlers <em>first</em>.</p>
<p>You can catch an exception without specifying a variable, if you don’t need to access its properties:</p>
<pre data-type="programlisting">catch (OverflowException)   // no variable
{ ... }</pre>
<p>Furthermore, you can omit both the variable and the type (meaning that all exceptions will be caught):</p>
<pre data-type="programlisting">catch { ... }</pre>
<section data-type="sect3" data-pdf-bookmark="Exception filters"><div class="sect3" id="exception_filters">
<h3>Exception filters</h3>
<p><a contenteditable="false" data-primary="exception filters" data-type="indexterm" id="id1204"/><a contenteditable="false" data-primary="try statements and exceptions" data-secondary="exception filters" data-type="indexterm" id="id1205"/>You can specify an <em>exception filter</em> in a <code>catch</code> clause by adding a <code>when</code> clause:</p>
<pre data-type="programlisting">catch (WebException ex) 
  <strong>when (ex.Status == WebExceptionStatus.Timeout)</strong>
{
  ...
}</pre>
<p>If a <code>WebException</code> is thrown in this example, the Boolean expression following the <code>when</code> keyword is then evaluated. If the result is false, the <code>catch</code> block in question is ignored, and any subsequent <code>catch</code> clauses are considered. With exception filters, it can be meaningful to catch the same exception type again:</p>
<pre data-type="programlisting">catch (WebException ex) when (ex.Status == <strong><em>something</em></strong>)
{ ... }
catch (WebException ex) when (ex.Status == <strong><em>somethingelse</em></strong>)
{ ... }</pre>
<p>The Boolean expression in the <code>when</code> clause can be side-effecting, such as a method that logs the exception for diagnostic purposes.</p>
</div></section>
</div></section>
<section data-type="sect2" data-pdf-bookmark="The finally Block"><div class="sect2" id="the_finally_block">
<h2>The finally Block</h2>
<p><a contenteditable="false" data-primary="finally blocks" data-type="indexterm" id="id1206"/><a contenteditable="false" data-primary="try statements and exceptions" data-secondary="finally blocks" data-type="indexterm" id="id1207"/>A <code>finally</code> block always executes—whether or not an exception is thrown and whether or not the <code>try</code> block runs to completion. <code>finally</code> blocks are typically used for cleanup code.</p>
<p>A <code>finally</code> block executes either:</p>
<ul>
<li><p>After a <code>catch</code> block finishes</p></li>
<li><p>After control leaves the <code>try</code> block because of a <code>jump</code> statement (e.g., <code>return</code> or <code>goto</code>)</p></li>
<li><p>After the <code>try</code> block ends</p></li>
</ul>
<p>A <code>finally</code> block helps add determinism to a program. In the following example, the file that we open <em>always</em> gets closed, regardless of whether:</p>
<ul>
<li><p>The <code>try</code> block finishes normally.</p></li>
<li><p>Execution returns early because the file is empty (<code>EndOfStream</code>).</p></li>
<li><p>An <code>IOException</code> is thrown while the file is being read.</p></li>
</ul>

<pre class="pagebreak-before" data-type="programlisting">static void ReadFile()
{
  StreamReader reader = null;  // In System.IO namespace
  try
  {
    reader = File.OpenText ("file.txt");
    if (reader.EndOfStream) <strong>return</strong>;
    Console.WriteLine (reader.ReadToEnd());
  }
  finally
  {
    if (reader != null) reader.Dispose();
  }
}</pre>
<p>In this example, we closed the file by calling <code>Dispose</code> on the <code>StreamReader</code>. Calling <code>Dispose</code> on an object, within a <code>finally</code> block, is a standard convention throughout .NET and is supported explicitly in C# through the <code>using</code> statement.</p>
<section data-type="sect3" data-pdf-bookmark="The using statement"><div class="sect3" id="the_using_statement">
<h3>The using statement</h3>
<p><a contenteditable="false" data-primary="try statements and exceptions" data-secondary="using statement" data-type="indexterm" id="id1208"/><a contenteditable="false" data-primary="using statement" data-type="indexterm" id="id1209"/>Many classes encapsulate unmanaged resources such as file handles, graphics handles, or database connections. These classes implement <code>System.IDisposable</code>, which defines a single parameterless method named <code>Dispose</code> to clean up these resources. The <code>using</code> statement provides an elegant syntax for calling <code>Dispose</code> on an <code>IDisposable</code> object within a <code>finally</code> block.</p>
<p>The following:</p>
<pre data-type="programlisting"><strong>using</strong> (StreamReader reader = File.OpenText ("file.txt"))
{
  ...
}</pre>
<p>is precisely equivalent to:</p>
<pre data-type="programlisting">{
  StreamReader reader = File.OpenText ("file.txt");
  try
  {
    ...
  }
  finally
  {
    if (reader != null) ((IDisposable)reader).Dispose();
  }
}</pre>
</div></section>
<section data-type="sect3" data-pdf-bookmark="using declarations"><div class="sect3" id="using_declarations">
<h3>using declarations</h3>
<p><a contenteditable="false" data-primary="try statements and exceptions" data-secondary="using declarations" data-type="indexterm" id="id1210"/><a contenteditable="false" data-primary="using declarations" data-type="indexterm" id="id1211"/>If you omit the brackets and statement block following a <code>using</code> statement, it becomes a <em>using declaration</em> (C# 8+). The resource is then disposed when execution falls outside the <em>enclosing</em> statement block:</p>
<pre data-type="programlisting">if (File.Exists ("file.txt"))
<strong>{</strong>
<strong>  using var reader = File.OpenText ("file.txt"); </strong> 
  Console.WriteLine (reader.ReadLine());
  ...
<strong>}</strong></pre>
<p>In this case, <code>reader</code> will be disposed when execution falls outside the <code>if</code> statement block.</p>
</div></section>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Throwing Exceptions"><div class="sect2" id="throwing_exceptions">
<h2>Throwing Exceptions</h2>
<p><a contenteditable="false" data-primary="throwing exceptions" data-type="indexterm" id="id1212"/><a contenteditable="false" data-primary="try statements and exceptions" data-secondary="throwing exceptions" data-type="indexterm" id="id1213"/>Exceptions can be thrown either by the runtime or in user code. In this example, <code>Display</code> throws a <code>System.ArgumentNul⁠l​Exception</code>:</p>
<pre data-type="programlisting">static void Display (string name)
{
  if (name == null)
<strong>    throw new ArgumentNullException (nameof (name));</strong>

  Console.WriteLine (name);
}</pre>
<section data-type="sect3" data-pdf-bookmark="throw expressions"><div class="sect3" id="throw_expressions">
<h3>throw expressions</h3>
<p><a contenteditable="false" data-primary="throw expressions" data-type="indexterm" id="id1214"/>From C# 7, <code>throw</code> can appear as an expression in expression-bodied functions:</p>
<pre data-type="programlisting">public string Foo() =&gt; <strong>throw new NotImplementedException()</strong>;</pre>
<p>A <code>throw</code> expression can also appear in a ternary conditional expression:</p>
<pre data-type="programlisting">string ProperCase (string value) =&gt;
  value == null ? <strong>throw new ArgumentException ("value")</strong> :
  value == "" ? "" :
  char.ToUpper (value[0]) + value.Substring (1);</pre>
</div></section>
<section data-type="sect3" data-pdf-bookmark="Rethrowing an exception"><div class="sect3" id="rethrowing_an_exception">
<h3>Rethrowing an exception</h3>
<p><a contenteditable="false" data-primary="rethrowing an exception" data-type="indexterm" id="id1215"/><a contenteditable="false" data-primary="try statements and exceptions" data-secondary="rethrowing exceptions" data-type="indexterm" id="id1216"/>You can capture and rethrow an exception as follows:</p>
<pre data-type="programlisting">try {  ...  }
catch (Exception ex)
{
  // Log error
  ...
<strong>  throw;          // Rethrow same exception</strong>
}</pre>
<p>Rethrowing in this manner lets you log an error without <em>swallowing</em> it. It also lets you back out of handling an exception should circumstances turn out to be outside what you expected.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>If we replaced <code>throw</code> with <code>throw ex</code>, the example would still work, but the <code>StackTrace</code> property of the exception would no longer reflect the original error.</p>
</div>
<p>The other common scenario is to rethrow a more specific or meaningful exception type:</p>
<pre data-type="programlisting">try
{
  ... // parse a date of birth from XML element data
}
catch (FormatException ex)
{
  throw new XmlException ("Invalid date of birth", ex);
}</pre>
<p>When rethrowing a different exception, you can populate the <code>InnerException</code> property with the original exception to aid debugging. Nearly all types of exceptions provide a constructor for this purpose (such as in our example).</p>
</div></section>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Key Properties of System.Exception"><div class="sect2" id="key_properties_of_systemdotexception">
<h2>Key Properties of System.Exception</h2>
<p><a contenteditable="false" data-primary="System.Exception" data-type="indexterm" id="id1217"/><a contenteditable="false" data-primary="try statements and exceptions" data-secondary="System.Exception key properties" data-type="indexterm" id="id1218"/>The most important properties of <code>System.Exception</code> are the following:</p>
<dl>
<dt><code>StackTrace</code></dt>
<dd>A string representing all the methods that are called from the origin of the exception to the <code>catch</code> block.</dd>
<dt><code>Message</code></dt>
<dd>A string with a description of the error.</dd>
<dt><code>InnerException</code></dt>
<dd>The inner exception (if any) that caused the outer exception. This, itself, might have another <code>InnerException</code>.<a contenteditable="false" data-primary="" data-startref="ch1001.html35" data-type="indexterm" id="id1219"/></dd>
</dl>
</div></section>
</div></section>
<section data-type="sect1" data-pdf-bookmark="Enumeration and Iterators"><div class="sect1" id="enumeration_and_iterators">
<h1>Enumeration and Iterators</h1>
<section data-type="sect2" data-pdf-bookmark="Enumeration"><div class="sect2" id="enumeration">
<h2>Enumeration</h2>
<p><a contenteditable="false" data-primary="enumeration and iterators" data-secondary="enumerator basics" data-type="indexterm" id="id1220"/>An <a contenteditable="false" data-primary="enumeration and iterators" data-type="indexterm" id="ch1001.html36"/><em>enumerator</em> is a read-only, forward-only cursor over a <em>sequence of values</em>. C# treats a type as an enumerator if it does any of the following:</p>
<ul>
<li><p>Has a public parameterless method named <code>MoveNext</code> and property called <code>Current</code></p></li>
<li><p>Implements <code>System.Collections.Generic.IEnumerator&lt;T&gt;</code></p></li>
<li><p>Implements <code>System.Collections.IEnumerator</code></p></li>
</ul>
<p>The <code>foreach</code> statement iterates over an <em>enumerable</em> object. An enumerable object is the logical representation of a sequence. It is not itself a cursor but an object that produces cursors over itself. C# treats a type as enumerable if it does any of the following (the check is performed in this order):</p>
<ul>
<li><p>Has a public parameterless method named <code>GetEnumerator</code> that returns an enumerator</p></li>
<li><p>Implements <code>System.Collections.Generic.IEnumerable&lt;T&gt;</code></p></li>
<li><p>Implements <code>System.Collections.IEnumerable</code></p></li>
<li><p>(From C# 9) Can bind to an <em>extension method</em> named <code>GetEnumerator</code> that returns an enumerator (see <a data-type="xref" href="#extension_methods">“Extension Methods”</a>)</p></li>
</ul>
<p>The enumeration pattern is as follows:</p>
<pre data-type="programlisting">class <em>Enumerator</em>   // Typically implements IEnumerator&lt;T&gt;
{
  public <em>IteratorVariableType</em> Current { get {...} }
  public bool MoveNext() {...}
}
class <em>Enumerable</em>   // Typically implements IEnumerable&lt;T&gt;
{
  public <em>Enumerator</em> GetEnumerator() {...}
}</pre>
<p>Here is the high-level way to iterate through the characters in the word <em>beer</em> using a <code>foreach</code> statement:</p>
<pre data-type="programlisting">foreach (char c in "beer") Console.WriteLine (c);</pre>
<p>Here is the low-level way to iterate through the characters in <em>beer</em> without using a <code>foreach</code> statement:</p>
<pre data-type="programlisting">using (var enumerator = "beer".<strong>GetEnumerator()</strong>)
  while (enumerator.<strong>MoveNext()</strong>)
  {
    var element = enumerator.<strong>Current</strong>;
    Console.WriteLine (element);
  }</pre>
<p>If the enumerator implements <code>IDisposable</code>, the <code>foreach</code> statement also acts as a <code>using</code> statement, implicitly disposing the enumerator object.</p>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Collection Initializers and Collection Expressions"><div class="sect2" id="collection_initializers_and_collection">
<h2>Collection Initializers and Collection Expressions</h2>
<p><a contenteditable="false" data-primary="collection initializers" data-type="indexterm" id="id1221"/><a contenteditable="false" data-primary="enumeration and iterators" data-secondary="collection initializers and collection expressions" data-type="indexterm" id="id1222"/><a contenteditable="false" data-primary="initializers" data-secondary="collection" data-type="indexterm" id="id1223"/>You can instantiate and populate an enumerable object in a single step. For example:</p>
<pre data-type="programlisting">using System.Collections.Generic;

List&lt;int&gt; list = new List&lt;int&gt; <strong>{1, 2, 3}</strong>;</pre>
<p><a contenteditable="false" data-primary="collection expressions" data-type="indexterm" id="id1224"/>From C# 12, you can shorten the last line further with a <em>collection expression</em> (note the square brackets):</p>
<pre data-type="programlisting">List&lt;int&gt; list = <strong>[1, 2, 3]</strong>;</pre>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p><a contenteditable="false" data-primary="target typing" data-type="indexterm" id="id1225"/>Collection expressions are <em>target-typed</em>, meaning that the type of <code>[1,2,3]</code> depends on the type to which it’s assigned (in this case, <code>List&lt;int&gt;</code>). In the following example, the target type is an array:</p>
<pre data-type="programlisting">int[] array = [1, 2, 3];</pre>
<p>Target typing means that you can omit the type in other scenarios where the compiler can infer it, such as when calling methods:</p>
<pre data-type="programlisting">Foo ([1, 2, 3]);
void Foo (List&lt;int&gt; numbers) { ... }</pre>
</div>
<p>The compiler translates this into the following:</p>
<pre data-type="programlisting">List&lt;int&gt; list = new List&lt;int&gt;();
list.Add (1); list.Add (2); list.Add (3);</pre>
<p>This requires that the enumerable object implements the <code>System.Collections.IEnumerable</code> interface and that it has an <code>Add</code> method that has the appropriate number of parameters for the call. You can similarly initialize dictionaries (types that implement <code>System.Collections.IDictionary</code>) as follows:</p>
<pre class="pagebreak-before" data-type="programlisting">var dict = new Dictionary&lt;int, string&gt;()
{
  { 5, "five" },
  { 10, "ten" }
};</pre>
<p>Or, more succinctly:</p>
<pre data-type="programlisting">var dict = new Dictionary&lt;int, string&gt;()
{
  [5] = "five",
  [10] = "ten"
};</pre>
<p>The latter is valid not only with dictionaries but with any type for which an indexer exists.</p>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Iterators"><div class="sect2" id="iterators">
<h2>Iterators</h2>
<p><a contenteditable="false" data-primary="enumeration and iterators" data-secondary="iterator basics" data-type="indexterm" id="id1226"/><a contenteditable="false" data-primary="foreach loops" data-type="indexterm" id="id1227"/><a contenteditable="false" data-primary="iterators" data-seealso="enumeration and iterators" data-type="indexterm" id="id1228"/>Whereas a <code>foreach</code> statement is a <em>consumer</em> of an enumerator, an iterator is a <em>producer</em> of an enumerator. In this example, we use an iterator to return a sequence of Fibonacci numbers (for which each number is the sum of the previous two):</p>
<pre data-type="programlisting">foreach (int fib in Fibs (6))
  Console.Write (fib + "  ");

IEnumerable&lt;int&gt; Fibs (int fibCount)
{
  for (int i=0, prevFib=1, curFib=1; i&lt;fibCount; i++)
  {
<strong>    yield return prevFib;</strong>
    int newFib = prevFib+curFib;
    prevFib = curFib;
    curFib = newFib;
  }
}
<em>OUTPUT: 1  1  2  3  5  8</em></pre>
<p>Whereas a <code>return</code> statement expresses, “Here’s the value you asked me to return from this method,” a <code>yield return</code> statement expresses, “Here’s the next element you asked me to yield from this enumerator.” On each <code>yield</code> statement, control is returned to the caller, but the callee’s state is maintained so that the method can continue executing as soon as the caller enumerates the next element. The lifetime of this state is bound to the enumerator, such that the state can be released when the caller has finished enumerating.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>The compiler converts iterator methods into private classes that implement <code>IEnumerable&lt;T&gt;</code> and/or <code>IEnumerator&lt;T&gt;</code>. The logic within the iterator block is “inverted” and spliced into the <code>MoveNext</code> method and the <code>Current</code> property on the compiler-written enumerator class, which effectively becomes a state machine. This means that when you call an iterator method, all you’re doing is instantiating the compiler-written class; none of your code actually runs! Your code runs only when you start enumerating over the resultant sequence, typically with a <code>foreach</code> statement.</p>
</div>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Iterator Semantics"><div class="sect2" id="iterator_semantics">
<h2>Iterator Semantics</h2>
<p><a contenteditable="false" data-primary="enumeration and iterators" data-secondary="iterator semantics" data-type="indexterm" id="id1229"/>An iterator is a method, property, or indexer that contains one or more <code>yield</code> statements. An iterator must return one of the following four interfaces (otherwise, the compiler will generate an error):</p>
<pre data-type="programlisting">System.Collections.IEnumerable
System.Collections.IEnumerator
System.Collections.Generic.IEnumerable&lt;T&gt;
System.Collections.Generic.IEnumerator&lt;T&gt;</pre>
<p>Iterators that return an <em>enumerator</em> interface tend to be used less often. They’re useful when you’re writing a custom collection class: typically, you name the iterator <code>GetEnumerator</code> and have your class implement <code>IEnumerable&lt;T&gt;</code>.</p>
<p>Iterators that return an <em>enumerable</em> interface are more common—and simpler to use because you don’t need to write a collection class. The compiler, behind the scenes, writes a private class implementing <code>IEnumerable&lt;T&gt;</code> (as well as <code>IEnumerator&lt;T&gt;</code>).</p>
<section data-type="sect3" data-pdf-bookmark="Multiple yield statements"><div class="sect3" id="multiple_yield_statements">
<h3>Multiple yield statements</h3>
<p><a contenteditable="false" data-primary="multiple yield statements" data-type="indexterm" id="id1230"/><a contenteditable="false" data-primary="yield statements" data-type="indexterm" id="id1231"/>An iterator can include multiple <code>yield</code> statements:</p>
<pre data-type="programlisting">foreach (string s in Foo())
  Console.Write (s + " ");    // One Two Three

IEnumerable&lt;string&gt; Foo()
{
  <strong>yield return</strong> "One";
  <strong>yield return</strong> "Two";
  <strong>yield return</strong> "Three";
}</pre>
</div></section>
<section data-type="sect3" data-pdf-bookmark="yield break"><div class="sect3" id="yield_break">
<h3>yield break</h3>
<p><a contenteditable="false" data-primary="yield break statements" data-type="indexterm" id="id1232"/>A <code>return</code> statement is illegal in an iterator block; instead, you must use the <code>yield break</code> statement to indicate that the iterator block should exit early, without returning more elements. We can modify <code>Foo</code> as follows to demonstrate:</p>
<pre data-type="programlisting">IEnumerable&lt;string&gt; Foo (bool breakEarly)
{
  yield return "One";
  yield return "Two";
  if (breakEarly) <strong>yield break</strong>;
  yield return "Three";
}</pre>
</div></section>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Composing Sequences"><div class="sect2" id="composing_sequences">
<h2>Composing Sequences</h2>
<p><a contenteditable="false" data-primary="enumeration and iterators" data-secondary="composing sequences" data-type="indexterm" id="id1233"/><a contenteditable="false" data-primary="sequences" data-secondary="composing" data-type="indexterm" id="id1234"/>Iterators are highly composable. We can extend our Fibonacci example by adding the following method to the class:</p>
<pre data-type="programlisting">Enumerable&lt;int&gt; EvenNumbersOnly (
  IEnumerable&lt;int&gt; sequence)
  {
    foreach (int x in sequence)
      if ((x % 2) == 0)
        yield return x;
  }
}</pre>
<p class="pagebreak-before">We can then output even Fibonacci numbers as follows:</p>
<pre data-type="programlisting">foreach (int fib in EvenNumbersOnly (Fibs (6)))
  Console.Write (fib + " ");   // 2 8</pre>
<p>Each element is not calculated until the last moment—when requested by a <code>MoveNext()</code> operation. <a data-type="xref" href="#composing_sequence">Figure 5</a> shows the data requests and data output over time.</p>
<figure><div id="composing_sequence" class="figure">
<img src="Images/c12p_0105.png" alt="Composing sequences" width="817" height="892"/>
<h6><span class="label">Figure 5. </span>Composing sequences</h6>
</div></figure>
<p>The composability of the iterator pattern is essential in building LINQ queries.<a contenteditable="false" data-primary="" data-startref="ch1001.html36" data-type="indexterm" id="id1235"/></p>
</div></section>
</div></section>
<section data-type="sect1" data-pdf-bookmark="Nullable Value Types"><div class="sect1" id="nullable_value_types">
<h1>Nullable Value Types</h1>
<p><a contenteditable="false" data-primary="nullable value types" data-type="indexterm" id="ch1001.html37"/>Reference <a contenteditable="false" data-primary="nullable value types" data-secondary="basics of" data-type="indexterm" id="id1236"/>types can represent a nonexistent value with a null reference. Value types, however, cannot ordinarily represent null values. For example:</p>
<pre data-type="programlisting">string s = null;   // OK - reference type
int i = null;      // Compile error - int cannot be null</pre>
<p>To represent null in a value type, you must use a special construct called a <em>nullable type</em>. <a contenteditable="false" data-primary="? (nullable types) symbol" data-type="indexterm" id="id1237"/><a contenteditable="false" data-primary="nullable types (?) symbol" data-type="indexterm" id="id1238"/>A nullable type is denoted with a value type followed by the <code>?</code> symbol:</p>
<pre data-type="programlisting">int<strong>?</strong> i = null;                     // OK - nullable type
Console.WriteLine (i == null);     // True</pre>
<section data-type="sect2" data-pdf-bookmark="Nullable&lt;T&gt; Struct"><div class="sect2" id="nullableless_thantgreater_than_struct">
<h2>Nullable&lt;T&gt; Struct</h2>
<p><a contenteditable="false" data-primary="nullable value types" data-secondary="Nullable&lt;T&gt; struct" data-type="indexterm" id="id1239"/><a contenteditable="false" data-primary="Nullable&lt;T&gt; struct" data-type="indexterm" id="id1240"/><a contenteditable="false" data-primary="structs" data-secondary="Nullable&lt;T&gt;" data-type="indexterm" id="id1241"/><code>T?</code> translates into <a contenteditable="false" data-primary="System.Nullable&lt;T&gt;" data-type="indexterm" id="id1242"/><code>System.Nullable&lt;T&gt;</code>. <code>Nullable&lt;T&gt;</code> is a lightweight immutable structure, having only two fields, to represent <code>Value</code> and <code>HasValue</code>. The essence of <code>System.Nullable&lt;T&gt;</code> is very simple:</p>
<pre data-type="programlisting">public struct Nullable&lt;T&gt; where T : struct
{
  public T Value {get;}
  public bool HasValue {get;}
  public T GetValueOrDefault();
  public T GetValueOrDefault (T defaultValue);
  ...
}</pre>
<p>The following code:</p>
<pre data-type="programlisting">int? i = null;
Console.WriteLine (i == null);              // True</pre>
<p>translates to:</p>
<pre data-type="programlisting">Nullable&lt;int&gt; i = new Nullable&lt;int&gt;();
Console.WriteLine (! i.HasValue);           // True</pre>
<p>Attempting to retrieve <code>Value</code> when <code>HasValue</code> is false throws an <code>InvalidOperationException</code>. <code>GetValueOrDefault()</code> returns <code>Value</code> if <code>HasValue</code> is true; otherwise, it returns <code>new T()</code> or a specified custom default value.</p>
<p>The default value of <code>T?</code> is <code>null</code>.</p>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Nullable Conversions"><div class="sect2" id="nullable_conversions">
<h2>Nullable Conversions</h2>
<p><a contenteditable="false" data-primary="conversions" data-secondary="nullable" data-type="indexterm" id="id1243"/><a contenteditable="false" data-primary="nullable value types" data-secondary="nullable conversions" data-type="indexterm" id="id1244"/>The conversion from <code>T</code> to <code>T?</code> is implicit, while from <code>T?</code> to <code>T</code> the conversion is explicit. For example:</p>
<pre data-type="programlisting">int? x = 5;        // implicit
int y = (int)x;    // explicit</pre>
<p>The explicit cast is directly equivalent to calling the nullable object’s <code>Value</code> property. Hence, an <code>InvalidOperationException</code> is thrown if <code>HasValue</code> is false.</p>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Boxing/Unboxing Nullable Values"><div class="sect2" id="boxingsolidusunboxing_nullable_values">
<h2>Boxing/Unboxing Nullable Values</h2>
<p><a contenteditable="false" data-primary="boxing" data-secondary="of nullable values" data-type="indexterm" id="id1245"/><a contenteditable="false" data-primary="nullable value types" data-secondary="boxing/unboxing" data-type="indexterm" id="id1246"/><a contenteditable="false" data-primary="unboxing" data-secondary="nullable values" data-type="indexterm" id="id1247"/>When <code>T?</code> is boxed, the boxed value on the heap contains <code>T</code>, not <code>T?</code>. This optimization is possible because a boxed value is a reference type that can already express null.</p>
<p><a contenteditable="false" data-primary="as operator" data-type="indexterm" id="id1248"/>C# also permits the unboxing of nullable types with the <code>as</code> operator. The result will be <code>null</code> if the cast fails:</p>
<pre data-type="programlisting">object o = "string";
int? x = o as int?;
Console.WriteLine (x.HasValue);   // False</pre>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Operator Lifting"><div class="sect2" id="operator_lifting">
<h2>Operator Lifting</h2>
<p><a contenteditable="false" data-primary="expressions and operators" data-secondary="operator lifting" data-type="indexterm" id="id1249"/><a contenteditable="false" data-primary="nullable value types" data-secondary="operator lifting" data-type="indexterm" id="id1250"/><a contenteditable="false" data-primary="operator lifting" data-type="indexterm" id="id1251"/><a contenteditable="false" data-primary="operators" data-secondary="operator lifting" data-type="indexterm" id="id1252"/>The <code>Nullable&lt;T&gt;</code> struct does not define operators such as <code>&lt;</code>, <code>&gt;</code>, or even <code>==</code>. Despite this, the following code compiles and executes correctly:</p>
<pre data-type="programlisting">int? x = 5;
int? y = 10;
bool b = x &lt; y;      // true</pre>
<p>This works because the compiler borrows or “lifts” the less-than operator from the underlying value type. Semantically, it translates the preceding comparison expression into this:</p>
<pre data-type="programlisting">bool b = (x.HasValue &amp;&amp; y.HasValue)
          ? (x.Value &lt; y.Value)
          : false;</pre>
<p>In other words, if both <code>x</code> and <code>y</code> have values, it compares via <code>int</code>’s less-than operator; otherwise, it returns <code>false</code>.</p>
<p>Operator lifting means that you can implicitly use <code>T</code>’s operators on <code>T?</code>. You can define operators for <code>T?</code> in order to provide special-purpose null behavior, but in the vast majority of cases, it’s best to rely on the compiler automatically applying systematic nullable logic for you.</p>
<p>The compiler performs null logic differently depending on the category of operator.</p>
<section data-type="sect3" data-pdf-bookmark="Equality operators (==, !=)"><div class="sect3" id="equality_operators_left_parenthesisequa">
<h3>Equality operators (==, !=)</h3>
<p><a contenteditable="false" data-primary="== (equality comparison) operator" data-secondary="operator lifting and" data-type="indexterm" id="id1253"/><a contenteditable="false" data-primary="!= (inequality) operator" data-type="indexterm" id="id1254"/><a contenteditable="false" data-primary="equality comparison (==) operator" data-secondary="operator lifting and" data-type="indexterm" id="id1255"/><a contenteditable="false" data-primary="inequality (!=) operator" data-type="indexterm" id="id1256"/><a contenteditable="false" data-primary="less-than (&lt;) operator" data-type="indexterm" id="id1257"/><a contenteditable="false" data-primary="relational operators" data-type="indexterm" id="id1258"/>Lifted equality operators handle nulls just like reference types do. This means two null values are equal:</p>
<pre data-type="programlisting">Console.WriteLine (       <strong>null</strong> ==        <strong>null</strong>);  // True
Console.WriteLine ((bool?)<strong>null</strong> == (bool?)<strong>null</strong>);  // True</pre>
<p>Further:</p>
<ul>
<li><p>If exactly one operand is null, the operands are unequal.</p></li>
<li><p>If both operands are non-null, their <code>Value</code>s are compared.</p></li>
</ul>
</div></section>
<section data-type="sect3" data-pdf-bookmark="Relational operators (&lt;, &lt;=, &gt;=, &gt;)"><div class="sect3" id="relational_operators_left_parenthesisle">
<h3>Relational operators (&lt;, &lt;=, &gt;=, &gt;)</h3>
<p><a contenteditable="false" data-primary="&gt;= (greater-than or equal to) operator" data-type="indexterm" id="id1259"/><a contenteditable="false" data-primary="&lt; (less-than) operator" data-type="indexterm" id="id1260"/><a contenteditable="false" data-primary="&lt;= operator" data-type="indexterm" id="id1261"/><a contenteditable="false" data-primary="greater-than or equal to (&gt;=) operator" data-type="indexterm" id="id1262"/>The relational operators work on the principle that it is meaningless to compare null operands. This means that comparing a null value to either a null or a non-null value returns <code>false</code>:</p>
<pre data-type="programlisting">bool b = x &lt; y;    // Translation:

bool b = (x == null || y == null)
  ? false 
  : (x.Value &lt; y.Value);

// b is false (assuming x is 5 and y is null)</pre>
</div></section>
<section data-type="sect3" data-pdf-bookmark="All other operators (+, −, *, /, %, &amp;, |, ^, &lt;&lt;, &gt;&gt;, +, ++, --, !, ~)"><div class="sect3" id="all_other_operators_left_parenthesisplu">
<h3>All other operators (+, −, *, /, %, &amp;, |, ^, &lt;&lt;, &gt;&gt;, +, ++, --, !, ~)</h3>
<p>These operators return null when any of the operands are null. This pattern should be familiar to SQL users:</p>
<pre class="pagebreak-before" data-type="programlisting">int? c = x + y;   // Translation:

int? c = (x == null || y == null)
         ? null 
         : (int?) (x.Value + y.Value);

// c is null (assuming x is 5 and y is null)</pre>
<p>An exception is when the <code>&amp;</code> and <code>|</code> operators are applied to <code>bool?</code>, which we will discuss shortly.</p>
</div></section>
<section data-type="sect3" data-pdf-bookmark="Mixing nullable and non-nullable types"><div class="sect3" id="mixing_nullable_and_non_nullable_types">
<h3>Mixing nullable and non-nullable types</h3>
<p><a contenteditable="false" data-primary="expressions and operators" data-secondary="mixing nullable and non-nullable operators" data-type="indexterm" id="id1263"/><a contenteditable="false" data-primary="nullable value types" data-secondary="mixing nullable and non-nullable operators" data-type="indexterm" id="id1264"/>You can mix and match nullable and non-nullable types (this works because there is an implicit conversion from <code>T</code> to <code>T?</code>):</p>
<pre data-type="programlisting">int? a = null;
int b = 2;
int? c = a + b;   // c is null - equivalent to a + (int?)b</pre>
</div></section>
</div></section>
<section data-type="sect2" data-pdf-bookmark="bool? with &amp; and | Operators"><div class="sect2" id="boolquestion_mark_with_ampersand_and_ve">
<h2>bool? with &amp; and | Operators</h2>
<p><a contenteditable="false" data-primary="&amp; operator" data-type="indexterm" id="id1265"/><a contenteditable="false" data-primary="| (OR operator)" data-type="indexterm" id="id1266"/><a contenteditable="false" data-primary="bool? type" data-type="indexterm" id="id1267"/><a contenteditable="false" data-primary="nullable value types" data-secondary="bool? with &amp; and | operators" data-type="indexterm" id="id1268"/><a contenteditable="false" data-primary="OR operator (|)" data-type="indexterm" id="id1269"/>When supplied operands of type <code>bool?</code>, the <code>&amp;</code> and <code>|</code> operators treat <code>null</code> as an <em>unknown value</em>. So, <code>null | true</code> is true, because:</p>
<ul>
<li><p>If the unknown value is false, the result would be true.</p></li>
<li><p>If the unknown value is true, the result would be true.</p></li>
</ul>
<p>Similarly, <code>null &amp; false</code> is false. This behavior should be familiar to SQL users. The following example enumerates other combinations:</p>
<pre data-type="programlisting">bool? n = null, f = false, t = true;
Console.WriteLine (n | n);    // <em>(null)</em>
Console.WriteLine (n | f);    // <em>(null)</em>
Console.WriteLine (n | t);    // True
Console.WriteLine (n &amp; n);    // <em>(null)</em>
Console.WriteLine (n &amp; f);    // False
Console.WriteLine (n &amp; t);    // <em>(null)</em></pre>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Nullable Types and Null Operators"><div class="sect2" id="nullable_types_and_null_operators">
<h2>Nullable Types and Null Operators</h2>
<p><a contenteditable="false" data-primary="?? (null-coalescing) operator" data-type="indexterm" id="id1270"/><a contenteditable="false" data-primary="null operators" data-type="indexterm" id="id1271"/><a contenteditable="false" data-primary="null-coalescing (??) operator" data-type="indexterm" id="id1272"/><a contenteditable="false" data-primary="nullable value types" data-secondary="nullable types and null operators" data-type="indexterm" id="id1273"/><a contenteditable="false" data-primary="operators" data-secondary="null" data-type="indexterm" id="id1274"/>Nullable types work particularly well with the <code>??</code> operator (see <a data-type="xref" href="#null_coalescing_operator">“Null-Coalescing Operator”</a>). For example:</p>
<pre data-type="programlisting">int? x = null;
int y = x ?? 5;        // y is 5

int? a = null, b = null, c = 123;
Console.WriteLine (a ?? b ?? c);  // 123</pre>
<p>Using <code>??</code> on a nullable value type is equivalent to calling <code>GetValueOrDefault</code> with an explicit default value, except that the expression for the default value is never evaluated if the variable is not null.</p>
<p>Nullable types also work well with the null-conditional operator (see <a data-type="xref" href="#null_conditional_operator">“Null-Conditional Operator”</a>). In the following example, <code>length</code> evaluates to null:</p>
<pre data-type="programlisting">System.Text.StringBuilder sb = null;
int? length = sb<strong>?.</strong>ToString().Length;</pre>
<p>We can combine this with the null-coalescing operator to evaluate to zero instead of null:<a contenteditable="false" data-primary="" data-startref="ch1001.html37" data-type="indexterm" id="id1275"/></p>
<pre data-type="programlisting">int length = sb<strong>?.</strong>ToString().Length ?? 0;</pre>
</div></section>
</div></section>
<section data-type="sect1" data-pdf-bookmark="Nullable Reference Types"><div class="sect1" id="nullable_reference_types">
<h1>Nullable Reference Types</h1>
<p><a contenteditable="false" data-primary="nullable reference types" data-type="indexterm" id="ch1001.html38"/>Whereas <em>nullable value types</em> bring nullability to value types, <em>nullable reference types</em> (from C# 8) do the opposite. <a contenteditable="false" data-primary="non-nullability" data-type="indexterm" id="id1276"/><a contenteditable="false" data-primary="NullReferenceException errors" data-type="indexterm" id="id1277"/>When enabled, they bring (a degree of) <em>non-nullability</em> to reference types, with the purpose of helping to avoid <code>NullReference​Excep⁠tion</code>s.</p>
<p>Nullable reference types introduce a level of safety that’s enforced purely by the compiler in the form of warnings when it detects code that’s at risk of generating a <code>NullReference​Excep⁠tion</code>.</p>
<p>To enable nullable reference types, you must either add the <code>Nullable</code> element to your <em>.csproj</em> project file (if you want to enable it for the entire project):</p>
<pre data-type="programlisting">&lt;Nullable&gt;enable&lt;/Nullable&gt;</pre>
<p>and/or you can use the following directives in your code, in the places where it should take effect:</p>
<pre data-type="programlisting">#nullable enable   // enables NRT from this point on
#nullable disable  // disables NRT from this point on
#nullable restore  // resets NRT to project setting</pre>
<p>After it is enabled, the compiler makes non-nullability the default: if you want a reference type to accept nulls without the compiler generating a warning, you must apply the <code>?</code> suffix to indicate a <em>nullable reference type</em>. In the following example, <code>s1</code> is non-nullable, whereas <code>s2</code> is nullable:</p>
<pre data-type="programlisting">#nullable enable    // Enable nullable reference types

string s1 = null;   // Generates a compiler warning!
<strong>string?</strong> s2 = null;  // OK: s2 is <em>nullable reference type</em></pre>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Because nullable reference types are compile-time constructs, there’s no runtime difference between <code>string</code> and <code>string?</code>. In contrast, nullable value types introduce something concrete into the type system—namely, the <code>Null​a⁠ble&lt;T&gt;</code> struct.</p>
</div>
<p>The following also generates a warning because <code>x</code> is not <span class="keep-together">initialized</span>:</p>
<pre data-type="programlisting">class Foo { string x; }</pre>
<p>The warning disappears if you initialize <code>x</code>, either via a field initializer or via code in the constructor.</p>
<p>The compiler also warns you upon dereferencing a nullable reference type if it thinks a <code>NullReferenceException</code> might occur. In the following example, accessing the string’s <code>Length</code> property generates a warning:</p>
<pre data-type="programlisting">void Foo (<strong>string?</strong> s) =&gt; Console.Write (<strong>s.Length</strong>);</pre>
<p><a contenteditable="false" data-primary="! (null-forgiving operator)" data-type="indexterm" id="id1278"/><a contenteditable="false" data-primary="null-forgiving operator (!)" data-type="indexterm" id="id1279"/>To remove the warning, you can use the <em>null-forgiving operator</em> (<code>!</code>):</p>
<pre data-type="programlisting">void Foo (string? s) =&gt; Console.Write (<strong>s!.Length</strong>);</pre>
<p>Our use of the null-forgiving operator in this example is dangerous in that we could end up throwing the very <code>NullReferen⁠ce​Exception</code> we were trying to avoid in the first place. We could fix it as follows:</p>
<pre data-type="programlisting">void Foo (string? s)
{
  if (s != null) Console.Write (s.Length);
}</pre>
<p>Notice now that we don’t need the null-forgiving operator. This is because the compiler performs static analysis and is smart enough to infer—at least in simple cases—when a dereference is safe and there’s no chance of a <code>NullReferenceException.</code></p>
<p>The compiler’s ability to detect and warn is not bulletproof, and there are also limits to what’s possible in terms of coverage. For instance, it’s unable to know whether an array’s elements have been populated, and so the following does not generate a warning:<a contenteditable="false" data-primary="" data-startref="ch1001.html38" data-type="indexterm" id="id1280"/></p>
<pre data-type="programlisting">var strings = new string[10];
Console.WriteLine (strings[0].Length);</pre>
</div></section>
<section data-type="sect1" data-pdf-bookmark="Extension Methods"><div class="sect1" id="extension_methods">
<h1>Extension Methods</h1>
<p><a contenteditable="false" data-primary="extension methods" data-secondary="basics of" data-type="indexterm" id="id1281"/><a contenteditable="false" data-primary="methods" data-secondary="extension methods" data-type="indexterm" id="id1282"/><em>Extension methods</em> allow an existing type to be extended with new methods without altering the definition of the original type. <a contenteditable="false" data-primary="this modifier" data-type="indexterm" id="id1283"/>An extension method is a static method of a static class, where the <code>this</code> modifier is applied to the first parameter. The type of the first parameter will be the type that is extended. For example:</p>
<pre data-type="programlisting">public static class StringHelper
{
  public static bool IsCapitalized (this string s)
  {
    if (string.IsNullOrEmpty (s)) return false;
    return char.IsUpper (s[0]);
  }
}</pre>
<p>The <code>IsCapitalized</code> extension method can be called as though it were an instance method on a string, as follows:</p>
<pre data-type="programlisting">Console.Write ("Perth".IsCapitalized());</pre>
<p>An extension method call, when compiled, is translated back into an ordinary static method call:</p>
<pre data-type="programlisting">Console.Write (StringHelper.IsCapitalized ("Perth"));</pre>
<p>Interfaces can be extended, too:</p>
<pre data-type="programlisting">public static T First&lt;T&gt; (this <strong>IEnumerable&lt;T&gt;</strong> sequence)
{
  foreach (T element in sequence)
    return element;
  throw new InvalidOperationException ("No elements!");
}
...
Console.WriteLine ("Seattle".First());   // S</pre>
<section data-type="sect2" data-pdf-bookmark="Extension Method Chaining"><div class="sect2" id="extension_method_chaining">
<h2>Extension Method Chaining</h2>
<p><a contenteditable="false" data-primary="extension methods" data-secondary="extension method chaining" data-type="indexterm" id="id1284"/><a contenteditable="false" data-primary="method chaining" data-type="indexterm" id="id1285"/>Extension methods, like instance methods, provide a tidy way to chain functions. Consider the following two functions:</p>
<pre data-type="programlisting">public static class StringHelper
{
  public static string Pluralize (this string s) {...}
  public static string Capitalize (this string s) {...}
}</pre>
<p><code>x</code> and <code>y</code> are equivalent, and both evaluate to <code>"Sausages"</code>, but <code>x</code> uses extension methods, whereas <code>y</code> uses static methods:</p>
<pre data-type="programlisting">string x = "sausage".Pluralize().Capitalize();

string y = StringHelper.Capitalize
           (StringHelper.Pluralize ("sausage"));</pre>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Ambiguity and Resolution"><div class="sect2" id="ambiguity_and_resolution">
<h2>Ambiguity and Resolution</h2>
<p><a contenteditable="false" data-primary="extension methods" data-secondary="ambiguity and resolution" data-type="indexterm" id="id1286"/><a contenteditable="false" data-primary="extension methods" data-secondary="instance methods versus" data-type="indexterm" id="id1287"/><a contenteditable="false" data-primary="instance methods" data-type="indexterm" id="id1288"/>Any compatible instance method will always take precedence over an extension method—even when the extension method’s parameters are more specifically type-matched.</p>
<p>If two extension methods have the same signature, the extension method must be called as an ordinary static method to disambiguate the method to call. If one extension method has more specific arguments, however, the more specific method takes precedence.</p>
</div></section>
</div></section>
<section data-type="sect1" data-pdf-bookmark="Anonymous Types"><div class="sect1" id="anonymous_types">
<h1>Anonymous Types</h1>
<p><a contenteditable="false" data-primary="anonymous types" data-type="indexterm" id="id1289"/><a contenteditable="false" data-primary="types" data-secondary="anonymous" data-type="indexterm" id="id1290"/>An <em>anonymous type</em> is a simple class created on the fly to store a set of values. <a contenteditable="false" data-primary="new keyword" data-type="indexterm" id="id1291"/>To create an anonymous type, you use the <code>new</code> keyword followed by an object initializer, specifying the properties and values the type will contain. For example:</p>
<pre data-type="programlisting">var dude = new { Name = "Bob", Age = 1 };</pre>
<p>The compiler resolves this by writing a private nested type with read-only properties for <code>Name</code> (type <code>string</code>) and <code>Age</code> (type <code>int</code>). You must use the <code>var</code> keyword to reference an anonymous type, because the type’s name is compiler-generated.</p>
<p>The property name of an anonymous type can be inferred from an expression that is itself an identifier; consider, for example:</p>
<pre data-type="programlisting">int <strong>Age</strong> = 1;
var dude = new { Name = "Bob", <strong>Age</strong> };</pre>
<p>This is equivalent to:</p>
<pre data-type="programlisting">var dude = new { Name = "Bob", <strong>Age = Age</strong> };</pre>
<p>You can create arrays of anonymous types as follows:</p>
<pre data-type="programlisting">var dudes = new[]
{
  new { Name = "Bob", Age = 30 },
  new { Name = "Mary", Age = 40 }
};</pre>
<p>Anonymous types are used primarily when you’re writing LINQ queries.</p>
<p>Anonymous types are immutable, so instances cannot be modified after creation. <a contenteditable="false" data-primary="with keyword" data-type="indexterm" id="id1292"/>However, from C# 10, you can use the <code>with</code> keyword to create a copy with variations, as you would with records. See <a data-type="xref" href="#nondestructive_mutation">“Nondestructive Mutation”</a> for an example.</p>
</div></section>
<section data-type="sect1" data-pdf-bookmark="Tuples"><div class="sect1" id="tuples">
<h1>Tuples</h1>
<p><a contenteditable="false" data-primary="tuples" data-secondary="purpose of" data-type="indexterm" id="id1293"/>Like <a contenteditable="false" data-primary="tuples" data-type="indexterm" id="ch1001.html39"/>anonymous types, <em>tuples</em> (C# 7+) provide a simple way to store a set of values. Tuples were introduced into C# with the main purpose of allowing methods to return multiple values without resorting to <code>out</code> parameters (something you cannot do with anonymous types). Since then, however, <em>records</em> have been introduced, offering a concise typed approach that we will describe in the following section.</p>
<p><a contenteditable="false" data-primary="tuples" data-secondary="creating" data-type="indexterm" id="id1294"/>The simplest way to create a <em>tuple literal</em> is to list the desired values in parentheses. This creates a tuple with <em>unnamed</em> <span class="keep-together">elements</span>:</p>
<pre data-type="programlisting">var bob = <strong>("Bob", 23)</strong>;
Console.WriteLine (bob<strong>.Item1</strong>);   // Bob
Console.WriteLine (bob<strong>.Item2</strong>);   // 23</pre>
<p>Unlike with anonymous types, <code>var</code> is optional, and you can specify a <em>tuple type</em> explicitly:</p>
<pre data-type="programlisting"><strong>(string,int)</strong> bob  = ("Bob", 23);</pre>
<p>This means that you can usefully return a tuple from a method:</p>
<pre data-type="programlisting"><strong>(string,int)</strong> person = GetPerson();
Console.WriteLine (person.Item1);    // Bob
Console.WriteLine (person.Item2);    // 23

<strong>(string,int)</strong> GetPerson() =&gt; <strong>("Bob", 23)</strong>;</pre>
<p>Tuples play well with generics, so the following types are all legal:</p>
<pre data-type="programlisting">Task&lt;(string,int)&gt;
Dictionary&lt;(string,int),Uri&gt;
IEnumerable&lt;(int ID, string Name)&gt;   // See below...</pre>
<p>Tuples are <em>value types</em> with <em>mutable</em> (read/write) elements. This means that you can modify <code>Item1</code>, <code>Item2</code>, and so on, after creating a tuple.</p>
<section data-type="sect2" data-pdf-bookmark="Naming Tuple Elements"><div class="sect2" id="naming_tuple_elements">
<h2>Naming Tuple Elements</h2>
<p><a contenteditable="false" data-primary="tuples" data-secondary="naming tuple elements" data-type="indexterm" id="id1295"/>You can optionally give meaningful names to elements when creating tuple literals:</p>
<pre data-type="programlisting">var tuple = (<strong>Name:</strong>"Bob", <strong>Age:</strong>23);
Console.WriteLine (tuple.<strong>Name</strong>);     // Bob
Console.WriteLine (tuple.<strong>Age</strong>);      // 23</pre>
<p>You can do the same when specifying <em>tuple types</em>:</p>
<pre data-type="programlisting">static (string<strong> Name</strong>, int <strong>Age)</strong> GetPerson() =&gt; ("Bob",23);</pre>
<p>Element names are automatically <em>inferred</em> from property or field names:</p>
<pre data-type="programlisting">var now = DateTime.Now;
var tuple = (now.Day, now.Month, now.Year);
Console.WriteLine (tuple.Day);               // OK</pre>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Tuples are syntactic sugar for using a family of generic structs called <code>ValueTuple&lt;T1&gt;</code> and <code>ValueTuple&lt;T1,T2&gt;</code>, which have fields named <code>Item1</code>, <code>Item2</code>, and so on. Hence <code>(string,int)</code> is an alias for <code>ValueTuple&lt;string,int&gt;</code>. This means that “named elements” exist only in the source code—and the imagination of the compiler—and mostly disappear at runtime.</p>
</div>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Deconstructing Tuples"><div class="sect2" id="deconstructing_tuples">
<h2>Deconstructing Tuples</h2>
<p><a contenteditable="false" data-primary="deconstruction, tuple" data-type="indexterm" id="id1296"/><a contenteditable="false" data-primary="tuples" data-secondary="deconstructing" data-type="indexterm" id="id1297"/>Tuples implicitly support the deconstruction pattern (see <a data-type="xref" href="#deconstructors">“Deconstructors”</a>), so you can easily <em>deconstruct</em> a tuple into individual variables. Consider the following:</p>
<pre data-type="programlisting">var bob = ("Bob", 23);
<strong>string name = bob.Item1;</strong>
<strong>int age = bob.Item2;</strong></pre>
<p>With the tuple’s deconstructor, you can simplify the code to this:</p>
<pre data-type="programlisting">var bob = ("Bob", 23);
<strong>(string name, int age) = bob;   // Deconstruct bob into</strong>
<strong>                                // name and age.</strong>
Console.WriteLine (name);
Console.WriteLine (age);</pre>
<p><a contenteditable="false" data-primary="" data-startref="ch1001.html39" data-type="indexterm" id="id1298"/>The syntax for deconstruction is confusingly similar to the syntax for declaring a tuple with named elements! The following highlights the difference:</p>
<pre data-type="programlisting">(string name, int age)      = bob;  // Deconstructing
(string name, int age) bob2 = bob;  // Declaring tuple</pre>
</div></section>
</div></section>
<section data-type="sect1" data-pdf-bookmark="Records"><div class="sect1" id="records">
<h1>Records</h1>
<p><a contenteditable="false" data-primary="records" data-type="indexterm" id="ch1001.html40"/>A <em>record</em> (from C# 9) is a special kind of class or struct that’s designed to work well with immutable (read-only) data. Its most useful feature is allowing <em>nondestructive mutation</em>, whereby to “modify” an immutable object, you create a new one and copy over the data while incorporating your <span class="keep-together">modifications</span>.</p>
<p>Records are also useful in creating types that just combine or hold data. In simple cases, they eliminate boilerplate code while honoring <em>structural equality</em> semantics (two objects are the same if their data is the same), which is usually what you want with immutable types.</p>
<p>A record is purely a C# compile-time construct. At runtime, the CLR sees them just as classes or structs (with a bunch of extra “synthesized” members added by the compiler).</p>
<section data-type="sect2" data-pdf-bookmark="Defining a Record"><div class="sect2" id="defining_a_record">
<h2>Defining a Record</h2>
<p><a contenteditable="false" data-primary="records" data-secondary="defining" data-type="indexterm" id="ch1001.html41"/>A record definition is like a class or struct definition and can contain the same kinds of members, including fields, properties, methods, and so on. Records can implement interfaces, and (class-based) records can subclass other (class-based) records.</p>
<p>By default, the underlying type of a record is a class:</p>
<pre data-type="programlisting">record Point { }          // Point is a class</pre>
<p>From C# 10, the underlying type of a record can also be a struct:</p>
<pre data-type="programlisting">record <strong>struct</strong> Point { }   // Point is a struct</pre>
<p>(<code>record class</code> is also legal and has the same meaning as <code>record</code>.)</p>
<p>A simple record might contain just a bunch of init-only properties, and perhaps a constructor:</p>
<pre data-type="programlisting">record Point
{
  public Point (double x, double y) =&gt; (X, Y) = (x, y);

  public double X { <strong>get; init;</strong> }
  public double Y { <strong>get; init;</strong> }    
}</pre>
<p>Upon compilation, C# transforms the record definition into a class (or struct) and performs the following additional steps:</p>
<ul>
<li><p>It writes a protected <em>copy constructor</em> (and a hidden <em>Clone</em> method) to facilitate nondestructive mutation.</p></li>
<li><p>It overrides/overloads the equality-related functions to implement structural equality.</p></li>
<li><p>It overrides the <code>ToString()</code> method (to expand the record’s public properties, as with anonymous types).</p></li>
</ul>
<p>The preceding record declaration expands into something like this:</p>
<pre data-type="programlisting">class Point
{  
  public Point (double x, double y) =&gt; (X, Y) = (x, y);

  public double X { get; init; }
  public double Y { get; init; }    

<strong>  protected Point (Point original) // “Copy constructor”</strong>
<strong>  {</strong>
<strong>    this.X = original.X; this.Y = original.Y</strong>
<strong>  }</strong>

  // This method has a strange compiler-generated name:
<strong>  public virtual Point &lt;Clone&gt;$() =&gt; new Point (this);</strong>

<strong>  // Additional code to override Equals, ==, !=,</strong>
<strong>  // GetHashCode, ToString()...</strong>
}</pre>
<section data-type="sect3" data-pdf-bookmark="Parameter lists"><div class="sect3" id="parameter_lists">
<h3>Parameter lists</h3>
<p><a contenteditable="false" data-primary="parameter lists" data-type="indexterm" id="id1299"/>A record definition can be shortened through the use of a <em>parameter list</em>:</p>
<pre data-type="programlisting">record Point <strong>(double X, double Y)</strong>
{
  ...
}</pre>
<p>Parameters can include the <code>in</code> and <code>params</code> modifiers but not <code>out</code> or <code>ref</code>. If a parameter list is specified, the compiler performs the following extra steps:</p>
<ul>
<li><p>It writes an init-only property per parameter (or a writable property, in the case of record structs).</p></li>
<li><p>It writes a <em>primary constructor</em> to populate the properties.</p></li>
<li><p>It writes a deconstructor.</p></li>
</ul>
<p>This means that we can declare our <code>Point</code> record simply as follows:</p>
<pre data-type="programlisting">record Point <strong>(double X, double Y);</strong></pre>
<p>The compiler will end up generating (almost) exactly what we listed in the preceding expansion. A minor difference is that the parameter names in the primary constructor will end up as <code>X</code> and <code>Y</code> instead of <code>x</code> and <code>y</code>:</p>
<pre data-type="programlisting">  public Point (double <strong>X</strong>, double <strong>Y</strong>)
  {
    this.X = X; this.Y = Y;
  }</pre>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Also, due to being a <em>primary constructor</em>, the parameters <code>X</code> and <code>Y</code> become magically available to any field or property initializers in your record. We discuss the subtleties of this later in <a data-type="xref" href="#primary_constructors">“Primary Constructors”</a>.</p>
</div>
<p>Another difference when you define a parameter list is that the compiler also generates a deconstructor:</p>
<pre data-type="programlisting">  public void Deconstruct (out double X, out double Y)
  {
    X = this.X; Y = this.Y;
  }</pre>
<p>Records with parameter lists can be subclassed using the following syntax:</p>
<pre data-type="programlisting">record Point3D (double X, double Y, double Z) 
  <strong>: Point (X, Y)</strong>;</pre>
<p>The compiler then emits a primary constructor as follows:</p>
<pre data-type="programlisting">class Point3D : Point
{
  public double Z { get; init; }

  public Point3D (double X, double Y, double Z)
    <strong>: base (X, Y)</strong>
    =&gt; this.Z = Z;
}</pre>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p><a contenteditable="false" data-primary="" data-startref="ch1001.html41" data-type="indexterm" id="id1300"/>Parameter lists offer a nice shortcut when you need a class that simply groups together a bunch of values (a <em>product type</em> in functional programming), and can also be useful for prototyping. They’re not so helpful when you need to add logic to the <code>init</code> accessors (such as argument <span class="keep-together">validation</span>).</p>
</div>
</div></section>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Nondestructive Mutation"><div class="sect2" id="nondestructive_mutation">
<h2>Nondestructive Mutation</h2>
<p><a contenteditable="false" data-primary="copy constructor" data-type="indexterm" id="id1301"/><a contenteditable="false" data-primary="mutation, nondestructive" data-type="indexterm" id="id1302"/><a contenteditable="false" data-primary="nondestructive mutation" data-type="indexterm" id="id1303"/><a contenteditable="false" data-primary="records" data-secondary="nondestructive mutation" data-type="indexterm" id="id1304"/>The most important step that the compiler performs with all records is to write a <em>copy constructor</em> (and a hidden <em>Clone</em> method). This enables nondestructive mutation via the <code>with</code> keyword:</p>
<pre data-type="programlisting">Point p1 = new Point (3, 3);
Point p2 = p1 <strong>with { Y = 4 }</strong>;
Console.WriteLine (p2);       // Point { X = 3, <strong>Y = 4</strong> }

record Point (double X, double Y);</pre>
<p>In this example, <code>p2</code> is a copy of <code>p1</code> but with its <code>Y</code> property set to 4. The benefit is greater when there are more properties.</p>
<p>Nondestructive mutation occurs in two phases:</p>
<ol>
<li><p>First, the <em>copy constructor</em> clones the record. By default, it copies each of the record’s underlying fields, creating a faithful replica while bypassing (the overhead of) any logic in the <code>init</code> accessors. All fields are included (public and private, as well as the hidden fields that back automatic properties).</p></li>
<li><p>Then, each property in the <em>member initializer list</em> is updated (this time using the <code>init</code> accessors).</p></li>
</ol>
<p>The compiler translates the following:</p>
<pre data-type="programlisting">Test t2 = <strong>t1 with { A = 10, C = 30 }</strong>;</pre>
<p>into something functionally equivalent to this:</p>
<pre data-type="programlisting">Test t2 = new Test(t1);  // Clone t1
t2.A = 10;               // Update property A
t2.C = 30;               // Update property C</pre>
<p>(The same code would not compile if you wrote it explicitly because <code>A</code> and <code>C</code> are init-only properties. Furthermore, the copy constructor is <em>protected</em>; C# works around this by invoking it via a public hidden method that it writes into the record called <code>&lt;Clone&gt;$</code>.)</p>
<p>If necessary, you can define your own <em>copy constructor</em>. C# will then use your definition instead of writing one itself:</p>
<pre data-type="programlisting"><strong>protected Point (Point original)</strong>
{
  this.X = original.X; this.Y = original.Y;
}</pre>
<p>When subclassing another record, the copy constructor is responsible for copying only its own fields. To copy the base record’s fields, delegate to the base:</p>
<pre data-type="programlisting">protected Point (Point original) <strong>: base (original)</strong>
{
  ...
}</pre>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Primary Constructors"><div class="sect2" id="primary_constructors">
<h2>Primary Constructors</h2>
<p><a contenteditable="false" data-primary="constructors" data-secondary="primary" data-type="indexterm" id="id1305"/><a contenteditable="false" data-primary="primary constructors" data-type="indexterm" id="id1306"/><a contenteditable="false" data-primary="records" data-secondary="primary constructors" data-type="indexterm" id="id1307"/>When you define a record with a parameter list, the compiler generates property declarations automatically, as well as a <em>primary constructor</em> (and a deconstructor). This works well in simple cases, and in more complex cases you can omit the parameter list and write the property declarations and constructor manually. C# also offers the mildly useful intermediate option of defining a parameter list while writing some or all of the property declarations yourself:</p>
<pre data-type="programlisting">record Student(int ID, string Surname, string FirstName)
{
<strong>  public int ID { get; } = ID;</strong>
}</pre>
<p>In this case, we “took over” the <code>ID</code> property definition, defining it as read-only (instead of init-only), preventing it from partaking in nondestructive mutation. If you never need to nondestructively mutate a particular property, making it read-only lets you cache computed data in the record without having to code up a refresh mechanism.</p>
<p>Notice that we needed to include a <em>property initializer</em> (in <span class="keep-together">boldface</span>):</p>
<pre data-type="programlisting">  public int ID { get; } <strong>= ID</strong>;</pre>
<p>When you “take over” a property declaration, you become responsible for initializing its value; the primary constructor no longer does this automatically. (This exactly matches the behavior when defining primary constructors on classes or structs.) Note that the <code>ID</code> in boldface refers to the <em>primary constructor parameter</em>, not the <code>ID</code> property.</p>
<p>In keeping with the semantics of primary constructors on classes and structs, the primary constructor parameters (<code>ID</code>, <code>Surname</code>, and <code>FirstName</code> in this case) are magically visible to all field and property initializers.</p>
<p>You can also take over a property definition with explicit <span class="keep-together">accessors</span>:</p>
<pre data-type="programlisting">int _id = <strong>ID</strong>;
public int ID { get =&gt; _id; init =&gt; _id = value; }</pre>
<p>Again, the <code>ID</code> in boldface refers to the primary constructor parameter, not the property. (The reason for there not being an ambiguity is that it’s illegal to access properties from <span class="keep-together">initializers</span>.)</p>
<p>The fact that we must initialize the <code>_id</code> property with <code>ID</code> makes this “takeover” less useful, in that any logic in the <code>init</code> accessor (such as validation) will get bypassed by the primary <span class="keep-together">constructor</span>.</p>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Records and Equality Comparison"><div class="sect2" id="records_and_equality_comparison">
<h2>Records and Equality Comparison</h2>
<p><a contenteditable="false" data-primary="records" data-secondary="equality comparison" data-type="indexterm" id="id1308"/>Just as with structs, anonymous types, and tuples, records provide structural equality out of the box, meaning that two records are equal if their fields (and automatic properties) are equal:</p>
<pre data-type="programlisting">var p1 = new Point (1, 2);
var p2 = new Point (1, 2);
Console.WriteLine (p1.Equals (p2));   // True

record Point (double X, double Y);</pre>
<p><a contenteditable="false" data-primary="== (equality comparison) operator" data-secondary="records and" data-type="indexterm" id="id1309"/><a contenteditable="false" data-primary="equality comparison (==) operator" data-secondary="records and" data-type="indexterm" id="id1310"/>The <em>equality operator</em> also works with records (as it does with tuples):</p>
<pre data-type="programlisting">Console.WriteLine (p1 == p2);         // True</pre>
<p>Unlike with classes and structs, you do not (and cannot) override the <code>object.Equals</code> method if you want to customize equality behavior. Instead, you define a public <code>Equals</code> method with the following signature:</p>
<pre data-type="programlisting">record Point (double X, double Y)
{
  <strong>public virtual bool Equals (Point other)</strong> =&gt;
<strong>  </strong>  other != null &amp;&amp; X == other.X &amp;&amp; Y == other.Y;
}</pre>
<p>The <code>Equals</code> method must be <code>virtual</code> (not <code>override</code>), and it must be <em>strongly typed</em> such that it accepts the actual record type (<code>Point</code> in this case, not <code>object</code>). Once you get the signature right, the compiler will automatically patch in your method.</p>
<p>As with any type, if you take over equality comparison, you should also override <code>GetHashCode()</code>. A nice feature of records is that you don’t overload <code>!=</code> or <code>==</code>; nor do you implement <code>IEquatable&lt;T&gt;</code>: this is all done for you. We cover this topic fully in “Equality Comparison” in Chapter 6 of <em>C# 12 in a Nutshell</em>.<a contenteditable="false" data-primary="" data-startref="ch1001.html40" data-type="indexterm" id="id1311"/></p>
</div></section>
</div></section>
<section data-type="sect1" data-pdf-bookmark="Patterns"><div class="sect1" id="patterns">
<h1>Patterns</h1>
<p><a contenteditable="false" data-primary="patterns" data-type="indexterm" id="ch1001.html42"/>Earlier, we demonstrated how to use the <code>is</code> operator to test whether a reference conversion will succeed, and then use its converted value:</p>
<pre data-type="programlisting">if (obj <strong>is string s</strong>)
  Console.WriteLine (s.Length);</pre>
<p>This employs one kind of pattern called a <em>type pattern</em>. The <code>is</code> operator also supports other patterns that were introduced in recent versions of C#. Patterns are supported in the following contexts:</p>
<ul>
<li><p>After the <code>is</code> operator (<code><em>variable</em> is <em>pattern</em></code>)</p></li>
<li><p>In switch statements</p></li>
<li><p>In switch expressions</p></li>
</ul>
<p>We’ve already covered the type pattern in <a data-type="xref" href="#switching_on_types">“Switching on types”</a> and <a data-type="xref" href="#the_is_operator">“The is operator”</a>. In this section, we cover more advanced patterns that were introduced in recent versions of C#.</p>
<p>Some of the more specialized patterns are intended for use in switch statements/expressions. Here, they reduce the need for <code>when</code> clauses and let you use switches where you couldn’t previously.</p>
<section data-type="sect2" data-pdf-bookmark="var Pattern"><div class="sect2" id="var_pattern">
<h2>var Pattern</h2>
<p><a contenteditable="false" data-primary="patterns" data-secondary="var" data-type="indexterm" id="id1312"/><a contenteditable="false" data-primary="var pattern" data-type="indexterm" id="id1313"/>The <em>var pattern</em> is a variation of the <em>type pattern</em> whereby you replace the type name with the <code>var</code> keyword. The conversion always succeeds, so its purpose is merely to let you reuse the variable that follows:</p>
<pre data-type="programlisting">bool IsJanetOrJohn (string name) =&gt; 
  name.ToUpper() is <strong>var upper</strong> &amp;&amp; 
  (<strong>upper</strong> == "JANET" || <strong>upper</strong> == "JOHN");</pre>
<p>This is equivalent to:</p>
<pre data-type="programlisting">bool IsJanetOrJohn (string name)
{
  string upper = name.ToUpper();
  return upper == "JANET" || upper == "JOHN";
}</pre>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Constant Pattern"><div class="sect2" id="constant_pattern">
<h2>Constant Pattern</h2>
<p><a contenteditable="false" data-primary="constant pattern" data-type="indexterm" id="id1314"/><a contenteditable="false" data-primary="patterns" data-secondary="constant" data-type="indexterm" id="id1315"/>The <em>constant pattern</em> lets you match directly to a constant and is useful when working with the <code>object</code> type:</p>
<pre data-type="programlisting">void Foo (object obj) 
{
  if (<strong>obj is 3</strong>) ...
}</pre>
<p>This expression in boldface is equivalent to the following:</p>
<pre data-type="programlisting"><strong>obj is int &amp;&amp; (int)obj == 3</strong></pre>
<p>As we’ll see soon, the constant pattern can become more useful with <em>pattern combinators</em>.</p>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Relational Patterns"><div class="sect2" id="relational_patterns">
<h2>Relational Patterns</h2>
<p><a contenteditable="false" data-primary="patterns" data-secondary="relational" data-type="indexterm" id="id1316"/><a contenteditable="false" data-primary="relational patterns" data-type="indexterm" id="id1317"/>From C# 9, you can use the <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, and <code>&gt;=</code> operators in patterns:</p>
<pre data-type="programlisting">if (x <strong>is &gt; 100</strong>) Console.Write ("x is greater than 100");</pre>
<p>This becomes meaningfully useful in a <code>switch</code>:</p>
<pre data-type="programlisting">string GetWeightCategory (decimal bmi) =&gt; bmi switch
{
  &lt; 18.5m =&gt; "underweight",
  &lt; 25m =&gt; "normal",
  &lt; 30m =&gt; "overweight",
  _ =&gt; "obese"
};</pre>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Pattern Combinators"><div class="sect2" id="pattern_combinators">
<h2>Pattern Combinators</h2>
<p><a contenteditable="false" data-primary="patterns" data-secondary="combinators" data-type="indexterm" id="id1318"/>From C# 9, you can use the <code>and</code>, <code>or</code>, and <code>not</code> keywords to combine patterns:</p>
<pre data-type="programlisting">bool IsJanetOrJohn (string name)
  =&gt; name.ToUpper() is <strong>"JANET" or "JOHN"</strong>;

bool IsVowel (char c) 
  =&gt; c is <strong>'a' or 'e' or 'i' or 'o' or 'u'</strong>;

bool Between1And9 (int n) =&gt; n is <strong>&gt;= 1 and &lt;= 9</strong>;

bool IsLetter (char c) =&gt; c is <strong>&gt;= 'a' and &lt;= 'z'</strong>
                            <strong>or &gt;= 'A' and &lt;= 'Z'</strong>;</pre>
<p>As with the <code>&amp;&amp;</code> and <code>||</code> operators, <code>and</code> has higher precedence than <code>or</code>. You can override this with parentheses. A nice trick is to combine the <code>not</code> combinator with the <em>type pattern</em> to test whether an object is (not) a type:</p>
<pre data-type="programlisting">if (obj is <strong>not string</strong>) ...</pre>
<p>This looks nicer than:</p>
<pre data-type="programlisting">if (!(obj is string)) ...</pre>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Tuple and Positional Patterns"><div class="sect2" id="tuple_and_positional_patterns">
<h2>Tuple and Positional Patterns</h2>
<p><a contenteditable="false" data-primary="patterns" data-secondary="tuple and positional" data-type="indexterm" id="id1319"/><a contenteditable="false" data-primary="positional patterns" data-type="indexterm" id="id1320"/><a contenteditable="false" data-primary="tuple patterns" data-type="indexterm" id="id1321"/>The <em>tuple pattern</em> (introduced in C# 8) matches tuples:</p>
<pre data-type="programlisting">var p = (2, 3);
Console.WriteLine (p <strong>is (2, 3)</strong>);   // True</pre>
<p>The tuple pattern can be considered a special case of the <em>positional pattern</em> (C# 8+), which matches any type that exposes a <code>Deconstruct</code> method (see <a data-type="xref" href="#deconstructors">“Deconstructors”</a>). In the following example, we leverage the <code>Point</code> record’s compiler-generated deconstructor:</p>
<pre data-type="programlisting">var p = new Point (2, 2);
Console.WriteLine (<strong>p is (2, 2)</strong>);  // True

record Point (int X, int Y);</pre>
<p>You can deconstruct as you match, using the following syntax:</p>
<pre data-type="programlisting">Console.WriteLine (p is <strong>(var x, var y) &amp;&amp; x == y</strong>);</pre>
<p>Here’s a switch expression that combines a type pattern with a positional pattern:</p>
<pre data-type="programlisting">string Print (object obj) =&gt; obj switch 
{
  Point <strong>(0, 0)</strong>                      =&gt; "Empty point",
  Point <strong>(var x, var y)</strong> when x == y  =&gt; "Diagonal"
  ...
};</pre>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Property Patterns"><div class="sect2" id="property_patterns">
<h2>Property Patterns</h2>
<p><a contenteditable="false" data-primary="patterns" data-secondary="property" data-type="indexterm" id="id1322"/><a contenteditable="false" data-primary="property patterns" data-type="indexterm" id="id1323"/>A <em>property pattern</em> (C# 8+) matches on one or more of an object’s property values:</p>
<pre data-type="programlisting">if (obj is <strong>string { Length:4 }</strong>) ...</pre>
<p>However, this doesn’t save much over the following:</p>
<pre data-type="programlisting">if (obj is string s &amp;&amp; s.Length == 4) ...</pre>
<p>With switch statements and expressions, property patterns are more useful. Consider the <code>System.Uri</code> class, which represents a URI. It has properties that include <code>Scheme</code>, <code>Host</code>, <code>Port</code>, and <code>IsLoopback</code>. In writing a firewall, we could decide whether to allow or block a URI by employing a switch expression that uses property patterns:</p>
<pre data-type="programlisting">bool ShouldAllow (Uri uri) =&gt; uri switch
{
  <strong>{ Scheme: "http",  Port: 80  }</strong> =&gt; true,
  <strong>{ Scheme: "https", Port: 443 }</strong> =&gt; true,
  <strong>{ Scheme: "ftp",   Port: 21  }</strong> =&gt; true,
  <strong>{ IsLoopback: true           }</strong> =&gt; true,
  _ =&gt; false
};</pre>
<p>You can nest properties, making the following clause legal:</p>
<pre data-type="programlisting">  { Scheme: <strong>{ Length: 4 }</strong>, Port: 80 } =&gt; true,</pre>
<p>which, from C# 10, can be simplified to:</p>
<pre data-type="programlisting">  { <strong>Scheme.Length: 4</strong>, Port: 80 } =&gt; true,</pre>
<p>You can use other patterns inside property patterns, including the relational pattern:</p>
<pre data-type="programlisting">  { Host: { <strong>Length: &lt; 1000</strong> }, <strong>Port: &gt; 0</strong> } =&gt; true,</pre>
<p>You can introduce a variable at the end of a clause and then consume that variable in a <code>when</code> clause:</p>
<pre data-type="programlisting">  { Scheme: "http", Port: 80 } httpUri 
      <strong>when</strong> httpUri.Host.Length &lt; 1000 =&gt; true,</pre>
<p>You can also introduce variables at the <em>property</em> level:</p>
<pre data-type="programlisting">  { Scheme: "http", Port: 80, Host: <strong>var host</strong> }
      when host.Length &lt; 1000 =&gt; true,</pre>
<p>In this case, however, the following is shorter and simpler:</p>
<pre data-type="programlisting">  { Scheme: "http", Port: 80, <strong>Host: { Length: &lt; 1000 }</strong> }</pre>
</div></section>
<section data-type="sect2" data-pdf-bookmark="List Patterns"><div class="sect2" id="list_patterns">
<h2>List Patterns</h2>
<p><a contenteditable="false" data-primary="list patterns" data-type="indexterm" id="id1324"/><a contenteditable="false" data-primary="patterns" data-secondary="list" data-type="indexterm" id="id1325"/>List patterns (from C# 11) work with any collection type that is countable (with a <code>Count</code> or <code>Length</code> property) and indexable (with an indexer of type <code>int</code> or <code>System.Index</code>).</p>
<p><a contenteditable="false" data-primary="[ ] (square brackets)" data-type="indexterm" id="id1326"/><a contenteditable="false" data-primary="square brackets ([ ])" data-type="indexterm" id="id1327"/>A list pattern matches a series of elements in square brackets:</p>
<pre data-type="programlisting">int[] numbers = { 0, 1, 2, 3, 4 };
Console.Write (numbers is<strong> [0, 1, 2, 3, 4]</strong>);   // True</pre>
<p>An underscore matches a single element of any value:</p>
<pre data-type="programlisting">Console.Write (numbers is<strong> [0, 1, _, _, 4]</strong>);   // True</pre>
<p>The <code>var</code> pattern also works in matching a single element:</p>
<pre data-type="programlisting">Console.Write (numbers is [0, 1, <strong>var x</strong>, 3, 4] <strong>&amp;&amp; x &gt; 1</strong>);</pre>
<p><a contenteditable="false" data-primary="slice" data-type="indexterm" id="id1328"/>Two dots indicate a <em>slice</em>. A slice matches zero or more elements:</p>
<pre data-type="programlisting">Console.Write (numbers is <strong>[0, .., 4]</strong>);    // True</pre>
<p>With arrays and other types that support indices and ranges (see <a data-type="xref" href="#indices_and_ranges">“Indices and Ranges”</a>), you can follow a slice with a <code>var</code> pattern:</p>
<pre data-type="programlisting">Console.Write (numbers is [0, <strong>.. var mid</strong>, 4]
               &amp;&amp; <strong>mid.Contains (2)</strong>);           // True</pre>
<p>A list pattern can include at most one slice.<a contenteditable="false" data-primary="" data-startref="ch1001.html42" data-type="indexterm" id="id1329"/></p>
</div></section>
</div></section>
<section data-type="sect1" data-pdf-bookmark="LINQ"><div class="sect1" id="linq">
<h1>LINQ</h1>
<p><a contenteditable="false" data-primary="LINQ (Language Integrated Query)" data-type="indexterm" id="ch1001.html43"/>LINQ, or Language Integrated Query, allows you to write structured type-safe queries over local object collections and remote data sources. LINQ lets you query any collection implementing <code>IEnumerable&lt;&gt;</code>, whether an array, list, XML DOM, or remote data source (such as a table in SQL Server). LINQ offers the benefits of both compile-time type checking and dynamic query composition.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>A good way to experiment with LINQ is to <a href="http://www.linqpad.net">download LINQPad</a>. LINQPad lets you interactively query local collections and SQL databases in LINQ without any setup and is preloaded with numerous examples.</p>
</div>
<section data-type="sect2" data-pdf-bookmark="LINQ Fundamentals"><div class="sect2" id="linq_fundamentals">
<h2>LINQ Fundamentals</h2>
<p><a contenteditable="false" data-primary="elements (LINQ)" data-type="indexterm" id="id1330"/><a contenteditable="false" data-primary="LINQ (Language Integrated Query)" data-secondary="basics of" data-type="indexterm" id="id1331"/><a contenteditable="false" data-primary="sequences" data-secondary="in LINQ" data-type="indexterm" id="id1332"/>The basic units of data in LINQ are <em>sequences</em> and <em>elements</em>. A sequence is any object that implements the generic <code>IEnumerable</code> interface, and an element is each item in the sequence. In the following example, <code>names</code> is a sequence, and <code>Tom</code>, <code>Dick</code>, and <code>Harry</code> are elements:</p>
<pre data-type="programlisting">string[] names = { "Tom", "Dick", "Harry" };</pre>
<p><a contenteditable="false" data-primary="local sequences" data-type="indexterm" id="id1333"/>We call a sequence such as this a <em>local sequence</em> because it represents a local collection of objects in memory.</p>
<p><a contenteditable="false" data-primary="query operators (LINQ)" data-secondary="basics of" data-type="indexterm" id="id1334"/><a contenteditable="false" data-primary="standard query operators (LINQ)" data-type="indexterm" id="id1335"/>A <em>query operator</em> is a method that transforms a sequence. <a contenteditable="false" data-primary="input sequences" data-type="indexterm" id="id1336"/>A typical query operator accepts an <em>input sequence</em> and emits a transformed <em>output sequence</em>. In the <code>Enumerable</code> class in <span class="keep-together"><code>System.Linq</code></span>, there are around 40 query operators, all implemented as static extension methods. These are called <em>standard query operators</em>.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>LINQ also supports sequences that can be dynamically fed from a remote data source such as SQL Server. These sequences additionally implement the <code>IQueryable&lt;&gt;</code> interface and are supported through a matching set of standard query operators in the <code>Queryable</code> class.</p>
</div>
<section data-type="sect3" data-pdf-bookmark="A simple query"><div class="sect3" id="a_simple_query">
<h3>A simple query</h3>
<p><a contenteditable="false" data-primary="LINQ (Language Integrated Query)" data-secondary="simple query using" data-type="indexterm" id="id1337"/>A <em>query</em> is an expression that transforms sequences with one or more query operators. The simplest query comprises one input sequence and one operator. <a contenteditable="false" data-primary="Where operator" data-type="indexterm" id="id1338"/>For instance, we can apply the <code>Where</code> operator on a simple array to extract those names whose length is at least four characters, as follows:</p>
<pre data-type="programlisting">string[] names = { "Tom", "Dick", "Harry" };

<strong>IEnumerable&lt;string&gt; filteredNames =</strong>
<strong>  System.Linq.Enumerable.Where (</strong>
<strong>    names, n =&gt; n.Length &gt;= 4);</strong>

foreach (string n in filteredNames)
  Console.Write (n + "|");            // Dick|Harry|</pre>
<p>Because the standard query operators are implemented as extension methods, we can call <code>Where</code> directly on <code>names</code>, as though it were an instance method:</p>
<pre data-type="programlisting">IEnumerable&lt;string&gt; filteredNames =
  <strong>names.Where</strong> (n =&gt; n.Length &gt;= 4);</pre>
<p>(For this to compile, you must import the <code>System.Linq</code> namespace with a <code>using</code> directive.) The <code>Where</code> method in <span class="keep-together"><code>System.Linq.Enumerable</code></span> has the following signature:</p>
<pre data-type="programlisting">static IEnumerable&lt;TSource&gt; Where&lt;TSource&gt; (
  this IEnumerable&lt;TSource&gt; source,
  Func&lt;TSource,bool&gt; predicate)</pre>
<p><code>source</code> is the <em>input sequence</em>; <code>predicate</code> is a delegate that is invoked on each input <em>element</em>. The <code>Where</code> method includes all elements in the <em>output sequence</em> for which the delegate returns <code>true</code>. Internally, it’s implemented with an iterator—here’s its source code:</p>
<pre data-type="programlisting">foreach (TSource element in source)
  if (predicate (element))
    yield return element;</pre>
</div></section>
<section data-type="sect3" data-pdf-bookmark="Projecting"><div class="sect3" id="projecting">
<h3>Projecting</h3>
<p><a contenteditable="false" data-primary="LINQ (Language Integrated Query)" data-secondary="projecting" data-type="indexterm" id="id1339"/><a contenteditable="false" data-primary="projecting (LINQ)" data-type="indexterm" id="id1340"/><a contenteditable="false" data-primary="Select method" data-type="indexterm" id="id1341"/>Another fundamental query operator is the <code>Select</code> method. This transforms (<em>projects</em>) each element in the input sequence with a given lambda expression:</p>
<pre data-type="programlisting">string[] names = { "Tom", "Dick", "Harry" };

IEnumerable&lt;string&gt; upperNames =
  names.<strong>Select</strong> (n =&gt; <strong>n.ToUpper()</strong>);

foreach (string n in upperNames)
  Console.Write (n + "|");       // TOM|DICK|HARRY|</pre>
<p>A query can project into an anonymous type:</p>
<pre data-type="programlisting">var query = names.Select (n =&gt; new { 
                                     Name = n,
                                     Length = n.Length
                                   });
foreach (var row in query)
  Console.WriteLine (row);</pre>
<p>Here’s the result:</p>
<pre data-type="programlisting">{ Name = Tom, Length = 3 }
{ Name = Dick, Length = 4 }
{ Name = Harry, Length = 5 }</pre>
</div></section>
<section data-type="sect3" data-pdf-bookmark="Take and Skip"><div class="sect3" id="take_and_skip">
<h3>Take and Skip</h3>
<p><a contenteditable="false" data-primary="LINQ (Language Integrated Query)" data-secondary="Take and Skip operators" data-type="indexterm" id="id1342"/>The original ordering of elements within an input sequence is significant in LINQ. Some query operators rely on this behavior, such as <code>Take</code>, <code>Skip</code>, and <code>Reverse</code>. <a contenteditable="false" data-primary="Take operator (LINQ)" data-type="indexterm" id="id1343"/>The <code>Take</code> operator outputs the first <em>x</em> elements, discarding the rest:</p>
<pre data-type="programlisting">int[] numbers  = { 10, 9, 8, 7, 6 };
IEnumerable&lt;int&gt; firstThree = numbers.Take (3);
// firstThree is { 10, 9, 8 }</pre>
<p><a contenteditable="false" data-primary="Skip operator (LINQ)" data-type="indexterm" id="id1344"/>The <code>Skip</code> operator ignores the first <em>x</em> elements and outputs the rest:</p>
<pre data-type="programlisting">IEnumerable&lt;int&gt; lastTwo = numbers.Skip (3);</pre>
<p>From .NET 6, there are also <code>TakeLast</code> and <code>SkipLast</code> methods, which take or skip the last <em>n</em> elements. Additionally, the <code>Take</code> method has been overloaded to accept a <code>Range</code> variable. This overload can subsume the functionality of all four methods; for instance, <code>Take(5..)</code> is equivalent to <code>Skip(5)</code>, and <code>Take(..^5)</code> is equivalent to <code>SkipLast(5)</code>.</p>
</div></section>
<section data-type="sect3" data-pdf-bookmark="Element operators"><div class="sect3" id="element_operators">
<h3>Element operators</h3>
<p><a contenteditable="false" data-primary="element operators (LINQ)" data-type="indexterm" id="id1345"/><a contenteditable="false" data-primary="LINQ (Language Integrated Query)" data-secondary="element operators" data-type="indexterm" id="id1346"/>Not all query operators return a sequence. The <em>element</em> operators extract one element from the input sequence; examples are <code>First</code>, <code>Last</code>, <code>Single</code>, and <code>ElementAt</code>:</p>
<pre data-type="programlisting">int[] numbers    = { 10, 9, 8, 7, 6 };
int firstNumber  = numbers.First();                // 10
int lastNumber   = numbers.Last();                 // 6
int secondNumber = numbers.ElementAt (2);          // 8
int firstOddNum  = numbers.First (n =&gt; n%2 == 1);  // 9</pre>
<p>All of these operators throw an exception if no elements are present. To avoid the exception, use <code>FirstOrDefault</code>, <code>LastOrDefault</code>, <code>SingleOrDefault</code>, or <code>ElementAtOrDefault</code>—these return <code>null</code> (or the <code>default</code> value for value types) when no element is found.</p>
<p>The <code>Single</code> and <code>SingleOrDefault</code> methods are equivalent to <code>First</code> and <code>FirstOrDefault</code> except that they throw an exception if there’s more than one match. This behavior is useful when you’re querying a database table for a row by primary key.</p>
<p>From .NET 6, there are also <code>MinBy</code> and <code>MaxBy</code> methods, which return the element with the lowest or highest value, as determined by a key selector:</p>
<pre data-type="programlisting">string[] names = { "Tom", "Dick", "Harry" };
Console.Write (names.MaxBy (n =&gt; n.Length));  // Harry</pre>
</div></section>
<section data-type="sect3" data-pdf-bookmark="Aggregation operators"><div class="sect3" id="aggregation_operator">
<h3>Aggregation operators</h3>
<p><a contenteditable="false" data-primary="aggregation operators (LINQ)" data-type="indexterm" id="id1347"/><a contenteditable="false" data-primary="LINQ (Language Integrated Query)" data-secondary="aggregation operators" data-type="indexterm" id="id1348"/>The <em>aggregation</em> operators return a scalar value, usually of numeric type. The most commonly used aggregation operators are <code>Count</code>, <code>Min</code>, <code>Max</code>, and <code>Average</code>:</p>
<pre data-type="programlisting">int[] numbers = { 10, 9, 8, 7, 6 };
int count     = numbers.Count();             // 5
int min       = numbers.Min();               // 6
int max       = numbers.Max();               // 10
double avg    = numbers.Average();           // 8</pre>
<p><code>Count</code> accepts an optional predicate, which indicates whether to include a given element. The following counts all even <span class="keep-together">numbers</span>:</p>
<pre data-type="programlisting">int evenNums = numbers.Count (n =&gt; n % 2 == 0);   // 3</pre>
<p>The <code>Min</code>, <code>Max</code>, and <code>Average</code> operators accept an optional argument that transforms each element prior to it being aggregated:</p>
<pre data-type="programlisting">int maxRemainderAfterDivBy5 = numbers.Max
                              (n =&gt; n % 5);       // 4</pre>
<p>The following calculates the root mean square of <code>numbers</code>:</p>
<pre data-type="programlisting">double rms = Math.Sqrt (numbers.Average (n =&gt; n * n));</pre>
</div></section>
<section data-type="sect3" data-pdf-bookmark="Quantifiers"><div class="sect3" id="quantifier">
<h3>Quantifiers</h3>
<p><a contenteditable="false" data-primary="LINQ (Language Integrated Query)" data-secondary="quantifiers" data-type="indexterm" id="id1349"/><a contenteditable="false" data-primary="quantifiers (LINQ)" data-type="indexterm" id="id1350"/>The <em>quantifiers</em> return a <code>bool</code> value. The quantifiers are <code>Contains</code>, <code>Any</code>, <code>All</code>, and <code>SequenceEquals</code> (which compares two sequences):</p>
<pre class="pagebreak-before" data-type="programlisting">int[] numbers = { 10, 9, 8, 7, 6 };

bool hasTheNumberNine = numbers.Contains (9);    // true
bool hasMoreThanZeroElements = numbers.Any();    // true
bool hasOddNum = numbers.Any (n =&gt; n % 2 == 1);  // true
bool allOddNums = numbers.All (n =&gt; n % 2 == 1); // false</pre>
</div></section>
<section data-type="sect3" data-pdf-bookmark="Set operators"><div class="sect3" id="set_operators">
<h3>Set operators</h3>
<p><a contenteditable="false" data-primary="LINQ (Language Integrated Query)" data-secondary="set operators" data-type="indexterm" id="id1351"/><a contenteditable="false" data-primary="set operators (LINQ)" data-type="indexterm" id="id1352"/>The <em>set</em> operators accept two same-typed input sequences. <code>Concat</code> appends one sequence to another; <code>Union</code> does the same but with duplicates removed:</p>
<pre data-type="programlisting">int[] seq1 = { 1, 2, 3 }, seq2 = { 3, 4, 5 };

IEnumerable&lt;int&gt;
  concat = seq1.Concat (seq2),   // { 1, 2, 3, 3, 4, 5 }
  union  = seq1.Union  (seq2),   // { 1, 2, 3, 4, 5 }</pre>
<p>The other two operators in this category are <code>Intersect</code> and <code>Except</code>:</p>
<pre data-type="programlisting">IEnumerable&lt;int&gt;
  commonality = seq1.Intersect (seq2),    //  { 3 }
  difference1 = seq1.Except    (seq2),    //  { 1, 2 }
  difference2 = seq2.Except    (seq1);    //  { 4, 5 }</pre>
<p>From .NET 6, there are also set operators that take a key selector (<code>UnionBy</code>, <code>ExceptBy</code>, <code>IntersectBy</code>). The key selector is used in determining whether an element counts as a duplicate:</p>
<pre data-type="programlisting">string[] seq1 = { "A", "b", "C" };
string[] seq2 = { "a", "B", "c" };
var union = seq1.UnionBy (seq2, x =&gt; x.ToUpper());
// union is { "A", "b", "C" }</pre>
</div></section>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Deferred Execution"><div class="sect2" id="deferred_execution">
<h2>Deferred Execution</h2>
<p><a contenteditable="false" data-primary="deferred execution (LINQ)" data-type="indexterm" id="id1353"/><a contenteditable="false" data-primary="LINQ (Language Integrated Query)" data-secondary="deferred execution" data-type="indexterm" id="id1354"/>An important feature of many query operators is that they execute not when constructed but when <em>enumerated</em> (in other words, when <code>MoveNext</code> is called on its enumerator). Consider the following query:</p>
<pre class="pagebreak-before" data-type="programlisting">var numbers = new List&lt;int&gt; { 1 };

IEnumerable&lt;int&gt; query = numbers.Select (n =&gt; n * 10); 
numbers.Add (2);    // Sneak in an extra element

foreach (int n in query)
  Console.Write (n + "|");          // 10|20|</pre>
<p>The extra number that we sneaked into the list <em>after</em> constructing the query is included in the result because it’s not until the <code>foreach</code> statement runs that any filtering or sorting takes place. <a contenteditable="false" data-primary="lazy evaluation" data-type="indexterm" id="id1355"/>This is called <em>deferred</em> or <em>lazy</em> evaluation. Deferred execution decouples query <em>construction</em> from query <em>execution</em>, allowing you to construct a query in several steps, as well as making it possible to query a database without retrieving all the rows to the client. All standard query operators provide deferred execution, with the following exceptions:</p>
<ul>
<li><p>Operators that return a single element or scalar value (the <em>element operators</em>, <em>aggregation operators</em>, and <em>quantifiers</em>)</p></li>
<li><p>The <em>conversion</em> operators <code>ToArray</code>, <code>ToList</code>, <code>ToDictionary</code>, <code>ToLookup</code>, and <code>ToHashSet</code></p></li>
</ul>
<p>The conversion operators are handy, in part because they defeat lazy evaluation. This can be useful to “freeze” or cache the results at a certain point in time, to avoid re-executing a computationally intensive or remotely sourced query such as an Entity Framework table. (A side effect of lazy evaluation is that the query is reevaluated should you later re-enumerate it.)</p>
<p>The following example illustrates the <code>ToList</code> operator:</p>
<pre data-type="programlisting">var numbers = new List&lt;int&gt;() { 1, 2 };

List&lt;int&gt; timesTen = numbers
  .Select (n =&gt; n * 10) 
<strong>  .ToList();    // Executes immediately into a List&lt;int&gt;</strong>

numbers.Clear();
Console.WriteLine (timesTen.Count);      // Still 2</pre>
<div data-type="warning" epub:type="warning"><h6>Warning</h6>
<p><a contenteditable="false" data-primary="subqueries" data-type="indexterm" id="id1356"/>Subqueries provide another level of indirection. Everything in a subquery is subject to deferred execution, including aggregation and conversion methods, because the subquery is itself executed only lazily upon demand. Assuming <code>names</code> is a string array, a subquery looks like this:</p>
<pre data-type="programlisting">names.Where (
  n =&gt; n.Length ==
<strong>    names.Min (n2 =&gt; n2.Length)</strong>)</pre>
</div>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Standard Query Operators"><div class="sect2" id="standard_query_operators">
<h2>Standard Query Operators</h2>
<p><a contenteditable="false" data-primary="LINQ (Language Integrated Query)" data-secondary="standard query operators" data-type="indexterm" id="id1357"/><a contenteditable="false" data-primary="query operators (LINQ)" data-secondary="standard" data-type="indexterm" id="id1358"/><a contenteditable="false" data-primary="standard query operators (LINQ)" data-type="indexterm" id="id1359"/>We can divide the standard query operators (as implemented in the <code>System.Linq.Enumerable</code> class) into 12 categories, as summarized in <a data-type="xref" href="#query_operator_categories">Table 1</a>.</p>
<table class="border" id="query_operator_categories">
<caption><span class="label">Table 1. </span>Query operator categories</caption>
<thead>
<tr>
<th>Category</th>
<th>Description</th>
<th>Deferred execution?</th>
</tr>
</thead>
<tbody>
<tr>
<td>Filtering</td>
<td>Returns a subset of elements that satisfy a given condition</td>
<td>Yes</td>
</tr>
<tr>
<td>Projecting</td>
<td>Transforms each element with a lambda function, optionally expanding subsequences</td>
<td>Yes</td>
</tr>
<tr>
<td>Joining</td>
<td>Meshes elements of one collection with another, using a time-efficient lookup strategy</td>
<td>Yes</td>
</tr>
<tr>
<td>Ordering</td>
<td>Returns a reordering of a sequence</td>
<td>Yes</td>
</tr>
<tr>
<td>Grouping</td>
<td>Groups a sequence into subsequences</td>
<td>Yes</td>
</tr>
<tr>
<td>Set</td>
<td>Accepts two same-typed sequences and returns their commonality, sum, or difference</td>
<td>Yes</td>
</tr>
<tr>
<td>Element</td>
<td>Picks a single element from a sequence</td>
<td>No</td>
</tr>
<tr>
<td>Aggregation</td>
<td>Performs a computation over a sequence, returning a scalar value (typically a number)</td>
<td>No</td>
</tr>
<tr>
<td>Quantification</td>
<td>Performs a computation over a sequence, returning <code>true</code> or <code>false</code></td>
<td>No</td>
</tr>
<tr>
<td>Conversion: Import</td>
<td>Converts a nongeneric sequence to a (queryable) generic sequence</td>
<td>Yes</td>
</tr>
<tr>
<td>Conversion: Export</td>
<td>Converts a sequence to an array, list, dictionary, or lookup, forcing immediate evaluation</td>
<td>No</td>
</tr>
<tr>
<td>Generation</td>
<td>Manufactures a simple sequence</td>
<td>Yes</td>
</tr>
</tbody>
</table>
<p>Tables <a data-type="xref" data-xrefstyle="select:labelnumber" href="#filtering_operators">2</a> through <a data-type="xref" data-xrefstyle="select:labelnumber" href="#generation_operators">13</a> summarize each query operator. The operators shown in bold have special support in C# (see <a data-type="xref" href="#query_expressions">“Query Expressions”</a>).</p>
<table class="border" id="filtering_operators">
<caption><span class="label">Table 2. </span>Filtering operators</caption>
<thead>
<tr>
<th>Method</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code><strong>Where</strong></code></td>
<td>Returns a subset of elements that satisfy a given condition</td>
</tr>
<tr>
<td><code>Take</code></td>
<td>Returns the first <em>x</em> elements, and discards the rest</td>
</tr>
<tr>
<td><code>Skip</code></td>
<td>Ignores the first <em>x</em> elements, and returns the rest</td>
</tr>
<tr>
<td><code>TakeLast</code></td>
<td>Returns the last <em>x</em> elements, and discards the rest</td>
</tr>
<tr>
<td><code>SkipLast</code></td>
<td>Ignores the last <em>x</em> elements, and returns the rest</td>
</tr>
<tr>
<td><code>TakeWhile</code></td>
<td>Emits elements from the input sequence until the given predicate is true</td>
</tr>
<tr>
<td><code>SkipWhile</code></td>
<td>Ignores elements from the input sequence until the given predicate is true and then emits the rest</td>
</tr>
<tr>
<td><code>Distinct</code>, <code>DistinctBy</code></td>
<td>Returns a collection that excludes duplicates</td>
</tr>
</tbody>
</table>
<table class="border pagebreak-before less_space" id="projection_operators">
<caption><span class="label">Table 3. </span>Projection operators</caption>
<thead>
<tr>
<th>Method</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code><strong>Select</strong></code></td>
<td>Transforms each input element with a given lambda expression</td>
</tr>
<tr>
<td><span class="keep-together"><code><strong>SelectMany</strong></code></span></td>
<td>Transforms each input element and then flattens and concatenates the resultant subsequences</td>
</tr>
</tbody>
</table>
<table class="border" id="joining_operators">
<caption><span class="label">Table 4. </span>Joining operators</caption>
<thead>
<tr>
<th>Method</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code><strong>Join</strong></code></td>
<td>Applies a lookup strategy to match elements from two collections, emitting a flat result set</td>
</tr>
<tr>
<td><span class="keep-together"><code><strong>GroupJoin</strong></code></span></td>
<td>As above, but emits a <em>hierarchical</em> result set</td>
</tr>
<tr>
<td><code>Zip</code></td>
<td>Enumerates two sequences in step, returning a sequence that applies a function over each element pair</td>
</tr>
</tbody>
</table>
<table class="border" id="ordering_operators">
<caption><span class="label">Table 5. </span>Ordering operators</caption>
<thead>
<tr>
<th>Method</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code><strong>OrderBy</strong></code>, <code><strong>ThenBy</strong></code></td>
<td>Returns the elements sorted in ascending order</td>
</tr>
<tr>
<td><code><strong>OrderByDescending</strong></code>, <code><strong>ThenByDescending</strong></code></td>
<td>Returns the elements sorted in descending order</td>
</tr>
<tr>
<td><code>Reverse</code></td>
<td>Returns the elements in reverse order</td>
</tr>
</tbody>
</table>
<table class="border" id="grouping_operators">
<caption><span class="label">Table 6. </span>Grouping operators</caption>
<thead>
<tr>
<th>Method</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code><strong>GroupBy</strong></code></td>
<td>Groups a sequence into subsequences</td>
</tr>
<tr>
<td><code>Chunk</code></td>
<td>Groups a sequence into chunks of a given size</td>
</tr>
</tbody>
</table>
<table class="border" id="set_operator">
<caption><span class="label">Table 7. </span>Set operators</caption>
<thead>
<tr>
<th>Method</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Concat</code></td>
<td>Concatenates two sequences</td>
</tr>
<tr>
<td><code>Union</code>,<code> UnionBy</code></td>
<td>Concatenates two sequences, removing duplicates</td>
</tr>
<tr>
<td><code>Intersect</code>, <span class="keep-together"><code>IntersectBy</code></span></td>
<td>Returns elements present in both sequences</td>
</tr>
<tr>
<td><code>Except</code>,<code> ExceptBy</code></td>
<td>Returns elements present in the first sequence but not the second</td>
</tr>
</tbody>
</table>
<table class="border" id="element_operator">
<caption><span class="label">Table 8. </span>Element operators</caption>
<thead>
<tr>
<th>Method</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>First</code>, <span class="keep-together"><code>FirstOrDefault</code></span></td>
<td>Returns the first element in the sequence, or the first element satisfying a given predicate</td>
</tr>
<tr>
<td><code>Last</code>, <span class="keep-together"><code>LastOrDefault</code></span></td>
<td>Returns the last element in the sequence, or the last element satisfying a given predicate</td>
</tr>
<tr>
<td><code>Single</code>, <span class="keep-together"><code>SingleOrDefault</code></span></td>
<td>Equivalent to <code>First</code>/<code>FirstOrDefault</code> but throws an exception if there is more than one match</td>
</tr>
<tr>
<td><code>MinBy</code>, <code>MaxBy</code></td>
<td>Returns the element with the smallest or largest value, as determined by a key selector</td>
</tr>
<tr>
<td><code>ElementAt</code>, <span class="keep-together"><code>ElementAtOrDefault</code></span></td>
<td>Returns the element at the specified position</td>
</tr>
<tr>
<td><span class="keep-together"><code>DefaultIfEmpty</code></span></td>
<td>Returns a single-value sequence whose value is null or <code>default(TSource)</code> if the sequence has no elements</td>
</tr>
</tbody>
</table>
<table class="border" id="aggregation_operators">
<caption><span class="label">Table 9. </span>Aggregation operators</caption>
<thead>
<tr>
<th>Method</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Count</code>, <span class="keep-together"><code>LongCount</code></span></td>
<td>Returns the total number of elements in the input sequence, or the number of elements satisfying a given predicate</td>
</tr>
<tr>
<td><code>Min</code>, <code>Max</code></td>
<td>Returns the smallest or largest element in the sequence</td>
</tr>
<tr>
<td><code>Sum</code>, <span class="keep-together"><code>Average</code></span></td>
<td>Calculates a numeric sum or average over elements in the sequence</td>
</tr>
<tr>
<td><code>Aggregate</code></td>
<td>Performs a custom aggregation</td>
</tr>
</tbody>
</table>
<table class="border" id="quantifiers">
<caption><span class="label">Table 10. </span>Quantifiers</caption>
<thead>
<tr>
<th>Method</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Contains</code></td>
<td>Returns <code>true</code> if the input sequence contains the given element</td>
</tr>
<tr>
<td><code>Any</code></td>
<td>Returns <code>true</code> if any elements satisfy the given predicate</td>
</tr>
<tr>
<td><code>All</code></td>
<td>Returns <code>true</code> if all elements satisfy the given predicate</td>
</tr>
<tr>
<td><span class="keep-together"><code>SequenceEqual</code></span></td>
<td>Returns <code>true</code> if the second sequence has identical elements to the input sequence</td>
</tr>
</tbody>
</table>
<table class="border" id="conversion_operators_left_parenthesisim">
<caption><span class="label">Table 11. </span>Conversion operators (import)</caption>
<thead>
<tr>
<th>Method</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>OfType</code></td>
<td>Converts <code>IEnumerable</code> to <code>IEnumerable&lt;T&gt;</code>, discarding wrongly typed elements</td>
</tr>
<tr>
<td><code><strong>Cast</strong></code></td>
<td>Converts <code>IEnumerable</code> to <code>IEnumerable&lt;T&gt;</code>, throwing an exception if there are any wrongly typed elements</td>
</tr>
</tbody>
</table>
<table class="border" id="conversion_operators_left_parenthesisex">
<caption><span class="label">Table 12. </span>Conversion operators (export)</caption>
<thead>
<tr>
<th>Method</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>ToArray</code></td>
<td>Converts <code>IEnumerable&lt;T&gt;</code> to <code>T[]</code></td>
</tr>
<tr>
<td><code>ToList</code></td>
<td>Converts <code>IEnumerable&lt;T&gt;</code> to <code>List&lt;T&gt;</code></td>
</tr>
<tr>
<td><code>ToDictionary</code></td>
<td>Converts <code>IEnumerable&lt;T&gt;</code> to <span class="keep-together"><code>Dictionary&lt;TKey,TValue&gt;</code></span></td>
</tr>
<tr>
<td><code>ToHashSet</code></td>
<td>Converts <code>IEnumerable&lt;T&gt;</code> to <code>HashSet&lt;T&gt;</code></td>
</tr>
<tr>
<td><code>ToLookup</code></td>
<td>Converts <code>IEnumerable&lt;T&gt;</code> to <span class="keep-together"><code>ILookup&lt;TKey,TElement&gt;</code></span></td>
</tr>
<tr>
<td><code>AsEnumerable</code></td>
<td>Downcasts to <code>IEnumerable&lt;T&gt;</code></td>
</tr>
<tr>
<td><code>AsQueryable</code></td>
<td>Casts or converts to <code>IQueryable&lt;T&gt;</code></td>
</tr>
</tbody>
</table>
<table class="border pagebreak-before less_space" id="generation_operators">
<caption><span class="label">Table 13. </span>Generation operators</caption>
<thead>
<tr>
<th>Method</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Empty</code></td>
<td>Creates an empty sequence</td>
</tr>
<tr>
<td><code>Repeat</code></td>
<td>Creates a sequence of repeating elements</td>
</tr>
<tr>
<td><code>Range</code></td>
<td>Creates a sequence of integers</td>
</tr>
</tbody>
</table>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Chaining Query Operators"><div class="sect2" id="chaining_query_operator">
<h2>Chaining Query Operators</h2>
<p><a contenteditable="false" data-primary="LINQ (Language Integrated Query)" data-secondary="chaining query operators" data-type="indexterm" id="id1360"/><a contenteditable="false" data-primary="query operators (LINQ)" data-secondary="chaining" data-type="indexterm" id="id1361"/>To build more complex queries, you chain query operators together. For example, the following query extracts all strings containing the letter <em>a</em>, sorts them by length, and then converts the results to uppercase:</p>
<pre data-type="programlisting">string[] names = { "Tom","Dick","Harry","Mary","Jay" };

IEnumerable&lt;string&gt; query = names
  .Where   (n =&gt; n.Contains ("a"))
  .OrderBy (n =&gt; n.Length)
  .Select  (n =&gt; n.ToUpper());

foreach (string name in query)
  Console.Write (name + "|");

// RESULT: JAY|MARY|HARRY|</pre>
<p><code>Where</code>, <code>OrderBy</code>, and <code>Select</code> are all standard query operators that resolve to extension methods in the <code>Enumerable</code> class. The <code>Where</code> operator emits a filtered version of the input sequence, <code>OrderBy</code> emits a sorted version of its input sequence, and <code>Select</code> emits a sequence in which each input element is transformed or <em>projected</em> with a given lambda expression (<code>n.To​Up⁠per()</code> in this case). Data flows from left to right through the chain of operators, so the data is first filtered, then sorted, then projected. The end result resembles a production line of conveyor belts, as illustrated in <a data-type="xref" href="#chaining_query_operators">Figure 6</a>.</p>
<figure><div id="chaining_query_operators" class="figure">
<img src="Images/c12p_0106.png" alt="Chaining query operators" width="848" height="335"/>
<h6><span class="label">Figure 6. </span>Chaining query operators</h6>
</div></figure>
<p>Deferred execution is honored throughout with operators, so no filtering, sorting, or projecting takes place until the query is actually enumerated.</p>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Query Expressions"><div class="sect2" id="query_expressions">
<h2>Query Expressions</h2>
<p><a contenteditable="false" data-primary="fluent syntax" data-type="indexterm" id="id1362"/>So far, we’ve written queries by calling extension methods in the <code>Enumerable</code> class. In this book, we describe this as <em>fluent syntax</em>. <a contenteditable="false" data-primary="LINQ (Language Integrated Query)" data-secondary="query expressions" data-type="indexterm" id="id1363"/>C# also provides special language support for writing queries, called <em>query expressions</em>. Here’s the preceding query expressed as a query expression:</p>
<pre data-type="programlisting">IEnumerable&lt;string&gt; query =
  from n in names
  where n.Contains ("a")
  orderby n.Length
  select n.ToUpper();</pre>
<p><a contenteditable="false" data-primary="from clauses" data-type="indexterm" id="id1364"/>A query expression always starts with a <code>from</code> clause, and ends with either a <code>select</code> or <code>group</code> clause. The <code>from</code> clause declares a <em>range variable</em> (in this case, <code>n</code>), which you can think of as traversing the input collection—rather like <code>foreach</code>. <a data-type="xref" href="#query_expression_syntax">Figure 7</a> illustrates the complete syntax.</p>
<figure><div id="query_expression_syntax" class="figure">
<img src="Images/c12p_0107.png" alt="Query expression syntax" width="827" height="913"/>
<h6><span class="label">Figure 7. </span>Query expression syntax</h6>
</div></figure>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>If you’re familiar with SQL, LINQ’s query expression syntax—with the <code>from</code> clause first and the <code>select</code> clause <span class="keep-together">last—might</span> look bizarre. Query expression syntax is actually more logical because the clauses appear <em>in the order they’re executed</em>. This allows Visual Studio to prompt you with IntelliSense as you type and simplifies the scoping rules for subqueries.</p>
</div>
<p>The compiler processes query expressions by translating them to fluent syntax. It does this in a fairly mechanical fashion—much like it translates <code>foreach</code> statements into calls to <code>GetEnumerator</code> and <code>MoveNext</code>:</p>
<pre data-type="programlisting">IEnumerable&lt;string&gt; query = names
  .Where   (n =&gt; n.Contains ("a"))
  .OrderBy (n =&gt; n.Length)
  .Select  (n =&gt; n.ToUpper());</pre>
<p>The <code>Where</code>, <code>OrderBy</code>, and <code>Select</code> operators then resolve using the same rules that would apply if the query were written in fluent syntax. In this case, they bind to extension methods in the <code>Enumerable</code> class (assuming that you’ve imported the <code>System.Linq</code> namespace) because <code>names</code> implements <span class="keep-together"><code>IEnumerable&lt;string&gt;</code></span>. The compiler doesn’t specifically favor the <code>Enumerable</code> class, however, when translating query syntax. You can think of the compiler as mechanically injecting the words <em>Where</em>, <em>OrderBy</em>, and <em>Select</em> into the statement and then compiling it as though you’d typed the method names yourself. This offers flexibility in how they resolve—the operators in Entity Framework queries, for instance, bind instead to the extension methods in the <code>Queryable</code> class.</p>
<section data-type="sect3" data-pdf-bookmark="Query expressions versus fluent queries"><div class="sect3" id="query_expressions_versus_fluent_queries">
<h3>Query expressions versus fluent queries</h3>
<p><a contenteditable="false" data-primary="fluent queries, query expressions versus" data-type="indexterm" id="id1365"/><a contenteditable="false" data-primary="query expressions, fluent queries versus" data-type="indexterm" id="id1366"/>Query expressions and fluent queries each have advantages.</p>
<p>Query expressions support only a small subset of query operators, namely:</p>
<pre data-type="programlisting">Where, Select, SelectMany
OrderBy, ThenBy, OrderByDescending, ThenByDescending
GroupBy, Join, GroupJoin</pre>
<p>For queries that use other operators, you must either write entirely in fluent syntax or construct mixed-syntax queries; for example:</p>
<pre data-type="programlisting">string[] names = { "Tom","Dick","Harry","Mary","Jay" };

IEnumerable&lt;string&gt; query =
  from   n in names
  where  n.Length == <strong>names.Min (n2 =&gt; n2.Length)</strong>
  select n;</pre>
<p>This query returns names whose length matches that of the shortest (“Tom” and “Jay”). The subquery (in bold) calculates the minimum length of each name and evaluates to 3. We need to use fluent syntax for the subquery, because the <code>Min</code> operator has no support in query expression syntax. We can, however, still use query syntax for the outer query.</p>
<p>The main advantage of query syntax is that it can radically simplify queries that involve the following:</p>
<ul>
<li><p>A <code>let</code> clause for introducing a new variable alongside the range variable</p></li>
<li><p>Multiple generators (<code>SelectMany</code>) followed by an outer range variable reference</p></li>
<li><p>A <code>Join</code> or <code>GroupJoin</code> equivalent followed by an outer range variable reference</p></li>
</ul>
</div></section>
</div></section>
<section data-type="sect2" data-pdf-bookmark="The let Keyword"><div class="sect2" id="the_let_keyword">
<h2>The let Keyword</h2>
<p><a contenteditable="false" data-primary="let keyword" data-type="indexterm" id="id1367"/><a contenteditable="false" data-primary="LINQ (Language Integrated Query)" data-secondary="let keyword" data-type="indexterm" id="id1368"/>The <code>let</code> keyword introduces a new variable alongside the range variable. For instance, suppose that you want to list all names whose length, without vowels, is greater than two characters:</p>
<pre data-type="programlisting">string[] names = { "Tom","Dick","Harry","Mary","Jay" };

IEnumerable&lt;string&gt; query =
  from n in names
<strong>  let vowelless = Regex.Replace (n, "[aeiou]", "")</strong>
  where vowelless.Length &gt; 2
  orderby vowelless
  select n + " - " + vowelless;</pre>
<p>The output from enumerating this query is:</p>
<pre data-type="programlisting">Dick - Dck
Harry - Hrry
Mary - Mry</pre>
<p>The <code>let</code> clause performs a calculation on each element, without losing the original element. In our query, the subsequent clauses (<code>where</code>, <code>orderby</code>, and <code>select</code>) have access to both <code>n</code> and <code>vowelless</code>. A query can include multiple <code>let</code> clauses, and they can be interspersed with additional <code>where</code> and <code>join</code> clauses.</p>
<p>The compiler translates the <code>let</code> keyword by projecting into a temporary anonymous type that contains both the original and transformed elements:</p>
<pre data-type="programlisting">IEnumerable&lt;string&gt; query = names
 .Select (n =&gt; new  
   {
     n = n, 
     vowelless = Regex.Replace (n, "[aeiou]", "")
   }
 )
 .Where (temp0 =&gt; (temp0.vowelless.Length &gt; 2))
 .OrderBy (temp0 =&gt; temp0.vowelless)
 .Select (temp0 =&gt; ((temp0.n + " - ") + temp0.vowelless))</pre>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Query Continuations"><div class="sect2" id="query_continuations">
<h2>Query Continuations</h2>
<p><a contenteditable="false" data-primary="LINQ (Language Integrated Query)" data-secondary="query continuations" data-type="indexterm" id="id1369"/>If you want to add clauses <em>after</em> a <code>select</code> or <code>group</code> clause, you must use the <code>into</code> keyword to “continue” the query. For instance:</p>
<pre data-type="programlisting">from c in "The quick brown tiger".Split()
select c.ToUpper() <strong>into upper</strong>
where upper.StartsWith ("T")
select upper

// RESULT: "THE", "TIGER"</pre>
<p>Following an <code>into</code> clause, the previous range variable is out of scope.</p>
<p>The compiler simply translates queries with an <code>into</code> keyword into a longer chain of operators:</p>
<pre data-type="programlisting">"The quick brown tiger".Split()
  .Select (c =&gt; c.ToUpper())
  .Where (upper =&gt; upper.StartsWith ("T"))</pre>
<p>(It omits the final <code>Select(upper=&gt;upper)</code> because it’s <span class="keep-together">redundant</span>.)</p>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Multiple Generators"><div class="sect2" id="multiple_generators">
<h2>Multiple Generators</h2>
<p><a contenteditable="false" data-primary="LINQ (Language Integrated Query)" data-secondary="multiple generators" data-type="indexterm" id="id1370"/><a contenteditable="false" data-primary="multiple generators" data-type="indexterm" id="id1371"/>A query can include multiple generators (<code>from</code> clauses). For example:</p>
<pre data-type="programlisting">int[] numbers = { 1, 2, 3 };
string[] letters = { "a", "b" };

IEnumerable&lt;string&gt; query = <strong>from n in numbers</strong>
<strong>                            from l in letters</strong>
                            select n.ToString() + l;</pre>
<p>The result is a cross product, rather like you’d get with nested <code>foreach</code> loops:</p>
<pre data-type="programlisting">"1a", "1b", "2a", "2b", "3a", "3b"</pre>
<p>When there’s more than one <code>from</code> clause in a query, the compiler emits a call to <code>SelectMany</code>:</p>
<pre data-type="programlisting">IEnumerable&lt;string&gt; query = numbers.<strong>SelectMany</strong> (
<strong>  n =&gt; letters,</strong>
<strong>  (n, l) =&gt; (n.ToString() + l));</strong></pre>
<p><code>SelectMany</code> performs nested looping. It enumerates every element in the source collection (<code>numbers</code>), transforming each element with the first lambda expression (<code>letters</code>). This generates a sequence of <em>subsequences</em>, which it then enumerates. The final output elements are determined by the second lambda expression (<code>n.ToString()+l</code>).</p>
<p>If you subsequently apply a <code>where</code> clause, you can filter the cross product and project a result akin to a <em>join</em>:</p>
<pre data-type="programlisting">string[] players = { "Tom", "Jay", "Mary" };

IEnumerable&lt;string&gt; query =
  from name1 in players
  from name2 in players
<strong>  where name1.CompareTo (name2) &lt; 0</strong>
  orderby name1, name2
  select name1 + " vs " + name2;

RESULT: { "Jay vs Mary", "Jay vs Tom", "Mary vs Tom" }</pre>
<p>The translation of this query into fluent syntax is more complex, requiring a temporary anonymous projection. The ability to perform this translation automatically is one of the key benefits of query expressions.</p>
<p>The expression in the second generator is allowed to use the first range variable:</p>
<pre data-type="programlisting">string[] fullNames =
  { "Anne Williams", "John Fred Smith", "Sue Green" };

IEnumerable&lt;string&gt; query =
  from <strong>fullName</strong> in fullNames
  from name in <strong>fullName.Split()</strong>
  select name + " came from " + fullName;

Anne came from Anne Williams
Williams came from Anne Williams
John came from John Fred Smith</pre>
<p>This works because the expression <code>fullName.Split</code> emits a <em>sequence</em> (an array of strings).</p>
<p>Multiple generators are used extensively in database queries to flatten parent–child relationships and to perform manual joins.</p>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Joining"><div class="sect2" id="joining">
<h2>Joining</h2>
<p><a contenteditable="false" data-primary="joining operators (LINQ)" data-type="indexterm" id="id1372"/><a contenteditable="false" data-primary="LINQ (Language Integrated Query)" data-secondary="joining operators" data-type="indexterm" id="id1373"/>LINQ provides three <em>joining</em> operators, the main ones being <code>Join</code> and <code>GroupJoin</code>, which perform keyed lookup-based joins. <code>Join</code> and <code>GroupJoin</code> support only a subset of the functionality you get with multiple generators/<code>SelectMany</code>, but are more performant with local queries because they use a hashtable-based lookup strategy rather than performing nested loops. (With Entity Framework queries, the joining operators have no advantage over multiple generators.)</p>
<p><a contenteditable="false" data-primary="joining operators (LINQ)" data-secondary="Join" data-type="indexterm" id="id1374"/><code>Join</code> and <code>GroupJoin</code> support only <em>equi-joins</em> (i.e., the joining condition must use the equality operator). There are two methods: <code>Join</code> and <code>GroupJoin</code>. <code>Join</code> emits a flat result set, whereas <code>GroupJoin</code> emits a hierarchical result set.</p>
<p>Following is the query expression syntax for a flat join:</p>
<pre data-type="programlisting">from <em>outer-var</em> in <em>outer-sequence</em>
join <em>inner-var</em> in <em>inner-sequence</em> 
  on <em>outer-key-expr</em> equals <em>inner-key-expr</em></pre>
<p>For example, consider the following collections:</p>
<pre data-type="programlisting">var customers = new[]
{
  new { ID = 1, Name = "Tom" },
  new { ID = 2, Name = "Dick" },
  new { ID = 3, Name = "Harry" }
};
var purchases = new[]
{
  new { CustomerID = 1, Product = "House" },
  new { CustomerID = 2, Product = "Boat" },
  new { CustomerID = 2, Product = "Car" },
  new { CustomerID = 3, Product = "Holiday" }
};</pre>
<p>We could perform a join as follows:</p>
<pre data-type="programlisting">IEnumerable&lt;string&gt; query =
<strong>  from c in customers</strong>
<strong>  join p in purchases on c.ID equals p.CustomerID</strong>
  select c.Name + " bought a " + p.Product;</pre>
<p>The compiler translates this to:</p>
<pre data-type="programlisting"><strong>customers</strong>.Join (                // outer collection
  <strong>purchases</strong>,                    // inner collection
  c =&gt; <strong>c.ID</strong>,                    // outer key selector
  p =&gt; <strong>p.CustomerID</strong>,            // inner key selector
  (c, p) =&gt;                     // result selector
     c.Name + " bought a " + p.Product 
);</pre>
<p>Here’s the result:</p>
<pre data-type="programlisting">Tom bought a House
Dick bought a Boat
Dick bought a Car
Harry bought a Holiday</pre>
<p>With local sequences, <code>Join</code> and <code>GroupJoin</code> are more efficient at processing large collections than <code>SelectMany</code> because they first preload the inner sequence into a keyed hashtable-based lookup. With a database query, however, you could achieve the same result equally efficiently as follows:</p>
<pre data-type="programlisting"><strong>from c in customers</strong>
<strong>from p in purchases</strong>
<strong>where c.ID == p.CustomerID</strong>
select c.Name + " bought a " + p.Product;</pre>
<section data-type="sect3" data-pdf-bookmark="GroupJoin"><div class="sect3" id="groupjoin">
<h3>GroupJoin</h3>
<p><a contenteditable="false" data-primary="GroupJoin operator" data-type="indexterm" id="id1375"/><a contenteditable="false" data-primary="joining operators (LINQ)" data-secondary="GroupJoin" data-type="indexterm" id="id1376"/><a contenteditable="false" data-primary="LINQ (Language Integrated Query)" data-secondary="GroupJoin operator" data-type="indexterm" id="id1377"/><code>GroupJoin</code> does the same work as <code>Join</code>, but instead of yielding a flat result, it yields a hierarchical result, grouped by each outer element.</p>
<p>The query expression syntax for <code>GroupJoin</code> is the same as for <code>Join</code>, but is followed by the <code>into</code> keyword. Here’s a basic example, using the <code>customers</code> and <code>purchases</code> collections we set up in the previous section:</p>
<pre data-type="programlisting">var query =
  from c in customers
  join p in purchases on c.ID equals p.CustomerID
<strong>  into custPurchases</strong>
  select custPurchases;   // custPurchases is a sequence</pre>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>An <code>into</code> clause translates to <code>GroupJoin</code> only when it appears directly after a <code>join</code> clause. After a <code>select</code> or <code>group</code> clause, it means <em>query continuation</em>. The two uses of the <code>into</code> keyword are quite different, although they have one feature in common: they both introduce a new query variable.</p>
</div>
<p>The result is a sequence of sequences—<code>IEnumerable&lt;IEnumerable&lt;T&gt;&gt;</code>—which you could enumerate as follows:</p>
<pre data-type="programlisting">foreach (var purchaseSequence in query)
  foreach (var purchase in purchaseSequence)
    Console.WriteLine (purchase.Product);</pre>
<p>This isn’t very useful, however, because <code>outerSeq</code> has no reference to the outer customer. More commonly, you’d reference the outer range variable in the projection:</p>
<pre data-type="programlisting">from c in customers
join p in purchases on c.ID equals p.CustomerID
<strong>into custPurchases</strong>
<strong>select new { CustName = c.Name, custPurchases };</strong></pre>
<p>You could obtain the same result (but less efficiently, for local queries) by projecting into an anonymous type that included a subquery:</p>
<pre data-type="programlisting">from c in customers
select new
{
  CustName = c.Name,
  custPurchases = 
    purchases.Where (p =&gt; c.ID == p.CustomerID)
}</pre>
</div></section>
<section data-type="sect3" data-pdf-bookmark="Zip"><div class="sect3" id="zip">
<h3>Zip</h3>
<p><a contenteditable="false" data-primary="joining operators (LINQ)" data-secondary="Zip" data-type="indexterm" id="id1378"/><a contenteditable="false" data-primary="Zip (LINQ joining operator)" data-type="indexterm" id="id1379"/><code>Zip</code> is the simplest joining operator. It enumerates two sequences in step (like a zipper), returning a sequence based on applying a function over each element pair; thus:</p>
<pre data-type="programlisting">int[] numbers = { 3, 5, 7 };
string[] words = { "three", "five", "seven", "ignored" };
IEnumerable&lt;string&gt; zip = 
  numbers.<strong>Zip (words, (n, w) =&gt; n + "=" + w)</strong>;</pre>
<p>produces a sequence with the following elements:</p>
<pre data-type="programlisting">3=three
5=five
7=seven</pre>
<p>Extra elements in either input sequence are ignored. <code>Zip</code> is not supported when you are querying a database.</p>
</div></section>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Ordering"><div class="sect2" id="ordering">
<h2>Ordering</h2>
<p><a contenteditable="false" data-primary="LINQ (Language Integrated Query)" data-secondary="orderby keyword" data-type="indexterm" id="id1380"/><a contenteditable="false" data-primary="orderby keyword" data-type="indexterm" id="id1381"/>The <code>orderby</code> keyword sorts a sequence. You can specify any number of expressions upon which to sort:</p>
<pre data-type="programlisting">string[] names = { "Tom","Dick","Harry","Mary","Jay" };

IEnumerable&lt;string&gt; query = from n in names
                            orderby <strong>n.Length, n</strong>
                            select n;</pre>
<p>This sorts first by length and then by name, yielding this result:</p>
<pre data-type="programlisting">Jay, Tom, Dick, Mary, Harry</pre>
<p>The compiler translates the first <code>orderby</code> expression to a call to <code>OrderBy</code>, and subsequent expressions to a call to <code>ThenBy</code>:</p>
<pre data-type="programlisting">IEnumerable&lt;string&gt; query = names
  .OrderBy (n =&gt; n.Length)
  .ThenBy (n =&gt; n)</pre>
<p>The <code>ThenBy</code> operator <em>refines</em> rather than <em>replaces</em> the previous sorting.</p>
<p>You can include the <code>descending</code> keyword after any of the <code>orderby</code> expressions:</p>
<pre data-type="programlisting">orderby n.Length <strong>descending</strong>, n</pre>
<p>This translates to the following:</p>
<pre data-type="programlisting">.OrderByDescending (n =&gt; n.Length).ThenBy (n =&gt; n)</pre>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>The ordering operators return an extended type of <code>IEnumerable&lt;T&gt;</code> called <code>IOrderedEnumerable&lt;T&gt;</code>. This interface defines the extra functionality required by the <code>ThenBy</code> operator.</p>
</div>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Grouping"><div class="sect2" id="grouping">
<h2>Grouping</h2>
<p><a contenteditable="false" data-primary="GroupBy operator" data-type="indexterm" id="id1382"/><a contenteditable="false" data-primary="LINQ (Language Integrated Query)" data-secondary="grouping" data-type="indexterm" id="id1383"/><code>GroupBy</code> organizes a flat input sequence into sequences of <em>groups</em>. For example, the following groups a sequence of names by their length:</p>
<pre data-type="programlisting">string[] names = { "Tom","Dick","Harry","Mary","Jay" };

var query = from name in names
            group name by name.Length;</pre>
<p>The compiler translates this query into the following:</p>
<pre data-type="programlisting">IEnumerable&lt;IGrouping&lt;int,string&gt;&gt; query = 
  names.GroupBy (name =&gt; name.Length);</pre>
<p>Here’s how to enumerate the result:</p>
<pre data-type="programlisting">foreach (IGrouping&lt;int,string&gt; grouping in query)
{
  Console.Write ("\r\n Length=" + <strong>grouping.Key</strong> + ":");
  foreach (string name in <strong>grouping</strong>)
    Console.Write (" " + name);
}

 Length=3: Tom Jay
 Length=4: Dick Mary
 Length=5: Harry</pre>
<p><code>Enumerable.GroupBy</code> works by reading the input elements into a temporary dictionary of lists so that all elements with the same key end up in the same sublist. It then emits a sequence of <em>groupings</em>. A grouping is a sequence with a <code>Key</code> property:</p>
<pre data-type="programlisting">public interface IGrouping &lt;TKey,TElement&gt;
  : IEnumerable&lt;TElement&gt;, IEnumerable
{
  // Key applies to the subsequence as a whole
  TKey Key { get; }    
}</pre>
<p>By default, the elements in each grouping are untransformed input elements, unless you specify an <code>elementSelector</code> argument. The following projects each input element to uppercase:</p>
<pre data-type="programlisting">from name in names
group name.ToUpper() by name.Length</pre>
<p>which translates to:</p>
<pre data-type="programlisting">names.GroupBy (
  name =&gt; name.Length, 
  name =&gt; name.ToUpper() )</pre>
<p>The subcollections are not emitted in order of key. <code>GroupBy</code> does no <em>sorting</em> (in fact, it preserves the original ordering). To sort, you must add an <code>OrderBy</code> operator (which means first adding an <code>into</code> clause, because <code>group by</code> ordinarily ends a query):</p>
<pre data-type="programlisting">from name in names
group name.ToUpper() by name.Length <strong>into grouping</strong>
orderby grouping.Key
select grouping</pre>
<p>Query continuations are often used in a <code>group by</code> query. The next query filters out groups that have exactly two matches in them:</p>
<pre data-type="programlisting">from name in names
group name.ToUpper() by name.Length <strong>into grouping</strong>
<strong>where grouping.Count() == 2</strong>
select grouping</pre>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>A <code>where</code> after a <code>group by</code> is equivalent to <code>HAVING</code> in SQL. It applies to each subsequence or grouping as a whole rather than the individual elements.</p>
</div>
</div></section>
<section data-type="sect2" data-pdf-bookmark="OfType and Cast"><div class="sect2" id="oftype_and_cast">
<h2>OfType and Cast</h2>
<p><a contenteditable="false" data-primary="Cast operator" data-type="indexterm" id="id1384"/><a contenteditable="false" data-primary="LINQ (Language Integrated Query)" data-secondary="OfType and Cast" data-type="indexterm" id="id1385"/><a contenteditable="false" data-primary="OfType operator" data-type="indexterm" id="id1386"/><code>OfType</code> and <code>Cast</code> accept a nongeneric <code>IEnumerable</code> collection and emit a generic <code>IEnumerable&lt;T&gt;</code> sequence that you can subsequently query:</p>
<pre data-type="programlisting">var classicList = new System.Collections.ArrayList();
classicList.AddRange ( new int[] { 3, 4, 5 } );
<strong>IEnumerable&lt;int&gt; sequence1 = classicList.Cast&lt;int&gt;();</strong></pre>
<p>This is useful because it allows you to query collections written prior to C# 2.0 (when <code>IEnumerable&lt;T&gt;</code> was introduced), such as <code>ControlCollection</code> in <code>System.Windows.Forms</code>.</p>
<p><code>Cast</code> and <code>OfType</code> differ in their behavior when encountering an input element that’s of an incompatible type: <code>Cast</code> throws an exception, whereas <code>OfType</code> ignores the incompatible element.</p>
<p>The rules for element compatibility follow those of C#’s <code>is</code> operator. Here’s the internal implementation of <code>Cast</code>:</p>
<pre data-type="programlisting">public static IEnumerable&lt;TSource&gt; Cast &lt;TSource&gt;
             (IEnumerable source)
{
  foreach (object element in source)
    yield return (TSource)element;
}</pre>
<p>C# supports the <code>Cast</code> operator in query expressions—simply insert the element type immediately after the <code>from</code> keyword:</p>
<pre data-type="programlisting">from <strong>int</strong> x in classicList ...</pre>
<p>This translates to the following:<a contenteditable="false" data-primary="" data-startref="ch1001.html43" data-type="indexterm" id="id1387"/></p>
<pre data-type="programlisting">from x in classicList<strong>.Cast &lt;int&gt;()</strong> ...</pre>
</div></section>
</div></section>
<section data-type="sect1" data-pdf-bookmark="Dynamic Binding"><div class="sect1" id="dynamic_binding">
<h1>Dynamic Binding</h1>
<p><a contenteditable="false" data-primary="binding" data-secondary="defined" data-type="indexterm" id="id1388"/><a contenteditable="false" data-primary="dynamic binding" data-secondary="basics of" data-type="indexterm" id="id1389"/><a contenteditable="false" data-primary="dynamic binding" data-secondary="uses for" data-type="indexterm" id="id1390"/><em>Dynamic binding</em> defers <a contenteditable="false" data-primary="dynamic binding" data-type="indexterm" id="ch1001.html44"/><em>binding</em>—the process of resolving types, members, and operators—from compile time to runtime. Dynamic binding is useful when at compile time <em>you</em> know that a certain function, member, or operator exists, but the <em>compiler</em> does not. This commonly occurs when you are interoperating with dynamic languages (such as IronPython) and COM and in scenarios when you might otherwise use reflection.</p>
<p>A dynamic type is declared by using the contextual keyword <code>dynamic</code>:</p>
<pre data-type="programlisting">dynamic d = GetSomeObject();
d.Quack();</pre>
<p>A dynamic type instructs the compiler to relax. We expect the runtime type of <code>d</code> to have a <code>Quack</code> method. We just can’t prove it statically. Because <code>d</code> is dynamic, the compiler defers binding <code>Quack</code> to <code>d</code> until runtime. Understanding what this means requires distinguishing between <em>static binding</em> and <em>dynamic binding</em>.</p>
<section data-type="sect2" data-pdf-bookmark="Static Binding Versus Dynamic Binding"><div class="sect2" id="static_binding_versus_dynamic_binding">
<h2>Static Binding Versus Dynamic Binding</h2>
<p><a contenteditable="false" data-primary="binding" data-secondary="static versus dynamic" data-type="indexterm" id="id1391"/><a contenteditable="false" data-primary="dynamic binding" data-secondary="static binding versus" data-type="indexterm" id="id1392"/><a contenteditable="false" data-primary="static binding" data-type="indexterm" id="id1393"/>The canonical binding example is mapping a name to a specific function when compiling an expression. To compile the following expression, the compiler needs to find the implementation of the method named <code>Quack</code>:</p>
<pre data-type="programlisting">d.Quack();</pre>
<p>Let’s suppose the static type of <code>d</code> is <code>Duck</code>:</p>
<pre data-type="programlisting">Duck d = ...
d.Quack();</pre>
<p>In the simplest case, the compiler does the binding by looking for a parameterless method named <code>Quack</code> on <code>Duck</code>. Failing that, the compiler extends its search to methods taking optional parameters, methods on base classes of <code>Duck</code>, and extension methods that take <code>Duck</code> as its first parameter. If no match is found, you’ll get a compilation error. Regardless of what method is bound, the bottom line is that the binding is done by the compiler, and the binding utterly depends on statically knowing the types of the operands (in this case, <code>d</code>). This makes it <em>static binding</em>.</p>
<p>Now let’s change the static type of <code>d</code> to <code>object</code>:</p>
<pre data-type="programlisting">object d = ...
d.Quack();</pre>
<p>Calling <code>Quack</code> gives us a compilation error because although the value stored in <code>d</code> can contain a method called <code>Quack</code>, the compiler cannot know it given that the only information it has is the type of the variable, which in this case is <code>object</code>. But let’s now change the static type of <code>d</code> to <code>dynamic</code>:</p>
<pre data-type="programlisting">dynamic d = ...
d.Quack();</pre>
<p>A <code>dynamic</code> type is like <code>object</code>—it’s equally nondescriptive about a type. The difference is that it lets you use it in ways that aren’t known at compile time. A dynamic object binds at runtime based on its runtime type, not its compile-time type. When the compiler sees a dynamically bound expression (which in general is an expression that contains any value of type <code>dynamic</code>), it merely packages up the expression such that the binding can be done later at runtime.</p>
<p>At runtime, if a dynamic object implements <code>IDynamicMeta​Ob⁠jectProvider</code>, that interface is used to perform the binding. If not, binding occurs in almost the same way as it would have had the compiler known the dynamic object’s runtime type. These two alternatives are called <em>custom binding</em> and <em>language binding</em>.</p>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Custom Binding"><div class="sect2" id="custom_binding">
<h2>Custom Binding</h2>
<p><a contenteditable="false" data-primary="binding" data-secondary="custom" data-type="indexterm" id="id1394"/><a contenteditable="false" data-primary="custom binding" data-type="indexterm" id="id1395"/><a contenteditable="false" data-primary="dynamic binding" data-secondary="custom binding" data-type="indexterm" id="id1396"/><a contenteditable="false" data-primary="IDMOP (IDynamicMetaObjectProvider)" data-type="indexterm" id="id1397"/>Custom binding occurs when a dynamic object implements <code>IDynamicMetaObjectProvider</code> (IDMOP). Although you can implement IDMOP on types that you write in C#, and this is useful to do, the more common case is that you have acquired an IDMOP object from a dynamic language that is implemented in .NET on the Dynamic Language Runtime (DLR), such as IronPython or IronRuby. Objects from those languages implicitly implement IDMOP as a means to directly control the meanings of operations performed on them. Here’s a simple example:</p>
<pre data-type="programlisting">dynamic d = new Duck();
d.Quack();       // Quack was called
d.Waddle();      // Waddle was called

public class Duck : DynamicObject   // in System.Dynamic
{
  public override bool TryInvokeMember (
    InvokeMemberBinder binder, object[] args,
    out object result)
  {
    Console.WriteLine (binder.Name + " was called");
    result = null;
    return true;
  }
}</pre>
<p>The <code>Duck</code> class doesn’t actually have a <code>Quack</code> method. Instead, it uses custom binding to intercept and interpret all method calls. We discuss custom binders in detail in <em>C# 12 in a Nutshell</em>.</p>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Language Binding"><div class="sect2" id="language_binding">
<h2>Language Binding</h2>
<p><a contenteditable="false" data-primary="binding" data-secondary="language" data-type="indexterm" id="id1398"/><a contenteditable="false" data-primary="dynamic binding" data-secondary="language binding" data-type="indexterm" id="id1399"/>Language binding occurs when a dynamic object does not implement <code>IDynamicMetaObjectProvider</code>. Language binding is useful when you are working around imperfectly designed types or inherent limitations in the .NET type system. For example, the built-in numeric types are imperfect in that they have no common interface. We have seen that methods can be bound dynamically; the same is true for operators:</p>
<pre data-type="programlisting">int x = 3, y = 4;
Console.WriteLine (Mean (x, y));

dynamic Mean (dynamic x, dynamic y) =&gt; (x+y) / 2;</pre>
<p>The benefit is obvious—you don’t need to duplicate code for each numeric type. However, you lose static type safety, risking runtime exceptions rather than compile-time errors.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Dynamic binding circumvents static type safety but not runtime type safety. Unlike with reflection, you cannot circumvent member accessibility rules with dynamic binding.</p>
</div>
<p>By design, language runtime binding behaves as similarly as possible to static binding, had the runtime types of the dynamic objects been known at compile time. In the previous example, the behavior of our program would be identical if we hardcoded <code>Mean</code> to work with the <code>int</code> type. The most notable exception in parity between static and dynamic binding is for extension methods, which we discuss in <a data-type="xref" href="#uncallable_functions">“Uncallable Functions”</a>.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Dynamic binding also incurs a performance hit. Because of the DLR’s caching mechanisms, however, repeated calls to the same dynamic expression are optimized, allowing you to efficiently call dynamic expressions in a loop. This optimization brings the typical overhead for a simple dynamic expression on today’s hardware down to less than 100 ns.</p>
</div>
</div></section>
<section data-type="sect2" data-pdf-bookmark="RuntimeBinderException"><div class="sect2" id="runtimebinderexception">
<h2>RuntimeBinderException</h2>
<p><a contenteditable="false" data-primary="dynamic binding" data-secondary="RuntimeBinderException" data-type="indexterm" id="id1400"/><a contenteditable="false" data-primary="RuntimeBinderException" data-type="indexterm" id="id1401"/>If a member fails to bind, a <code>RuntimeBinderException</code> is thrown. You can think of this as a compile-time error at runtime:</p>
<pre data-type="programlisting">dynamic d = 5;
d.Hello();       // throws RuntimeBinderException</pre>
<p>The exception is thrown because the <code>int</code> type has no <code>Hello</code> method.</p>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Runtime Representation of dynamic"><div class="sect2" id="runtime_representation_of_dynamic">
<h2>Runtime Representation of dynamic</h2>
<p><a contenteditable="false" data-primary="dynamic binding" data-secondary="runtime representation of dynamic" data-type="indexterm" id="id1402"/>There is a deep equivalence between the <code>dynamic</code> and <code>object</code> types. The runtime treats the following expression as <code>true</code>:</p>
<pre data-type="programlisting">typeof (dynamic) == typeof (object)</pre>
<p>This principle extends to constructed types and array types:</p>
<pre data-type="programlisting">typeof (List&lt;dynamic&gt;) == typeof (List&lt;object&gt;)
typeof (dynamic[]) == typeof (object[])</pre>
<p>Like an object reference, a dynamic reference can point to an object of any type (except pointer types):</p>
<pre data-type="programlisting">dynamic x = "hello";
Console.WriteLine (x.GetType().Name);  // String

x = 123;  // No error (despite same variable)
Console.WriteLine (x.GetType().Name);  // Int32</pre>
<p>Structurally, there is no difference between an object reference and a dynamic reference. A dynamic reference simply enables dynamic operations on the object it points to. You can convert from <code>object</code> to <code>dynamic</code> to perform any dynamic operation you want on an <code>object</code>:</p>
<pre data-type="programlisting">object o = new System.Text.StringBuilder();
dynamic d = o;
d.Append ("hello");
Console.WriteLine (o);   // hello</pre>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Dynamic Conversions"><div class="sect2" id="dynamic_conversions">
<h2>Dynamic Conversions</h2>
<p><a contenteditable="false" data-primary="dynamic binding" data-secondary="dynamic conversions" data-type="indexterm" id="id1403"/>The <code>dynamic</code> type has implicit conversions to and from all other types. For a conversion to succeed, the runtime type of the dynamic object must be implicitly convertible to the target static type.</p>
<p>The following example throws a <code>RuntimeBinderException</code> because an <code>int</code> is not implicitly convertible to a <code>short</code>:</p>
<pre data-type="programlisting">int i = 7;
dynamic d = i;
long l = d;       // OK - implicit conversion works
short j = d;      // throws RuntimeBinderException</pre>
</div></section>
<section data-type="sect2" data-pdf-bookmark="var Versus dynamic"><div class="sect2" id="var_versus_dynamic">
<h2>var Versus dynamic</h2>
<p><a contenteditable="false" data-primary="dynamic binding" data-secondary="var versus dynamic types" data-type="indexterm" id="id1404"/><a contenteditable="false" data-primary="var keyword" data-type="indexterm" id="id1405"/>The <code>var</code> and <code>dynamic</code> types bear a superficial resemblance, but the difference is deep:</p>
<ul class="list_style_type_none">
<li><p><code>var</code> says, “Let the <em>compiler</em> figure out the type.”</p></li>
<li><p><code>dynamic</code> says, “Let the <em>runtime</em> figure out the type.”</p></li>
</ul>
<p>To illustrate:</p>
<pre data-type="programlisting">dynamic x = "hello";  // Static type is <strong>dynamic</strong>
var y = "hello";      // Static type is <strong>string</strong>
int i = x;            // Runtime error
int j = y;            // Compile-time error</pre>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Dynamic Expressions"><div class="sect2" id="dynamic_expressions">
<h2>Dynamic Expressions</h2>
<p><a contenteditable="false" data-primary="dynamic binding" data-secondary="dynamic expressions" data-type="indexterm" id="id1406"/><a contenteditable="false" data-primary="expressions and operators" data-secondary="dynamic" data-type="indexterm" id="id1407"/>Fields, properties, methods, events, constructors, indexers, operators, and conversions can all be called dynamically.</p>
<p>Trying to consume the result of a dynamic expression with a <code>void</code> return type is prohibited—just as with a statically typed expression. The difference is that the error occurs at runtime.</p>
<p>Expressions involving dynamic operands are typically themselves dynamic, since the effect of absent type information is cascading:</p>
<pre data-type="programlisting">dynamic x = 2;
var y = x * 3;       // Static type of y is dynamic</pre>
<p>There are a couple of obvious exceptions to this rule. First, casting a dynamic expression to a static type yields a static expression. Second, constructor invocations always yield static expressions—even when called with dynamic arguments.</p>
<p>In addition, there are a few edge cases for which an expression containing a dynamic argument is static, including passing an index to an array and delegate creation expressions.</p>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Dynamic Member Overload Resolution"><div class="sect2" id="dynamic_member_overload_resolution">
<h2>Dynamic Member Overload Resolution</h2>
<p><a contenteditable="false" data-primary="dynamic binding" data-secondary="dynamic member overload resolution" data-type="indexterm" id="id1408"/>The canonical use case for <code>dynamic</code> involves a dynamic <em>receiver</em>. This means that a dynamic object is the receiver of a dynamic function call:</p>
<pre data-type="programlisting">dynamic x = ...;
x.Foo (123);          // x is the receiver</pre>
<p><a contenteditable="false" data-primary="runtime overload resolution" data-type="indexterm" id="id1409"/>However, dynamic binding is not limited to receivers: the method arguments are also eligible for dynamic binding. The effect of calling a function with dynamic arguments is to defer overload resolution from compile time to runtime:</p>
<pre data-type="programlisting">static void Foo (int x)    =&gt; Console.WriteLine ("int");
static void Foo (string x) =&gt; Console.WriteLine ("str");

static void Main()
{
  dynamic x = 5;
  dynamic y = "watermelon";

  Foo (x);    // int
  Foo (y);    // str
}</pre>
<p><a contenteditable="false" data-primary="multiple dispatch" data-type="indexterm" id="id1410"/>Runtime overload resolution is also called <em>multiple dispatch</em> and is useful in implementing design patterns such as <em>visitor</em>.</p>
<p>If a dynamic receiver is not involved, the compiler can statically perform a basic check to see whether the dynamic call will succeed: it checks that a function with the right name and number of parameters exists. If no candidate is found, you get a compile-time error.</p>
<p>If a function is called with a mixture of dynamic and static arguments, the final choice of method will reflect a mixture of dynamic and static binding decisions:</p>
<pre data-type="programlisting">static void X(object x, object y) =&gt;Console.Write("oo");
static void X(object x, string y) =&gt;Console.Write("os");
static void X(string x, object y) =&gt;Console.Write("so");
static void X(string x, string y) =&gt;Console.Write("ss");

static void Main()
{
  object o = "hello";
  dynamic d = "goodbye";
  X (o, d);               // os
}</pre>
<p>The call to <code>X(o,d)</code> is dynamically bound because one of its arguments, <code>d</code>, is <code>dynamic</code>. But because <code>o</code> is statically known, the binding—even though it occurs dynamically—will make use of that. In this case, overload resolution will pick the second implementation of <code>X</code> due to the static type of <code>o</code> and the runtime type of <code>d</code>. In other words, the compiler is “as static as it can possibly be.”</p>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Uncallable Functions"><div class="sect2" id="uncallable_functions">
<h2>Uncallable Functions</h2>
<p><a contenteditable="false" data-primary="dynamic binding" data-secondary="uncallable functions" data-type="indexterm" id="id1411"/><a contenteditable="false" data-primary="uncallable functions" data-type="indexterm" id="id1412"/>Some functions cannot be called dynamically. You cannot call the following:</p>
<ul>
<li><p>Extension methods (via extension method syntax)</p></li>
<li><p>Any member of an interface (via the interface)</p></li>
<li><p>Base members hidden by a subclass</p></li>
</ul>
<p>This is because dynamic binding requires two pieces of information: the name of the function to call, and the object upon which to call the function. However, in each of the three uncallable scenarios, an <em>additional type</em> is involved, which is known only at compile time. And there is no way to specify these additional types dynamically.</p>
<p>When you are calling extension methods, that additional type is an extension class, chosen implicitly by virtue of <code>using</code> directives in your source code (which disappear after compilation). When calling members via an interface, you communicate the additional type via an implicit or explicit cast. (With explicit implementation, it’s in fact impossible to call a member without casting to the interface.) A similar situation arises when you are calling a hidden base member: you must specify an additional type via either a cast or the <code>base</code> keyword—and that additional type is lost at runtime.<a contenteditable="false" data-primary="" data-startref="ch1001.html44" data-type="indexterm" id="id1413"/></p>
</div></section>
</div></section>
<section data-type="sect1" data-pdf-bookmark="Operator Overloading"><div class="sect1" id="operator_overloading">
<h1>Operator Overloading</h1>
<p><a contenteditable="false" data-primary="operator overloading" data-secondary="basics of" data-type="indexterm" id="id1414"/><a contenteditable="false" data-primary="expressions and operators" data-secondary="operator overloading" data-type="indexterm" id="ch1001.html45"/><a contenteditable="false" data-primary="operator overloading" data-type="indexterm" id="ch1001.html46"/>You can overload operators to provide more natural syntax for custom types. Operator overloading is most appropriately used for implementing custom structs that represent fairly primitive data types. For example, a custom numeric type is an excellent candidate for operator overloading.</p>
<p>You can overload the following symbolic operators:</p>
<pre data-type="programlisting">+   -   *   /   ++   --   !   ~   %   &amp;   |   ^
==  !=  &lt;   &lt;&lt;  &gt;&gt;   &gt;</pre>
<p>You can override implicit and explicit conversions (with the <code>implicit</code> and <code>explicit</code> keywords), as you can the <code>true</code> and <code>false</code> operators.</p>
<p><a contenteditable="false" data-primary="+ (concatenation) operator" data-type="indexterm" id="id1415"/><a contenteditable="false" data-primary="concatenation (+) operator" data-type="indexterm" id="id1416"/>The compound assignment operators (e.g., <code>+=</code>, <code>/=</code>) are automatically overridden when you override the noncompound operators (e.g., <code>+</code>, <code>/</code>).</p>
<section data-type="sect2" data-pdf-bookmark="Operator Functions"><div class="sect2" id="operator_functions">
<h2>Operator Functions</h2>
<p><a contenteditable="false" data-primary="operator overloading" data-secondary="operator functions" data-type="indexterm" id="id1417"/>To overload an operator, you declare an <em>operator function</em>. An operator function must be static, and at least one of the operands must be the type in which the operator function is declared.</p>
<p>In the following example, we define a struct called <code>Note</code>, representing a musical note, and then overload the <code>+</code> operator:</p>
<pre data-type="programlisting">public struct Note
{
  int value;

  public Note (int semitonesFromA) 
    =&gt; value = semitonesFromA;

<strong>  public static Note operator + (Note x, int semitones)</strong>
    =&gt; new Note (x.value + semitones);
}</pre>
<p>This overload allows us to add an <code>int</code> to a <code>Note</code>:</p>
<pre data-type="programlisting">Note B = new Note (2);
Note CSharp = B + 2;</pre>
<p>Because we overrode <code>+</code>, we can use <code>+=</code> too:</p>
<pre data-type="programlisting">CSharp += 2;</pre>
<p><a contenteditable="false" data-primary="checked operator" data-type="indexterm" id="id1418"/>From C# 11, you can also declare a <code>checked</code> version that will be called inside checked expressions or blocks. These are called <em>checked operators</em>:</p>
<pre data-type="programlisting">public static Note operator <strong>checked</strong> + (Note x, int semis)
  =&gt; checked (new Note (x.value + semis));</pre>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Overloading Equality and Comparison Operators"><div class="sect2" id="overloading_equality_and_comparison_ope">
<h2>Overloading Equality and Comparison Operators</h2>
<p><a contenteditable="false" data-primary="== (equality comparison) operator" data-secondary="overloading" data-type="indexterm" id="id1419"/><a contenteditable="false" data-primary="equality comparison (==) operator" data-secondary="overloading" data-type="indexterm" id="id1420"/><a contenteditable="false" data-primary="operator overloading" data-secondary="overloading equality and comparison operators" data-type="indexterm" id="id1421"/>Equality and comparison operators are often overridden when writing structs, and in rare cases with classes. Special rules and obligations apply when overloading these operators:</p>
<dl>
<dt>Pairing</dt>
<dd>The C# compiler enforces that operators that are logical pairs are both defined. These operators are (<code>== !=</code>), (<code>&lt; &gt;</code>), and (<code>&lt;= &gt;=</code>).</dd>
<dt><code>Equals</code> and <code>GetHashCode</code></dt>
<dd>If you overload <code>==</code> and <code>!=</code>, you will usually need to override <code>object</code>’s <code>Equals</code> and <code>GetHashCode</code> methods so that collections and hashtables will work reliably with the type.</dd>
<dt><code>IComparable</code> and <code>IComparable&lt;T&gt;</code></dt>
<dd>If you overload <code>&lt;</code> and <code>&gt;</code>, you would also typically implement <code>IComparable</code> and <code>IComparable&lt;T&gt;</code>.</dd>
</dl>
<p>Extending the previous example, here’s how you could overload <code>Note</code>’s equality operators:</p>
<pre data-type="programlisting"><strong>public static bool operator == (Note n1, Note n2)</strong>
  =&gt; n1.value == n2.value;

<strong>public static bool operator != (Note n1, Note n2)</strong>
  =&gt; !(n1.value == n2.value);

public override bool Equals (object otherNote)
{
  if (!(otherNote is Note)) return false;
  return this == (Note)otherNote;
}
// value’s hashcode will work for our own hashcode:
public override int GetHashCode() =&gt; value.GetHashCode();</pre>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Custom Implicit and Explicit Conversions"><div class="sect2" id="custom_implicit_and_explicit_conversion">
<h2>Custom Implicit and Explicit Conversions</h2>
<p><a contenteditable="false" data-primary="explicit conversions" data-secondary="overloading" data-type="indexterm" id="id1422"/><a contenteditable="false" data-primary="operator overloading" data-secondary="custom conversions" data-type="indexterm" id="id1423"/>Implicit and explicit conversions are overloadable operators. These conversions are typically overloaded to make converting between strongly related types (such as numeric types) concise and natural.</p>
<p>As explained in the discussion on types, the rationale behind implicit conversions is that they should always succeed and not lose information during conversion. Otherwise, explicit conversions should be defined.</p>
<p>In the following example, we define conversions between our musical <code>Note</code> type and a <code>double</code> (which represents the frequency in hertz of that note):</p>
<pre data-type="programlisting">...
// Convert to hertz
<strong>public static implicit operator double (Note x)</strong>
  =&gt; 440 * Math.Pow (2,(double) x.value / 12 );
  
// Convert from hertz (accurate to nearest semitone)
<strong>public static explicit operator Note (double x)</strong>
  =&gt; new Note ((int) (0.5 + 12 * (Math.Log(x/440)
               / Math.Log(2)) ));
...
  
Note n =(Note)554.37;  // explicit conversion
double x = n;          // implicit conversion</pre>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>This example is somewhat contrived: in real life, these conversions might be better implemented with a <code>ToFrequency</code> method and a (static) <code>FromFrequency</code> method.</p>
</div>
<p>Custom conversions are ignored by the <code>as</code> and <code>is</code> operators.<a contenteditable="false" data-primary="" data-startref="ch1001.html46" data-type="indexterm" id="id1424"/><a contenteditable="false" data-primary="" data-startref="ch1001.html45" data-type="indexterm" id="id1425"/></p>
</div></section>
</div></section>
<section data-type="sect1" data-pdf-bookmark="Attributes"><div class="sect1" id="attributes">
<h1>Attributes</h1>
<p><a contenteditable="false" data-primary="attributes" data-type="indexterm" id="ch1001.html47"/>You’re <a contenteditable="false" data-primary="attributes" data-secondary="basics of" data-type="indexterm" id="id1426"/>already familiar with the notion of attributing code elements of a program with modifiers, such as <code>virtual</code> or <code>ref</code>. These constructs are built into the language. <em>Attributes</em> are an extensible mechanism for adding custom information to code elements (assemblies, types, members, return values, and parameters). This extensibility is useful for services that integrate deeply into the type system, without requiring special keywords or constructs in the C# language.</p>
<section data-type="sect2" data-pdf-bookmark="Attribute Classes"><div class="sect2" id="attribute_classes">
<h2>Attribute Classes</h2>
<p><a contenteditable="false" data-primary="attributes" data-secondary="attribute classes" data-type="indexterm" id="id1427"/>An attribute is defined by a class that inherits (directly or indirectly) from the abstract class <code>System.Attribute</code>. To attach an attribute to a code element, specify the attribute’s type name in square brackets, before the code element. For example, the following attaches <code>ObsoleteAttribute</code> to the <code>Foo</code> class:</p>
<pre data-type="programlisting"><strong>[ObsoleteAttribute]</strong>
public class Foo {...}</pre>
<p>This particular attribute is recognized by the compiler and will cause compiler warnings if a type or member marked obsolete is referenced. By convention, all attribute types end with the word <em>Attribute</em>. C# recognizes this and allows you to omit the suffix when attaching an attribute:</p>
<pre data-type="programlisting"><strong>[Obsolete]</strong>
public class Foo {...}</pre>
<p><code>ObsoleteAttribute</code> is a type declared in the <code>System</code> namespace as follows (simplified for brevity):</p>
<pre data-type="programlisting">public sealed class ObsoleteAttribute : Attribute {...}</pre>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Named and Positional Attribute Parameters"><div class="sect2" id="named_and_positional_attribute_paramete">
<h2>Named and Positional Attribute Parameters</h2>
<p><a contenteditable="false" data-primary="attributes" data-secondary="named and positional parameters" data-type="indexterm" id="id1428"/><a contenteditable="false" data-primary="named parameters" data-type="indexterm" id="id1429"/><a contenteditable="false" data-primary="positional parameters" data-type="indexterm" id="id1430"/>Attributes can have parameters. In the following example, we apply <code>XmlElementAttribute</code> to a class. This attribute instructs <code>XmlSerializer</code> (in <code>System.Xml.Serialization</code>) how an object is represented in XML and accepts several <em>attribute parameters</em>. The following attribute maps the <code>CustomerEntity</code> class to an XML element named <code>Customer</code>, belonging to the <code>http://oreilly.com</code> namespace:</p>
<pre data-type="programlisting"><strong>[XmlElement ("Customer", Namespace="http://oreilly.com")]</strong>
public class CustomerEntity { ... }</pre>
<p>Attribute parameters fall into one of two categories: positional or named. In the preceding example, the first argument is a <em>positional parameter</em>; the second is a <em>named parameter</em>. Positional parameters correspond to parameters of the attribute type’s public constructors. Named parameters correspond to public fields or public properties on the attribute type.</p>
<p>When specifying an attribute, you must include positional parameters that correspond to one of the attribute’s constructors. Named parameters are optional.</p>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Attribute Targets"><div class="sect2" id="attribute_targets">
<h2>Attribute Targets</h2>
<p><a contenteditable="false" data-primary="attributes" data-secondary="attribute targets" data-type="indexterm" id="id1431"/><a contenteditable="false" data-primary="targets, attribute" data-type="indexterm" id="id1432"/>Implicitly, the target of an attribute is the code element it immediately precedes, which is typically a type or type member. You can also attach attributes, however, to an assembly. This requires that you explicitly specify the attribute’s target. Here’s an example of using the <code>CLSCompliant</code> attribute to specify Common Language Specification (CLS) compliance for an entire assembly:</p>
<pre data-type="programlisting">[<strong>assembly:</strong>CLSCompliant(true)]</pre>
<p>From C# 10, you can apply attributes to the method, parameters, and return value of a lambda expression:</p>
<pre data-type="programlisting">Action&lt;int&gt; a =
  [Description ("Method")]
  [return: Description ("Return value")]
  ([Description ("Parameter")]int x) =&gt; Console.Write (x);</pre>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Specifying Multiple Attributes"><div class="sect2" id="specifying_multiple_attributes">
<h2>Specifying Multiple Attributes</h2>
<p><a contenteditable="false" data-primary="attributes" data-secondary="specifying multiple" data-type="indexterm" id="id1433"/>You can specify multiple attributes for a single code element. You can list each attribute either within the same pair of square brackets (separated by a comma) or in separate pairs of square brackets (or a combination of the two). The following two examples are semantically identical:</p>
<pre data-type="programlisting">[Serializable, Obsolete, CLSCompliant(false)]
public class Bar {...}

[Serializable] [Obsolete] [CLSCompliant(false)]
public class Bar {...}</pre>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Writing Custom Attributes"><div class="sect2" id="writing_custom_attributes">
<h2>Writing Custom Attributes</h2>
<p><a contenteditable="false" data-primary="attributes" data-secondary="writing custom" data-type="indexterm" id="id1434"/><a contenteditable="false" data-primary="custom attributes" data-type="indexterm" id="id1435"/>You can define your own attributes by subclassing <code>Sys⁠tem​.Attribute</code>. For example, you could use the following custom attribute for flagging a method for unit testing:</p>
<pre data-type="programlisting">[AttributeUsage (AttributeTargets.Method)]
public sealed class TestAttribute : Attribute
{
  public int     Repetitions;
  public string  FailureMessage;

  public TestAttribute () : this (1) { }
  public TestAttribute (int repetitions)
    =&gt; Repetitions = repetitions;
}</pre>
<p>Here’s how you could apply the attribute:</p>
<pre data-type="programlisting">class Foo
{
  [Test]
  public void Method1() { ... }
  
  [Test(20)]
  public void Method2() { ... }
  
  [Test(20, FailureMessage="Debugging Time!")]
  public void Method3() { ... }
}</pre>
<p><code>AttributeUsage</code> is itself an attribute that indicates the construct (or combination of constructs) to which the custom attribute can be applied. The <code>AttributeTargets</code> enum includes such members as <code>Class</code>, <code>Method</code>, <code>Parameter</code>, and <code>Constructor</code> (as well as <code>All</code>, which combines all targets).</p>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Retrieving Attributes at Runtime"><div class="sect2" id="retrieving_attributes_at_runtime">
<h2>Retrieving Attributes at Runtime</h2>
<p><a contenteditable="false" data-primary="attributes" data-secondary="retrieving at runtime" data-type="indexterm" id="id1436"/>There are two standard ways to retrieve attributes at runtime:</p>
<ul>
<li><p>Call <code>GetCustomAttributes</code> on any <code>Type</code> or <code>MemberInfo</code> object</p></li>
<li><p>Call <code>Attribute.GetCustomAttribute</code> or <code>Attribute.Get​Cus⁠tomAttributes</code></p></li>
</ul>
<p>These latter two methods are overloaded to accept any reflection object that corresponds to a valid attribute target (<code>Type</code>, <code>Assembly</code>, <code>Module</code>, <code>MemberInfo</code>, or <code>ParameterInfo</code>).</p>
<p>Here’s how we can enumerate each method in the preceding <code>Foo</code> class that has a <code>TestAttribute</code>:</p>
<pre data-type="programlisting">foreach (MethodInfo mi in typeof (Foo).GetMethods())
{
  TestAttribute att = (TestAttribute)
    Attribute.GetCustomAttribute
     (mi, typeof (TestAttribute));
  
  if (att != null)
    Console.WriteLine (
      "{0} will be tested; reps={1}; msg={2}",
      mi.Name, att.Repetitions, att.FailureMessage);
}</pre>
<p>Here’s the output:<a contenteditable="false" data-primary="" data-startref="ch1001.html47" data-type="indexterm" id="id1437"/></p>
<pre data-type="programlisting">Method1 will be tested; reps=1; msg=
Method2 will be tested; reps=20; msg=
Method3 will be tested; reps=20; msg=Debugging Time!</pre>
</div></section>
</div></section>
<section data-type="sect1" data-pdf-bookmark="Caller Info Attributes"><div class="sect1" id="caller_info_attributes">
<h1>Caller Info Attributes</h1>
<p><a contenteditable="false" data-primary="attributes" data-secondary="caller info attributes" data-type="indexterm" id="id1438"/><a contenteditable="false" data-primary="caller info attributes" data-type="indexterm" id="id1439"/>You can tag optional parameters with one of three <em>caller info attributes</em>, which instruct the compiler to feed information obtained from the caller’s source code into the parameter’s default value:</p>
<ul>
<li><p><code>[CallerMemberName]</code> applies the caller’s member name.</p></li>
<li><p><code>[CallerFilePath]</code> applies the path to the caller’s source code file.</p></li>
<li><p><code>[CallerLineNumber]</code> applies the line number in the caller’s source code file.</p></li>
</ul>
<p>The <code>Foo</code> method in the following program demonstrates all three:</p>
<pre data-type="programlisting">using System;
using System.Runtime.CompilerServices;

class Program
{
  static void Main() =&gt; Foo();

  static void Foo (
    <strong>[CallerMemberName]</strong> string memberName = null,
    <strong>[CallerFilePath]</strong> string filePath = null,
    <strong>[CallerLineNumber]</strong> int lineNumber = 0)
  {
    Console.WriteLine (memberName);
    Console.WriteLine (filePath);
    Console.WriteLine (lineNumber);
  }
}</pre>
<p>Assuming that our program resides in <em>c:\source\test\Program.cs</em>, the output would be:</p>
<pre data-type="programlisting">Main
c:\source\test\Program.cs
6</pre>
<p>As with standard optional parameters, the substitution is done at the <em>calling site</em>. Hence, our <code>Main</code> method is syntactic sugar for this:</p>
<pre data-type="programlisting">static void Main()
  =&gt; Foo ("Main", @"c:\source\test\Program.cs", 6);</pre>
<p>Caller info attributes are useful for writing logging functions and for implementing change notification patterns. For instance, we can call a method such as the following from within a property’s <code>set</code> accessor—without having to specify the property’s name:</p>
<pre data-type="programlisting">void RaisePropertyChanged (
  <strong>[CallerMemberName]</strong> string propertyName = null)
  {  
    ...
  }</pre>
<section data-type="sect2" data-pdf-bookmark="CallerArgumentExpression"><div class="sect2" id="callerargumentexpression">
<h2>CallerArgumentExpression</h2>
<p><a contenteditable="false" data-primary="arguments" data-secondary="CallerArgumentExpression" data-type="indexterm" id="id1440"/><a contenteditable="false" data-primary="CallerArgumentExpression" data-type="indexterm" id="id1441"/><a contenteditable="false" data-primary="parameters" data-secondary="CallerArgumentExpression" data-type="indexterm" id="id1442"/>A method parameter to which you apply the <code>[CallerArgumentExpression]</code> attribute captures an argument expression from the call site:</p>
<pre data-type="programlisting">Print (<strong>Math.PI * 2</strong>);

void Print (double number,
  [<strong>CallerArgumentExpression("number")</strong>] string expr = null)
    =&gt; Console.WriteLine (expr);

// Output: <strong>Math.PI * 2</strong></pre>
<p>The main application for this feature is when writing validation and assertion libraries. In the following example, an exception is thrown, whose message includes the text “2 + 2 == 5.” This aids in debugging:</p>
<pre data-type="programlisting">Assert (2 + 2 == 5);

void Assert (bool condition,
  [<strong>CallerArgumentExpression ("condition")</strong>]
  string msg = null)
{
  if (!condition)
   throw new Exception ("Assert failed: " + msg);
}</pre>
<p>You can use <code>[CallerArgumentExpression]</code> multiple times in order to capture multiple argument expressions.</p>
</div></section>
</div></section>
<section data-type="sect1" data-pdf-bookmark="Asynchronous Functions"><div class="sect1" id="asynchronous_functions">
<h1>Asynchronous Functions</h1>
<p><a contenteditable="false" data-primary="asynchronous functions" data-type="indexterm" id="ch1001.html48"/>The <a contenteditable="false" data-primary="asynchronous functions" data-secondary="basics of" data-type="indexterm" id="id1443"/><code>await</code> and <code>async</code> keywords support <em>asynchronous programming</em>, a style of programming in which long-running functions do most or all of their work <em>after</em> returning to the caller.<a contenteditable="false" data-primary="callbacks" data-secondary="asynchronous functions and" data-type="indexterm" id="id1444"/> This is in contrast to normal <em>synchronous</em> programming, in which long-running functions <em>block</em> the caller until the operation is complete. Asynchronous programming implies <em>concurrency</em> because the long-running operation continues <em>in parallel</em> to the caller. The implementer of an asynchronous function initiates this concurrency either through multithreading (for compute-bound operations) or via a callback mechanism (for I/O-bound operations).</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Multithreading, concurrency, and asynchronous programming are large topics. We dedicate two chapters to them in <em>C# 12 in a Nutshell</em> and discuss them online at <a href="http://albahari.com/threading"><em class="hyperlink">http://albahari.com/threading</em></a>.</p>
</div>
<p>For instance, consider the following <em>synchronous</em> method, which is long-running and compute-bound:</p>
<pre data-type="programlisting">int ComplexCalculation()
{
  double x = 2;
  for (int i = 1; i &lt; 100000000; i++)
    x += Math.Sqrt (x) / i;
  return (int)x;
}</pre>
<p>This method blocks the caller for a few seconds while it runs, before returning the result of the calculation to the caller:</p>
<pre data-type="programlisting">int <strong>result</strong> = ComplexCalculation(); 
// Sometime later:
Console.WriteLine (result);   // 116</pre>
<p><a contenteditable="false" data-primary="asynchronous functions" data-secondary="returning Task&lt;TResult&gt;" data-type="indexterm" id="id1445"/><a contenteditable="false" data-primary="Task&lt;TResult&gt;" data-type="indexterm" id="id1446"/>The CLR defines a class called <code>Task&lt;TResult&gt;</code> (in <code>System.Threading.Tasks</code>) to encapsulate the concept of an operation that completes in the future. You can generate a <code>Task&lt;TResult&gt;</code> for a compute-bound operation by calling <code>Task.Run</code>, which instructs the CLR to run the specified delegate on a separate thread that executes in parallel to the caller:</p>
<pre data-type="programlisting"><strong>Task&lt;int&gt;</strong> ComplexCalculation<strong>Async</strong>()
  =&gt; <strong>Task.Run (</strong> () =&gt; ComplexCalculation() <strong>)</strong>;</pre>
<p>This method is <em>asynchronous</em> because it returns immediately to the caller while it executes concurrently. However, we need some mechanism to allow the caller to specify what should happen when the operation finishes and the result becomes available. <code>Task&lt;TResult&gt;</code> solves this by exposing a <code>GetAwaiter</code> method that lets the caller attach a <em>continuation</em>:</p>
<pre data-type="programlisting">Task&lt;int&gt; task = ComplexCalculationAsync();
var awaiter = task.<strong>GetAwaiter</strong>();
awaiter.<strong>OnCompleted</strong> (() =&gt;        // Continuation
{
  int result = awaiter.<strong>GetResult</strong>();
  Console.WriteLine (result);       // 116
});</pre>
<p>This says to the operation, “When you finish, execute the specified delegate.” Our continuation first calls <code>GetResult</code>, which returns the result of the calculation. (Or, if the task <em>faulted</em>—threw an exception—calling <code>GetResult</code> rethrows that exception.) Our continuation then writes out the result via <code>Console.WriteLine</code>.</p>
<section data-type="sect2" data-pdf-bookmark="The await and async Keywords"><div class="sect2" id="the_await_and_async_keywords">
<h2>The await and async Keywords</h2>
<p><a contenteditable="false" data-primary="asynchronous functions" data-secondary="await and async keywords" data-type="indexterm" id="id1447"/><a contenteditable="false" data-primary="await keyword" data-type="indexterm" id="id1448"/>The <code>await</code> keyword simplifies the attaching of continuations. Starting with a basic scenario, consider the following:</p>
<pre data-type="programlisting">var <em>result</em> = <strong>await</strong> <em>expression</em>;
<em>statement(s)</em>;</pre>
<p>The compiler expands this into something functionally similar to the following:</p>
<pre data-type="programlisting">var awaiter = <em>expression</em>.GetAwaiter();
awaiter.OnCompleted (() =&gt; 
{
  var <em>result</em> = awaiter.GetResult();
  <em>statement(s)</em>;
});</pre>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>The compiler also emits code to optimize the scenario of the operation completing synchronously (immediately). A common reason for an asynchronous operation completing immediately is if it implements an internal caching mechanism and the result is already cached.</p>
</div>
<p>Hence, we can call the <code>ComplexCalculationAsync</code> method we defined previously, like this:</p>
<pre data-type="programlisting">int result = <strong>await</strong> ComplexCalculationAsync();
Console.WriteLine (result);</pre>
<p><a contenteditable="false" data-primary="async keyword" data-type="indexterm" id="id1449"/>To compile, we need to add the <code>async</code> modifier to the containing method:</p>
<pre data-type="programlisting"><strong>async</strong> void Test()
{
  int result = <strong>await</strong> ComplexCalculationAsync();
  Console.WriteLine (result);
}</pre>
<p>The <code>async</code> modifier instructs the compiler to treat <code>await</code> as a keyword rather than an identifier should an ambiguity arise within that method (this ensures that code written prior to C# 5.0 that might use <code>await</code> as an identifier will still compile without error). The <code>async</code> modifier can be applied only to methods (and lambda expressions) that return <code>void</code> or (as you’ll see later) a <code>Task</code> or <code>Task&lt;TResult&gt;</code>.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>The <code>async</code> modifier is similar to the <code>unsafe</code> modifier in that it has no effect on a method’s signature or public metadata; it affects only what happens <em>within</em> the method.</p>
</div>
<p>Methods with the <code>async</code> modifier are called <em>asynchronous functions</em> because they themselves are typically asynchronous. To see why, let’s look at how execution proceeds through an asynchronous function.</p>
<p>Upon encountering an <code>await</code> expression, execution (normally) returns to the caller—rather like with <code>yield return</code> in an iterator. But before returning, the runtime attaches a continuation to the awaited task, ensuring that when the task completes, execution jumps back into the method and continues where it left off. If the task faults, its exception is rethrown (by virtue of calling <code>GetResult</code>); otherwise, its return value is assigned to the <code>await</code> expression.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>The CLR’s implementation of a task awaiter’s <code>OnCompleted</code> method ensures that by default, continuations are posted through the current <em>synchronization context</em>, if one is present. In practice, this means that in rich-client UI scenarios (WPF, WinUI, and Windows Forms), if you <code>await</code> on a UI thread, your code will continue on that same thread. This simplifies thread safety.</p>
</div>
<p>The expression upon which you <code>await</code> is typically a task; however, any object with a <code>GetAwaiter</code> method that returns an <em>awaitable object</em>—implementing <code>INotifyCompletion.On​Com⁠pleted</code> and with an appropriately typed <code>GetResult</code> method (and a <code>bool IsCompleted</code> property that tests for synchronous completion)—will satisfy the compiler.</p>
<p>Notice that our <code>await</code> expression evaluates to an <code>int</code> type; this is because the expression that we awaited was a <code>Task&lt;int&gt;</code> (whose <code>GetAwaiter().GetResult()</code> method returns an <code>int</code>).</p>
<p class="pagebreak-before">Awaiting a nongeneric task is legal and generates a void <span class="keep-together">expression</span>:</p>
<pre data-type="programlisting">await Task.Delay (5000);
Console.WriteLine ("Five seconds passed!");</pre>
<p><code>Task.Delay</code> is a static method that returns a <code>Task</code> that completes in the specified number of milliseconds. The <em>synchronous</em> equivalent of <code>Task.Delay</code> is <code>Thread.Sleep</code>.</p>
<p><code>Task</code> is the nongeneric base class of <code>Task&lt;TResult&gt;</code> and is functionally equivalent to <code>Task&lt;TResult&gt;</code> except that it has no result.</p>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Capturing Local State"><div class="sect2" id="capturing_local_state">
<h2>Capturing Local State</h2>
<p><a contenteditable="false" data-primary="asynchronous functions" data-secondary="capturing local state" data-type="indexterm" id="id1450"/><a contenteditable="false" data-primary="local state, capturing" data-type="indexterm" id="id1451"/>The real power of <code>await</code> expressions is that they can appear almost anywhere in code. Specifically, an <code>await</code> expression can appear in place of any expression (within an asynchronous function) except for within a <code>lock</code> statement or <code>unsafe</code> context.</p>
<p>In the following example, we <code>await</code> within a loop:</p>
<pre data-type="programlisting">async void Test()
{
  for (int i = 0; i &lt; 10; i++)
  {
    int result = <strong>await</strong> ComplexCalculationAsync();
    Console.WriteLine (result);
  }
}</pre>
<p>Upon first executing <code>ComplexCalculationAsync</code>, execution returns to the caller by virtue of the <code>await</code> expression. When the method completes (or faults), execution resumes where it left off, with the values of local variables and loop counters preserved. The compiler achieves this by translating such code into a state machine, like it does with iterators.</p>
<p>Without the <code>await</code> keyword, the manual use of continuations means that you must write something equivalent to a state machine. This is traditionally what makes asynchronous programming difficult.</p>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Writing Asynchronous Functions"><div class="sect2" id="writing_asynchronous_functions">
<h2>Writing Asynchronous Functions</h2>
<p><a contenteditable="false" data-primary="asynchronous functions" data-secondary="writing" data-type="indexterm" id="id1452"/>With any asynchronous function, you can replace the <code>void</code> return type with a <code>Task</code> to make the method itself <em>usefully</em> asynchronous (and <code>await</code>able). No further changes are required:</p>
<pre data-type="programlisting">async <strong>Task</strong> PrintAnswerToLife()
{
  await Task.Delay (5000);
  int answer = 21 * 2;
  Console.WriteLine (answer);  
}</pre>
<p>Notice that we don’t explicitly return a task in the method body. The compiler manufactures the task, which it signals upon completion of the method (or upon an unhandled exception). This makes it easy to create asynchronous call chains:</p>
<pre data-type="programlisting">async Task Go()
{
  await PrintAnswerToLife();
  Console.WriteLine ("Done");
}</pre>
<p>(And because <code>Go</code> returns a <code>Task</code>, <code>Go</code> itself is <code>await</code>able.) The compiler expands asynchronous functions that return tasks into code that (indirectly) uses <code>TaskCompletionSource</code> to create a task that it then signals or faults.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p><code>TaskCompletionSource</code> is a CLR type that lets you create tasks that you manually control, signaling them as complete with a result (or as faulted with an exception). Unlike <code>Task.Run</code>, <code>TaskCompletionSource</code> doesn’t tie up a thread for the duration of the operation. It’s also used for writing I/O-bound task-returning methods (such as <code>Task.Delay</code>).</p>
</div>
<p>The aim is to ensure that when a task-returning asynchronous method finishes, execution can jump back to whoever awaited it, via a continuation.</p>
<section data-type="sect3" data-pdf-bookmark="Returning Task&lt;TResult&gt;"><div class="sect3" id="returning_taskless_thantresultgreater_t">
<h3>Returning Task&lt;TResult&gt;</h3>
<p><a contenteditable="false" data-primary="Task&lt;TResult&gt;" data-type="indexterm" id="id1453"/>You can return a <code>Task&lt;TResult&gt;</code> if the method body returns <code>TResult</code>:</p>
<pre data-type="programlisting">async <strong>Task&lt;int&gt;</strong> GetAnswerToLife()
{
  await Task.Delay (5000);
  int answer = 21 * 2;
  // answer is <strong>int</strong> so our method returns Task&lt;<strong>int</strong>&gt;
  return <strong>answer</strong>;    
}</pre>
<p>We can demonstrate <code>GetAnswerToLife</code> by calling it from <code>Prin⁠t​AnswerToLife</code> (which is, in turn, called from <code>Go</code>):</p>
<pre data-type="programlisting"><strong>async Task</strong> Go()
{
  <strong>await</strong> PrintAnswerToLife();
  Console.WriteLine ("Done");
}
<strong>async Task</strong> PrintAnswerToLife()
{
  int answer = <strong>await</strong> GetAnswerToLife();
  Console.WriteLine (answer);
}
<strong>async Task&lt;</strong>int<strong>&gt;</strong> GetAnswerToLife()
{
  <strong>await</strong> Task.Delay (5000);
  int answer = 21 * 2;
  return answer;
}</pre>
<p>Asynchronous functions make asynchronous programming similar to synchronous programming. Here’s the synchronous equivalent of our call graph, for which calling <code>Go()</code> gives the same result after blocking for five seconds:</p>
<pre class="pagebreak-before" data-type="programlisting">void Go()
{
  PrintAnswerToLife();
  Console.WriteLine ("Done");
}
void PrintAnswerToLife()
{
  int answer = GetAnswerToLife();
  Console.WriteLine (answer);
}
int GetAnswerToLife()
{
  Thread.Sleep (5000);
  int answer = 21 * 2;
  return answer;
}</pre>
<p>This also illustrates the basic principle of how to design with asynchronous functions in C#, which is to write your methods synchronously and then replace <em>synchronous</em> method calls with <em>asynchronous</em> method calls that you <code>await</code>.</p>
</div></section>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Parallelism"><div class="sect2" id="parallelism">
<h2>Parallelism</h2>
<p><a contenteditable="false" data-primary="asynchronous functions" data-secondary="parallelism" data-type="indexterm" id="id1454"/><a contenteditable="false" data-primary="parallelism" data-type="indexterm" id="id1455"/>We’ve just demonstrated the most common pattern, which is to <code>await</code> task-returning functions immediately after calling them. This results in sequential program flow that’s logically similar to the synchronous equivalent.</p>
<p>Calling an asynchronous method without awaiting it allows the code that follows to execute in parallel. For example, the following executes <code>PrintAnswerToLife</code> twice, concurrently:</p>
<pre data-type="programlisting">var task1 = PrintAnswerToLife();
var task2 = PrintAnswerToLife();
await task1; await task2;</pre>
<p><a contenteditable="false" data-primary="WhenAll method" data-type="indexterm" id="id1456"/>By awaiting both operations afterward, we “end” the parallelism at that point (and rethrow any exceptions from those tasks). The <code>Task</code> class provides a static method called <code>WhenAll</code> to achieve the same result slightly more efficiently. <code>WhenAll</code> returns a task that completes when all of the tasks that you pass to it complete:</p>
<pre data-type="programlisting">await Task.WhenAll (PrintAnswerToLife(),
                    PrintAnswerToLife());</pre>
<p><code>WhenAll</code> is called a <em>task combinator</em>. (The <code>Task</code> class also provides a task combinator called <code>WhenAny</code>, which completes when <em>any</em> of the tasks provided to it complete.) We cover the task combinators in detail in <em>C# 12 in a Nutshell</em>.</p>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Asynchronous Lambda Expressions"><div class="sect2" id="asynchronous_lambda_expressions">
<h2>Asynchronous Lambda Expressions</h2>
<p><a contenteditable="false" data-primary="asynchronous functions" data-secondary="lambda expressions" data-type="indexterm" id="id1457"/><a contenteditable="false" data-primary="lambda expressions" data-secondary="asynchronous" data-type="indexterm" id="id1458"/>We know that ordinary <em>named</em> methods can be asynchronous:</p>
<pre data-type="programlisting"><strong>async Task</strong> NamedMethod()
{
  await Task.Delay (1000);
  Console.WriteLine ("Foo");
}</pre>
<p>So, too, can <em>unnamed</em> methods (lambda expressions and anonymous methods), if preceded by the <code>async</code> keyword:</p>
<pre data-type="programlisting">Func&lt;<strong>Task</strong>&gt; unnamed = <strong>async</strong> () =&gt;
{
  await Task.Delay (1000);
  Console.WriteLine ("Foo");
};</pre>
<p>You can call and await these in the same way:</p>
<pre data-type="programlisting">await NamedMethod();
await unnamed();</pre>
<p>You can use asynchronous lambda expressions when attaching event handlers:</p>
<pre data-type="programlisting">myButton.Click += <strong>async</strong> (sender, args) =&gt;
{
  await Task.Delay (1000);
  myButton.Content = "Done";
};</pre>
<p>This is more succinct than the following, which has the same effect:</p>
<pre data-type="programlisting">myButton.Click += ButtonHandler;
...
<strong>async</strong> void ButtonHandler (object sender, EventArgs args)
{
  await Task.Delay (1000);
  myButton.Content = "Done";
};</pre>
<p>Asynchronous lambda expressions can also return <code>Task​&lt;TRe⁠sult&gt;</code>:</p>
<pre data-type="programlisting">Func&lt;<strong>Task&lt;int&gt;</strong>&gt; unnamed = async () =&gt;
{
  await Task.Delay (1000);
  return 123;
};
int answer = await unnamed();</pre>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Asynchronous Streams"><div class="sect2" id="asynchronous_streams">
<h2>Asynchronous Streams</h2>
<p><a contenteditable="false" data-primary="asynchronous functions" data-secondary="streams" data-type="indexterm" id="id1459"/>With <code>yield return</code>, you can write an iterator; with <code>await</code>, you can write an asynchronous function. <em>Asynchronous streams</em> (from C# 8) combine these concepts and let you write an iterator that awaits, yielding elements asynchronously. This support builds on the following pair of interfaces, which are asynchronous counterparts to the enumeration interfaces we described in <a data-type="xref" href="#enumeration_and_iterators">“Enumeration and Iterators”</a>:</p>
<pre data-type="programlisting">public interface IAsyncEnumerable&lt;out T&gt;
{
  IAsyncEnumerator&lt;T&gt; GetAsyncEnumerator (...);
}

public interface IAsyncEnumerator&lt;out T&gt;: IAsyncDisposable
{
  T Current { get; }
  ValueTask&lt;bool&gt; MoveNextAsync();
}</pre>
<p><code>ValueTask&lt;T&gt;</code> is a struct that wraps <code>Task&lt;T&gt;</code> and is behaviorally equivalent to <code>Task&lt;T&gt;</code>, except that it enables more efficient execution when the task completes synchronously (which can happen often when enumerating a sequence). <code>IAsyncDisposable</code> is an asynchronous version of <code>IDisposable</code> and provides an opportunity to perform cleanup should you choose to manually implement the interfaces:</p>
<pre data-type="programlisting">public interface IAsyncDisposable
{
  ValueTask DisposeAsync();
}</pre>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>The act of fetching each element from the sequence (<code>MoveNextAsync</code>) is an asynchronous operation, so asynchronous streams are suitable when elements arrive in a piecemeal fashion (such as when processing data from a video stream). In contrast, the following type is more suitable when the sequence <em>as a whole</em> is delayed, but the elements, when they arrive, arrive all together:</p>
<pre data-type="programlisting">Task&lt;IEnumerable&lt;T&gt;&gt;</pre>
</div>
<p>To generate an asynchronous stream, you write a method that combines the principles of iterators and asynchronous methods. In other words, your method should include both <code>yield return</code> and <code>await</code>, and it should return <code>IAsyncEnumerable&lt;T&gt;</code>:</p>
<pre data-type="programlisting">async <strong>IAsyncEnumerable&lt;int&gt;</strong> RangeAsync (
  int start, int count, int delay)
{
  for (int i = start; i &lt; start + count; i++)
  {
    <strong>await</strong> Task.Delay (delay);
    <strong>yield return</strong> i;
  }
}</pre>
<p><a contenteditable="false" data-primary="await foreach statement" data-type="indexterm" id="id1460"/>To consume an asynchronous stream, use the <code>await foreach</code> statement:<a contenteditable="false" data-primary="" data-startref="ch1001.html48" data-type="indexterm" id="id1461"/></p>
<pre data-type="programlisting"><strong>await foreach</strong> (var number in RangeAsync (0, 10, 100))
  Console.WriteLine (number);</pre>
</div></section>
</div></section>
<section data-type="sect1" data-pdf-bookmark="Static Polymorphism"><div class="sect1" id="static_polymorphism">
<h1>Static Polymorphism</h1>
<p><a contenteditable="false" data-primary="polymorphic behavior" data-secondary="static polymorphism" data-type="indexterm" id="ch01.html6"/><a contenteditable="false" data-primary="static polymorphism" data-type="indexterm" id="ch01.html7"/>In <a data-type="xref" href="#static_virtualsolidusabstract_interface">“Static virtual/abstract interface members”</a>, we introduced an advanced feature whereby an interface can define <code>static virtual</code> or <code>static abstract</code> members, which are then implemented as static members by classes and structs. Later, in <a data-type="xref" href="#generic_constraints">“Generic Constraints”</a>, we showed that applying an interface constraint to a type parameter gives a method access to that interface’s members. In this section, we’ll demonstrate how this enables <em>static polymorphism</em>, allowing for features such as generic math.</p>
<p>To illustrate, consider the following interface, which defines a static method to create a random instance of some type <code>T</code>:</p>
<pre data-type="programlisting">interface ICreateRandom&lt;T&gt;
{
  <strong>static abstract</strong> T CreateRandom();
}</pre>
<p>Suppose now that we wish to implement this interface in the following record:</p>
<pre data-type="programlisting">record Point (int X, int Y);</pre>
<p>With the help of the <code>System.Random</code> class (whose <code>Next</code> method generates a random integer), we can implement the static <code>Crea⁠te​Random</code> method as follows:</p>
<pre data-type="programlisting">record Point (int X, int Y) : ICreateRandom&lt;Point&gt;
{
  static Random rnd = new();

  <strong>public static Point CreateRandom()</strong> =&gt; 
    new Point (rnd.Next(), rnd.Next());
}</pre>
<p>To call this method via the interface, we use a <em>constrained type parameter</em>. The following method creates an array of test data using this approach:</p>
<pre data-type="programlisting">T[] CreateTestData&lt;T&gt; (int count)
  <strong>where T : ICreateRandom&lt;T&gt;</strong>
{
  T[] result = new T[count];
  for (int i = 0; i &lt; count; i++)
    result [i] = <strong>T.CreateRandom()</strong>;
  return result;
}</pre>
<p>This line of code demonstrates its use:</p>
<pre data-type="programlisting">Point[] testData = CreateTestData&lt;Point&gt;(50);</pre>
<p>Our call to the static <code>CreateRandom</code> method in <code>CreateTestData</code> is <em>polymorphic</em> because it works not just with <code>Point</code> but with any type that implements <code>ICreateRandom&lt;T&gt;</code>. This is different from <em>instance</em> polymorphism, because we don’t need an <em>instance</em> of <code>ICreateRandom&lt;T&gt;</code> on which to call <code>CreateRandom</code>; we call <code>CreateRandom</code> on the type itself.</p>
<section data-type="sect2" data-pdf-bookmark="Polymorphic Operators"><div class="sect2" id="polymorphic_operators">
<h2>Polymorphic Operators</h2>
<p><a contenteditable="false" data-primary="operators" data-secondary="polymorphic" data-type="indexterm" id="ch01.html8"/><a contenteditable="false" data-primary="polymorphic behavior" data-secondary="polymorphic operators" data-type="indexterm" id="ch01.html9"/><a contenteditable="false" data-primary="static interface members" data-secondary="polymorphic operators" data-type="indexterm" id="ch01.html10"/>Because operators are essentially static functions (see <a data-type="xref" href="#operator_overloading">“Operator Overloading”</a>), operators can also be declared as static virtual interface members:</p>
<pre data-type="programlisting">interface IAddable&lt;T&gt; where T : IAddable&lt;T&gt;
{
   abstract static T operator + (T left, T right);
}</pre>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p><a contenteditable="false" data-primary="self-referencing type constraint" data-type="indexterm" id="id1462"/>The <em>self-referencing</em> type constraint in this interface definition is necessary to satisfy the compiler’s rules for operator overloading. Recall that when defining an operator function, at least one of the operands must be the type in which the operator function is declared. In this example, our operands are of type <code>T</code>, whereas the containing type is <code>IAddable&lt;T&gt;</code>, so we require a self-referencing type constraint to allow <code>T</code> to be treated as <code>IAddable&lt;T&gt;</code>.</p>
</div>
<p>Here’s how we can implement the interface:</p>
<pre data-type="programlisting">record Point (int X, int Y) : IAddable&lt;Point&gt;
{
  public static Point operator +(Point left, Point right)
    =&gt; new Point (left.X + right.X, left.Y + right.Y);
}</pre>
<p>With a constrained type parameter, we can then write a method that calls our addition operator polymorphically (with edge-case handling omitted for brevity):</p>
<pre data-type="programlisting">T Sum&lt;T&gt; (params T[] values) <strong>where T : IAddable&lt;T&gt;</strong>
{
  T total = values[0];
  for (int i = 1; i &lt; values.Length; i++)
    total <strong>+=</strong> values[i];
  return total;
}</pre>
<p>Our call to the <code>+</code> operator (via the <code>+=</code> operator) is polymorphic because it binds to <code>IAddable&lt;T&gt;</code>, not <code>Point</code>. Hence, our <code>Sum</code> method works with all types that implement <code>IAddable&lt;T&gt;</code>.</p>
<p>Of course, an interface such as <code>IAddable&lt;T&gt;</code> would be much more useful if it were defined in the .NET runtime, and if all .NET numeric types implemented it. Fortunately, this is indeed the case from .NET 7: the <code>System.Numerics</code> namespace includes (a more sophisticated version of) <code>IAddable</code>, along with many other arithmetic interfaces—most of which are encompassed by <code>INumber&lt;TSelf&gt;</code>.<a contenteditable="false" data-primary="" data-startref="ch01.html10" data-type="indexterm" id="id1463"/><a contenteditable="false" data-primary="" data-startref="ch01.html9" data-type="indexterm" id="id1464"/><a contenteditable="false" data-primary="" data-startref="ch01.html8" data-type="indexterm" id="id1465"/></p>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Generic Math"><div class="sect2" id="generic_math">
<h2>Generic Math</h2>
<p><a contenteditable="false" data-primary="generics" data-secondary="math" data-type="indexterm" id="id1466"/><a contenteditable="false" data-primary="polymorphic behavior" data-secondary="generic math" data-type="indexterm" id="id1467"/><a contenteditable="false" data-primary="generic math" data-type="indexterm" id="id1468"/>Before .NET 7, code that performed arithmetic had to be hardcoded to a particular numeric type such as <code>int</code> or <code>double</code>. From .NET 7, the <code>INumber&lt;TSelf&gt;</code> interface was added to unify arithmetic operations across numeric types, allowing generic methods such as the following to be written:</p>
<pre data-type="programlisting">T Sum&lt;T&gt; (params T[] numbers) <strong>where T : INumber&lt;T&gt;</strong>
{
  T total = <strong>T.Zero</strong>;
  foreach (T n in numbers)
    total <strong>+=</strong> n;  // Invokes addition for any numeric type
  return total;
}

int intSum = Sum (3, 5, 7);
double doubleSum = Sum (3.2, 5.3, 7.1);
decimal decimalSum = Sum (3.2m, 5.3m, 7.1m);</pre>
<p><code>INumber&lt;TSelf&gt;</code> is implemented by all real and integral numeric types in .NET (as well as <code>char</code>). It can be thought of as an umbrella interface, comprising other more granular interfaces for each kind of arithmetic operation (addition, subtraction, multiplication, division, modulus calculation, comparison, and so on), as well as interfaces for parsing and formatting. These interfaces define static abstract operators and methods—which allow the <code>+=</code> operator (and the call to <code>T.Zero</code>) to work inside our <code>Sum</code> method.<a contenteditable="false" data-primary="" data-startref="ch01.html7" data-type="indexterm" id="id1469"/><a contenteditable="false" data-primary="" data-startref="ch01.html6" data-type="indexterm" id="id1470"/></p>
</div></section>
</div></section>
<section data-type="sect1" data-pdf-bookmark="Unsafe Code and Pointers"><div class="sect1" id="unsafe_code_and_pointers">
<h1>Unsafe Code and Pointers</h1>
<p><a contenteditable="false" data-primary="/unsafe compiler option" data-type="indexterm" id="id1471"/>C# <a contenteditable="false" data-primary="unsafe code and pointers" data-type="indexterm" id="ch1001.html49"/>supports direct memory manipulation via pointers within blocks of code marked as <code>unsafe</code>. Pointer types are useful for interoperating with native APIs, for accessing memory outside the managed heap, and   in implementing micro-optimizations in performance-critical hotspots.</p>
<p>Projects that include unsafe code must specify <code>&lt;AllowUnsafeBlocks&gt;true&lt;/AllowUnsafeBlocks&gt;</code> in the project file.</p>
<section data-type="sect2" data-pdf-bookmark="Pointer Basics"><div class="sect2" id="pointer_basics">
<h2>Pointer Basics</h2>
<p><a contenteditable="false" data-primary="pointers" data-secondary="basics of" data-type="indexterm" id="id1472"/><a contenteditable="false" data-primary="pointers" data-seealso="unsafe code and pointers" data-type="indexterm" id="id1473"/><a contenteditable="false" data-primary="unsafe code and pointers" data-secondary="pointer basics" data-type="indexterm" id="id1474"/>For every value type or reference type <em>V</em>, there is a corresponding pointer type <em>V*</em>. A pointer instance holds the address of a variable. Pointer types can be (unsafely) cast to any other pointer type. <a contenteditable="false" data-primary="&amp; (address-of) operator" data-type="indexterm" id="id1475"/><a contenteditable="false" data-primary="* (dereference) operator" data-type="indexterm" id="id1476"/><a contenteditable="false" data-primary="address-of (&amp;) operator" data-type="indexterm" id="id1477"/><a contenteditable="false" data-primary="dereference (*) operator" data-type="indexterm" id="id1478"/>Following are the main pointer operators:</p>
<table class="border pagebreak-before less_space">
<thead>
<tr>
<th>Operator</th>
<th>Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>&amp;</code></td>
<td>The <em>address-of</em> operator returns a pointer to the address of a variable.</td>
</tr>
<tr>
<td><code>*</code></td>
<td>The <em>dereference</em> operator returns the variable at the address of a pointer.</td>
</tr>
<tr>
<td><code>-&gt;</code></td>
<td>The <em>pointer-to-member</em> operator is a syntactic shortcut, in which <code>x-&gt;y</code> is equivalent to <code>(*x).y</code>.</td>
</tr>
</tbody>
</table>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Unsafe Code"><div class="sect2" id="unsafe_code">
<h2>Unsafe Code</h2>
<p><a contenteditable="false" data-primary="unsafe code and pointers" data-secondary="marking code unsafe" data-type="indexterm" id="id1479"/><a contenteditable="false" data-primary="unsafe code and pointers" data-secondary="unsafe keyword" data-type="indexterm" id="id1480"/>By marking a type, type member, or statement block with the <code>unsafe</code> keyword, you’re permitted to use pointer types and perform C++-style pointer operations on memory within that scope. Here is an example of using pointers to quickly process a bitmap:</p>
<pre data-type="programlisting">unsafe void BlueFilter (int[,] bitmap)
{
  int length = bitmap.Length;
  fixed (int* b = bitmap)
  {
    int* p = b;
    for (int i = 0; i &lt; length; i++)
      *p++ &amp;= 0xFF;
  }
}</pre>
<p><a contenteditable="false" data-primary="arrays" data-secondary="unsafe code and" data-type="indexterm" id="id1481"/>Unsafe code can run faster than a corresponding safe implementation. In this case, the code would have required a nested loop with array indexing and bounds checking. An unsafe C# method can also be faster than calling an external C function because there is no overhead associated with leaving the managed execution environment.</p>
</div></section>
<section data-type="sect2" data-pdf-bookmark="The fixed Statement"><div class="sect2" id="the_fixed_statement">
<h2>The fixed Statement</h2>
<p><a contenteditable="false" data-primary="fixed statement" data-type="indexterm" id="id1482"/><a contenteditable="false" data-primary="pointers" data-secondary="fixed statement" data-type="indexterm" id="id1483"/><a contenteditable="false" data-primary="unsafe code and pointers" data-secondary="fixed statement" data-type="indexterm" id="id1484"/>The <code>fixed</code> statement is required to pin a managed object such as the bitmap in the previous example. During the execution of a program, many objects are allocated and deallocated from the heap. To avoid unnecessary waste or fragmentation of memory, the garbage collector moves objects around. Pointing to an object is futile if its address could change while referencing it, so the <code>fixed</code> statement instructs the garbage collector to “pin” the object and not move it around. This can have an impact on the efficiency of the runtime, so you should use fixed blocks only briefly, and you should avoid heap allocation within the fixed block.</p>
<p>Within a <code>fixed</code> statement, you can get a pointer to a value type, an array of value types, or a string. In the case of arrays and strings, the pointer will actually point to the first element, which is a value type.</p>
<p>Value types declared inline within reference types require the reference type to be pinned, as follows:</p>
<pre data-type="programlisting">Test test = new Test();
unsafe
{
  fixed (int* p = &amp;test.X)   // Pins test
  {
    *p = 9;
  }
  Console.WriteLine (test.X);
}

class Test { public int X; }</pre>
</div></section>
<section data-type="sect2" data-pdf-bookmark="The Pointer-to-Member Operator"><div class="sect2" id="the_pointer_to_member_operator">
<h2>The Pointer-to-Member Operator</h2>
<p><a contenteditable="false" data-primary="-&gt; (pointer-to-member) operator" data-type="indexterm" id="id1485"/><a contenteditable="false" data-primary="pointer-to-member operator (-&gt;)" data-type="indexterm" id="id1486"/><a contenteditable="false" data-primary="unsafe code and pointers" data-secondary="fixed-size buffers" data-type="indexterm" id="id1487"/><a contenteditable="false" data-primary="unsafe code and pointers" data-secondary="pointer-to-member operator" data-type="indexterm" id="id1488"/>In addition to the <code>&amp;</code> and <code>*</code> operators, C# also provides the <span class="keep-together">C++-style</span> <code>-&gt;</code> operator, which you can use on structs:</p>
<pre data-type="programlisting">Test test = new Test();
unsafe
{
  Test* p = &amp;test;
  p-&gt;X = 9;
  System.Console.WriteLine (test.X);
}

struct Test { public int X; }</pre>
</div></section>
<section data-type="sect2" data-pdf-bookmark="The stackalloc Keyword"><div class="sect2" id="the_stackalloc_keyword">
<h2>The stackalloc Keyword</h2>
<p><a contenteditable="false" data-primary="arrays" data-secondary="stackalloc keyword" data-type="indexterm" id="id1489"/><a contenteditable="false" data-primary="stackalloc keyword" data-type="indexterm" id="id1490"/><a contenteditable="false" data-primary="unsafe code and pointers" data-secondary="stackalloc keyword" data-type="indexterm" id="id1491"/>You can allocate memory in a block on the stack explicitly with the <code>stackalloc</code> keyword. Because it is allocated on the stack, its lifetime is limited to the execution of the method, just as with any other local variable. <a contenteditable="false" data-primary="[ ] (square brackets)" data-type="indexterm" id="id1492"/><a contenteditable="false" data-primary="braces" data-secondary="square ([ ])" data-type="indexterm" id="id1493"/><a contenteditable="false" data-primary="square brackets ([ ])" data-type="indexterm" id="id1494"/>The block can use the <code>[]</code> operator to index into memory:</p>
<pre data-type="programlisting">int* a = stackalloc int [10];
for (int i = 0; i &lt; 10; ++i)
  Console.WriteLine (a[i]);   // Print raw memory</pre>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Fixed-Size Buffers"><div class="sect2" id="fixed_size_buffers">
<h2>Fixed-Size Buffers</h2>
<p><a contenteditable="false" data-primary="arrays" data-secondary="fixed-size buffers" data-type="indexterm" id="id1495"/><a contenteditable="false" data-primary="fixed keyword" data-type="indexterm" id="id1496"/>To allocate a block of memory within a struct, use the <code>fixed</code> keyword:</p>
<pre data-type="programlisting">unsafe struct UnsafeUnicodeString
{
  public short Length;
  public <strong>fixed</strong> byte Buffer[30];
}

unsafe class UnsafeClass
{
  UnsafeUnicodeString uus;

  public UnsafeClass (string s)
  {
    uus.Length = (short)s.Length;
    fixed (byte* p = uus.Buffer)
      for (int i = 0; i &lt; s.Length; i++)
        p[i] = (byte) s[i];
  }
}</pre>
<p>Fixed-size buffers are not arrays: if <code>Buffer</code> were an array, it would consist of a reference to an object stored on the (managed) heap, rather than 30 bytes within the struct itself.</p>
<p>The <code>fixed</code> keyword is also used in this example to pin the object on the heap that contains the buffer (which will be the instance of <code>UnsafeClass</code>).</p>
</div></section>
<section data-type="sect2" data-pdf-bookmark="void*"><div class="sect2" id="voidasterisk">
<h2>void*</h2>
<p><a contenteditable="false" data-primary="pointers" data-secondary="void*" data-type="indexterm" id="id1497"/><a contenteditable="false" data-primary="unsafe code and pointers" data-secondary="void pointer (void*)" data-type="indexterm" id="id1498"/><a contenteditable="false" data-primary="void pointer (void*)" data-type="indexterm" id="id1499"/>A <em>void pointer</em> (<code>void*</code>) makes no assumptions about the type of the underlying data and is useful for functions that deal with raw memory. An implicit conversion exists from any pointer type to <code>void*</code>. A <code>void*</code> cannot be dereferenced, and arithmetic operations cannot be performed on void pointers. For example:</p>
<pre data-type="programlisting">short[] a = {1,1,2,3,5,8,13,21,34,55};
fixed (short* p = a)
{
  //sizeof returns size of value-type in bytes
  Zap (p, a.Length * sizeof (short));
}
foreach (short x in a)
  Console.WriteLine (x);  // Prints all zeros

unsafe void Zap (void* memory, int byteCount)
{
  byte* b = (byte*) memory;
    for (int i = 0; i &lt; byteCount; i++)
      *b++ = 0;
}</pre>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Function Pointers"><div class="sect2" id="function_pointers">
<h2>Function Pointers</h2>
<p><a contenteditable="false" data-primary="function pointers" data-type="indexterm" id="id1500"/>A <em>function pointer</em> (from C# 9) is like a delegate but without the indirection of a delegate instance; instead, it points directly to a method. A function pointer points only to static methods, lacks multicast capability, and requires an <code>unsafe</code> context (because it bypasses runtime type safety). Its main purpose is to simplify and optimize interop with unmanaged APIs (we cover interop in <em>C# 12 in a Nutshell</em>).</p>
<p>A function pointer type is declared as follows (with the return type appearing last):</p>
<pre data-type="programlisting"><strong>delegate*&lt;int, char, string, void&gt;</strong></pre>
<p>This matches a function with this signature:</p>
<pre data-type="programlisting"><strong>void</strong> SomeFunction (<strong>int</strong> x, <strong>char</strong> y, <strong>string</strong> z)</pre>
<p><a contenteditable="false" data-primary="&amp; operator" data-type="indexterm" id="id1501"/>The <code>&amp;</code> operator creates a function pointer from a method group. Here’s a complete example:</p>
<pre data-type="programlisting">unsafe
{
<strong>  delegate*&lt;string, int&gt;</strong> functionPointer = <strong>&amp;GetLength</strong>;
  int length = functionPointer ("Hello, world");

  static int GetLength (string s) =&gt; s.Length;
}</pre>
<p>In this example, <code>functionPointer</code> is not an <em>object</em> upon which you can call a method such as <code>Invoke</code> (or with a reference to a <code>Target</code> object). Instead, it’s a variable that points directly to the target method’s address in memory:<a contenteditable="false" data-primary="" data-startref="ch1001.html49" data-type="indexterm" id="id1502"/></p>
<pre data-type="programlisting">Console.WriteLine ((IntPtr)functionPointer);</pre>
</div></section>
</div></section>
<section data-type="sect1" data-pdf-bookmark="Preprocessor Directives"><div class="sect1" id="preprocessor_directive">
<h1>Preprocessor Directives</h1>
<p><a contenteditable="false" data-primary="preprocessor directives" data-type="indexterm" id="id1503"/>Preprocessor directives supply the compiler with additional information about regions of code. The most common preprocessor directives are the conditional directives, which provide a way to include or exclude regions of code from compilation. For example:</p>
<pre data-type="programlisting"><strong>#define DEBUG</strong>
class MyClass
{
  int x;
  void Foo()
  {
<strong>    #if DEBUG</strong>
    Console.WriteLine ("Testing: x = {0}", x);
<strong>    #endif</strong>
<strong>  }</strong>
  ...
}</pre>
<p>In this class, the statement in <code>Foo</code> is compiled as conditionally dependent upon the presence of the <code>DEBUG</code> symbol. If we remove the <code>DEBUG</code> symbol, the statement is not compiled. Preprocessor symbols can be defined within a source file (as we have done), or within the <code>&lt;DefineConstants&gt;</code> element in a project file.</p>
<p><a contenteditable="false" data-primary="#elif directive" data-type="indexterm" id="id1504"/><a contenteditable="false" data-primary="#if directive" data-type="indexterm" id="id1505"/>With the <code>#if</code> and <code>#elif</code> directives, you can use the <code>||</code>, <code>&amp;&amp;</code>, and <code>!</code> operators to perform <em>or</em>, <em>and</em>, and <em>not</em> operations on multiple symbols. The following directive instructs the compiler to include the code that follows if the <code>TESTMODE</code> symbol is defined and the <code>DEBUG</code> symbol is not defined:</p>
<pre data-type="programlisting">#if TESTMODE &amp;&amp; !DEBUG
  ...</pre>
<p>Keep in mind, however, that you’re not building an ordinary C# expression, and the symbols upon which you operate have absolutely no connection to <em>variables</em>—static or otherwise.</p>
<p><a contenteditable="false" data-primary="#error symbol" data-type="indexterm" id="id1506"/><a contenteditable="false" data-primary="#warning symbol" data-type="indexterm" id="id1507"/>The <code>#error</code> and <code>#warning</code> symbols prevent accidental misuse of conditional directives by making the compiler generate a warning or error given an undesirable set of compilation symbols.</p>
<p><a data-type="xref" href="#preprocessor_directives">Table 14</a> describes the complete list of preprocessor directives.</p>
<table class="border" id="preprocessor_directives">
<caption><span class="label">Table 14. </span>Preprocessor directives</caption>
<thead>
<tr>
<th>Preprocessor directive</th>
<th>Action</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>#define <code><em>symbol</em></code></code></td>
<td>Defines <code><em>symbol</em></code>.</td>
</tr>
<tr>
<td><code>#undef <code><em>symbol</em></code></code></td>
<td>Undefines <code><em>symbol</em></code>.</td>
</tr>
<tr>
      <td><code>#if</code> <code><em>symbol</em></code> <code><span class="keep-together">[<em>operator symbol2</em>]</span>...</code></td>
<td>Conditional compilation (<code><em>operator</em></code>s are <code>==</code>, <code>!=</code>, <code>&amp;&amp;</code>, and <code>||</code>).</td>
</tr>
<tr>
<td><code>#else</code></td>
<td>Executes code to subsequent <code>#endif</code>.</td>
</tr>
<tr>
      <td><code>#elif</code> <code><em>symbol</em></code> <span class="keep-together"><code>[<em>operator symbol2</em>]</code></span></td>
<td>Combines <code>#else</code> branch and <code>#if</code> test.</td>
</tr>
<tr>
<td><code>#endif</code></td>
<td>Ends conditional directives.</td>
</tr>
<tr>
<td><code>#warning <code><em>text</em></code></code></td>
<td><code><em>text</em></code> of the warning to appear in compiler output.</td>
</tr>
<tr>
<td><code>#error <code><em>text</em></code></code></td>
<td><code><em>text</em></code> of the error to appear in compiler output.</td>
</tr>
<tr>
<td><code>#line [<code><em>number</em></code> ["<code><em>file</em></code>"] | <span class="keep-together">hidden</span>]</code></td>
<td><code><em>number</em></code> specifies the line in source code; <code><em>file</em></code> is the filename to appear in computer output; <code>hidden</code> instructs debuggers to skip over code from this point until the next <code>#line</code> directive.</td>
</tr>
<tr>
<td><code>#region <code><em>name</em></code></code></td>
<td>Marks the beginning of an outline.</td>
</tr>
<tr>
<td><code>#endregion</code></td>
<td>Ends an outline region.</td>
</tr>
<tr>
<td><code>#pragma warning</code></td>
<td>See the next section.</td>
</tr>
<tr>
<td><code>#nullable <code><em>option</em></code></code></td>
<td>See <a data-type="xref" href="#nullable_reference_types">“Nullable Reference Types”</a>.</td>
</tr>
</tbody>
</table>
<section data-type="sect2" data-pdf-bookmark="Pragma Warning"><div class="sect2" id="pragma_warning">
<h2>Pragma Warning</h2>
<p><a contenteditable="false" data-primary="#pragma warning directive" data-type="indexterm" id="id1508"/><a contenteditable="false" data-primary="compilation" data-secondary="pragma warning" data-type="indexterm" id="id1509"/><a contenteditable="false" data-primary="pragma warning" data-type="indexterm" id="id1510"/>The compiler generates a warning when it spots something in your code that seems unintentional. Unlike errors, warnings don’t ordinarily prevent your application from compiling.</p>
<p>Compiler warnings can be extremely valuable in spotting bugs. Their usefulness, however, is undermined when you get <em>false</em> warnings. In a large application, maintaining a good signal-to-noise ratio is essential if the “real” warnings are to be noticed.</p>
<p>To this effect, the compiler allows you to selectively suppress warnings with the <code>#pragma warning</code> directive. In this example, we instruct the compiler not to warn us about the field <code>Message</code> not being used:</p>
<pre data-type="programlisting">public class Foo
{
<strong>  #pragma warning disable 414</strong>
  static string Message = "Hello";
<strong>  #pragma warning restore 414</strong>
}</pre>
<p>Omitting the number in the <code>#pragma warning</code> directive disables or restores all warning codes.</p>
<p>If you are thorough in applying this directive, you can compile with the <code>/warnaserror</code> switch—this instructs the compiler to treat any residual warnings as errors.</p>
</div></section>
</div></section>
<section data-type="sect1" data-pdf-bookmark="XML Documentation"><div class="sect1" id="xml_documentation">
<h1>XML Documentation</h1>
<p><a contenteditable="false" data-primary="documentation comments" data-type="indexterm" id="id1511"/>A <a contenteditable="false" data-primary="documentation" data-type="indexterm" id="ch1001.html50"/><a contenteditable="false" data-primary="XML documentation" data-type="indexterm" id="ch1001.html51"/><em>documentation comment</em> is a piece of embedded XML that documents a type or member. A documentation comment comes immediately before a type or member declaration and starts with three slashes:</p>
<pre data-type="programlisting"><strong>/// &lt;summary&gt;Cancels a running query.&lt;/summary&gt;</strong>
public void Cancel() { ... }</pre>
<p>Multiline comments can be done like this:</p>
<pre data-type="programlisting">/// &lt;summary&gt;
/// Cancels a running query
/// &lt;/summary&gt;
public void Cancel() { ... }</pre>
<p>Or like this (notice the extra star at the start):</p>
<pre data-type="programlisting"><strong>/**</strong> 
    &lt;summary&gt; Cancels a running query. &lt;/summary&gt;
<strong>*/</strong>
public void Cancel() { ... }</pre>
<p><a contenteditable="false" data-primary="/doc directive" data-type="indexterm" id="id1512"/>If you compile with the <code>/doc</code> directive (or enable XML documentation in the project file), the compiler extracts and collates documentation comments into a single XML file. This has two main uses:</p>
<ul>
<li><p>If placed in the same folder as the compiled assembly, Visual Studio automatically reads the XML file and uses the information to provide IntelliSense member listings to consumers of the assembly of the same name.</p></li>
<li><p>Third-party tools (such as Sandcastle and NDoc) can transform the XML file into an HTML help file.</p></li>
</ul>
<section data-type="sect2" data-pdf-bookmark="Standard XML Documentation Tags"><div class="sect2" id="standard_xml_documentation_tags">
<h2>Standard XML Documentation Tags</h2>
<p>Here are the standard XML tags that Visual Studio and documentation generators recognize:</p>
<dl>
<dt><code>&lt;summary&gt;</code></dt>
<dd><pre data-type="programlisting">&lt;summary&gt;<em>...</em>&lt;/summary&gt;</pre>
<p>Indicates the tool tip that IntelliSense should display for the type or member. Typically, a single phrase or sentence.</p></dd>
<dt><code>&lt;remarks&gt;</code></dt>
<dd><pre data-type="programlisting">&lt;remarks&gt;<em>...</em>&lt;/remarks&gt;</pre>
<p>Additional text that describes the type or member. Documentation generators pick this up and merge it into the bulk of a type or member’s description.</p></dd>
<dt><code>&lt;param&gt;</code></dt>
<dd><pre data-type="programlisting">&lt;param name="<em>name</em>"&gt;<em>...</em>&lt;/param&gt;</pre>
<p>Explains a parameter on a method.</p></dd>
<dt><code>&lt;returns&gt;</code></dt>
<dd><pre data-type="programlisting">&lt;returns&gt;<em>...</em>&lt;/returns&gt;</pre>
<p>Explains the return value for a method.</p></dd>
<dt><code>&lt;exception&gt;</code></dt>
<dd><pre data-type="programlisting">&lt;exception [cref="<em>type</em>"]&gt;<em>...</em>&lt;/exception&gt;</pre>
<p>Lists an exception that a method might throw (<code>cref</code> refers to the exception type).</p></dd>
<dt><code>&lt;permission&gt;</code></dt>
<dd><pre data-type="programlisting">&lt;permission [cref="<em>type</em>"]&gt;<em>...</em>&lt;/permission&gt;</pre>
<p>Indicates an <code>IPermission</code> type required by the documented type or member.</p></dd>
<dt><code>&lt;example&gt;</code></dt>
<dd><pre data-type="programlisting">&lt;example&gt;<em>...</em>&lt;/example&gt;</pre>
<p>Denotes an example (used by documentation generators). This usually contains both description text and source code (source code is typically within a <code>&lt;c&gt;</code> or <code>&lt;code&gt;</code> tag).</p></dd>
<dt><code>&lt;c&gt;</code></dt>
<dd><pre data-type="programlisting">&lt;c&gt;<em>...</em>&lt;/c&gt;</pre>
<p>Indicates an inline code snippet. This tag is usually used within an <code>&lt;example&gt;</code> block.</p></dd>
<dt><code>&lt;code&gt;</code></dt>
<dd><pre data-type="programlisting">&lt;code&gt;<em>...</em>&lt;/code&gt;</pre>
<p>Indicates a multiline code sample. This tag is usually used within an <code>&lt;example&gt;</code> block.</p></dd>
<dt><code>&lt;see&gt;</code></dt>
<dd><pre data-type="programlisting">&lt;see cref="<em>member</em>"&gt;<em>...</em>&lt;/see&gt;</pre>
<p>Inserts an inline cross-reference to another type or member. HTML documentation generators typically convert this to a hyperlink. The compiler emits a warning if the type or member name is invalid.</p></dd>
<dt><code>&lt;seealso&gt;</code></dt>
<dd><pre data-type="programlisting">&lt;seealso cref="<em>member</em>"&gt;<em>...</em>&lt;/seealso&gt;</pre>
<p>Cross-references another type or member. Documentation generators typically write this into a separate “See Also” section at the bottom of the page.</p></dd>
<dt><code>&lt;paramref&gt;</code></dt>
<dd><pre data-type="programlisting">&lt;paramref name="<em>name</em>"/&gt;</pre>
<p>References a parameter from within a <code>&lt;summary&gt;</code> or <code>&lt;remarks&gt;</code> tag.</p></dd>
<dt><code>&lt;list&gt;</code></dt>
<dd><pre data-type="programlisting">&lt;list type=[ bullet | number | table ]&gt;
  &lt;listheader&gt;
    &lt;term&gt;<em>...</em>&lt;/term&gt;
    &lt;description&gt;<em>...</em>&lt;/description&gt;
  &lt;/listheader&gt;
  &lt;item&gt;
    &lt;term&gt;<em>...</em>&lt;/term&gt;
    &lt;description&gt;<em>...</em>&lt;/description&gt;
  &lt;/item&gt;
&lt;/list&gt;</pre>
<p>Instructs documentation generators to emit a bulleted, numbered, or table-style list.</p></dd>
<dt><code>&lt;para&gt;</code></dt>
<dd><pre data-type="programlisting">&lt;para&gt;<em>...</em>&lt;/para&gt;</pre>
<p>Instructs documentation generators to format the contents into a separate paragraph.</p></dd>
<dt><code>&lt;include&gt;</code></dt>
<dd><pre data-type="programlisting">&lt;include file='<em>filename</em>' path='<em>tagpath</em>[@name="<em>id</em>"]'&gt;
  ...
&lt;/include&gt;</pre>
<p>Merges an external XML file that contains documentation. The path attribute denotes an XPath query to a specific element in that file. <a contenteditable="false" data-primary="" data-startref="ch1001.html51" data-type="indexterm" id="id1513"/><a contenteditable="false" data-primary="" data-startref="ch1001.html50" data-type="indexterm" id="id1514"/><a contenteditable="false" data-primary="case keyword" data-see="switch statements" data-type="indexterm" id="id1515"/><a contenteditable="false" data-primary="characters" data-see="strings" data-type="indexterm" id="id1516"/><a contenteditable="false" data-primary="classes" data-secondary="inheritance" data-see="inheritance" data-type="indexterm" id="id1517"/><a contenteditable="false" data-primary="classes" data-secondary="object type" data-see="object type" data-type="indexterm" id="id1518"/><a contenteditable="false" data-primary="exception handling" data-see="try statements and exceptions" data-type="indexterm" id="id1519"/><a contenteditable="false" data-primary="operators" data-secondary="overloading" data-see="operator overloading" data-type="indexterm" id="id1520"/><a contenteditable="false" data-primary="types" data-secondary="nullable" data-see="nullable value types" data-type="indexterm" id="id1521"/><a contenteditable="false" data-primary="types" data-secondary="numeric" data-see="numeric types" data-type="indexterm" id="id1522"/></p></dd>
</dl>
</div></section>
</div></section>
</div></section></div></body></html>